//For every comment Zoria has left on a script, I have left nothing.
//As such, the universe balances itself out.
//Perfect equilibrium.

const int DEBUG = 0;

//{ LinkMovement
const int FOUR_WAY_MOVEMENT = 0; //Set to 1 if your quest has four-way movement. 
								//Note that four-way movement Link has a step speed of 1.33 instead of 1.5.
								//This happens seemingly in a pattern of 1-1-1-2-1-2 pixel steps.
								//This settings is all around buggy and there's not much I can do about it, unfortunately. :(

const int MAX_PUSH = 24; //This is the maximum number of pixels Link can be pushed in a single frame.
						//Extra pixels past this maximum will be handled the next frame and so on.
						//Increasing this will increase the max number of interations in loops in the
						//__LinkMovement_UpdatePush() function. This shouldn't be too big a deal in terms of
						//slowdown, but to keep it reasonable.

int LinkMovement[16];
//These constants are all array indeces for the global array
const int LM_PUSHX1A = 0;
const int LM_PUSHY1A = 1;
const int LM_PUSHX1B = 2;
const int LM_PUSHY1B = 3;
const int LM_PUSHX2A = 4;
const int LM_PUSHY2A = 5;
const int LM_PUSHX2B = 6;
const int LM_PUSHY2B = 7;
const int LM_STICKX = 8;
const int LM_STICKY = 9;
const int LM_MOVEBOOST = 10;
const int LM_LASTX = 11;
const int LM_LASTY = 12;
const int LM_UNDOLINKMOVEMENT = 13;
const int LM_LASTDMAP = 14;
const int LM_LASTDMAPSCREEN = 15;


//This function keeps track of Link's last X and Y input.
//If two opposing inputs are held at once, this should hopefully keep track of which one ZC will prioritize.
void __LinkMovement_UpdateInput(){
	if(LinkMovement[LM_STICKY]==0){ //If no Y axis pressed
		if(Link->PressUp&&Link->PressDown) //Default to up when buttons pressed simultaneously
			LinkMovement[LM_STICKY] = -1;
		else if(Link->PressUp||Link->InputUp) //Set axis based on which button what pressed
			LinkMovement[LM_STICKY] = -1;
		else if(Link->PressDown||Link->InputDown)
			LinkMovement[LM_STICKY] = 1;
	}
	else{ //If Y axis pressed
		if(!Link->InputUp&&!Link->InputDown) //Release Y axis if neither button pressed
			LinkMovement[LM_STICKY] = 0;
		else if(LinkMovement[LM_STICKY]==-1&&!Link->InputUp) //Reverse Y axis if opposite direction held and button released
			LinkMovement[LM_STICKY] = 1;
		else if(LinkMovement[LM_STICKY]==1&&!Link->InputDown)
			LinkMovement[LM_STICKY] = -1;
	}
	
	if(LinkMovement[LM_STICKX]==0){ //If no X axis pressed
		if(Link->PressLeft&&Link->PressRight) //Default to left when buttons pressed simultaneously
			LinkMovement[LM_STICKX] = -1;
		else if(Link->PressLeft||Link->InputLeft) //Set axis based on which button what pressed
			LinkMovement[LM_STICKX] = -1;
		else if(Link->PressRight||Link->InputRight)
			LinkMovement[LM_STICKX] = 1;
	}
	else{ //If Y axis pressed
		if(!Link->InputLeft&&!Link->InputRight) //Release Y axis if neither button pressed
			LinkMovement[LM_STICKX] = 0;
		else if(LinkMovement[LM_STICKX]==-1&&!Link->InputLeft) //Reverse Y axis if opposite direction held and button released
			LinkMovement[LM_STICKX] = 1;
		else if(LinkMovement[LM_STICKX]==1&&!Link->InputRight)
			LinkMovement[LM_STICKX] = -1;
	}
}

//Function adds extra movement to Link's step speed
void __LinkMovement_SpeedChange(){
	if(Link->Action==LA_NONE||Link->Action==LA_WALKING){
		if(LinkMovement[LM_STICKX]!=0||LinkMovement[LM_STICKY]!=0){
			float movementSpeed = LinkMovement[LM_MOVEBOOST];
			//We're calculating CanWalk for all directions in advance to hopefully save a bit on speed.
			bool CanWalk[4];
			CanWalk[DIR_UP] = CanWalk(Link->X, Link->Y, DIR_UP, 1, false);
			CanWalk[DIR_DOWN] = CanWalk(Link->X, Link->Y, DIR_DOWN, 1, false);
			CanWalk[DIR_LEFT] = CanWalk(Link->X, Link->Y, DIR_LEFT, 1, false);
			CanWalk[DIR_RIGHT] = CanWalk(Link->X, Link->Y, DIR_RIGHT, 1, false);
			//If four way movement isn't on, Link's speed boost should be dampened for diagonals since he moves slower
			if(!FOUR_WAY_MOVEMENT){
				if(LinkMovement[LM_STICKX]!=0&&LinkMovement[LM_STICKY]!=0){
					//If he's pressing against a wall or in sideview, the speed dampening won't take effect
					if(CanWalk[Cond(LinkMovement[LM_STICKX]==-1, DIR_LEFT, DIR_RIGHT)] &&
					CanWalk[Cond(LinkMovement[LM_STICKY]==-1, DIR_UP, DIR_DOWN)] &&
					!IsSideview() )
						movementSpeed = movementSpeed*0.7071; //Reduce movement speed at a diagonal
				}
			}
			//Otherwise, disable directions Link isn't facing
			else{
				if(LinkMovement[LM_STICKX]!=0&&(Link->Dir==DIR_UP||Link->Dir==DIR_DOWN)){
					CanWalk[DIR_LEFT] = false;
					CanWalk[DIR_RIGHT] = false;
				}
				if(LinkMovement[LM_STICKY]!=0&&(Link->Dir==DIR_LEFT||Link->Dir==DIR_RIGHT)){
					CanWalk[DIR_UP] = false;
					CanWalk[DIR_DOWN] = false;
				}
			}
			
			//If there's a moving block in play, cancel the speed boost if Link is touching it
			if(Screen->MovingBlockX>-1){
				//Predict where Link will move to so he doesn't clip into the block
				int projX = Link->X+movementSpeed*LinkMovement[LM_STICKX];
				int projY = Link->Y+movementSpeed*LinkMovement[LM_STICKY];
				if(RectCollision(projX, projY+8, projX+15, projY+15, Screen->MovingBlockX, Screen->MovingBlockY, Screen->MovingBlockX+15, Screen->MovingBlockY+15)){
					LinkMovement[LM_MOVEBOOST] = 0;
					return;
				}
			}
			
			//This chunk is pretty much the same for both positive and negative movement speeds.
			//The only difference is that negative needs to check both opposing directions before adding the push.
			if(movementSpeed>0){
				//Left
				if(LinkMovement[LM_STICKX]<0&&CanWalk[DIR_LEFT])
					LinkMovement[LM_PUSHX2B] -= movementSpeed;
				//Right
				else if(LinkMovement[LM_STICKX]>0&&CanWalk[DIR_RIGHT])
					LinkMovement[LM_PUSHX2B] += movementSpeed;
				//Up
				if(LinkMovement[LM_STICKY]<0&&CanWalk[DIR_UP])
					LinkMovement[LM_PUSHY2B] -= movementSpeed;
				//Down
				else if(LinkMovement[LM_STICKY]>0&&CanWalk[DIR_DOWN])
					LinkMovement[LM_PUSHY2B] += movementSpeed;
			}
			else if(movementSpeed<0){
				//Left
				if(LinkMovement[LM_STICKX]<0&&CanWalk[DIR_LEFT]&&CanWalk[DIR_RIGHT])
					LinkMovement[LM_PUSHX2B] -= movementSpeed;
				//Right
				else if(LinkMovement[LM_STICKX]>0&&CanWalk[DIR_LEFT]&&CanWalk[DIR_RIGHT])
					LinkMovement[LM_PUSHX2B] += movementSpeed;
				//Up
				if(LinkMovement[LM_STICKY]<0&&CanWalk[DIR_UP]&&CanWalk[DIR_DOWN])
					LinkMovement[LM_PUSHY2B] -= movementSpeed;
				//Down
				else if(LinkMovement[LM_STICKY]>0&&CanWalk[DIR_UP]&&CanWalk[DIR_DOWN])
					LinkMovement[LM_PUSHY2B] += movementSpeed;
			}
		}	
	}
	LinkMovement[LM_MOVEBOOST] = 0; //Movement boost gets reset at the end of every frame to prevent confusion 
									//with what it's set to or what should turn it on/off
}

//Heckin gross function. Why do I need to do this
void __LinkMovement_UglyReverseMovementFix(){
	//So basically if Link's movement boost is enough to make him go backwards
	//some extra stuff needs to happen so he scrolls screens properly.
	//It's opposite day, everybody!
	if(LinkMovement[LM_MOVEBOOST]<-1.5){
		//If he's moving towards the edge, move him away from it
		if(Link->X<=0&&LinkMovement[LM_STICKX]<0)
			Link->X+=2;
		else if(Link->X>=240&&LinkMovement[LM_STICKX]>0)
			Link->X-=2;
		if(Link->Y<=0&&LinkMovement[LM_STICKY]<0)
			Link->Y+=2;
		else if(Link->Y>=160&&LinkMovement[LM_STICKY]>0)
			Link->Y-=2;
		
		//If he's moving away from the edge, push him towards it
		if(Link->X<=0&&LinkMovement[LM_STICKX]>0)
			Link->X-=2;
		else if(Link->X>=240&&LinkMovement[LM_STICKX]<0)
			Link->X+=2;
		if(Link->Y<=0&&LinkMovement[LM_STICKY]>0)
			Link->Y-=2;
		else if(Link->Y>=160&&LinkMovement[LM_STICKY]<0)
			Link->Y+=2;
	}
}

//The ugly deformed child of the original CanWalk() function and something else entirely
bool __LinkMovement_CanWalk(int x, int y, int dir, int step, bool full_tile, bool noEdge) {
    int i; int xx; int yy;
	int xoffset = 0; int yoffset = 0;
	int width = 16; int height = 16;
	//Link's sideview hitbox is 8 pixels wide and centered on him
	if(IsSideview()&&(dir==DIR_UP||dir==DIR_DOWN)){
		xoffset = 4;
		width = 8;
	}
	//If !full_tile, trim the top half off the hitbox
	else if(!full_tile){
		yoffset = 8;
		height = 8;
	}
	if(dir==DIR_UP||dir==DIR_DOWN){ 
		//Loop between three points of collision (two if sideview)
		for(i=0; i<=width-1; i=Min(i+8, width-1)){
			if(dir==DIR_UP){
				xx = x+xoffset+i;
				yy = y+yoffset-step;
			}
			else if(dir==DIR_DOWN){
				xx = x+xoffset+i;
				yy = y+yoffset+height-1+step;
			}
			//If !noEdge, positions off the screen are considered solid
			if(xx<0||xx>255||yy<0||yy>175){
				if(!noEdge)
					return false;
			}
			if(__LinkMovement_IsSolid(xx, yy))
				return false;
			if(i==width-1)
				break;
		}
		return true;
	}
	else if(dir==DIR_LEFT||dir==DIR_RIGHT){
		//Loop between three points of collision (two if !full_tile)
		for(i=0; i<=height-1; i=Min(i+8, height-1)){
			if(dir==DIR_LEFT){
				xx = x+xoffset-step;
				yy = y+yoffset+i;
			}
			else if(dir==DIR_RIGHT){
				xx = x+xoffset+width-1+step;;
				yy = y+yoffset+i;
			}
			//If !noEdge, positions off the screen are considered solid
			if(xx<0||xx>255||yy<0||yy>175){
				if(!noEdge)
					return false;
			}
			if(__LinkMovement_IsSolid(xx, yy))
				return false;
			if(i==height-1)
				break;
		}
		return true;
	}
	return false;
}

//This function moves Link based on the values of the push indices in the global array
void __LinkMovement_UpdatePush(int indexX, int indexY, bool noEdge){
	int Imprecision = 0; //This is currently unused, but I guess I left it in in case I 
						//ever see a reason to use it again...three cheers for bloat!
	
	//So what we have here is a series of for loops that run for as long as:
	//	-The absolute value of the push array is greater than 0
	//	-Link isn't being blocked by a wall
	//  -Link hasn't been moved the max number of pixels that frame
	
	//Any movement of less than a pixel is left over in the array and any time the function successfully moves Link,
	//the array counts back down towards 0. This way movements of less than a pixel can "add up" to a full pixel movement.
	
	//Left
	for(int i=0; i<MAX_PUSH&&LinkMovement[indexX]<=-1; i++){
		if(__LinkMovement_CanWalk(Link->X, Link->Y, DIR_LEFT, 1, false, noEdge)){
			Link->X--;
			LinkMovement[indexX]++;
		}
		//This is unused, but would snap Link to the grid if he's close enough to aligned
		else if(Imprecision>0&&Abs(GridY(Link->Y+8)-Link->Y)<Imprecision&&__LinkMovement_CanWalk(Link->X, GridY(Link->Y+8), DIR_LEFT, 1, false, noEdge)){
			Link->Y = GridY(Link->Y+8);
			Link->X--;
			LinkMovement[indexX]++;
		}
		//If Link has been blocked, clear the push value. This will also end the loop.
		else{
			LinkMovement[indexX] = 0;
		}
	}
	//Right
	for(int i=0; i<MAX_PUSH&&LinkMovement[indexX]>=1; i++){
		if(__LinkMovement_CanWalk(Link->X, Link->Y, DIR_RIGHT, 1, false, noEdge)){
			Link->X++;
			LinkMovement[indexX]--;
		}
		//This is unused, but would snap Link to the grid if he's close enough to aligned
		else if(Imprecision>0&&Abs(GridY(Link->Y+8)-Link->Y)<Imprecision&&__LinkMovement_CanWalk(Link->X, GridY(Link->Y+8), DIR_RIGHT, 1, false, noEdge)){
			Link->Y = GridY(Link->Y+8);
			Link->X++;
			LinkMovement[indexX]--;
		}
		//If Link has been blocked, clear the push value. This will also end the loop.
		else{
			LinkMovement[indexX] = 0;
		}
	}
	//Up
	for(int i=0; i<MAX_PUSH&&LinkMovement[indexY]<=-1; i++){
		if(__LinkMovement_CanWalk(Link->X, Link->Y, DIR_UP, 1, false, noEdge)){
			Link->Y--;
			LinkMovement[indexY]++;
		}
		//This is unused, but would snap Link to the grid if he's close enough to aligned
		else if(Imprecision>0&&Abs(GridX(Link->X+8)-Link->X)<Imprecision&&__LinkMovement_CanWalk(GridX(Link->X+8), Link->Y, DIR_UP, 1, false, noEdge)){
			Link->X = GridX(Link->X+8);
			Link->Y--;
			LinkMovement[indexY]++;
		}
		//If Link has been blocked, clear the push value. This will also end the loop.
		else{
			LinkMovement[indexY] = 0;
		}
	}
	//Down
	for(int i=0; i<MAX_PUSH&&LinkMovement[indexY]>=1; i++){
		if(__LinkMovement_CanWalk(Link->X, Link->Y, DIR_DOWN, 1, false, noEdge)){
			Link->Y++;
			LinkMovement[indexY]--;
		}
		//This is unused, but would snap Link to the grid if he's close enough to aligned
		else if(Imprecision>0&&Abs(GridX(Link->X+8)-Link->X)<Imprecision&&__LinkMovement_CanWalk(GridX(Link->X+8), Link->Y, DIR_DOWN, 1, false, noEdge)){
			Link->X = GridX(Link->X+8);
			Link->Y++;
			LinkMovement[indexY]--;
		}
		//If Link has been blocked, clear the push value. This will also end the loop.
		else{
			LinkMovement[indexY] = 0;
		}
	}
}

//Update functions for undoing Link's movement. This relies on a certain order of events during the frame
//	1.) Pushing before waitdraw
//	2.) Waitdraw (engine movement happens now)
//	3.) Link's movement is undone. This negates pushing done before waitdraw but also engine movement.
//	4.) Pushing after waitdraw
//	5.) Link's position is stored to undo movement for the next frame
// 	6.) Waitframe

//This function handles step 3, resetting Link to his last position
void __LinkMovement_UndoLinkMovementUpdate1(){
	if(LinkMovement[LM_UNDOLINKMOVEMENT]){
		//Check that we're on the same map and screen. We don't want to reset Link's position to where he was on a different screen.
		if(LinkMovement[LM_LASTDMAP]==Game->GetCurDMap()&&LinkMovement[LM_LASTDMAPSCREEN]==Game->GetCurDMapScreen()){
			//We can undo X and Y movement selectively
			if(LinkMovement[LM_UNDOLINKMOVEMENT]&01b)
				Link->X = LinkMovement[LM_LASTX];
			if(LinkMovement[LM_UNDOLINKMOVEMENT]&10b)
				Link->Y = LinkMovement[LM_LASTY];
		}
		LinkMovement[LM_UNDOLINKMOVEMENT] = 0; //This property is also undone each frame to prevent confusion
	}
}

//This function handles step 5, storing Link's position to use the next frame
void __LinkMovement_UndoLinkMovementUpdate2(){
	//Also keep the DMap and screen tracking up to date
	LinkMovement[LM_LASTDMAP] = Game->GetCurDMap();
	LinkMovement[LM_LASTDMAPSCREEN] = Game->GetCurDMapScreen();
	
	LinkMovement[LM_LASTX] = Link->X;
	LinkMovement[LM_LASTY] = Link->Y;
}

//GLOBAL SCRIPT FUNCTIONS

//This function goes before waitframe, and resets all the global variables back to their defaults
void LinkMovement_Init(){
	LinkMovement[LM_PUSHX1A] = 0;
	LinkMovement[LM_PUSHY1A] = 0;
	LinkMovement[LM_PUSHX1B] = 0;
	LinkMovement[LM_PUSHY1B] = 0;
	LinkMovement[LM_PUSHX2A] = 0;
	LinkMovement[LM_PUSHY2A] = 0;
	LinkMovement[LM_PUSHX2B] = 0;
	LinkMovement[LM_PUSHY2B] = 0;
	LinkMovement[LM_STICKX] = 0;
	LinkMovement[LM_STICKY] = 0;
	LinkMovement[LM_MOVEBOOST] = 0;
	LinkMovement[LM_LASTX] = Link->X;
	LinkMovement[LM_LASTY] = Link->Y;
	LinkMovement[LM_LASTDMAP] = Game->GetCurDMap();
	LinkMovement[LM_LASTDMAPSCREEN] = Game->GetCurDMapScreen();
}

//This function goes within the while(true) loop and before Waitdraw() it handles:
//	-Storing Link's inputs
//	-Scrolling stuff when speed boost < -1.5
//	-Pre-waitdraw push

void LinkMovement_Update1(){
	__LinkMovement_UpdateInput();
	__LinkMovement_UglyReverseMovementFix();
	__LinkMovement_UpdatePush(LM_PUSHX1A, LM_PUSHY1A, false);
	__LinkMovement_UpdatePush(LM_PUSHX1B, LM_PUSHY1B, true);
}

//This function goes within the while(true) loop and after Waitdraw() it handles:
//	-Undoing base movement when instructed
//	-Applying speed boosts
//	-Post-waitdraw push

void LinkMovement_Update2(){
	__LinkMovement_UndoLinkMovementUpdate1();
	__LinkMovement_SpeedChange();
	__LinkMovement_UpdatePush(LM_PUSHX2A, LM_PUSHY2A, false);
	__LinkMovement_UpdatePush(LM_PUSHX2B, LM_PUSHY2B, true);
	__LinkMovement_UndoLinkMovementUpdate2();
}

//Here's an example global script with just the LinkMovement update functions. 
//Combine this with your other global scripts if you have any.

global script LinkMovement_Example{
	void run(){
		LinkMovement_Init();
		while(true){
			LinkMovement_Update1();
			Waitdraw();
			LinkMovement_Update2();
			Waitframe();
		}
	}
}

//USER SCRIPT FUNCTIONS

//Push Functions:
//All four of these functions do the same thing: Push Link around by an amount on the X and Y axis.
//pX: Amount to move Link on the X axis in pixels
//pY: Amount to move Link on the Y axis in pixels
//When moved by these functions, Link will not move through solid objects of any kind.

//Will push Link before Waitdraw()
//Will not push Link past the edge of the screen
void LinkMovement_Push(int pX, int pY){
	LinkMovement[LM_PUSHX1A] += pX;
	LinkMovement[LM_PUSHY1A] += pY;
}

//Will push Link before Waitdraw()
//Will push Link past the edge of the screen
void LinkMovement_PushNoEdge(int pX, int pY){
	LinkMovement[LM_PUSHX1B] += pX;
	LinkMovement[LM_PUSHY1B] += pY;
}

//Will push Link after Waitdraw()
//Will not push Link past the edge of the screen
void LinkMovement_Push2(int pX, int pY){
	LinkMovement[LM_PUSHX2A] += pX;
	LinkMovement[LM_PUSHY2A] += pY;
}

//Will push Link after Waitdraw()
//Will push Link past the edge of the screen
void LinkMovement_Push2NoEdge(int pX, int pY){
	LinkMovement[LM_PUSHX2B] += pX;
	LinkMovement[LM_PUSHY2B] += pY;
}

//Speed boost functions:
//These change the speed boost variable for the frame. 
//This is once again measured in pixels and will reset at the end of the frame.
//Setting a speed boost adds extra movement onto Link's base speed of 1.5 pixels per frames.
//Using these functions is preferable to writing to the speed boost directly in case things change in a future update.

//This function adds to the speed boost.
void LinkMovement_AddLinkSpeedBoost(float i){
	LinkMovement[LM_MOVEBOOST] += i;
}

//This function sets the speed boost.
void LinkMovement_SetLinkSpeedBoost(float i){
	LinkMovement[LM_MOVEBOOST] = i;
}

//This function returns the value of the current speed boost.
float LinkMovement_GetLinkSpeedBoost(){
	return LinkMovement[LM_MOVEBOOST];
}

//This function returns the current X value of Link's directional inputs.
// 0 = No InputLeft or InputRight
//-1 = InputLeft
// 1 = InputRight
int LinkMovement_StickX(){
	return LinkMovement[LM_STICKX];
}

//This function returns the current Y value of Link's directional inputs.
// 0 = No InputUp or InputDown
//-1 = InputUp
// 1 = InputDown
int LinkMovement_StickY(){
	return LinkMovement[LM_STICKY];
}

//This function sets the global script to undo Link's movement for the next frame
void LinkMovement_UndoLinkMovement(){
	LinkMovement[LM_UNDOLINKMOVEMENT] = 3;
}

//This function sets the global script to undo Link's movement selectively for the next frame
//	-bool undoX: Undo movement on the X-axis
//	-bool undoY: Undo movement on the Y-axis
void LinkMovement_UndoLinkMovement(bool undoX, bool undoY){
	LinkMovement[LM_UNDOLINKMOVEMENT] = Cond(undoX, 1, 0)+2*Cond(undoY, 1, 0);
}

bool __LinkMovement_IsSolid(int x, int y){
	if(Game->GetCurLevel()>0&&Game->GetCurLevel()<9){
		if(y<40)
			return true;
		else if(y>=144)
			return true;
		if(x<32)
			return true;
		else if(x>=224)
			return true;
	}
	return Screen->isSolid(x, y);
}

//}

//{ Dumb Ghost.zh Shit

bool Q7_Ghost_Waitframe(ffc this, npc ghost, bool clearOnDeath, bool quitOnDeath){
	bool res = Ghost_Waitframe(this, ghost, false, false);
	
	DamageNumbers_CalculateDamage(ghost, true);
	
	if(ghost->HP<ghost->Misc[NPCM_LASTHP])
		Ghost_StartFlashing();
	
	//TraceB(res);
	
	int hp;
	if(ghost->isValid())
		hp = ghost->HP;
	
	if(!res&&hp<=0){
		if(clearOnDeath)
		{
			__GhCleanUp(this);
			Ghost_Data=0;
			Ghost_ClearCombos();
			
			int cx = CenterX(ghost);
			int cy = CenterY(ghost);
			ghost->X = cx-8;
			ghost->Y = cy-8;
			ghost->TileWidth = 1;
			ghost->TileHeight = 1;
		}
		
		if(quitOnDeath)
			Quit();
		
		return false;
	}

	return true;
}
bool Q7_Ghost_Waitframe(ffc this, npc ghost){
	Q7_Ghost_Waitframe(this, ghost, true, true);
}

void Q7_Ghost_Waitframes(ffc this, npc ghost, bool clearOnDeath, bool quitOnDeath, int frames){
	for(int i=0; i<frames; ++i){
		Q7_Ghost_Waitframe(this, ghost, clearOnDeath, quitOnDeath);
	}
}
void Q7_Ghost_Waitframes(ffc this, npc ghost, int frames){
	for(int i=0; i<frames; ++i){
		Q7_Ghost_Waitframe(this, ghost, true, true);
	}
}

//}

int G[1024];

const int G_LASTX = 0;
const int G_LASTY = 1;
const int G_LASTDMAP = 2;
const int G_LASTSCREEN = 3;
const int G_LASTEXITDIR = 4;
const int G_ISF6 = 5;
const int G_LASTOVERWORLDSCREEN = 6;
const int G_ANIM = 7;
const int G_PHASEDIR = 8;
const int G_PHASEX = 9;
const int G_PHASEY = 10;
const int G_PHASEPUSHCOUNTER = 11;
const int G_PHASECOUNTER = 12;
const int G_LASTHP = 13;
const int G_REALLYJOELCLEARALL = 14;
const int G_SPECIALMODE = 15;
const int G_WAITSCROLL = 16;
const int G_MESSAGEQUEUE = 17;
const int G_MESSAGEQUEUETIME = 18;
const int G_BRANGPUSHX = 19;
const int G_BRANGPUSHY = 20;
const int G_PHASESCREEN = 21;
const int G_PHASEMAP = 22;
const int G_L10BG_X = 23;
const int G_L10BG_Y = 24;
const int G_L10BG_VX = 25;
const int G_L10BG_VY = 26;
const int G_L10BG_SCALE = 27;
const int G_L10BG_T = 28;
const int G_FAKECAVEEXITDMAP = 29;
const int G_FAKECAVEEXITSCREEN = 30;
const int G_HASSBOMB = 31;
const int G_SBOMBTIMER = 32;
const int G_PHASELEVEL2 = 33;
const int G_ACCELERATOR_TIME = 34;
const int G_ACCELERATOR_ANGLE = 35;
const int G_ACCELERATOR_DOUBLETAP = 36;
const int G_ACCELERATOR_ACCEL = 37;
const int G_ACCELERATOR_LASTDIR = 38;
const int G_TRACKTILEX = 39;
const int G_TRACKTILEY = 40;
const int G_TRACKTILEDIR = 41;
const int G_TRACKTILED = 42;
const int G_TRACKTILESUBPIXELS = 43;
const int G_TRACKTILECMB = 44;
const int G_TRACKTILECS = 45;
const int G_DARMCONVEYORDIR = 46;
const int G_TRACKTILERESET = 47;
const int G_TRACKTILERESETD = 48;
const int G_TRACKTILERESETDHALF = 49;
const int G_TRACKTILESTEP = 50;
const int G_NODARKENROOM = 51;
const int G_LANMOLASPAWNX = 52;
const int G_LANMOLASPAWNY = 53;
const int G_DARMLIGHTNINGCOOLDOWN = 54;
const int G_BOOTSLIFE = 55;
const int G_BOOTSONDAMAGE = 56;
const int G_BOOTSTIMER = 57;
const int G_GANNONX = 58;
const int G_GANNONY = 59;
const int G_SCRIPTPASSAGE_TYPE = 60;
const int G_SCRIPTPASSAGE_OLDDMAP = 61;
const int G_SCRIPTPASSAGE_OLDSCREEN = 62;
const int G_SCRIPTPASSAGE_OLDITEM = 63;
const int G_SCRIPTPASSAGE_NEWDMAP = 64;
const int G_SCRIPTPASSAGE_NEWSCREEN = 65;
const int G_SHOWDAMAGENUMBERS = 66;
const int G_LASTLEVEL = 67;
const int G_LASTKEYCOUNT = 68;
const int G_SFXANIM = 69; //Nice >:]
const int G_SAWBANNONCUTSCENE = 70;

const int G_DISABLE_SPECIALMODES = 71;
const int G_MODE_HYRULEWARRIORS = 72;
const int G_MODE_BINLAND = 73;
const int G_MODE_DARKNUT = 74;
const int G_MODE_ALWAYSHARD = 75;
const int G_MODE_SPEEDHACK = 76;
const int G_MODE_LOGGINGMEMES = 77;
const int G_MODE_GLITCH = 78;
const int G_MODE_YOLOREF = 79;
const int G_MODE_NOTRIFORCE = 80;
const int G_MODE_DIMENTIO = 81; //deprecated
const int G_MODE_SUPERBOMBS = 82;
const int G_MODE_SAITAMA = 83;
const int G_MODE_NJFHP = 84;
const int G_MODE_COLORSHIFT = 85;
const int G_MODE_RANDOMIZER = 86;
const int G_AUTOBOWLASTX = 87;
const int G_AUTOBOWLASTY = 88;
const int G_AUTOBOWANGLE = 89;
const int G_AUTOBOWTIMER = 90;
const int G_AUTOBOWSTATE = 91;
const int G_MODE_EASYNAVIGATION = 92;
const int G_MODE_SPOILENEMYSECRETS = 93;
const int G_AUTOBOWFIRINGCOST = 94;
const int G_MODE_FORCESLASH = 95;
const int G_DIMENTIOSHORTCUT = 96;
const int G_FROZEN = 97;
const int G_RANDOMENUOPEN = 98;
const int G_RANDOMENUPAGE = 99;
const int G_RANDOMIZER_HASCHEATED = 100;
const int G_MODE_HANDYMAP = 101;
const int G_MODE_GARDEVOIR = 102;
const int G_MODE_OKBOOMER = 103;
const int G_MODE_NORANDOMIZERPROGRESSIVE = 104;
const int G_MODE_NORANDOMIZERLOGIC = 105;
const int G_CANDLE3COREFIRES = 106;

const int G_ISRANDOMIZER = 200;
const int G_RANDOMIZETRIFORCE = 201;
const int G_RANDOMIZETRASH = 202;
const int G_RANDOMIZESTARTINGSWORD = 203;
const int G_RANDOMIZER_REQTRIFORCE = 204;
const int G_RANDOMIZER_CHOOSEONETYPE = 205;
const int G_SEEDX = 206;
const int G_SEEDY = 207;

const int G_LASTOVERWORLDDMAP = 208;
const int G_CONTINUEHP = 209;
const int G_PARTIALJOKE = 210;
const int G_PERMADEATHCOUNTER = 211;
const int G_ALLOWCOPYTILEINIT = 212;
const int G_F6HP = 213; //HP to set Link to on F6
const int G_MODE_BSIDES = 214;
const int G_MODE_GIMMICKRINGS = 215;
const int G_RANDOMENU_SELECTINGRINGS = 216;
const int G_RANDOMENU_RINGSEL1 = 217;
const int G_RANDOMENU_RINGSEL2 = 218;
const int G_RANDOMENU_RING1 = 219;
const int G_RANDOMENU_RING2 = 220;
const int G_RANDOMENU_RING3 = 221;
const int G_RANDOMENU_RING4 = 222;
const int G_RANDOMENU_RINGID1 = 223;
const int G_RANDOMENU_RINGID2 = 224;
const int G_RANDOMENU_RINGID3 = 225;
const int G_RANDOMENU_RINGID4 = 226;
const int G_JANDRARING_BOOSTFRAMES = 227;
const int G_LIKELIKE_STOLENITEM = 228;
const int G_LIKELIKE_STOLENITEMFRAMES = 229;
const int G_ZARATH_TIMER = 230;
const int G_ZARATH_MULTIPLIER = 231;
const int G_ZARATH_SAFETYFRAMES = 232;
const int G_ZARATH_FILL = 233;
const int G_BLUETEARHEAL = 234;
const int G_BLUETEARHEALCOOLDOWN = 235;
const int G_AUTIMECIARING = 236;
const int G_AUTIMECIARINGID = 237;
const int G_AUTIMECIARING_ANIMS = 238;
const int G_MODE_KEYSANITY = 239;
const int G_L0ACCEL = 240;
const int G_MODE_ENTRANCE_RANDO = 241;
const int G_SEEN_L1 = 242;
const int G_SEEN_L2 = 243;
const int G_SEEN_L3 = 244;
const int G_SEEN_L4 = 245;
const int G_SEEN_L5 = 246;
const int G_SEEN_L6 = 247;
const int G_SEEN_L7 = 248;
const int G_SEEN_L8 = 249;
const int G_SEEN_L9 = 250;
const int G_SEEN_L10 = 251;
const int G_SCRIPTPASSAGE_OLDSTRING = 252;
const int G_SCRIPTPASSAGE_OLDGUY = 253; //unused?
const int G_RANDOMIZERAUTOMAXSETTINGS = 254;
const int G_LOSTRUSSIANROULETTE = 255;
const int G_REVOLVERCHAMBER = 256;
const int G_REVOLVERDEATHCHAMBER = 257;
const int G_DOORREPAIRTRACKER = 258;
const int G_MODE_CAVESANITY = 259;
const int G_SUBSCREENANIM = 260;
const int G_ENTRANCERANDOMIZER_NUMENTRANCES = 261;
const int G_MODE_RANDOMIZEMUMPUS = 262;
const int G_MODE_FREESIGHT = 263;
const int G_MODE_TRACKERHINTS = 264;
const int G_SPECIALWARP = 265;
const int G_ALTCHARACTER = 266;
const int G_ALTCHARACTERPAL = 267;
const int G_SIGCOOLDOWNMAX = 268;
const int G_SIGCOOLDOWN = 269;
const int G_UTILITYCOOLDOWNMAX = 270;
const int G_UTILITYCOOLDOWN = 271;
const int G_MODE_ALTCHARACTER = 272;
const int G_HPSCALE = 273;
const int G_TEMPDAMAGEMULTIPLIER = 274;
const int G_MODE_NORANDOMIZERNIGHTMARE = 275;
const int G_REALDAMAGEMULTIPLIER = 276;
const int G_INVISTIMER = 277;
const int G_NOCOLLTIMER = 278;
const int G_REMAININGLADDERS = 279;
const int G_FIRSTLOAD = 280;
const int G_PRESERVEDCHARGEA = 281;
const int G_IGNORESIGCOOLDOWN = 282;
const int G_SWIFTSWIMCOOLDOWN = 283;
const int G_NODRAWSUBSCREEN = 284;
const int G_PRESERVEDCHARGEB = 285;
const int G_NORAATTACKCOMMAND = 286;
const int G_HOLMLASTSHIELD = 287;
const int G_ENEMYCOUNT = 288;
const int G_ENEMYHPTOTAL = 289;
const int G_OLDENEMYHPTOTAL = 290;
const int G_MANISTARFALLCHARGE = 291;
const int G_MANISTARFALLLEVEL = 292;
const int G_LASTMAPSCRN1 = 293;
const int G_LASTMAPSCRN2 = 294;
const int G_LASTMAPSCRN3 = 295;
const int G_LASTMAPSCRN4 = 296;
const int G_LASTMAPSCRN5 = 297;
const int G_LASTMAPSCRN6 = 298;
const int G_MODE_DUNGEONCEPTION = 299;
const int G_MODE_DEBUGSTART = 300;
const int G_FROGGER_SHIELDFLAGS = 301;
const int G_FROGGER_SHIELDCOOLDOWN = 302;
const int G_FROGGER_SHIELDDECAYTIME = 303;
const int G_FROGGER_SHIELDLEVEL = 304;
const int G_FROGGER_SHIELDTEMPLEVEL = 305;
const int G_LINKSPEEDBOOST = 306;
const int G_FROGGER_BLACKHOLETIMER = 307;
const int G_FROGGER_HALOEXCEPTION = 308; //Makes halo draw while invisible
const int G_LASTRUPEECOUNT = 309;
const int G_DIMITRANSFORM = 310;
const int G_WALLMASTERSTORAGE1 = 311;
const int G_WALLMASTERSTORAGE2 = 312;
const int G_WALLMASTERSTORAGE3 = 313;
const int G_WALLMASTERSTORAGE4 = 314;
const int G_WALLMASTERSTORAGE5 = 315;
const int G_WALLMASTERSTORAGE6 = 316;
const int G_WALLMASTERSTORAGE7 = 317;
const int G_WALLMASTERSTORAGE8 = 318;
const int G_WALLMASTERSTORAGE9 = 319;
const int G_WALLMASTERSTORAGE10 = 320;
const int G_DIMITRANSFORMSUBTYPE = 321;
const int G_MODE_EQUIPALLRINGS = 322;
const int G_SWORDSHOOTERFLAG = 323;
const int G_MODE_RUPOORGARBAGE = 324;
const int G_MODE_BLEEDINGHEART = 325;
const int G_MODE_BLEEDINGWALLET = 326;
const int G_LINKBLEEDCOOLDOWN = 327;
const int G_LINKRUPEEDRAINCOOLDOWN = 328;

const int G_RIGGSLADDERSTART = 500;
const int G_RIGGSLADDEREND = 563;

const int CMB_SCREENFREEZEA = 458;
const int CMB_SCREENFREEZEB = 459;

void LoadInvulnerableNPCs(int npcT, int npcID){
	npcT[NPCT_GUY] = 1;
	npcT[NPCT_FAIRY] = 1;
	npcT[NPCT_PROJECTILE] = 1;
	npcT[NPCT_DIGDOGGER] = 1;
	npcT[NPCT_TRAP] = 1;
}

bool NPCInvulnerable(npc n, int npcT, int npcID){
	if(!n->CollDetection)
		return true;
	if(Abs(n->HitXOffset)==1000||Abs(n->HitYOffset)==1000)
		return true;
	
	if(npcT[n->Type]||npcID[n->ID])
		return true;
	
	return false;
}

void TraceBinary(int num, int cap){
	int str[17];
	for(int i=0; i<cap; i++){
		str[i] = 48;
		if(num&(1<<(cap-1-i)))
			str[i] = 49;
	}
	str[cap] = 0;
	TraceS(str);
	TraceNL();
}

void BinaryToString(int str, int num, int cap){
	for(int i=0; i<cap; i++){
		str[i] = 48;
		if(num&(1<<(cap-1-i)))
			str[i] = 49;
	}
	str[cap] = 0;
}

void ScreenFreeze(){
	ffc f1 = Screen->LoadFFC(31);
	f1->Data = CMB_SCREENFREEZEA;
	ffc f2 = Screen->LoadFFC(32);
	f2->Data = CMB_SCREENFREEZEB;
	G[G_FROZEN] = 1;
}

void ScreenUnfreeze(){
	ffc f1 = Screen->LoadFFC(31);
	f1->Data = 0;
	ffc f2 = Screen->LoadFFC(32);
	f2->Data = 0;
	G[G_FROZEN] = 0;
}

void FirstTrace(){
	int str1[] = "\n\nConsole giving me bad times, but eh, we take those.\n\n";
	int str2[] = "\n\ndefault default default default default default default\n\n";
	int str3[] = "\n\nFLAGRANT SYSTEM ERROR: The system is down. I dunno what you did, moron, but you sure screwed everything up.\n\n";
	int str4[] = "\n\nAll working and no jank makes Moosh a dull boy.\n\n";
	int str5[] = "\n\nThese are not the traces you're looking for.\n\n";
	int str6[] = "\n\nGive me the controller.\n\n";
	int str7[] = "\n\n动态网自由门 天安門 天安门 法輪功 李洪志\n\n";
	int str8[] = "\n\nFree Tibet --- The Tiananmen Square protests of 1989 --- The Tiananmen Square Massacre --- The Anti-Rightist Struggle --- The Great Leap Forward --- The Great Proletarian Cultural Revolution --- Human Rights --- Democratization --- Freedom --- Independence --- Multi-party system --- Taiwan Formosa --- Republic of China --- Tibet --- Dalai Lama --- Falun Dafa --- The Xinjiang Uyghur Autonomous Region --- Nobel Peace Prize --- Liu Xiaobo --- Winnie the Pooh\n\n";
	int str9[] = "\n\n2 + 2 = 5\n\n";
	int str10[] = "\n\nA trolley has already run over five people and five more are tied to the tracks. If you pull the lever it will divert the trolley to a track with nobody tied to it. Would it be fair to the people the trolley has already killed to divert it now?\n\n";
	int str11[] = "\n\nYo! Yo! Funky monkey!\n\n";
	int str12[] = "\n\nLook for the feather. 8:14 2:3D 14:1C 7:43 7:0E\n\n";
	int str13[] = "\n\nTell Evan to work on Inverse Mirror.\n\n";
	int str14[] = "\n\nBe gay. Do crime.\n\n";
	int str15[] = "\n\nSame line curly brace master race.\n\n";
	int str16[] = "\n\nEnter the void. Empty and become Moosh.\n\n";
	int str17[] = "\n\nIt's hip to despair.\n\n";
	int str18[] = "\n\nLove and hate are two sides of the same coin.\n\n";
	int str19[] = "\n\nOh no. Those weren't the right gummy bears.\n\n";
	int str20[] = "\n\nPrepare to die, eggbear!\n\n";
	int str21[] = "\n\nMaybe the real 7th quest was the friends we made along the way.\n\n";
	int str22[] = "\n\nGive me your juice, I'll give you mine...\n\n";
	int str23[] = "\n\nLive on the edge. Skip the compile test. Become perfection.\n\n";
	int str24[] = "\n\nThis isn't even my final fedora.\n\n";
	int str25[] = "\n\nAll art is impermanent. Moldorm is eternal.\n\n";
	int str26[] = "\n\nThis too is a beautiful lie.\n\n";
	int str27[] = "\n\nWhy be the best when you can be the first?\n\n";
	int str28[] = "\n\nI'd write something here, but that would require effort.\n\n";
	int str29[] = "\n\nFear the old code.\n\n";
	int str30[] = "\n\nMy oh my...No one can control Spergileus now...\n\n";
	int str111[] = "\n\nWHEN WILL YOU REALIZE THE REALITY\n\nOF THINGS THAT ARE YEARNED FOR BUT NEVER TO BE\n\nAT ODDS WITH THE WORLD YOU CAN NEVER BE FREED\n\nAWAKEN THE META WITHIN ME.\n\n";
	
	int str[] = {str1, str2, str3, str4, str5, str6, str7, str8, str9, str10, str11, str12, str13, str14, str15, str16, str17, str18, str19, str20, str21, str22, str23, str24, str25, str26, str27, str28, str29, str30};
	int size = SizeOfArray(str);
	if(!Rand(8192))
		printf(str111);
	else
		printf(str[Rand(size)]);
}

void Main2_Init(int scramblePages){
	if(DEBUG_RANDOMIZER_SEEDS)
		G[G_MODE_RANDOMIZER] = 1;
	if(G[G_ISRANDOMIZER]){
		if(Link->InputEx1&&Link->InputEx2){
			G[G_RANDOMIZER_HASCHEATED] = 1;
		}
		if(G[G_RANDOMIZER_HASCHEATED]){
			for(int i=G_SEEN_L1; i<=G_SEEN_L9; ++i){
				G[i] = 1;
			}
		}
		ImGonnaCoooooom(Link->InputEx1&&Link->InputEx2);
	}
	
	if(G[G_DOORREPAIRTRACKER]!=0){
		Game->DCounter[CR_RUPEES] += G[G_DOORREPAIRTRACKER];
		G[G_DOORREPAIRTRACKER] = 0;
	}
	
	if(Q7_CheatEnabled(G_MODE_SAITAMA))
		Link->Item[I_CRIT5] = true;
	if(G[G_ALLOWCOPYTILEINIT]){
		G[G_LINKBLEEDCOOLDOWN] = 0;
		MiscCopyTile_Init();
		NoJoke_CopyTile();
		HeartEffects_CopyTile();
	}
	FirstTrace();
	Global_Init();
	MessageQueue_Init();
	StartGhostZH();
	PhaseCloak_Init();
	L10BG_Init();
	TrackTile_Init();
	DamageNumbers_Init();
	Boots_Recharge();
	FreeformDoorwayAutoWalk();
	LevelKeys_Init();
	Difficulty_Init();
	TileScramble_Init(scramblePages);
	PermComboChanges_Init();
	RandomizerPauseMenu_InitRings();
	AltCharacter_Init();
	ManiStarfallCopyTile();
	
	if(Q7_CheatEnabled(G_MODE_DEBUGSTART)){
		Link->MaxHP = 12*16;
		Link->HP = 12*16;
		
		Game->MCounter[CR_BOMBS] = 20;
		Game->Counter[CR_BOMBS] = 20;
		Link->Item[I_BOMB] = true;
		Game->Counter[CR_RUPEES] = 255;
		
		G[G_RANDOMIZER_CHOOSEONETYPE] = 2;
		
		Link->Item[I_CRIT1] = true;
		Link->Item[I_CRIT2] = true;
		Link->Item[I_CRIT3] = true;
		Link->Item[I_CRIT4] = true;
		
		Link->Item[I_SWORD3] = true;
		Link->Item[I_RING1] = true;
		Link->Item[I_RING2] = true;
		
		Link->Item[I_BRACELET2] = true;
		Link->Item[I_LETTER] = true;
		Link->Item[I_POTION1] = true;
		Link->Item[I_POTION2] = true;
		Link->Item[I_SECRETRING] = true;
		Link->Item[I_BAIT] = true;
		
		Link->Item[I_WHISTLE] = true;
		Link->Item[I_BRANG3] = true;
		Link->Item[I_BOW2] = true;
		Link->Item[I_ARROW2] = true;
		Link->Item[I_WAND] = true;
		Link->Item[I_REFWANDBOOK] = true;
		Link->Item[I_FLIPPERS2] = true;
		Link->Item[I_CANDLE3] = true;
		Link->Item[I_PHASECLOAK2] = true;
		Link->Item[I_SHIELD2] = true;
		Link->Item[I_SHIELD3] = true;
		Link->Item[I_SHIELD4] = true;
		Link->Item[I_SCRIPTBOOTS] = true;
		Link->Item[I_ACCELERATOR] = true;
		
		for(int i=1; i<=8; ++i){
			SetLevelItem(LI_TRIFORCE, true);
			SetLevelItem(LI_MAP, true);
			SetLevelItem(LI_COMPASS, true);
		}
	}
}

global script Main2{
	void run(){
		int scramblePages[] = {0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 25, 26, 27, 28, 29, 30, 31, 40, 41, 42, 43, 44, 100, 101, 102, 103, 104, 105, 106, 200};
		
		if(Link->Item[I_SETTING_3HEARTCONTINUE]){
			if(G[G_CONTINUEHP]==0)
				Link->HP = 16;
			else if(G[G_CONTINUEHP]==1)
				Link->HP = 48;
			else if(G[G_CONTINUEHP]==2)
				Link->HP = Max(48, Round(Link->MaxHP/16*0.5)*16);
			else if(G[G_CONTINUEHP]==3)
				Link->HP = Max(48, Round(Link->MaxHP/16*0.75)*16);
			else if(G[G_CONTINUEHP]==5){
				if(G[G_PERMADEATHCOUNTER]){
					G[G_PERMADEATHCOUNTER] = 0;
					Link->Warp(34, 0x31);
				}
				else{
					if(G[G_F6HP]>0)
						Link->HP = G[G_F6HP];
				}
			}
			if(Game->GetCurDMap()==18&&G[G_CONTINUEHP]!=5)
				Link->HP = Link->MaxHP;
		}
		
		Main2_Init(scramblePages);
		
		G[G_ISF6] = 1;
		
		int npct_NoClone[42];
		int npc_NoClone[512];
		NPCData_NoClone_Init(npct_NoClone, npc_NoClone);
		int npct_NoHPLower[42];
		int npc_NoHPLower[512];
		NPCData_NoHPLower_Init(npct_NoHPLower, npc_NoHPLower);
		int npct_NoSpeedChange[42];
		int npc_NoSpeedChange[512];
		NPCData_NoSpeedChange_Init(npct_NoSpeedChange, npc_NoSpeedChange);
		int npcData[16] = {npc_NoClone, npct_NoClone, npc_NoHPLower, npct_NoHPLower, npc_NoSpeedChange, npct_NoSpeedChange};
		
		int randoPauseMenuData[2048];

		while(true){
			Debug_Update();
			SpecialModes_Update(scramblePages);
			RandomizerPauseMenu_Update(randoPauseMenuData);
			RandoPowerPotions_Update();
			
			if(!G[G_FROZEN]){
				Cheats_Update();
				ScriptRings_Update();
				LevelKeys_Update();
				TrackTile_Update1();
				G[G_ANIM] = (G[G_ANIM]+1)%360;
				OWRain_Update();
				Difficulty_Update();
				MessageQueue_Update();
				OnScreenChange();
				SecretSparkles();
				Candle3_Update();
				PhaseCloak();
				LinkMovement_Update1();
				LWeapon_Update();
				NPC_Update(npcData);
				Item_Update();
				UpdateGhostZH1();
				Combo_Update();
				EasyModeShutters_Update();
				L10BG_Update();
				TunicEatingLikeLike_Update();
				SuperBomb_Update();
				Accelerator_Update();
				DamageNumbers_UpdateLink();
				DamageNumbers_UpdateNumberGFX();
				Boots_Update();
				AutoBow_Update();
				Permadeath_Update();
				Timers_Update();
				AltCharacter_Update();
			}
			
			Waitdraw();
			
			if(!G[G_FROZEN]){
				Flippers2_Update();
				UpdateGhostZH2();
				PhaseCloak2();
				LinkMovement_Update2();
				TrackTile_Update2();
			}
			
			Waitframe();
		}
	}
}

const int SFX_RANDOSUBSCREEN = 5;

void RandomizerPauseMenu_QuickWarp(){
	int destDMap = -1;
	int destScreen = -1;
	if(G[G_RANDOMENUPAGE]==1){
		destDMap = 0;
		destScreen = 0x77;
	}
	else if(G[G_RANDOMENUPAGE]==2){
		destDMap = 1;
		destScreen = 0x72;
	}
	else if(G[G_RANDOMENUPAGE]==3){
		destDMap = 2;
		destScreen = 0x73;
	}
	else if(G[G_RANDOMENUPAGE]==4){
		destDMap = 3;
		destScreen = 0x12;
	}
	else if(G[G_RANDOMENUPAGE]==5){
		destDMap = 4;
		destScreen = 0x57;
	}
	else if(G[G_RANDOMENUPAGE]==6){
		destDMap = 5;
		destScreen = 0x53;
	}
	else if(G[G_RANDOMENUPAGE]==7){
		destDMap = 6;
		destScreen = 0x73;
	}
	else if(G[G_RANDOMENUPAGE]==8){
		destDMap = 7;
		destScreen = 0x15;
	}
	else if(G[G_RANDOMENUPAGE]==9){
		destDMap = 8;
		destScreen = 0x51;
	}
	else if(G[G_RANDOMENUPAGE]>9&&G[G_RANDOMENUPAGE]<=15){
		destDMap = 9;
		destScreen = 0x73;
	}
	
	if(Q7_CheatEnabled(G_MODE_COLORSHIFT)){
		if(G[G_RANDOMENUPAGE]<=9)
			destDMap += 59;
		else
			destDMap += 60;
	}
	
	if(IsRaining()){
		if(destDMap==0)
			destDMap = 22;
		else if(destDMap==7)
			destDMap = 37;
		else if(destDMap==66)
			destDMap = 68;
	}
	
	if(destDMap>-1){
		G[G_SPECIALWARP] = 1;
		Link->Warp(destDMap, destScreen);
	}
}

void RandomizerPauseMenu_DrawSeed(int layer, int x, int y){
	int dig[4];
	dig[0] = Floor(G[G_SEEDX]/16);
	dig[1] = G[G_SEEDX]%16;
	dig[2] = Floor(G[G_SEEDY]/16);
	dig[3] = G[G_SEEDY]%16;
	
	int seedStr[] = "SEED: XXXX";
	if(dig[0]>9)
		seedStr[6] = 'A'+dig[0]-10;
	else
		seedStr[6] = '0'+dig[0];
	
	if(dig[1]>9)
		seedStr[7] = 'A'+dig[1]-10;
	else
		seedStr[7] = '0'+dig[1];
	
	if(dig[2]>9)
		seedStr[8] = 'A'+dig[2]-10;
	else
		seedStr[8] = '0'+dig[2];
	
	if(dig[3]>9)
		seedStr[9] = 'A'+dig[3]-10;
	else
		seedStr[9] = '0'+dig[3];
	
	Screen->DrawString(layer, x, y, FONT_Z1, 0x01, 0x0F, TF_CENTERED, seedStr, 128);
}

void RandomizerPauseMenu_Update(int randoPauseMenuData){
	if(!G[G_ISRANDOMIZER])
		return;
	if(Link->Action==LA_SCROLLING)
		return;
	if(!G[G_RANDOMENUOPEN]){
		if(Link->PressMap){
			Game->PlaySound(SFX_RANDOSUBSCREEN);
			
			ScreenFreeze();
			
			RandomizerPauseMenu_InitData(randoPauseMenuData);
			G[G_RANDOMENUOPEN] = 1;
			
			Link->InputMap = false;
			Link->PressMap = false;
		}
	}
	else{
		G[G_SUBSCREENANIM] = (G[G_SUBSCREENANIM]+1)%360;
		if(G[G_RANDOMIZER_HASCHEATED]||Q7_CheatEnabled(G_MODE_HANDYMAP)){
			if(Link->PressEx1&&!G[G_RANDOMENU_SELECTINGRINGS]){
				if(G[G_RANDOMENUPAGE]>0){
					G[G_RANDOMENUPAGE] = 0;
					Game->PlaySound(SFX_SELECT);
				}
				else{
					G[G_RANDOMENUPAGE] = 1+Clamp(RandomizerPauseMenu_GetMetaLevel(), 0, 14);
					Game->PlaySound(SFX_SELECT);
				}
			}
			if(Q7_HasRing(I_SPRING22_SOARING)){
				if(Link->PressA&&G[G_RANDOMENUPAGE]>0&&G[G_RANDOMENUPAGE]<=15){
					ScreenUnfreeze();
				
					G[G_RANDOMENUOPEN] = 0;
					G[G_RANDOMENU_SELECTINGRINGS] = 0;
						
					Link->InputMap = false;
					Link->PressMap = false;
					
					RandomizerPauseMenu_QuickWarp();
				}
			}
			if(Link->PressL||(Link->PressLeft&&!G[G_RANDOMENU_SELECTINGRINGS])){
				G[G_RANDOMENU_SELECTINGRINGS] = 0;
				Game->PlaySound(SFX_SELECT);
				--G[G_RANDOMENUPAGE];
				if(G[G_MODE_GIMMICKRINGS]){
					if(G[G_RANDOMENUPAGE]<-1)
						G[G_RANDOMENUPAGE] = 15;
				}
				else{
					if(G[G_RANDOMENUPAGE]<0)
						G[G_RANDOMENUPAGE] = 15;
				}
			}
			if(Link->PressR||(Link->PressRight&&!G[G_RANDOMENU_SELECTINGRINGS])){
				G[G_RANDOMENU_SELECTINGRINGS] = 0;
				Game->PlaySound(SFX_SELECT);
				++G[G_RANDOMENUPAGE];
				if(G[G_RANDOMENUPAGE]>15){
					if(G[G_MODE_GIMMICKRINGS])
						G[G_RANDOMENUPAGE] = -1;
					else
						G[G_RANDOMENUPAGE] = 0;
				}
			}
		}
		
		Screen->Rectangle(6, 0, 0, 255, 175, 0x0F, 1, 0, 0, 0, true, 128);
		if(G[G_RANDOMENUPAGE]==-1)
			RandomizerPauseMenu_DrawRingScreen();
		else
			RandomizerPauseMenu_DrawText(randoPauseMenuData, G[G_RANDOMENUPAGE]);
		if(Link->PressMap){
			Game->PlaySound(SFX_RANDOSUBSCREEN);
			
			ScreenUnfreeze();
			
			G[G_RANDOMENUOPEN] = 0;
			G[G_RANDOMENU_SELECTINGRINGS] = 0;
				
			Link->InputMap = false;
			Link->PressMap = false;
		}
	}
}

void RandomizerPauseMenu_DrawText(int randoPauseMenuData, int tab){
	int str_itemCollection[] = "ITEM COLLECTION";
	int str_overworld[] = "OVERWORLD";
	int str_level1[] = "L1: LUNAR";
	int str_level2[] = "L2: TOXIC";
	int str_level3[] = "L3: TEMPORAL";
	int str_level4[] = "L4: CASCADE";
	int str_level5[] = "L5: BLACKSTAR";
	int str_level6[] = "L6: POVERTY";
	int str_level7[] = "L7: CYCLONE";
	int str_level8[] = "L8: NIGHTMARE";
	int str_level9[] = "L9: ADJEAN'S TOWER";
	int str_level9F1[] = "L9: ADJEAN'S TOWER F1";
	int str_level9F2[] = "L9: ADJEAN'S TOWER F2";
	int str_level9F3[] = "L9: ADJEAN'S TOWER F3";
	int str_level9F4[] = "L9: ADJEAN'S TOWER F4";
	int str_level9F5[] = "L9: ADJEAN'S TOWER F5";
	int str_level9F6[] = "L9: ADJEAN'S TOWER F6";
	
	int tabTitles[] = {str_itemCollection, str_overworld, str_level1, str_level2, str_level3, str_level4, str_level5, str_level6, str_level7, str_level8, str_level9F1, str_level9F2, str_level9F3, str_level9F4, str_level9F5, str_level9F6};
	int levelTitles[] = {str_itemCollection, str_overworld, str_level1, str_level2, str_level3, str_level4, str_level5, str_level6, str_level7, str_level8, str_level9, str_level9, str_level9, str_level9, str_level9, str_level9};
	
	Screen->DrawString(6, 128, 8, FONT_Z1, 0x01, -1, TF_CENTERED, tabTitles[tab], 128);
	
	if(tab==0){
		RandomizerPauseMenu_DrawSeed(7, 144, -56+4);
		
		int levelC[] = {0x01, 0x82, 0x52, 0x12, 0x72, 0xB1, 0xA2, 0xAB, 0x81, 0xB2, 0xB2, 0xB2, 0xB2, 0xB2, 0xB2};
		if(G[G_MODE_KEYSANITY]&&Link->Item[I_SETTING_TRUEKEYS])
			Screen->FastTile(6, 224, 8, 5881, 0, 128);
		
		for(int i=0; i<=9; i++){
			Screen->DrawString(6, 8, 8+24+12*i, FONT_Z1, levelC[i], -1, TF_NORMAL, levelTitles[1+i], 128);
			int current[16];
			int total[16];
			int divisor[] = " / ";
			int completion[16];
			int j;
			itoa(current, randoPauseMenuData[2*i+1]);
			itoa(total, randoPauseMenuData[2*i+0]);
			
			strcat(completion, current);
			strcat(completion, divisor);
			strcat(completion, total);
			
			Screen->DrawString(6, 128+32, 8+24+12*i, FONT_Z1, levelC[i], -1, TF_NORMAL, completion, 128);
		
			if(G[G_MODE_KEYSANITY]&&Link->Item[I_SETTING_TRUEKEYS]&&i>0){
				Screen->DrawInteger(6, 224, 8+24+12*i, FONT_Z1, 0x01, -1, -1, -1, Game->LKeys[i], 0, 128);
			}
		}
	}
	else{
		RandomizerPauseMenu_DrawMap(randoPauseMenuData, 128, 8+24, tab);
	}
}

void RandomizerPauseMenu_DrawMap(int randoPauseMenuData, int centerX, int topY, int tab){
	int itemGFX[256];
	itemGFX[I_SWORD1] = 8320;
	itemGFX[I_SWORD2] = 8320;
	itemGFX[I_SWORD3] = 8320;
	itemGFX[I_SWORD4] = 8320;
	
	itemGFX[I_FLIPPERS] = 8322;
	itemGFX[I_FLIPPERS2] = 8322;
	
	itemGFX[I_REFWANDBOOK] = 8324;
	
	itemGFX[I_RING1] = 8326;
	itemGFX[I_RING2] = 8326;
	
	itemGFX[I_SECRETRING] = 8328;
	itemGFX[I_RINGBOX] = 8374;
	
	itemGFX[I_BRACELET2] = 8330;
	
	itemGFX[I_SCRIPTBOOTS] = 8332;
	
	itemGFX[I_SHIELD3] = 8334;
	itemGFX[I_SHIELD4] = 8334;
	
	itemGFX[I_ACCELERATOR] = 8336;
	
	itemGFX[I_BRANG1] = 8338;
	itemGFX[I_BRANG2] = 8338;
	itemGFX[I_BRANG3] = 8338;
	
	itemGFX[I_ARROW1] = 8340;
	itemGFX[I_ARROW2] = 8340;
	
	itemGFX[I_BOW1] = 8342;
	itemGFX[I_BOW2] = 8342;
	
	itemGFX[I_CANDLE1] = 8344;
	itemGFX[I_CANDLE2] = 8344;
	itemGFX[I_CANDLE3] = 8344;
	
	itemGFX[I_WHISTLE] = 8346;
	
	itemGFX[I_BAIT] = 8348;
	
	itemGFX[I_BAIT] = 8348;
	
	itemGFX[I_POTION1] = 8350;
	
	itemGFX[I_WAND] = 8352;
	itemGFX[I_WAND2] = 8352;
	
	itemGFX[I_FAKETRIFORCE] = 8354;
	
	itemGFX[I_RUPEE5] = 8356;
	itemGFX[I_SECRETMONEY10] = 8356;
	itemGFX[I_SECRETMONEY20] = 8356;
	itemGFX[I_SECRETMONEY30] = 8356;
	itemGFX[I_SECRETMONEY100] = 8356;
	itemGFX[I_RUPOOR10] = 8376;
	itemGFX[I_RUPOOR20] = 8376;
	itemGFX[I_RUPOOR30] = 8376;
	itemGFX[I_RUPOOR50] = 8376;
	
	itemGFX[I_BOMB] = 8358;
	
	itemGFX[I_HEARTCONTAINER] = 8360;
	
	itemGFX[I_CRITPOTION] = 8362;
	
	itemGFX[I_PHASECLOAK] = 8364;
	itemGFX[I_PHASECLOAK2] = 8364;
	
	itemGFX[I_LETTER] = 8366;
	
	itemGFX[I_BOMBUPGRADE] = 8368;
	
	itemGFX[I_KEY] = 8372;
	
	for(int i=I_KEY_L1; i<=I_KEY_L9; ++i)
		itemGFX[i] = 8380+(i-I_KEY_L1)*2;
	for(int i=192; i<=221; ++i)
		itemGFX[i] = 8370;
	
	int x; int y;
	int scrnX; int scrnY;
	int cd;
	int map = RandomizerPauseMenu_GetMetaLevelMap(tab-1);
	int offsets[] = {0, 0, 8, 0, 8, 0, 8, 0, 8, 0, 5, 9, -1, 3, 6};
	if(tab>1){
		for(int i=0; i<64; i++){
			scrnX = Floor(i%8);
			scrnY = Floor(i/8);
			cd = Game->GetComboData(18, tab-1, scrnY*16+scrnX);
			x = centerX-44+11*scrnX;
			y = topY+11*scrnY;
			if(cd>0){
				Screen->FastCombo(6, x, y, cd, 0, 128);
				
				int miniMapScrn = scrnY*16+scrnX+offsets[tab-1];
				int val = randoPauseMenuData[128+128*(tab-1)+miniMapScrn];
				int itemID = val&0xFF;
				int hasItem = val>>8&0x1;
				int seenItem = val>>9&0x1;
				if(!itemID){
					seenItem = Randomizer_GetLocVisited(map*128+miniMapScrn);
				}
				int canAccessItem = Randomizer_GetLocAccessible(map*128+miniMapScrn);
				if(itemID){
					RandomizerPauseMenu_DrawMapItem(x, y, itemID, itemGFX, hasItem, seenItem, canAccessItem);
				}
				else{
					int dmap = EntranceRandomizer_GetLocDMap(map*128+miniMapScrn);
					int scrn = EntranceRandomizer_GetLocScreen(map*128+miniMapScrn);
					int lvl = Game->DMapLevel[dmap];
					if(lvl>=1&&lvl<=9&&EntranceRandomizer_IsLocEntrance(map*128+miniMapScrn)){
						RandomizerPauseMenu_DrawMapLevelEntrance(x, y, lvl, G[G_SEEN_L1+lvl-1]);
					}
					else if(dmap==20){
						if(scrn>=0x4A&&scrn<=0x4C)
							RandomizerPauseMenu_DrawMapSpecialIcon(x, y, ICN_POTIONSHOP, seenItem);
						else if(scrn>=0x4D&&scrn<=0x4E)
							RandomizerPauseMenu_DrawMapSpecialIcon(x, y, ICN_SHOP, seenItem);
						else if(scrn>=0x02&&scrn<=0x05)
							RandomizerPauseMenu_DrawMapSpecialIcon(x, y, ICN_GAMBLE, seenItem);
						else if(scrn>=0x3A&&scrn<=0x3E)
							RandomizerPauseMenu_DrawMapSpecialIcon(x, y, ICN_INFO, seenItem);
						else if(scrn==0x1A)
							RandomizerPauseMenu_DrawMapSpecialIcon(x, y, ICN_ROULETTE, seenItem);
					}
				}
			}
		}
		if(RandomizerPauseMenu_GetMetaLevel()==tab-1){
			scrnX = Game->GetCurScreen()%16;
			scrnY = Floor(Game->GetCurScreen()/16);
			x = centerX-44+11*(scrnX-offsets[tab-1]);
			y = topY+11*scrnY;
			Screen->FastCombo(6, x, y, 555, 6, 128);
		}
	}
	else{
		Screen->Rectangle(6, centerX-88+3, topY+3, centerX+88+1, topY+88+1, 0x03, 1, 0, 0, 0, true, 128);
		for(int i=0; i<128; i++){
			scrnX = Floor(i%16);
			scrnY = Floor(i/16);
			x = centerX-88+11*scrnX;
			y = topY+11*scrnY;
			Screen->FastCombo(6, x, y, cd, 0, 128);
			
			int miniMapScrn = scrnY*16+scrnX;
			int val = randoPauseMenuData[128+miniMapScrn];
			int itemID = val&0xFF;
			int hasItem = val>>8&0x1;
			int seenItem = val>>9&0x1;
			int canAccessItem = Randomizer_GetLocAccessible(map*128+miniMapScrn);
			if(G[G_RANDOMIZER_HASCHEATED])
				seenItem = 1;
			if(itemID){
				RandomizerPauseMenu_DrawMapItem(x, y, itemID, itemGFX, hasItem, seenItem, canAccessItem);
			}
			else{
				int dmap = EntranceRandomizer_GetLocDMap(8*128+miniMapScrn);
				int scrn = EntranceRandomizer_GetLocScreen(8*128+miniMapScrn);
				int lvl = Game->DMapLevel[dmap];
				if(lvl>=1&&lvl<=9){
					RandomizerPauseMenu_DrawMapLevelEntrance(x, y, lvl, G[G_SEEN_L1+lvl-1]);
				}
				else if(dmap==20){
					if(scrn>=0x4A&&scrn<=0x4C)
						RandomizerPauseMenu_DrawMapSpecialIcon(x, y, ICN_POTIONSHOP, seenItem);
					else if(scrn>=0x4D&&scrn<=0x4E)
						RandomizerPauseMenu_DrawMapSpecialIcon(x, y, ICN_SHOP, seenItem);
					else if(scrn>=0x02&&scrn<=0x05)
						RandomizerPauseMenu_DrawMapSpecialIcon(x, y, ICN_GAMBLE, seenItem);
					else if(scrn>=0x3A&&scrn<=0x3E)
						RandomizerPauseMenu_DrawMapSpecialIcon(x, y, ICN_INFO, seenItem);
					else if(scrn==0x1A)
						RandomizerPauseMenu_DrawMapSpecialIcon(x, y, ICN_ROULETTE, seenItem);
				}
			}
		}
		if(RandomizerPauseMenu_GetMetaLevel()==0){
			scrnX = Game->GetCurScreen()%16;
			scrnY = Floor(Game->GetCurScreen()/16);
			x = centerX-88+11*scrnX;
			y = topY+11*scrnY;
			Screen->FastCombo(6, x, y, 555, 6, 128);
		}
	}
}

bool Q7_HasRing(int ringID){
	if(Link->Item[ringID])
		return true;
	if(G[G_AUTIMECIARINGID]==ringID&&Link->Item[I_SPRING16_AUTIMECIA])
		return true;
	return false;
}

int Q7_SPRingToID(int ringID){
	if(ringID==0)
		return I_SPRING1_HITO;
	if(ringID==1)
		return I_SPRING2_JACK;
	if(ringID==2)
		return I_SPRING3_WILL;
	if(ringID==3)
		return I_SPRING4_RHONE;
	if(ringID==4)
		return I_SPRING5_SEINE;
	if(ringID==5)
		return I_SPRING6_LOIRE;
	if(ringID==6)
		return I_SPRING7_NAIYA;
	if(ringID==7)
		return I_SPRING8_TYRE;
	if(ringID==8)
		return I_SPRING9_JANDRA;
	if(ringID==9)
		return I_SPRING10_HOLM;
	if(ringID==10)
		return I_SPRING11_MIRR;
	if(ringID==11)
		return I_SPRING12_HART;
	if(ringID==12)
		return I_SPRING13_FLECT;
	if(ringID==13)
		return I_SPRING14_VANICE;
	if(ringID==14)
		return I_SPRING15_ZARATH;
	if(ringID==15)
		return I_SPRING16_AUTIMECIA;
	if(ringID==16)
		return I_SPRING17_REDTEAR;
	if(ringID==17)
		return I_SPRING18_BLUETEAR;
	if(ringID==18)
		return I_SPRING19_WALLMASTER;
	if(ringID==19)
		return I_SPRING20_GAMBLE;
	if(ringID==20)
		return I_SPRING21_STARVATION;
	if(ringID==21)
		return I_SPRING22_SOARING;
	if(ringID==22)
		return I_SPRING23_HEART;
	if(ringID==23)
		return I_SPRING24_BOMB;
	if(ringID==24)
		return I_SPRING25_WILLARD;
	if(ringID==25)
		return I_SPRING26_RAINY;
	if(ringID==26)
		return I_SPRING27_POTION;
	if(ringID==27)
		return I_SPRING28_ACCEL;
	if(ringID==28)
		return I_SPRING29_BRANG;
	if(ringID==29)
		return I_SPRING30_CALAMITY;
}

const int I_SPRING1_HITO = 192;
const int I_SPRING2_JACK = 193;
const int I_SPRING3_WILL = 194;
const int I_SPRING4_RHONE = 195;
const int I_SPRING5_SEINE = 196;
const int I_SPRING6_LOIRE = 197;
const int I_SPRING7_NAIYA = 198;
const int I_SPRING8_TYRE = 199;
const int I_SPRING9_JANDRA = 200;
const int I_SPRING10_HOLM = 201;
const int I_SPRING11_MIRR = 202;
const int I_SPRING12_HART = 203;
const int I_SPRING13_FLECT = 204;
const int I_SPRING14_VANICE = 212;
const int I_SPRING15_ZARATH = 213;
const int I_SPRING16_AUTIMECIA = 214;
const int I_SPRING17_REDTEAR = 205;
const int I_SPRING18_BLUETEAR = 215;
const int I_SPRING19_WALLMASTER = 206;
const int I_SPRING20_GAMBLE = 207;
const int I_SPRING21_STARVATION = 208;
const int I_SPRING22_SOARING = 209;
const int I_SPRING23_HEART = 210;
const int I_SPRING24_BOMB = 216;
const int I_SPRING25_WILLARD = 217;
const int I_SPRING26_RAINY = 218;
const int I_SPRING27_POTION = 219;
const int I_SPRING28_ACCEL = 220;
const int I_SPRING29_BRANG = 221;
const int I_SPRING30_CALAMITY = 211;

const int TIL_RING_BASE = 8800;
const int CMB_RING_SELECTION = 675;

int WrapValue(int val, int min, int max){
	int diff = Abs(min-max)+1;
	while(val<min)
		val += diff;
	while(val>max)
		val -= diff;
	return val;
}

void RandomizerMenu_UpdateRings(){
	for(int i=192; i<=221; ++i){
		if(Link->Item[i])
			ItemStringsPlayed[i] = true;
	}
}

void RandomizerPauseMenu_DrawRingName(int id){
	int n0[] = "???";
	int n1[] = "HITO'S RING";
	int n2[] = "JACK'S RING";
	int n3[] = "WILL'S RING";
	int n4[] = "RHONE'S RING";
	int n5[] = "SEINE'S RING";
	int n6[] = "LOIRE'S RING";
	int n7[] = "NAIYA'S RING";
	int n8[] = "TYRE'S RING";
	int n9[] = "JANDRA'S RING";
	int n10[] = "HOLM'S RING";
	int n11[] = "MIRR'S RING";
	int n12[] = "HART'S RING";
	int n13[] = "FLECT'S RING";
	int n14[] = "VANICE'S RING";
	int n15[] = "ZARATH'S RING";
	int n16[] = "AUTIMECIA'S RING";
	int n17[] = "RED TEAR RING";
	int n18[] = "BLUE TEAR RING";
	int n19[] = "WALLMASTER RING";
	int n20[] = "GAMBLER'S RING";
	int n21[] = "STARVATION RING";
	int n22[] = "SOARING RING";
	int n23[] = "HEART RING";
	int n24[] = "BOMB RING";
	int n25[] = "WILLARD'S RING";
	int n26[] = "RAINY RING";
	int n27[] = "POTION RING";
	int n28[] = "ACCELERATOR RING";
	int n29[] = "BOOMERANG RING";
	int n30[] = "CALAMITY RING";
	int names[] = {n0, n1, n2, n3, n4, n5, n6, n7, n8, n9, n10, n11, n12, n13, n14, n15, n16, n17, n18, n19, n20, n21, n22, n23, n24, n25, n26, n27, n28, n29, n30};
	
	Screen->DrawString(7, 16, 16, FONT_Z1, 0x01, 0xF, TF_NORMAL, names[id], 128);
}

void RandomizerPauseMenu_DrawRingDescription(int id){
	bool autimecia;
	// Trace(G[G_AUTIMECIARING]);
	// Trace(G[G_AUTIMECIARINGID]);
	if(id==16){
		id = G[G_AUTIMECIARING]+1;
		autimecia = true;
	}
	
	int n0[64] = "???";
	int n1[64] = "HOMING ARROWS";
	int n2[64] = "PIERCING FIRE";
	int n3[64] = "LIGHTSPEED ARROWS";
	int n4[64] = "NO KNOCKBACK";
	int n5[64] = "PHASE CLOAK UPGRADE";
	int n6[64] = "LIFE STEAL";
	int n7[64] = "BUBBLE BARRIER";
	int n8[64] = "FLOOR REVERSAL";
	int n9[64] = "COUNTERHIT BOOST";
	int n10[64] = "REFLECTION BOOST";
	int n11[64] = "NO DARK ROOMS";
	int n12[64] = "NUKE BOMBS";
	int n13[64] = "POISON SWORD";
	int n14[64] = "PLAGUE COUNTER";
	int n15[64] = "OVERDRIVE BOOST";
	int n16[64] = "???";
	int n17[64] = "LOW HP DAMAGE BOOST";
	int n18[64] = "LOW HP HEALING CHANCE";
	int n19[64] = "NO WALLMASTER GRABS";
	int n20[64] = "DOUBLED RUPEES";
	int n21[64] = "BAIT KILLS";
	int n22[64] = "WARP TO DUNGEONS WITH \"A\"";
	int n23[64] = "MORE HEART DROPS";
	int n24[64] = "MORE BOMB DROPS";
	int n25[64] = "DARKNUT SHIELDS BREAK";
	int n26[64] = "INVERTS RAINY EFFECT";
	int n27[64] = "AUTO POTION";
	int n28[64] = "STRONG ACCELERATOR";
	int n29[64] = "FASTER BOOMERANG";
	int n30[64] = "BAD TIMES";
	
	int names[] = {n0, n1, n2, n3, n4, n5, n6, n7, n8, n9, n10, n11, n12, n13, n14, n15, n16, n17, n18, n19, n20, n21, n22, n23, n24, n25, n26, n27, n28, n29, n30};
	int effect[] = "EFFECT:";
	
	if(autimecia){
		strcatf(names[id], '?', MF_CHAR);
	}
	
	Screen->DrawString(7, 8, 144, FONT_Z1, 0x01, 0xF, TF_NORMAL, effect, 128);
	Screen->DrawString(7, 16, 152, FONT_Z1, 0x01, 0xF, TF_NORMAL, names[id], 128);
}

void RandomizerPauseMenu_DrawRingScreen(){
	int ringsStr[] = "EQUIP RINGS:";
	
	int rings[] =     {0, I_SPRING1_HITO, I_SPRING2_JACK, I_SPRING3_WILL, I_SPRING4_RHONE, I_SPRING5_SEINE, I_SPRING6_LOIRE, I_SPRING7_NAIYA, I_SPRING8_TYRE, I_SPRING9_JANDRA, I_SPRING10_HOLM, I_SPRING11_MIRR, I_SPRING12_HART, I_SPRING13_FLECT, I_SPRING14_VANICE, I_SPRING15_ZARATH, I_SPRING16_AUTIMECIA, I_SPRING17_REDTEAR, I_SPRING18_BLUETEAR, I_SPRING19_WALLMASTER, I_SPRING20_GAMBLE, I_SPRING21_STARVATION, I_SPRING22_SOARING, I_SPRING23_HEART, I_SPRING24_BOMB, I_SPRING25_WILLARD, I_SPRING26_RAINY, I_SPRING27_POTION, I_SPRING28_ACCEL, I_SPRING29_BRANG, I_SPRING30_CALAMITY};
	int ringTiles[] = {0, 8581,           8581,           8581,           8590,            8591,            8592,            8587,            8643,           8589,             8583,            8584,            8585,            8586,             8588,              8642,              8644,                 8582,               8582,                8593,                  8594,              8595,                  8596,               8597,             8646,            8641,               8647,             8645,              8649,             8648,             8598};
	int ringCSets[] = {0, 10,             8,              5,              1,               7,               8,               7,               11,             10,               11,              1,               8,               10,               10,                1,                 10,                   8,                  7,                   7,                     5,                 8,                     7,                  8,                7,               11,                 7,                8,                 5,                1,                8};
	
	int i; int j;
	int x; int y;
	int x2; int y2;
	
	int ringCount = 3;
	if(Link->Item[I_RINGBOX])
		ringCount = 4;
	
	Screen->DrawString(7, 8, 8, FONT_Z1, 0x01, 0xF, TF_NORMAL, ringsStr, 128);
	if(G[G_RANDOMENU_SELECTINGRINGS]){
		if(ItemStringsPlayed[rings[G[G_RANDOMENU_RINGSEL2]]]){
			RandomizerPauseMenu_DrawRingName(G[G_RANDOMENU_RINGSEL2]);
			RandomizerPauseMenu_DrawRingDescription(G[G_RANDOMENU_RINGSEL2]);
		}
		else{
			RandomizerPauseMenu_DrawRingName(0);
			RandomizerPauseMenu_DrawRingDescription(0);
		}
	}
	else{
		RandomizerPauseMenu_DrawRingName(G[G_RANDOMENU_RING1+G[G_RANDOMENU_RINGSEL1]]);
		RandomizerPauseMenu_DrawRingDescription(G[G_RANDOMENU_RING1+G[G_RANDOMENU_RINGSEL1]]);
	}
	for(i=0; i<ringCount; ++i){
		x = 16;
		y = 32 + i*24;
		
		Screen->FastTile(7, x, y, TIL_RING_BASE, 8, 128);
		j = G[G_RANDOMENU_RING1+i];
		if(rings[j]&&ItemStringsPlayed[rings[j]]){
			Screen->FastTile(7, x, y, ringTiles[j], ringCSets[j], 128);
			if(G[G_MODE_EQUIPALLRINGS])
				Screen->FastTile(7, x, y, 5739, 8, 128);
		}
		if(G[G_RANDOMENU_RINGSEL1]==i){
			Screen->FastCombo(7, x, y, CMB_RING_SELECTION, 8, 128);
		}
	}
	
	if(G[G_RANDOMENU_SELECTINGRINGS]){
		x = (G[G_RANDOMENU_RINGSEL2]-1)%10;
		y = Floor((G[G_RANDOMENU_RINGSEL2]-1)/10);
		if(Link->PressUp){
			Game->PlaySound(SFX_SELECT);
			y = WrapValue(y-1, 0, 2);
		}
		else if(Link->PressDown){
			Game->PlaySound(SFX_SELECT);
			y = WrapValue(y+1, 0, 2);
		}
		else if(Link->PressLeft){
			Game->PlaySound(SFX_SELECT);
			x = WrapValue(x-1, 0, 9);
		}
		else if(Link->PressRight){
			Game->PlaySound(SFX_SELECT);
			x = WrapValue(x+1, 0, 9);
		}
		G[G_RANDOMENU_RINGSEL2] = 1+y*10+x;
		
		for(i=0; i<30; ++i){
			x = i%10;
			y = Floor(i/10);
			
			x2 = 64+x*18;
			y2 = 32+y*18;
			
			Screen->FastTile(7, x2, y2, TIL_RING_BASE, 8, 128);
			if(rings[i+1]&&ItemStringsPlayed[rings[i+1]]){
				Screen->FastTile(7, x2, y2, ringTiles[i+1], ringCSets[i+1], 128);
			}
			if(G[G_RANDOMENU_RINGSEL2]==i+1){
				Screen->FastCombo(7, x2, y2, CMB_RING_SELECTION, 8, 128);
			}
		}
		
		if(Link->PressA){
			Game->PlaySound(SFX_SELECT);
			RandomizerPauseMenu_EquipRing(G[G_RANDOMENU_RINGSEL2], rings);
			G[G_RANDOMENU_SELECTINGRINGS] = 0;
		}
		else if(Link->PressB){
			Game->PlaySound(SFX_SELECT);
			G[G_RANDOMENU_SELECTINGRINGS] = 0;
		}
	}
	else{
		if(Link->PressUp){
			Game->PlaySound(SFX_SELECT);
			G[G_RANDOMENU_RINGSEL1] = WrapValue(G[G_RANDOMENU_RINGSEL1]-1, 0, ringCount-1);
		}
		else if(Link->PressDown){
			Game->PlaySound(SFX_SELECT);
			G[G_RANDOMENU_RINGSEL1] = WrapValue(G[G_RANDOMENU_RINGSEL1]+1, 0, ringCount-1);
		}
		if(Link->PressA){
			Game->PlaySound(SFX_SELECT);
			
			i = G[G_RANDOMENU_RING1+G[G_RANDOMENU_RINGSEL1]];
			if(i==0)
				i = 1;
			G[G_RANDOMENU_RINGSEL2] = i;
			G[G_RANDOMENU_SELECTINGRINGS] = 1;
		}
	}
}

void RandomizerPauseMenu_EquipRing(int i, int rings){
	int j;
	int ringCount = 3;
	if(Link->Item[I_RINGBOX])
		ringCount = 4;
	for(j=0; j<ringCount; ++j){
		if(G[G_RANDOMENU_RINGID1+j]){
			Link->Item[G[G_RANDOMENU_RINGID1+j]] = false;
		}
	}
	
	if(ItemStringsPlayed[rings[i]]){
		int identical = -1;
		if(G[G_RANDOMENU_RING1]==i)
			identical = 0;
		else if(G[G_RANDOMENU_RING2]==i)
			identical = 1;
		else if(G[G_RANDOMENU_RING3]==i)
			identical = 2;
		else if(G[G_RANDOMENU_RING4]==i)
			identical = 3;
		
		if(identical>-1){
			if(identical==G[G_RANDOMENU_RINGSEL1]){
				G[G_RANDOMENU_RING1+G[G_RANDOMENU_RINGSEL1]] = 0;
				G[G_RANDOMENU_RINGID1+G[G_RANDOMENU_RINGSEL1]] = 0;
			}
			else{
				int oldPos = G[G_RANDOMENU_RING1+G[G_RANDOMENU_RINGSEL1]];
				int oldID = G[G_RANDOMENU_RINGID1+G[G_RANDOMENU_RINGSEL1]];
				
				G[G_RANDOMENU_RING1+identical] = oldPos;
				G[G_RANDOMENU_RINGID1+identical] = oldID;
				G[G_RANDOMENU_RING1+G[G_RANDOMENU_RINGSEL1]] = i;
				G[G_RANDOMENU_RINGID1+G[G_RANDOMENU_RINGSEL1]] = rings[i];
			}
		}
		else{
			G[G_RANDOMENU_RING1+G[G_RANDOMENU_RINGSEL1]] = i;
			G[G_RANDOMENU_RINGID1+G[G_RANDOMENU_RINGSEL1]] = rings[i];
		}
	}
	else{
		G[G_RANDOMENU_RING1+G[G_RANDOMENU_RINGSEL1]] = 0;
		G[G_RANDOMENU_RINGID1+G[G_RANDOMENU_RINGSEL1]] = 0;
	}
	
	RandomizerPauseMenu_InitRings();
	// for(j=0; j<ringCount; ++j){
		// if(G[G_RANDOMENU_RINGID1+j]){
			// Link->Item[G[G_RANDOMENU_RINGID1+j]] = true;
		// }
	// }
}

void RandomizerPauseMenu_InitRings(){
	int ringCount = 3;
	if(Link->Item[I_RINGBOX])
		ringCount = 4;
	for(int i=192; i<=221; ++i){
		if(Link->Item[i])
			ItemStringsPlayed[i] = true;
		Link->Item[i] = false;
	}
	if(G[G_MODE_EQUIPALLRINGS]){
		for(int i=192; i<=221; ++i){
			if(ItemStringsPlayed[i])
				Link->Item[i] = true;
		}
		for(int j=0; j<ringCount; ++j){
			if(G[G_RANDOMENU_RINGID1+j]){
				Link->Item[G[G_RANDOMENU_RINGID1+j]] = false;
			}
		}
	}
	else{
		for(int j=0; j<ringCount; ++j){
			if(G[G_RANDOMENU_RINGID1+j]){
				Link->Item[G[G_RANDOMENU_RINGID1+j]] = true;
			}
		}
	}
}

int RandomizerPauseMenu_GetMetaLevelMap(int metalevel){
	if(metalevel>=0&&metalevel<=14)
		return Game->DMapMap[metalevel];
	return 0;
}

int RandomizerPauseMenu_GetMetaLevel(){
	if(Game->GetCurDMap()==0||Game->GetCurDMap()==22)
		return 0;
	if(Game->GetCurDMap()==1||Game->GetCurDMap()==60)
		return 1;
	if(Game->GetCurDMap()==2||Game->GetCurDMap()==61)
		return 2;
	if(Game->GetCurDMap()==3||Game->GetCurDMap()==62)
		return 3;
	if(Game->GetCurDMap()==4||Game->GetCurDMap()==63)
		return 4;
	if(Game->GetCurDMap()==5||Game->GetCurDMap()==64)
		return 5;
	if(Game->GetCurDMap()==6||Game->GetCurDMap()==65)
		return 6;
	if(Game->GetCurDMap()==7||Game->GetCurDMap()==66||Game->GetCurDMap()==37||Game->GetCurDMap()==68)
		return 7;
	if(Game->GetCurDMap()==8||Game->GetCurDMap()==67)
		return 8;
	if(Game->GetCurDMap()==9||Game->GetCurDMap()==69)
		return 9;
	if(Game->GetCurDMap()==10||Game->GetCurDMap()==70)
		return 10;
	if(Game->GetCurDMap()==11||Game->GetCurDMap()==71)
		return 11;
	if(Game->GetCurDMap()==12||Game->GetCurDMap()==72)
		return 12;
	if(Game->GetCurDMap()==13||Game->GetCurDMap()==73)
		return 13;
	if(Game->GetCurDMap()==14||Game->GetCurDMap()==74)
		return 14;
	return -1;
}

void RandomizerPauseMenu_DrawMapItem(int x, int y, int itemID, int itemGFX, bool hasItem, bool seenItem, bool canAccessItem){
	int cs = 0;
	if(canAccessItem&&!hasItem){
		//hasItem = false;
		if(G[G_SUBSCREENANIM]%8<4)
			cs = 7;
	}
	if(itemGFX[itemID]==0){
		Screen->FastTile(6, x, y, 8560, cs, 128);
	}
	else{
		if(hasItem)
			Screen->FastTile(6, x, y, itemGFX[itemID]+1, cs, 128);
		else{
			if(G[G_RANDOMIZER_HASCHEATED]||seenItem){
				Screen->FastTile(6, x, y, itemGFX[itemID], cs, 128);
			}
			else{
				Screen->FastTile(6, x, y, 8564, cs, 128);
			}
		}
	}
}

void RandomizerPauseMenu_DrawMapLevelEntrance(int x, int y, int lvl, bool hasSeen){
	if(hasSeen){
		Screen->FastTile(6, x, y, 8566+lvl-1, 0, 128);
	}
	else
		Screen->FastTile(6, x, y, 8575, 0, 128);
}

const int ICN_GAMBLE = 0;
const int ICN_SHOP = 1;
const int ICN_POTIONSHOP = 2;
const int ICN_ROULETTE = 3;
const int ICN_INFO = 4;

void RandomizerPauseMenu_DrawMapSpecialIcon(int x, int y, int icon, bool hasSeen){
	if(hasSeen){
		if(icon==ICN_GAMBLE)
			Screen->FastTile(6, x, y, 8541, 0, 128);
		else if(icon==ICN_SHOP)
			Screen->FastTile(6, x, y, 8542, 0, 128);
		else if(icon==ICN_POTIONSHOP)
			Screen->FastTile(6, x, y, 8544, 0, 128);
		else if(icon==ICN_INFO)
			Screen->FastTile(6, x, y, 8543, 0, 128);
		else if(icon==ICN_ROULETTE)
			Screen->FastTile(6, x, y, 8540, 0, 128);
	}
	else
		Screen->FastTile(6, x, y, 8575, 0, 128);
}

void RandomizerPauseMenu_GetRedirects(int owRedirect, int scrn, int newscrn){
	if(G[G_MODE_ENTRANCE_RANDO]){
		int i = 128*6+scrn;
		
		//If only you knew how bad it really was
		if(G[G_RANDOMIZESTARTINGSWORD]==2&&scrn==0x11){
			owRedirect[scrn] = 0x77;
			owRedirect[scrn+128] = 0;
		}
		else if(EntranceRandomizerLocs[i]){
			if(Game->GetComboFlag(6, scrn, 0)==98){ 
				int entranceRandoScrn = EntranceRandomizer_GetLocScreen(i);
				int entranceRandoDMap = EntranceRandomizer_GetLocDMap(i);
				// Trace(scrn);
				// Trace(newscrn);
				// Trace(entranceRandoDMap);
				// Trace(entranceRandoScrn);
				// Trace(99);
				// TraceNL();
				
				owRedirect[scrn] = entranceRandoScrn;
				owRedirect[scrn+128] = entranceRandoDMap;
			}
		}
	}
	else
		owRedirect[scrn] = newscrn;
}

int Randomizer_GetAccessFlags(){
	int flags;
	if(Link->Item[I_SWORD1]||Link->Item[I_SWORD2]||Link->Item[I_SWORD3]||Link->Item[I_SWORD4])
		flags |= RRF_DAMAGE;
	if(Link->Item[I_BRACELET2])
		flags |= RRF_BRACELET;
	if(Link->Item[I_CANDLE3]){
		flags |= RRF_DAMAGE;
		flags |= RRF_CANDLE3;
		flags |= RRF_CANDLE2;
		flags |= RRF_CANDLE;
		
	}
	else if(Link->Item[I_CANDLE2]){
		flags |= RRF_DAMAGE;
		flags |= RRF_CANDLE2;
		flags |= RRF_CANDLE;
	}
	else if(Link->Item[I_CANDLE1]){
		flags |= RRF_DAMAGE;
		flags |= RRF_CANDLE;
	}
	if(Link->Item[I_WHISTLE])
		flags |= RRF_WHISTLE;
	if(Link->Item[I_BOW1]||Link->Item[I_BOW2])
		flags |= RRF_ARROW1;
	if(Link->Item[I_ARROW1]||Link->Item[I_ARROW2])
		flags |= RRF_ARROW2;
	if(Link->Item[I_WAND]||Link->Item[I_WAND2]){
		flags |= RRF_WAND;
		flags |= RRF_DAMAGE;
	}
	if(Link->Item[I_FLIPPERS]||Link->Item[I_FLIPPERS2])
		flags |= RRF_FLIPPERS;
	if(Link->Item[I_PHASECLOAK2]){
		flags |= RRF_PHASECLOAK2;
		flags |= RRF_PHASECLOAK;
	}
	else if(Link->Item[I_PHASECLOAK])
		flags |= RRF_PHASECLOAK;
	if(Link->Item[I_SCRIPTBOOTS])
		flags |= RRF_BOOTS;
	if(Link->Item[I_ACCELERATOR])
		flags |= RRF_DAMAGE;
	if(Link->Item[I_SPRING14_VANICE])
		flags |= RRF_DAMAGE;
	if(NumTriforcePieces()>=8)
		flags |= RRF_TRIFORCES;
	
	return flags;
}

void RandomizerPauseMenu_InitData(int randoPauseMenuData){
	int i;
	RandomizerMenu_UpdateRings();
	for(i=0; i<2048; i++){
		randoPauseMenuData[i] = 0;
	}
	int owRedirect[256]; //128 screens, 128 dmaps
	int owRedirectDMap[128];
	RandomizerPauseMenu_GetRedirects(owRedirect, 0x00, 0x6D);
	RandomizerPauseMenu_GetRedirects(owRedirect, 0x01, 0x01); //what're the odds?
	RandomizerPauseMenu_GetRedirects(owRedirect, 0x10, 0x0B);
	RandomizerPauseMenu_GetRedirects(owRedirect, 0x11, 0x77);
	RandomizerPauseMenu_GetRedirects(owRedirect, 0x12, 0x1F);
	RandomizerPauseMenu_GetRedirects(owRedirect, 0x06, 0x1A);
	RandomizerPauseMenu_GetRedirects(owRedirect, 0x07, 0x22);
	RandomizerPauseMenu_GetRedirects(owRedirect, 0x08, 0x10);
	RandomizerPauseMenu_GetRedirects(owRedirect, 0x09, 0x45);
	RandomizerPauseMenu_GetRedirects(owRedirect, 0x0A, 0x62);
	RandomizerPauseMenu_GetRedirects(owRedirect, 0x0B, 0x4B);
	RandomizerPauseMenu_GetRedirects(owRedirect, 0x0C, 0x0B);
	RandomizerPauseMenu_GetRedirects(owRedirect, 0x0D, 0x21);

	int dgnRedirect[2560];
	dgnRedirect[15*128+0x6A] = 13*128+0x28;
	int accessFlags = Randomizer_GetAccessFlags();
	for(i=0; i<32768; i++){
		if(RandomizerLocs[i]>0){
			int itemID = Randomizer_GetLocID(i);
			int level = Randomizer_GetLocLevel(i);
			int metalevel = Randomizer_GetLocMetaLevel(i);
			int map = Floor(i/128);
			int scrn = i%128;
			int miniMapScrn = scrn;
			if(map==6){
				if(G[G_MODE_ENTRANCE_RANDO]){
					metalevel = owRedirect[miniMapScrn+128];
				}
				miniMapScrn = owRedirect[miniMapScrn];
				if(metalevel>=1&&metalevel<=10)
					miniMapScrn += Game->DMapOffset[metalevel];
				//Debug stuffs
				// Trace(metalevel);
				// Trace(miniMapScrn);
				// itemdata id = Game->LoadItemData(itemID);
				// int nameStr[256];
				// id->GetName(nameStr);
				// TraceS(nameStr);
				// TraceNL();
				// TraceNL();
			}
			if(dgnRedirect[map*128+scrn]){
				miniMapScrn = dgnRedirect[map*128+scrn]%128;
			}
			
			if(G[G_MODE_TRACKERHINTS]){
				int reqFlags = RandomizerLocsFlags[i];
				int reqKeys = RandomizerLocsKeys[i]&0xF;
				if(DEBUG_RANDOMIZER){
					int str[] = "Map:%d Screen:%X\n  Flags:%s\n        %s\n";
					int bin[17];
					int bin2[17];
					BinaryToString(bin, reqFlags, 16);
					BinaryToString(bin2, accessFlags, 16);
					//printf(str, map, scrn, bin, bin2);
				}
				if((accessFlags&reqFlags)==reqFlags){
					if(!Link->Item[I_SETTING_TRUEKEYS]||Game->LKeys[level]>=reqKeys){
						if(map==6)
							Randomizer_SetLocAccessible(8*128+miniMapScrn);
						else if(dgnRedirect[map*128+scrn])
							Randomizer_SetLocAccessible(map*128+miniMapScrn);
						else
							Randomizer_SetLocAccessible(i);
					}
				}
			}
			
			randoPauseMenuData[128+128*metalevel+miniMapScrn] = itemID;
			++randoPauseMenuData[level*2];
			if(Randomizer_GetLocVisited(i)){
				randoPauseMenuData[128+128*metalevel+miniMapScrn] |= (1<<9);
			}
			if(Game->GetScreenState(map, scrn, ST_ITEM)||Game->GetScreenState(map, scrn, ST_SPECIALITEM)){
				randoPauseMenuData[128+128*metalevel+miniMapScrn] |= (1<<8);
				++randoPauseMenuData[level*2+1];
			}
		}
	}
}

void Debug_Update(){
	if(!DEBUG)
		return;
	int i; int j;
	i = 128*Game->GetCurMap()+Game->GetCurScreen();
	Screen->DrawInteger(6, 0, 0, FONT_Z1, 0x01, 0x0F, -1, -1, Randomizer_GetLocVisited(i), 0, 128);
	Screen->DrawInteger(6, 0, 8, FONT_Z1, 0x01, 0x0F, -1, -1, Randomizer_GetLocID(i), 0, 128);
	Screen->DrawInteger(6, 0, 16, FONT_Z1, 0x01, 0x0F, -1, -1, EntranceRandomizer_GetLocDMap(i), 0, 128);
	Screen->DrawInteger(6, 0, 24, FONT_Z1, 0x01, 0x0F, -1, -1, EntranceRandomizer_GetLocScreen(i), 0, 128);
	
	
	
	// for(i=0; i<8; i++){
		// j = Screen->D[i]&0xFF;
		// Screen->DrawInteger(6, 8, 8+8*i, FONT_Z3SMALL, 0x01, 0x0F, -1, -1, j, 0, 128);
		// j = (Screen->D[i]>>8)&0xFF;
		// Screen->DrawInteger(6, 8+64, 8+8*i, FONT_Z3SMALL, 0x01, 0x0F, -1, -1, j, 0, 128);
		// j = (Screen->D[i]>>16)&1;
		// Screen->DrawInteger(6, 8+128, 8+8*i, FONT_Z3SMALL, 0x01, 0x0F, -1, -1, j, 0, 128);
		
		// Screen->DrawInteger(6, 8+196, 8+8*i, FONT_Z3SMALL, 0x01, 0x0F, -1, -1, Screen->D[i], 0, 128);
	// }
}

void NoJoke_CopyTile(){
	if(AllowAllJokes()){
		//P-Tux Head
		CopyTileBlock(6573, 6614, 6569);
		CopyTileBlock(6313, 6354, 6309);
		
		//P-Tux Cutscene
		CopyTileBlock(7286, 7397, 6766);
		CopyTileBlock(7406, 7451, 6886);
		CopyTileBlock(7280, 7322, 6629);
		
		//The banhammer
		CopyTileBlock(7888, 7911, 7828);
	}
	else{
		if(!AllowSomeJokes()){
			//Gohma
			CopyTileBlock(2094, 2139, 1446);
			//Lanmolars
			CopyTileBlock(4980, 5005, 1768); //Body 6x2
			CopyTileBlock(5020, 5023, 1746); //Rocks 4x1
			CopyTileBlock(4986, 5007, 1732); //Plaque 2x2
			CopyTileBlock(5026, 5027, 1816); //Toothbrushes
		}
	}
}

void TileScramble_Init(int scramblePages){
	int i; int j; int k;
	int pageCount = SizeOfArray(scramblePages);
	
	int offset;
	if(Q7_CheatEnabled(G_MODE_DARKNUT)){
		for(i=0; i<pageCount; i++){
			k = scramblePages[i]*260;
			for(j=0; j<260; j++){
				CopyTile(65000+offset, k+j);
				++offset;
				offset %= 4;
			}
		}
	}
	else if(Q7_CheatEnabled(G_MODE_BINLAND)){
		for(i=0; i<pageCount; i++){
			k = scramblePages[i]*260;
			for(j=0; j<260; j++){
				CopyTile(65004+offset, k+j);
				++offset;
				offset %= 2;
			}
		}
	}
}

void TileCorruption_Update(int scramblePages){
	int i; int j; int k;
	int pageCount = SizeOfArray(scramblePages);
	
	for(i=0; i<50; i++){
		int page1 = Rand(pageCount);
		int tile1 = Rand(260);
		
		int page2 = Rand(pageCount);
		int tile2 = Rand(260);
		
		CopyTile(page1*260+tile1, 65006);
		CopyTile(page2*260+tile2, page1*260+tile1);
		CopyTile(65006, page2*260+tile2);
	}
}

void PermComboChanges_Init(){
	ColorShift_8Bit_Init();
	
	if(Game->GetComboData(1, 0x0F, 87)!=8){
		
		ColorShift_Init();
		
		Game->SetComboData(1, 0x0F, 87, 8);
	}
}

void ColorShift_Init(){
	if(Q7_CheatEnabled(G_MODE_COLORSHIFT)){
		int i; int j; int k;
		int dungeonExceptions[] = {2, 3, 4, 5};
		//Overworld layers
		for(i=8; i<=12; i++){
			for(j=0; j<128; j++){
				for(k=0; k<176; k++){
					int cs = Game->GetComboCSet(i, j, k);
					if(cs>=2&&cs<=4){
						--cs;
						if(cs<2)
							cs = 4;
						
						Game->SetComboCSet(i, j, k, cs);
					}
				}
			}
		}
		
		//Outer ring
		for(j=0; j<136; j++){
			for(k=0; k<176; k++){
				int cs = Game->GetComboCSet(15, j, k);
				if(cs>=2&&cs<=3){
					--cs;
					if(cs<2)
						cs = 3;
					
					Game->SetComboCSet(15, j, k, cs);
				}
			}
		}
		
		//Misc screens
		int extraMap[] 	  = {2,    2,    14,   14,   14,   14,   17,   17,   17,   17,   14,   14,   14,   14,   14};
		int extraScreen[] = {0x04, 0x05, 0x3C, 0x2B, 0x2D, 0x0C, 0x3C, 0x2B, 0x2D, 0x0C, 0x4C, 0x6B, 0x6D, 0x7C, 0x0D};
		int extraSP[]     = {0,    0,    1,    1,    1,    1,    1,    1,    1,    1,    1,    1,    1,    1,    1};
		int size = SizeOfArray(extraMap);
		for(j=0; j<size; j++){
			for(k=0; k<176; k++){
				int cs = Game->GetComboCSet(extraMap[j], extraScreen[j], k);
				if(extraSP[j]!=1||cs!=4){
					if(cs>=2&&cs<=4){
						--cs;
						if(cs<2)
							cs = 4;
						if(cs==4&&extraSP[j]==1)
							cs = 3;
						
						Game->SetComboCSet(extraMap[j], extraScreen[j], k, cs);
					}
				}
			}
		}
	}
}

void MiscCopyTile_Init(){
	if(Q7_CheatEnabled(G_MODE_GARDEVOIR)){
		CopyTile(11420, 84);
		CopyTile(11420, 85);
		CopyTile(11420, 86);
		CopyTile(11420, 87);
	}
	if(Q7_CheatEnabled(G_MODE_OKBOOMER)){
		CopyTile(11402, 832);
		CopyTile(11403, 830);
	}
	if(Link->Item[I_SETTING_VISION]){
		//Sparkles
		CopyTileBlock(3540, 3543, 890);
		
		//L3 Darknut
		CopyTileBlock(4255, 4259, 4275);
		
		//L3 Stalfos
		CopyTile(4298, 4299);
		
		//L3 Tektite
		CopyTileBlock(4316, 4317, 4318);
		
		//Breath Wizzrobe
		CopyTileBlock(5296, 5299, 5276);
		
		//Baba Wizzrobe
		CopyTileBlock(4352, 4358, 4332);
	}
	if(IsRandomizer()&&G[G_RANDOMIZER_CHOOSEONETYPE]==3){
		CopyTile(52361, 851);
	}
	else{
		CopyTile(52465, 851);
	}
}

void RandoPowerPotions_Update(){
	if(IsRandomizer()&&G[G_RANDOMIZER_CHOOSEONETYPE]==3){
		if(Link->Item[I_CRIT4])
			CopyTile(52464, 52460);
		else if(Link->Item[I_CRIT3])
			CopyTile(52463, 52460);
		else if(Link->Item[I_CRIT2])
			CopyTile(52462, 52460);
		else if(Link->Item[I_CRIT1])
			CopyTile(52461, 52460);
	}
}

void ColorShift_WarpChange(){
	for(int i=0; i<4; i++){
		int dmap = Screen->GetSideWarpDMap(i);
		if(dmap>=1&&dmap<=8){
			dmap += 59;
			Screen->SetSideWarp(i, Screen->GetSideWarpScreen(i), dmap, Screen->GetSideWarpType(i));
		}
		if(dmap>=100&&dmap<=108){
			dmap += 8;
			Screen->SetSideWarp(i, Screen->GetSideWarpScreen(i), dmap, Screen->GetSideWarpType(i));
		}
		if(dmap>=9&&dmap<=14){
			dmap += 60;
			Screen->SetSideWarp(i, Screen->GetSideWarpScreen(i), dmap, Screen->GetSideWarpType(i));
		}
		
		dmap = Screen->GetTileWarpDMap(i);
		if(dmap>=1&&dmap<=8){
			dmap += 59;
			Screen->SetTileWarp(i, Screen->GetTileWarpScreen(i), dmap, Screen->GetTileWarpType(i));
		}
		if(dmap>=100&&dmap<=108){
			dmap += 9;
			Screen->SetTileWarp(i, Screen->GetTileWarpScreen(i), dmap, Screen->GetTileWarpType(i));
		}
		if(dmap>=9&&dmap<=14){
			dmap += 60;
			Screen->SetTileWarp(i, Screen->GetTileWarpScreen(i), dmap, Screen->GetTileWarpType(i));
		}
	}
}

void EntranceRando_WarpChange(){
	int scrn = Game->GetCurScreen();
	int map = Game->GetCurMap();
	int dmap = EntranceRandomizer_GetLocDMap(map*128+scrn);
	int dmapscrn = EntranceRandomizer_GetLocScreen(map*128+scrn);
	
	// Trace(dmap);
	// Trace(dmapscrn);
	if(dmap>0||dmapscrn>0){
		if(!G[G_SPECIALWARP]){
			if(map==8||map==22){
				if(dmap>0&&dmap<=9)
					Screen->SetTileWarp(0, dmapscrn, dmap, WT_ENTRANCEEXIT);
				else
					Screen->SetTileWarp(0, dmapscrn, dmap, WT_IWARPBLACKOUT);
			}
			else if(map!=6){ //Only set exit warps for dungeons, caves set themselves
				int destDMap = Screen->GetSideWarpDMap(0);
				Screen->SetSideWarp(0, dmapscrn, dmap, WT_ENTRANCEEXIT);
			}
		}
	}
}

void ColorShift_8Bit_Init(){
	if(Q7_CheatEnabled(G_MODE_COLORSHIFT)){
		CopyTileBlock(11295, 11377, 11192);
		CopyTileBlock(11338, 11358, 11235);
		
		CopyTileBlock(52261, 52323, 911);
		CopyTile(52260, 910);
	}
}

void SpecialModes_Update(int scramblePages){
	if(Q7_CheatEnabled(G_MODE_GLITCH)){
		if(!(G[G_ANIM]%60))
			TileCorruption_Update(scramblePages);
	}
	if(Q7_CheatEnabled(G_MODE_LOGGINGMEMES)){
		FirstTrace();
	}
	if(Q7_CheatEnabled(G_MODE_YOLOREF)){
		if(Link->HP>0)
			Link->HP = Rand(1, Link->MaxHP);
	}
	if(Q7_CheatEnabled(G_MODE_ENTRANCE_RANDO)){
		EntranceRando_WarpChange();
	}
	if(Q7_CheatEnabled(G_MODE_COLORSHIFT)){
		ColorShift_WarpChange();
	}
	
	if(G[G_SPECIALWARP])
		--G[G_SPECIALWARP];
}

void LevelKeys_Init(){
	G[G_LASTKEYCOUNT] = Game->Counter[CR_KEYS];
}

void LevelKeys_Update(){
	int level = Game->GetCurLevel();
	if(G[G_LASTKEYCOUNT]!=Game->Counter[CR_KEYS]){
		if(Link->Item[I_SETTING_TRUEKEYS]){
			if(level>0){
				if(Game->Counter[CR_KEYS]>G[G_LASTKEYCOUNT]){
					++Game->LKeys[level];
					--Game->Counter[CR_KEYS];
				}
			}
		}
		G[G_LASTKEYCOUNT] = Game->Counter[CR_KEYS];
	}
}

const int SFX_TYREHEAL = 22;

const int SPR_ZARATHMULT = 121;

const int SFX_ZARATH_CHARGE1 = 115;
const int SFX_ZARATH_CHARGE2 = 116;
const int SFX_ZARATH_CHARGE3 = 117;
const int SFX_ZARATH_CHARGE4 = 118;

void Overdrive_Update(){
	int x = 148;
	int y = -8;
	int w;
	int h = 4;
	lweapon mult;
	
	if(G[G_NODRAWSUBSCREEN])
		return;
	
	if(G[G_ZARATH_MULTIPLIER]==0){
		w = Clamp(G[G_ZARATH_TIMER]/900*13, 0, 13)+1;
		if(G[G_ZARATH_TIMER]>0)
			Screen->Rectangle(7, x+1, y+1, x+1+w, y+h-2, 0x02, 1, 0, 0, 0, true, 128);
		if(G[G_ZARATH_TIMER]>900){
			G[G_ZARATH_TIMER] -= 900;
			G[G_ZARATH_MULTIPLIER] = 1;
			G[G_ZARATH_SAFETYFRAMES] = 60;
			Game->PlaySound(SFX_ZARATH_CHARGE1);
			mult = SpriteAnim(Link->X, Link->Y-16, SPR_ZARATHMULT, 1, 1);
			mult->CSet = 5;
			mult->DeadState = 64;
		}
	}
	else if(G[G_ZARATH_MULTIPLIER]==1){
		w = Clamp(G[G_ZARATH_TIMER]/600*13, 0, 13)+1;
		Screen->Rectangle(7, x, y, x+15, y+h-1, 0x02, 1, 0, 0, 0, true, 128);
		if(G[G_ZARATH_TIMER]>0)
			Screen->Rectangle(7, x+1, y+1, x+1+w, y+h-2, 0x52, 1, 0, 0, 0, true, 128);
		if(G[G_ZARATH_TIMER]>600){
			G[G_ZARATH_TIMER] -= 600;
			G[G_ZARATH_MULTIPLIER] = 2;
			G[G_ZARATH_SAFETYFRAMES] = 60;
			Game->PlaySound(SFX_ZARATH_CHARGE2);
			mult = SpriteAnim(Link->X, Link->Y-16, SPR_ZARATHMULT, 1, 1);
			mult->OriginalTile += 20;
			mult->Tile += 20;
			mult->CSet = 7;
			mult->DeadState = 64;
		}
	}
	else if(G[G_ZARATH_MULTIPLIER]==2){
		w = Clamp(G[G_ZARATH_TIMER]/600*13, 0, 13)+1;
		Screen->Rectangle(7, x, y, x+15, y+h-1, 0x52, 1, 0, 0, 0, true, 128);
		if(G[G_ZARATH_TIMER]>0)
			Screen->Rectangle(7, x+1, y+1, x+1+w, y+h-2, 0x72, 1, 0, 0, 0, true, 128);
		if(G[G_ZARATH_TIMER]>600){
			G[G_ZARATH_TIMER] -= 600;
			G[G_ZARATH_MULTIPLIER] = 3;
			G[G_ZARATH_SAFETYFRAMES] = 60;
			Game->PlaySound(SFX_ZARATH_CHARGE3);
			mult = SpriteAnim(Link->X, Link->Y-16, SPR_ZARATHMULT, 1, 1);
			mult->OriginalTile += 40;
			mult->Tile += 40;
			mult->CSet = 8;
			mult->DeadState = 64;
		}
	}
	else if(G[G_ZARATH_MULTIPLIER]==3){
		w = Clamp(G[G_ZARATH_TIMER]/600*13, 0, 13)+1;
		Screen->Rectangle(7, x, y, x+15, y+h-1, 0x72, 1, 0, 0, 0, true, 128);
		if(G[G_ZARATH_TIMER]>0)
			Screen->Rectangle(7, x+1, y+1, x+1+w, y+h-2, 0x82, 1, 0, 0, 0, true, 128);
		if(G[G_ZARATH_TIMER]>600){
			G[G_ZARATH_TIMER] = 300;
			G[G_ZARATH_MULTIPLIER] = 4;
			Game->PlaySound(SFX_ZARATH_CHARGE4);
			mult = SpriteAnim(Link->X-8, Link->Y-16, SPR_ZARATHMULT, 2, 1);
			mult->OriginalTile += 60;
			mult->Tile += 60;
			mult->CSet = 10;
			mult->DeadState = 64;
		}
	}
	else if(G[G_ZARATH_MULTIPLIER]==4){
		G[G_ZARATH_FILL] = 0;
		w = Clamp(G[G_ZARATH_TIMER]/300*13, 0, 13)+1;
		if(G[G_ZARATH_TIMER]>0)
			Screen->Rectangle(7, x+1, y+1, x+1+w, y+h-2, Choose(0x01, 0x02, 0x0F), 1, 0, 0, 0, true, 128);
	}
	Screen->Rectangle(7, x, y, x+15, y+h-1, 0x01, 1, 0, 0, 0, false, 128);
	
	if(G[G_ZARATH_FILL]){
		G[G_ZARATH_FILL] -= 10;
		G[G_ZARATH_TIMER] += 10;
	}
	else if(G[G_ZARATH_SAFETYFRAMES])
		--G[G_ZARATH_SAFETYFRAMES];
	else if(G[G_ZARATH_TIMER]){
		--G[G_ZARATH_TIMER];
		if(G[G_ZARATH_TIMER]==0){
			if(G[G_ZARATH_MULTIPLIER]==4){
				G[G_ZARATH_TIMER] = 0;
				G[G_ZARATH_MULTIPLIER] = 0;
			}
			if(G[G_ZARATH_MULTIPLIER]>1){
				G[G_ZARATH_TIMER] = 600;
				--G[G_ZARATH_MULTIPLIER];
			}
			else if(G[G_ZARATH_MULTIPLIER]==1){
				G[G_ZARATH_TIMER] = 900;
				--G[G_ZARATH_MULTIPLIER];
			}
		}
	}
}

void AutimeciaRing_CopyTiles(){
	if(G[G_AUTIMECIARING_ANIMS]==-1){
		//Arrows
		CopyTile(9372, 4144);
		CopyTile(9373, 4145);
		
		CopyTile(9392, 4146);
		CopyTile(9393, 4147);
		
		//Arrow Sparkles
		CopyTile(9712, 1335);
		CopyTile(9713, 1336);
		CopyTile(9714, 1337);
		CopyTile(9715, 1338);
		CopyTile(9716, 1335);
		
		//Fire
		CopyTile(9412, 292);
		
		//Magic
		CopyTile(9432, 4142);
		CopyTile(9433, 4143);
		
		//Bomb
		CopyTile(9452, 291);
		
		//Boomerang
		CopyTile(9472, 4148);
		CopyTile(9473, 4149);
		CopyTile(9474, 4150);
		
		//Bait
		CopyTile(9512, 270);
		
		//Sword
		CopyTile(9532, 4081);
		CopyTile(9533, 4082);
		CopyTile(9534, 4083);
		CopyTile(9535, 4084);
		CopyTile(9536, 4085);
		CopyTile(9537, 4086);
		CopyTile(9538, 4087);
		
		CopyTile(9632, 4101);
		CopyTile(9633, 4102);
		CopyTile(9634, 4103);
		CopyTile(9635, 4104);
		CopyTile(9636, 4105);
		CopyTile(9637, 4106);
		CopyTile(9638, 4107);
		
		G[G_AUTIMECIARING_ANIMS] = -2;
	}
	else if(G[G_AUTIMECIARING_ANIMS]>-1){
		++G[G_AUTIMECIARING_ANIMS];
		G[G_AUTIMECIARING_ANIMS] %= 24;
		int i = Floor(G[G_AUTIMECIARING_ANIMS]/4);
		
		if(G[G_AUTIMECIARING_ANIMS]%4==0){
			//Arrows
			CopyTile(9360+i, 4144);
			CopyTile(9366+i, 4145);
			
			CopyTile(9380+i, 4146);
			CopyTile(9386+i, 4147);
			
			//Arrow Sparkles
			CopyTile(9700+i, 1335);
			CopyTile(9706+i, 1336);
			CopyTile(9720+i, 1337);
			CopyTile(9726+i, 1338);
			CopyTile(9740+i, 1335);
			
			//Fire
			CopyTile(9400+i, 292);
			
			//Magic
			CopyTile(9420+i, 4142);
			CopyTile(9426+i, 4143);
			
			//Bomb
			CopyTile(9440+i, 291);
			
			//Boomerang
			CopyTile(9460+i, 4148);
			CopyTile(9466+i, 4149);
			CopyTile(9480+i, 4150);
			
			//Bait
			CopyTile(9500+i, 270);
			
			//Sword
			CopyTile(9520+i, 4081);
			CopyTile(9526+i, 4082);
			CopyTile(9540+i, 4083);
			CopyTile(9546+i, 4084);
			CopyTile(9560+i, 4085);
			CopyTile(9566+i, 4086);
			CopyTile(9580+i, 4087);
			
			CopyTile(9620+i, 4101);
			CopyTile(9626+i, 4102);
			CopyTile(9640+i, 4103);
			CopyTile(9646+i, 4104);
			CopyTile(9660+i, 4105);
			CopyTile(9666+i, 4106);
			CopyTile(9680+i, 4107);
		}
	}
}

void Cheats_Update(){
	if(Q7_CheatEnabled(G_MODE_BLEEDINGHEART)){
		if(Link->HP<G[G_LASTHP]){
			if(G[G_LINKBLEEDCOOLDOWN]==0){
				G[G_LINKBLEEDCOOLDOWN] = 300;
				HeartEffects_CopyTile();
			}
		}
		else if(Link->HP>G[G_LASTHP]){
			G[G_LINKBLEEDCOOLDOWN] = 0;
			HeartEffects_CopyTile();
		}
		
		if(G[G_LINKBLEEDCOOLDOWN]){
			--G[G_LINKBLEEDCOOLDOWN];
			if(!G[G_LINKBLEEDCOOLDOWN]){
				Game->PlaySound(SFX_OUCH);
				DealDirectDamage(8);
				G[G_LINKBLEEDCOOLDOWN] = 300;
			}
		}
	}
	
	if(Q7_CheatEnabled(G_MODE_BLEEDINGWALLET)&&!G[G_PERMADEATHCOUNTER]&&Game->GetCurDMap()!=34){
		if(Game->Counter[CR_RUPEES]!=G[G_LASTRUPEECOUNT]||G[G_LINKRUPEEDRAINCOOLDOWN]==0){
			G[G_LINKRUPEEDRAINCOOLDOWN] = Cond(Game->Counter[CR_RUPEES]>10, 180, 300);
		}
		
		if(G[G_LINKRUPEEDRAINCOOLDOWN]>0){
			--G[G_LINKRUPEEDRAINCOOLDOWN];
			if(!G[G_LINKRUPEEDRAINCOOLDOWN]){
				Game->PlaySound(SFX_MSG);
				Game->Counter[CR_RUPEES] = Max(Game->Counter[CR_RUPEES]-1, 0);
				G[G_LINKRUPEEDRAINCOOLDOWN] = Cond(Game->Counter[CR_RUPEES]>10, 180, 300);
			}
		}
		
		if(!Game->Counter[CR_RUPEES]){
			G[G_LINKRUPEEDRAINCOOLDOWN] = -1;
			Link->HP = 0;
		}
	}
}

void HeartEffects_CopyTile(){
	if(G[G_LINKBLEEDCOOLDOWN]){
		CopyTileBlock(766, 767, 0);
	}
	else{
		CopyTileBlock(764, 765, 0);
	}
}

void ScriptRings_Update(){
	if(Q7_HasRing(I_SPRING4_RHONE)){
		Link->HitDir = -1;
	}
	
	if(Q7_HasRing(I_SPRING9_JANDRA)){
		if(Link->Action==LA_GOTHURTLAND||Link->Action==LA_GOTHURTWATER){
			G[G_JANDRARING_BOOSTFRAMES] = 40;
		}
	}
	
	if(Q7_HasRing(I_SPRING11_MIRR)){
		Screen->Lit = true;
	}
	
	if(Q7_HasRing(I_SPRING15_ZARATH)){
		Overdrive_Update();
	}
	else{
		G[G_ZARATH_MULTIPLIER] = 0;
		G[G_ZARATH_TIMER] = 0;
	}
	
	if(Q7_HasRing(I_SPRING16_AUTIMECIA)){
		if(G[G_AUTIMECIARING_ANIMS]<0)
			G[G_AUTIMECIARING_ANIMS] = 0;
	}
	else{
		if(G[G_AUTIMECIARING_ANIMS]>=0)
			G[G_AUTIMECIARING_ANIMS] = -1;
	}
	AutimeciaRing_CopyTiles();
	
	if(Q7_HasRing(I_SPRING20_GAMBLE)){
		int rupees = Game->Counter[CR_RUPEES]+Game->DCounter[CR_RUPEES];
		if(rupees>G[G_LASTRUPEECOUNT]){
			Game->DCounter[CR_RUPEES] += rupees-G[G_LASTRUPEECOUNT];
		}
	}
	
	if(Q7_HasRing(I_SPRING27_POTION)){
		if(Link->HP<=16){
			if(Link->HP<=0&&(Link->Item[I_POTION1]||Link->Item[I_POTION2]))
				Link->HP = 1;
			
			if(Link->Item[I_POTION2]){
				while(GetEquipmentB()!=I_POTION2)
					Link->SelectBWeapon(DIR_LEFT);
				Link->InputB = true;
			}
			else if(Link->Item[I_POTION1]){
				while(GetEquipmentB()!=I_POTION1)
					Link->SelectBWeapon(DIR_LEFT);
				Link->InputB = true;
			}
				
		}
	}
	
	if(G[G_BLUETEARHEAL]){
		--G[G_BLUETEARHEAL];
		if(G[G_BLUETEARHEAL]%10==0){
			Link->HP += 8;
		}
	}
	if(G[G_BLUETEARHEALCOOLDOWN])
		--G[G_BLUETEARHEALCOOLDOWN];
	
	if(G[G_JANDRARING_BOOSTFRAMES])
		--G[G_JANDRARING_BOOSTFRAMES];
	
	G[G_LASTRUPEECOUNT] = Game->Counter[CR_RUPEES]+Game->DCounter[CR_RUPEES];
}

const int SPR_FIREBALL_UNBLOCKABLE = 111;
const int SPR_FIRE_UNBLOCKABLE = 112;

// void SpecialModes_Init(){
	// int hw[] = "HYRULE";
	// int filename[9];
	// for(int i=0; i<8; i++){
		// filename[i] = LowerToUpper(filename[i]);
	// }
	// Game->GetSaveName(filename);
	// if(strcmp(filename, hw)==0){
		// G[G_SPECIALMODE] = SPECMODE_HYRULEWARRIORS;
	// }
// }

void NPCData_NoClone_Init(int npct_NoClone, int npc_NoClone){
	npct_NoClone[NPCT_GUY] = 1;
	npct_NoClone[NPCT_TRAP] = 1;
	npct_NoClone[NPCT_AQUAMENTUS] = 1;
	npct_NoClone[NPCT_MOLDORM] = 1;
	npct_NoClone[NPCT_DODONGO] = 1;
	npct_NoClone[NPCT_MANHANDLA] = 1;
	npct_NoClone[NPCT_GLEEOK] = 1;
	npct_NoClone[NPCT_DIGDOGGER] = 1;
	npct_NoClone[NPCT_GOHMA] = 1;
	npct_NoClone[NPCT_LANMOLA] = 1;
	npct_NoClone[NPCT_PATRA] = 1;
	npct_NoClone[NPCT_GANON] = 1;
	npct_NoClone[NPCT_NONE] = 1;
	npct_NoClone[NPCT_FAIRY] = 1;
	npct_NoClone[NPCT_PROJECTILE] = 1;
	npct_NoClone[NPCT_OTHER] = 1;
	
	npc_NoClone[51] = 1; //Bubble
	npc_NoClone[81] = 1; 
	npc_NoClone[82] = 1; 
	npc_NoClone[117] = 1;
	npc_NoClone[118] = 1; 
	npc_NoClone[119] = 1; 
	npc_NoClone[85] = 1; //Fire
	npc_NoClone[263] = 1; //Super Digdogger
	npc_NoClone[264] = 1; 
	npc_NoClone[265] = 1; //Skeleton war
	npc_NoClone[266] = 1;
	npc_NoClone[273] = 1; //Script Gohma
	npc_NoClone[274] = 1; //Lanmolar
	npc_NoClone[276] = 1; //Katatafish
	npc_NoClone[277] = 1; //Ghini Pirate
	npc_NoClone[280] = 1; //The Duke
	npc_NoClone[289] = 1; //Nightmare
	npc_NoClone[290] = 1; 
	npc_NoClone[291] = 1; 
	npc_NoClone[292] = 1; 
	npc_NoClone[293] = 1; 
	npc_NoClone[315] = 1; //Adjean
	npc_NoClone[316] = 1; //Bannon
	
	npc_NoClone[116] = 1; //Trigger
}

void NPCData_NoHPLower_Init(int npct_NoHPLower, int npc_NoHPLower){
	npc_NoHPLower[43] = 1; //Zol
	npc_NoHPLower[89] = 1;
	npc_NoHPLower[52] = 1; //Vire
	npc_NoHPLower[91] = 1;
	npc_NoHPLower[85] = 1; //Fire
	npc_NoHPLower[300] = 1; //Bat Zol
	
	npc_NoHPLower[263] = 1; //Super Digdogger
	npc_NoHPLower[264] = 1; 
	npc_NoHPLower[265] = 1; //Skeleton war
	npc_NoHPLower[266] = 1;
	npc_NoHPLower[273] = 1; //Script Gohma
	npc_NoHPLower[274] = 1; //Lanmolar
	npc_NoHPLower[276] = 1; //Katatafish
	npc_NoHPLower[277] = 1; //Ghini Pirate
	npc_NoHPLower[280] = 1; //The Duke
	npc_NoHPLower[289] = 1; //Nightmare
	npc_NoHPLower[290] = 1; 
	npc_NoHPLower[291] = 1; 
	npc_NoHPLower[292] = 1; 
	npc_NoHPLower[293] = 1; 
	npc_NoHPLower[315] = 1; //Adjean
	npc_NoHPLower[316] = 1; //Bannon
	
	npc_NoHPLower[116] = 1; //Trigger
	npc_NoHPLower[270] = 1; //Scripted Trap
	npc_NoHPLower[269] = 1; //Scripted Trap
	
	npc_NoHPLower[118] = 1; //Bubbles
	npc_NoHPLower[119] = 1;
	npc_NoHPLower[117] = 1;
	npc_NoHPLower[81] = 1;
	npc_NoHPLower[82] = 1;
	npc_NoHPLower[51] = 1;
	
	npct_NoHPLower[NPCT_GUY] = 1;
	npct_NoHPLower[NPCT_TRAP] = 1;
	npct_NoHPLower[NPCT_AQUAMENTUS] = 1;
	npct_NoHPLower[NPCT_MOLDORM] = 1;
	npct_NoHPLower[NPCT_DODONGO] = 1;
	npct_NoHPLower[NPCT_MANHANDLA] = 1;
	npct_NoHPLower[NPCT_GLEEOK] = 1;
	npct_NoHPLower[NPCT_DIGDOGGER] = 1;
	npct_NoHPLower[NPCT_GOHMA] = 1;
	npct_NoHPLower[NPCT_LANMOLA] = 1;
	npct_NoHPLower[NPCT_PATRA] = 1;
	npct_NoHPLower[NPCT_GANON] = 1;
	npct_NoHPLower[NPCT_NONE] = 1;
	npct_NoHPLower[NPCT_FAIRY] = 1;
	npct_NoHPLower[NPCT_PROJECTILE] = 1;
}

void NPCData_NoSpeedChange_Init(int npct_NoSpeedChange, int npc_NoSpeedChange){
	npc_NoSpeedChange[263] = 1; //Super Digdogger
	npc_NoSpeedChange[264] = 1; 
	npc_NoSpeedChange[265] = 1; //Skeleton war
	npc_NoSpeedChange[266] = 1;
	npc_NoSpeedChange[273] = 1; //Script Gohma
	npc_NoSpeedChange[274] = 1; //Lanmolar
	npc_NoSpeedChange[276] = 1; //Katatafish
	npc_NoSpeedChange[277] = 1; //Ghini Pirate
	npc_NoSpeedChange[280] = 1; //The Duke
	npc_NoSpeedChange[289] = 1; //Nightmare
	npc_NoSpeedChange[290] = 1; 
	npc_NoSpeedChange[291] = 1; 
	npc_NoSpeedChange[292] = 1; 
	npc_NoSpeedChange[293] = 1; 
	npc_NoSpeedChange[315] = 1; //Adjean
	npc_NoSpeedChange[316] = 1; //Bannon
	
	npc_NoSpeedChange[116] = 1; //Trigger
	
	
	npct_NoSpeedChange[NPCT_GUY] = 1;
	npct_NoSpeedChange[NPCT_TRAP] = 1;
	npct_NoSpeedChange[NPCT_AQUAMENTUS] = 1;
	npct_NoSpeedChange[NPCT_MOLDORM] = 1;
	npct_NoSpeedChange[NPCT_DODONGO] = 1;
	npct_NoSpeedChange[NPCT_MANHANDLA] = 1;
	npct_NoSpeedChange[NPCT_GLEEOK] = 1;
	npct_NoSpeedChange[NPCT_DIGDOGGER] = 1;
	npct_NoSpeedChange[NPCT_GOHMA] = 1;
	npct_NoSpeedChange[NPCT_LANMOLA] = 1;
	npct_NoSpeedChange[NPCT_PATRA] = 1;
	npct_NoSpeedChange[NPCT_GANON] = 1;
	npct_NoSpeedChange[NPCT_NONE] = 1;
	npct_NoSpeedChange[NPCT_FAIRY] = 1;
	npct_NoSpeedChange[NPCT_PROJECTILE] = 1;
	npct_NoSpeedChange[NPCT_WALLMASTER] = 1;
}

void LWeapon_Update(){
	G[G_NODARKENROOM] = 0;
	G[G_CANDLE3COREFIRES] = 0;
	for(int i=Screen->NumLWeapons(); i>=1; i--){
		lweapon l = Screen->LoadLWeapon(i);
		LWeapon_GlobalEffects(l);
		
		LWeapon_EchoWand(l);
		LWeapon_MagicBrang(l);
		LWeapon_FireBrang(l);
		LWeapon_RingEffectsUpdate(l);
		LWeapon_SilverArrow(l);
		LWeapon_Candle3(l);
		LWeapon_Shield4(l);
		LWeapon_DamageMod(l);
	}
}

void LWeapon_DamageMod(lweapon l){
	if(!l->Misc[LWM_DAMAGEMODDED]){
		if(Link->Item[I_CRIT5]){
			l->Damage += 100*G[G_HPSCALE];
		}
		else{
			if(l->ID==LW_BRANG){
				if(Link->Item[I_CRIT4]){
					if(!Rand(2))
						l->Damage += 2*G[G_HPSCALE];
				}
				else if(Link->Item[I_CRIT3]){
					if(!Rand(4))
						l->Damage += 2*G[G_HPSCALE];
				}
				else if(Link->Item[I_CRIT2]){
					if(!Rand(6))
						l->Damage += 2*G[G_HPSCALE];
				}
				else if(Link->Item[I_CRIT1]){
					if(!Rand(8))
						l->Damage += 2*G[G_HPSCALE];
				}
			}
			else{
				if(Link->Item[I_CRIT4]){
					l->Damage += 2*G[G_HPSCALE];
				}
				else if(Link->Item[I_CRIT3]){
					if(!Rand(2))
						l->Damage += 2*G[G_HPSCALE];
				}
				else if(Link->Item[I_CRIT2]){
					if(!Rand(3))
						l->Damage += 2*G[G_HPSCALE];
				}
				else if(Link->Item[I_CRIT1]){
					if(!Rand(4))
						l->Damage += 2*G[G_HPSCALE];
				}
			}
		}
		if(G[G_ALTCHARACTER]==CHAR_FROGGER){
			if(l->ID==LW_BOMB){
				if(G[G_FROGGER_SHIELDLEVEL]>=1)
					l->Damage += 2*G[G_HPSCALE];
				if(G[G_FROGGER_SHIELDLEVEL]>=4)
					l->Damage += 4*G[G_HPSCALE];
				if(G[G_FROGGER_SHIELDLEVEL]>=7)
					l->Damage += 4*G[G_HPSCALE];
			}
		}
		l->Misc[LWM_DAMAGEMODDED] = 1;
	}
}

int CritRingDamage(){
	if(Link->Item[I_CRIT5])
		return 100;
	if(Link->Item[I_CRIT4])
		return 2;
	else if(Link->Item[I_CRIT3]){
		if(!Rand(2))
			return 2;
	}
	else if(Link->Item[I_CRIT2]){
		if(!Rand(3))
			return 2;
	}
	else if(Link->Item[I_CRIT1]){
		if(!Rand(3))
			return 2;
	}
	return 0;
}

const int SPR_ARROW_HITO = 118;
const int SPR_ARROW_WILL = 119;
const int SPR_ARROW_HITOWILL = 120;

int CenterHitX(lweapon l){
	return l->X+l->HitXOffset+l->HitWidth/2;
}
int CenterHitY(lweapon l){
	return l->Y+l->HitYOffset+l->HitHeight/2;
}
int CenterHitX(eweapon e){
	return e->X+e->HitXOffset+e->HitWidth/2;
}
int CenterHitY(eweapon e){
	return e->Y+e->HitYOffset+e->HitHeight/2;
}

void LWeapon_RingEffectsUpdate(lweapon l){
	if(l->Misc[LWM_MISCFLAGS]&LWMF_NODEADANIM){
		if(l->ID==LW_BEAM){
			if(l->DeadState==WDS_BEAMSHARDS)
				l->DeadState = 0;
		}
	}
	if(l->ID==LW_ARROW||l->Misc[LWM_MISCFLAGS]&LWMF_FAKEARROW){
		if(!l->Misc[LWM_RINGMODS]){
			if(Q7_HasRing(I_SPRING1_HITO)){
				l->Misc[LWM_RINGMODS] = 2;
				l->Step *= 0.66;
				if(l->ID==LW_ARROW)
					l->UseSprite(SPR_ARROW_HITO);
				if(!l->Angular){
					l->Angular = true;
					l->Angle = DegtoRad(DirAngle(l->Dir));
				}
				if(Q7_HasRing(I_SPRING3_WILL)){
					LWeapon_WillStun(l);
					l->Misc[LWM_RINGMODS] = 3;
					if(l->ID==LW_ARROW)
						l->UseSprite(SPR_ARROW_HITOWILL);
					l->Step *= 2;
				}
				
			}
			else if(Q7_HasRing(I_SPRING3_WILL)){
				LWeapon_WillStun(l);
				l->Misc[LWM_RINGMODS] = 1;
				if(l->ID==LW_ARROW)
					l->UseSprite(SPR_ARROW_WILL);
				l->Flip = 0;
				l->Step *= 2;
				if(!l->Angular){
					if(l->Dir>DIR_DOWN){
						l->OriginalTile += 4;
						l->Tile += 4;
					}
					if(l->Dir==DIR_LEFT)
						l->Flip = 1;
					else if(l->Dir==DIR_DOWN)
						l->Flip = 2;
				}
				else{
					l->OriginalTile += 4;
					l->Tile += 4;
				}
			}
			else
				l->Misc[LWM_RINGMODS] = 9;
		}
		else{
			if(l->Misc[LWM_RINGMODS]==1){
				LWeapon_WillStun(l);
				if(G[G_ANIM]%2==0){
					lweapon l2 = SpriteAnim(CenterHitX(l)-8+Rand(-4, 4), CenterHitY(l)-8+Rand(-4, 4), SPR_ARROW_WILL, 1, 1);
					l2->OriginalTile += 20;
					l2->Tile += 20;
				}
			}
			else if(l->Misc[LWM_RINGMODS]==2){
				npc target = HomingArrow_FindTarget(l);
				if(target->isValid()){
					//Screen->Rectangle(6, target->X, target->Y, target->X+15, target->Y+15, 0x01, 1, 0, 0, 0, false, 128);
					int angle = WrapDegrees(RadtoDeg(l->Angle));
					angle = TurnToAngle(angle, Angle(CenterX(l), CenterY(l), CenterX(target), CenterY(target)), 4);
					l->Angle = DegtoRad(angle);
					l->Dir = AngleDir4(WrapDegrees(angle));
				}
				if(G[G_ANIM]%4==0){
					lweapon l2 = SpriteAnim(CenterHitX(l)-8+Rand(-4, 4), CenterHitY(l)-8+Rand(-4, 4), SPR_ARROW_HITO, 1, 1);
					l2->OriginalTile += 20;
					l2->Tile += 20;
				}
			}
			else if(l->Misc[LWM_RINGMODS]==3){
				LWeapon_WillStun(l);
				npc target = HomingArrow_FindTarget(l);
				if(target->isValid()){
					// Screen->Rectangle(6, target->X, target->Y, target->X+15, target->Y+15, 0x01, 1, 0, 0, 0, false, 128);
					int angle = WrapDegrees(RadtoDeg(l->Angle));
					angle = TurnToAngle(angle, Angle(CenterX(l), CenterY(l), CenterX(target), CenterY(target)), 4);
					l->Angle = DegtoRad(angle);
					l->Dir = AngleDir4(WrapDegrees(angle));
				}
				if(G[G_ANIM]%2==0){
					lweapon l2 = SpriteAnim(CenterHitX(l)-8+Rand(-4, 4), CenterHitY(l)-8+Rand(-4, 4), SPR_ARROW_HITOWILL, 1, 1);
					l2->OriginalTile += 20;
					l2->Tile += 20;
				}
			}
		}
	}
	else if(l->ID==LW_BOMBBLAST){
		if(l->Misc[LWM_RINGMODS]!=1){
			if(Q7_HasRing(I_SPRING12_HART)){
				int args[8];
				args[0] = l->X;
				args[1] = l->Y;
				if(l->Misc[LWM_RINGMODS]==0)
					args[2] = 4;
				else
					args[2] = l->Misc[LWM_RINGMODS];
				RunFFCScript(FFCS_SHOCKWAVES, args);
				l->Misc[LWM_RINGMODS] = 1;
			}
		}
	}
	else if(l->ID==LW_BAIT){
		if(Q7_HasRing(I_SPRING21_STARVATION)){
			for(int i=Screen->NumNPCs(); i>0; --i){
				npc n = Screen->LoadNPC(i);
				if(n->CollDetection&&n->HP>0){
					if(n->Hunger>0){
						if(Collision(n, l)){
							SetEnemyProperty(n, ENPROP_HP, 0);
							Game->PlaySound(SFX_EDEAD);
						}
					}
				}
			}
		}
	}
	else if(l->ID==LW_FIRE){
		if(!l->Misc[LWM_RINGMODS]){
			if(Q7_HasRing(I_SPRING2_JACK))
				l->Damage += 2*G[G_HPSCALE];
			l->Misc[LWM_RINGMODS] = 1;
		}
	}
	else if(l->ID==LW_REFMAGIC||l->ID==LW_REFBEAM||l->ID==LW_REFBEAM||l->ID==LW_REFROCK){
		if(!l->Misc[LWM_RINGMODS]){
			if(Q7_HasRing(I_SPRING10_HOLM))
				l->Damage += 4*G[G_HPSCALE];
			l->Misc[LWM_RINGMODS] = 1;
		}
	}
}

void LWeapon_WillStun(lweapon l){
	for(int i=Screen->NumNPCs(); i>0; --i){
		npc n = Screen->LoadNPC(i);
		if(n->CollDetection){
			int x = l->X;
			int y = l->Y;
			if(l->Angular){
				x += VectorX(l->Step/100, RadtoDeg(l->Angle));
				y += VectorY(l->Step/100, RadtoDeg(l->Angle));
			}
			else{
				x += DirX(l->Step/100, l->Dir);
				y += DirY(l->Step/100, l->Dir);
			}
			// Screen->Rectangle(6, x, y, x+15, y+15, 0x01, 1, 0, 0, 0, true, 64);
			// Screen->Rectangle(6, n->X, n->Y, n->X+n->TileWidth*16-1, n->Y+n->TileHeight*16-1, 0x02, 1, 0, 0, 0, true, 64);
			if(RectCollision(n->X, n->Y, n->X+n->TileWidth*16-1, n->Y+n->TileHeight*16-1, x, y, x+15, y+15)){
				if(!n->Misc[NPCM_STATUSCOUNTER]){
					n->Misc[NPCM_STATUSTYPE] = 2;
					n->Misc[NPCM_STATUSCOUNTER] = 180;
				}
			}
		}
	}
}

npc HomingArrow_FindTarget(lweapon l){
	npc closest;
	int closestDist = 1000;
	int x; int y;
	for(int i=Screen->NumNPCs(); i>=1; --i){
		npc n = Screen->LoadNPC(i);
		if(n->CollDetection){
			if(n->Defense[NPCD_ARROW]==NPCDT_NONE||n->Defense[NPCD_ARROW]==NPCDT_ONEHITKILL||n->Defense[NPCD_ARROW]==NPCDT_HALFDAMAGE){
				x = n->X+n->HitWidth/2+n->HitXOffset;
				y = n->Y+n->HitHeight/2+n->HitYOffset;
				if(Distance(CenterX(l), CenterY(l), x, y)<closestDist){
					if(x>0&&x<240&&y>0&&y<160){
						int angle = Angle(CenterX(l), CenterY(l), x, y);
						if(Abs(AngDiff(WrapDegrees(RadtoDeg(l->Angle)), angle))<90){
							closest = n;
							closestDist = Distance(CenterX(l), CenterY(l), x, y);
						}
					}
				}
			}
		}
	}
	return closest;
}

npc Generic_FindTarget(int def, int sourceX, int sourceY, int sourceAngle){
	npc closest;
	int closestDist = 1000;
	int x; int y;
	for(int i=Screen->NumNPCs(); i>=1; --i){
		npc n = Screen->LoadNPC(i);
		if(n->CollDetection){
			if(n->Defense[def]==NPCDT_NONE||n->Defense[def]==NPCDT_ONEHITKILL||n->Defense[def]==NPCDT_HALFDAMAGE){
				x = n->X+n->HitWidth/2+n->HitXOffset;
				y = n->Y+n->HitHeight/2+n->HitYOffset;
				if(Distance(sourceX, sourceY, x, y)<closestDist){
					if(x>0&&x<240&&y>0&&y<160){
						int angle = Angle(sourceX, sourceY, x, y);
						if(sourceAngle==-1000){
							closest = n;
							closestDist = Distance(sourceX, sourceY, x, y);
						}
						else if(Abs(AngDiff(WrapDegrees(sourceAngle), angle))<90){
							closest = n;
							closestDist = Distance(sourceX, sourceY, x, y);
						}
					}
				}
			}
		}
	}
	return closest;
}

npc Generic_FindTarget(int def, int sourceX, int sourceY, int sourceAngle, int anglePriority){
	npc closest;
	int closestDist = 1000;
	int x; int y;
	for(int i=Screen->NumNPCs(); i>=1; --i){
		npc n = Screen->LoadNPC(i);
		if(n->CollDetection){
			if(n->Defense[def]==NPCDT_NONE||n->Defense[def]==NPCDT_ONEHITKILL||n->Defense[def]==NPCDT_HALFDAMAGE){
				x = n->X+n->HitWidth/2+n->HitXOffset;
				y = n->Y+n->HitHeight/2+n->HitYOffset;
				int angle = Angle(sourceX, sourceY, x, y);
				int dist = Distance(sourceX, sourceY, x, y);
				if(anglePriority)
					dist += dist*(Abs(AngDiff(WrapDegrees(sourceAngle), angle))/90)*anglePriority;
				if(dist<closestDist){
					if(x>0&&x<240&&y>0&&y<160){
						if(sourceAngle==-1000){
							closest = n;
							closestDist = Distance(sourceX, sourceY, x, y);
						}
						else if(Abs(AngDiff(WrapDegrees(sourceAngle), angle))<90){
							closest = n;
							closestDist = Distance(sourceX, sourceY, x, y);
						}
					}
				}
			}
		}
	}
	return closest;
}

const int I_REFWANDBOOK = 124;

const int LWM_DEATHTIMER = 0; //Used by everything
const int LWM_MISCFLAGS = 1; //Used by everything
const int LWM_ARROWFRAMES = 5; //Used by Arrow
const int LWM_CHARMODS = 6; //Used by Hito
const int LWM_RINGMODS = 7; //Used by Hito, Will, Holm, and Hart
const int LWM_ROTATION = 8; //Used by everything
const int LWM_DAMAGEMODDED = 9;
const int LWM_ARTIFICIALPUSHTIME = 10; //Used by Trimirror Shield
const int LWM_ARTIFICIALPUSHX = 11; //Used by Trimirror Shield
const int LWM_ARTIFICIALPUSHY = 12; //Used by Trimirror Shield
const int LWM_BRANGFRAMES = 13; //Used by Brang
const int LWM_REFLINKCOLLISION = 13; //Used by Trimirror Shield
const int LWM_BRANGLASTDIR = 14; //Used by Brang
const int LWM_FIRETYPE = 14; //Used by Fire
const int LWM_REFHASMULTIPLIED = 14; //Used by Trimirror Shield
const int LWM_REFCOUNT = 15; //Used by Magic and Brang
const int LWM_FIRETIME = 15; //Used by Fire

const int LWMF_PIERCING    = 00000001b;
const int LWMF_FAKEARROW   = 00000010b;
const int LWMF_DRAWOVER    = 00000100b;
const int LWMF_NODEADANIM  = 00001000b;

void LWeapon_GlobalEffects(lweapon l){
	if(l->Misc[LWM_MISCFLAGS]){
		if(l->Misc[LWM_MISCFLAGS]&LWMF_PIERCING)
			l->DeadState = WDS_ALIVE;
		if(l->Misc[LWM_MISCFLAGS]&LWMF_DRAWOVER){
			l->DrawXOffset = -1000;
			Q7_DrawToLayer(l, 4, 128);
		}
	}
	if(l->Misc[LWM_DEATHTIMER]){
		--l->Misc[LWM_DEATHTIMER];
		if(l->Misc[LWM_DEATHTIMER]==0)
			l->DeadState = 0;
	}
	if(l->Misc[LWM_ROTATION]){
		l->DrawXOffset = -1000;
		int layer = 2;
		if(ScreenFlag(1, 4)) //Layer -2
			layer = 1;
		Screen->DrawTile(layer, l->X, l->Y+l->DrawYOffset, l->Tile, 1, 1, l->CSet, -1, -1, l->X, l->Y+l->DrawYOffset, RadtoDeg(l->Angle), 0, true, 128);
	}
}

void LWeapon_EchoWand(lweapon l){
	if(l->Misc[LWM_DEATHTIMER])
		return;
	if(l->ID==LW_MAGIC||l->ID==LW_REFMAGIC){
		if(Link->Item[I_REFWANDBOOK]&&l->Misc[LWM_REFCOUNT]!=-1000)
			l->DeadState = -1;
		if(l->ID==LW_REFMAGIC){
			if(LinkCollision(l))
				l->CollDetection = false;
			else
				l->CollDetection = true;
		}
		if(l->Misc[LWM_REFCOUNT]<=4){
			if(!CanPlaceLadderHookshot(l->X, l->Y+8, 16, 8)){
				int step = Max(Ceiling(l->Step/100), 1);
				int newX = l->X+InFrontX(OppositeDir(l->Dir), 16-step);
				int newY = l->Y+InFrontY(OppositeDir(l->Dir), 16-step);
				
				if(CanPlaceLadderHookshot(newX, newY+8, 16, 8)){
					if(l->Misc[LWM_REFCOUNT]<4&&Link->Item[I_REFWANDBOOK]){
						lweapon dupe = CreateLWeaponAt(LW_REFMAGIC, l->X, l->Y);
						if(l->Dir<=DIR_DOWN)
							dupe->Y = GridY(l->Y+8);
						else
							dupe->X = GridX(l->X+8);
						dupe->Dir = OppositeDir(l->Dir);
						dupe->Step = Min(l->Step*1.5, 400);
						dupe->Damage = l->Damage;
						dupe->UseSprite(16);
						if(dupe->Dir>DIR_DOWN){
							dupe->OriginalTile++;
							dupe->Tile = dupe->OriginalTile;
						}
						if(dupe->Dir==DIR_DOWN)
							dupe->Flip = 2;
						else if(dupe->Dir==DIR_LEFT)
							dupe->Flip = 1;
						
						if(LinkCollision(dupe))
							dupe->CollDetection = false;
						else
							dupe->CollDetection = true;
						dupe->DeadState = -1;
						
						dupe->Misc[LWM_REFCOUNT] = l->Misc[LWM_REFCOUNT]+1;
						dupe->Misc[LWM_REFHASMULTIPLIED] = 1;
					}
					l->DeadState = 0;
				}
			}
		}
	}
}

void LWeapon_MagicBrang(lweapon l){
	if(l->ID==LW_BRANG){
		int ang1; int ang2;
		int vX; int vY;
		int step = 1;
		int step2 = 0;
		if(Link->Item[I_BRANG3]){
			step += 1;
			step2 += 2;
		}
		if(Q7_HasRing(I_SPRING29_BRANG)){
			step += 2;
			step2 += 2;
			if(l->Damage==0)
				l->Damage = 1;
		}
		if(Link->Item[I_BRANG2]){
			if(l->Misc[LWM_BRANGFRAMES]==1){
				if(Link->InputUp||Link->InputDown||Link->InputLeft||Link->InputRight)
					l->Misc[LWM_BRANGFRAMES] = -1; //No turn
			}
			if(l->Misc[LWM_BRANGFRAMES]>=0)
				l->Misc[LWM_BRANGFRAMES]++;
			if(l->Misc[LWM_REFCOUNT]==0){
				if(l->Misc[LWM_BRANGLASTDIR]==0)
					l->Misc[LWM_BRANGLASTDIR] = l->Dir+1;
				if(l->DeadState==WDS_BOUNCE||l->Dir+1!=l->Misc[LWM_BRANGLASTDIR])
					l->Misc[LWM_REFCOUNT] = 1;
				
				npc target = LWeapon_MagicBrang_FindTarget(l);
				if(target->isValid()&&l->Misc[LWM_BRANGFRAMES]!=-1){
					ang1 = Q7_DirAngle(l->Dir);
					ang2 = Angle(CenterX(l), CenterY(l), CenterX(target), CenterY(target));
					if(Abs(AngDiff(ang1, ang2))<100){
						G[G_BRANGPUSHX] += VectorX(step, ang2);
						G[G_BRANGPUSHY] += VectorY(step, ang2);
						l->Dir = AngleDir8(ang2);
						l->Misc[LWM_BRANGLASTDIR] = l->Dir+1;
					}
					
					if(Abs(G[G_BRANGPUSHX])>=1){
						vX = Floor(Abs(G[G_BRANGPUSHX]))*Sign(G[G_BRANGPUSHX]);
						l->X += vX;
						G[G_BRANGPUSHX] -= vX;
					}
					if(Abs(G[G_BRANGPUSHY])>=1){
						vY = Floor(Abs(G[G_BRANGPUSHY]))*Sign(G[G_BRANGPUSHY]);
						l->Y += vY;
						G[G_BRANGPUSHY] -= vY;
					}
				}
				else{
					ang1 = Q7_DirAngle(l->Dir);
					if(step2){
						G[G_BRANGPUSHX] += DirX(l->Dir, step2); //VectorX(step, ang1);
						G[G_BRANGPUSHY] += DirY(l->Dir, step2); //VectorY(step, ang1);
					}
					
					if(Abs(G[G_BRANGPUSHX])>=1){
						vX = Floor(Abs(G[G_BRANGPUSHX]))*Sign(G[G_BRANGPUSHX]);
						l->X += vX;
						G[G_BRANGPUSHX] -= vX;
					}
					if(Abs(G[G_BRANGPUSHY])>=1){
						vY = Floor(Abs(G[G_BRANGPUSHY]))*Sign(G[G_BRANGPUSHY]);
						l->Y += vY;
						G[G_BRANGPUSHY] -= vY;
					}
				}
			}
			else{
				ang1 = Q7_DirAngle(l->Dir);
				ang2 = Angle(CenterX(l), CenterY(l), CenterLinkX(), CenterLinkY());
				if(Abs(AngDiff(ang1, ang2))<90){
					G[G_BRANGPUSHX] += VectorX(4, ang2);
					G[G_BRANGPUSHY] += VectorY(4, ang2);
				}
				
				if(Abs(G[G_BRANGPUSHX])>=1){
					vX = Floor(Abs(G[G_BRANGPUSHX]))*Sign(G[G_BRANGPUSHX]);
					l->X += vX;
					G[G_BRANGPUSHX] -= vX;
				}
				if(Abs(G[G_BRANGPUSHY])>=1){
					vY = Floor(Abs(G[G_BRANGPUSHY]))*Sign(G[G_BRANGPUSHY]);
					l->Y += vY;
					G[G_BRANGPUSHY] -= vY;
				}
			}
		}
		else if(Link->Item[I_BRANG1]){
			if(Q7_HasRing(I_SPRING29_BRANG)){
				if(l->Misc[LWM_REFCOUNT]==0){
					if(l->Misc[LWM_BRANGLASTDIR]==0)
						l->Misc[LWM_BRANGLASTDIR] = l->Dir+1;
					if(l->DeadState==WDS_BOUNCE||l->Dir+1!=l->Misc[LWM_BRANGLASTDIR])
						l->Misc[LWM_REFCOUNT] = 1;
				}
				else{
					ang1 = Q7_DirAngle(l->Dir);
					ang2 = Angle(CenterX(l), CenterY(l), CenterLinkX(), CenterLinkY());
					if(Abs(AngDiff(ang1, ang2))<90){
						G[G_BRANGPUSHX] += VectorX(4, ang2);
						G[G_BRANGPUSHY] += VectorY(4, ang2);
					}
					
					if(Abs(G[G_BRANGPUSHX])>=1){
						vX = Floor(Abs(G[G_BRANGPUSHX]))*Sign(G[G_BRANGPUSHX]);
						l->X += vX;
						G[G_BRANGPUSHX] -= vX;
					}
					if(Abs(G[G_BRANGPUSHY])>=1){
						vY = Floor(Abs(G[G_BRANGPUSHY]))*Sign(G[G_BRANGPUSHY]);
						l->Y += vY;
						G[G_BRANGPUSHY] -= vY;
					}
				}
			}
		}
	}
}

npc LWeapon_MagicBrang_FindTarget(lweapon l){
	npc closest;
	int closestDist = 1000;
	for(int i=Screen->NumNPCs(); i>=1; i--){
		npc n = Screen->LoadNPC(i);
		if(n->CollDetection){
			int ang1 = Q7_DirAngle(l->Dir);
			int ang2 = Angle(CenterX(l), CenterY(l), CenterX(n), CenterY(n));
			if(n->Type!=NPCT_GUY&&n->Type!=NPCT_PROJECTILE){
				if(Abs(AngDiff(ang1, ang2))<100){
					if(n->ID==NPC_FAIRY){
						int dist = Distance(CenterX(l), CenterY(l), CenterX(n), CenterY(n));
						if(dist/4<closestDist){
							closestDist = dist/4;
							closest = n;
						}
					}
					else if(n->Defense[NPCD_BRANG]!=NPCDT_BLOCK&&n->Defense[NPCD_BRANG]!=NPCDT_IGNORE&&(n->Defense[NPCD_BRANG]!=NPCDT_STUNORBLOCK||l->Damage>0)){
						int dist = Distance(CenterX(l), CenterY(l), CenterX(n), CenterY(n));
						if(dist<closestDist){
							closestDist = dist;
							closest = n;
						}
					}
				}
			}
		}
	}
	return closest;
}

const int CMB_FIRE_BRANG_AURA = 397;

bool FireBrang_CanBlock(eweapon e){
	if(e->Misc[__EWI_FLAGS]&EWF_UNBLOCKABLE)
		return false;
	
	return true;
}

const int SPR_SMOKEPUFF = 105;

void LWeapon_FireBrang(lweapon l){
	if(l->ID==LW_BRANG){
		if(Link->Item[I_BRANG3]){
			int x = l->X+l->DrawXOffset+DirX(l->Dir, l->Step*0.01);
			int y = l->Y+l->DrawYOffset+DirY(l->Dir, l->Step*0.01);
			
			for(int i=Screen->NumEWeapons(); i>0; --i){
				eweapon e = Screen->LoadEWeapon(i);
				if(e->CollDetection){
					if(Collision(e, l)){
						if(FireBrang_CanBlock(e)){
							lweapon poof = CreateLWeaponAt(LW_SPARKLE, CenterX(e)-8, CenterY(e)-8);
							poof->UseSprite(SPR_SMOKEPUFF);
							poof->Angular = true;
							poof->Angle = DegtoRad(Q7_DirAngle(l->Dir));
							poof->Step = 50;
							e->DeadState = 0;
						}
					}
				}
			}
			Screen->FastCombo(4, x, y, CMB_FIRE_BRANG_AURA, 8, 128);
		}
	}
}

const int SPR_SILVERSPARKLE = 106;

void LWeapon_SilverArrow(lweapon l){
	if(l->ID==LW_ARROW){
		if(G[G_AUTOBOWSTATE]==0)
			G[G_AUTOBOWSTATE] = 1;
		if(Link->Item[I_ARROW2]){
			int i;
			int x; int y;
			int angle = Q7_DirAngle(l->Dir);
			if(l->Misc[LWM_RINGMODS]==9){
				lweapon sparkle;
				for(i=-1; i<=1; i+=2){
					x = l->X+l->HitXOffset+l->HitWidth/2-8+VectorX(i*8*Sin(l->Misc[LWM_ARROWFRAMES]*16), angle+90);
					y = l->Y+l->HitYOffset+l->HitHeight/2-8+VectorY(i*8*Sin(l->Misc[LWM_ARROWFRAMES]*16), angle+90);
					if(l->Dir>=2)
						y += 2;
					
					sparkle = CreateLWeaponAt(LW_SPARKLE, x, y);
					sparkle->UseSprite(SPR_SILVERSPARKLE);
					// sparkle->Angular = true;
					// sparkle->Angle = DegtoRad(Q7_DirAngle(l->Dir));
					// sparkle->Step = 100;
				}
			}
			
			if(l->Misc[LWM_ARROWFRAMES]==24){
				if(!Screen->isSolid(l->X+8, l->Y+8)&&l->Damage>=12){
					item rupee = CreateItemAt(I_RUPEE1, l->X, l->Y);
					rupee->Pickup = IP_TIMEOUT;
				}
			}
			l->Misc[LWM_ARROWFRAMES]++;
		}
	}
}

const int SPR_FLAMEPURPLE = 104;

void Candle3_Update(){
	if(PressButtonItem(I_CANDLE3)){
		if((Link->Action==LA_NONE||Link->Action==LA_WALKING)&&G[G_CANDLE3COREFIRES]<2&&Link->ItemJinx==0){
			Link->Action = LA_ATTACKING;
			Game->PlaySound(SFX_FIRE);
			
			itemdata ic = Game->LoadItemData(I_CANDLE3);
			
			lweapon fire = CreateLWeaponAt(LW_FIRE, Link->X+InFrontX(Link->Dir, 0), Link->Y+InFrontY(Link->Dir, 0));
			fire->UseSprite(12);
			fire->CSet = 10;
			fire->Step = 100;
			fire->Dir = Link->Dir;
			fire->Angular = false;
			fire->Damage = ic->Power*2;
		}
		Link->InputB = false;
		Link->PressB = false;
	}
}

void LWeapon_Candle3(lweapon l){
	if(l->ID==LW_FIRE){
		if(Link->Item[I_CANDLE3]){
			if(l->Misc[LWM_FIRETYPE]==0)
				++G[G_CANDLE3COREFIRES];
			G[G_NODARKENROOM] = 1;
			if(l->Misc[LWM_FIRETIME]!=-1){
				lweapon l2;
				if(l->Misc[LWM_FIRETYPE]==0){
					if(l->Misc[LWM_FIRETIME]==0){
						l->Step = 100;
						
						// l2 = Duplicate(l);
						// l2->UseSprite(SPR_FLAMEPURPLE);
						// l2->Misc[LWM_FIRETYPE] = 1;
						// l2->Misc[LWM_FIRETIME] = -32;
						// l2->Step = 100;
						
						l2 = Duplicate(l);
						l2->UseSprite(SPR_FLAMEPURPLE);
						l2->Misc[LWM_FIRETYPE] = 1;
						l2->Misc[LWM_FIRETIME] = -32;
						l2->Step = 50;
						
						l2 = Duplicate(l);
						l2->UseSprite(SPR_FLAMEPURPLE);
						l2->Misc[LWM_FIRETYPE] = 1;
						l2->Misc[LWM_FIRETIME] = -32;
						l2->Step = 0;
					}
					l->Misc[LWM_FIRETIME]++;
					if(l->Misc[LWM_FIRETIME]>=32){
						Game->PlaySound(SFX_FIRE);
						for(int i=0; i<4; i++){
							if(i!=OppositeDir(l->Dir)){
								l2 = Duplicate(l);
								l2->Dir = i;
								l2->UseSprite(SPR_FLAMEPURPLE);
								l2->Misc[LWM_FIRETYPE] = 1;
								l2->Misc[LWM_FIRETIME] = 1;
								l2->Step = 50;
								
								l2 = Duplicate(l);
								l2->Dir = i;
								l2->UseSprite(SPR_FLAMEPURPLE);
								l2->Misc[LWM_FIRETYPE] = 1;
								l2->Misc[LWM_FIRETIME] = 1;
								l2->Step = 100;
								
								// l2 = Duplicate(l);
								// l2->Dir = i;
								// l2->UseSprite(SPR_FLAMEPURPLE);
								// l2->Misc[LWM_FIRETYPE] = 1;
								// l2->Misc[LWM_FIRETIME] = 1;
								// l2->Step = 150;
							}
						}
						l->Misc[LWM_FIRETIME] = -1;
					}
				}
				else if(l->Misc[LWM_FIRETYPE]==1){
					l->Misc[LWM_FIRETIME]++;
					if(l->Misc[LWM_FIRETIME]>=63){
						l->DeadState = 0;
					}
				}
			}
			if(LinkCollision(l)){
				l->CollDetection = false;
			}
			else{
				l->CollDetection = true;
			}
		}
		if(l->Misc[LWM_FIRETYPE]){
			G[G_NODARKENROOM] = 1;
			if(LinkCollision(l)){
				l->CollDetection = false;
			}
			else{
				l->CollDetection = true;
			}
		}
	}
}

const int I_SHIELD4 = 163;

void LWeapon_Shield4(lweapon l){
	int i;
	if(Link->Item[I_SHIELD4]){
		lweapon l2;
		
		if(l->ID==LW_REFMAGIC){
			if(l->Misc[LWM_REFHASMULTIPLIED]==0){
				if(LinkCollision(l)){
					for(i=0; i<2; i++){
						l2 = Duplicate(l);
						l2->Step = 0.3333*(i+1)*l->Step;
						l2->CollDetection = false;
						l2->Misc[LWM_REFLINKCOLLISION] = 1;
						l2->Misc[LWM_REFHASMULTIPLIED] = 1;
						l2->Misc[LWM_ARTIFICIALPUSHTIME] = 16;
						l2->OriginalTile = l->OriginalTile;
						l2->Tile = l->OriginalTile;
						if(l2->Dir>=2)
							l2->Tile++;
						if(l2->Dir==DIR_DOWN)
							l2->Flip = 2;
						else if(l2->Dir==DIR_LEFT)
							l2->Flip = 1;
					}
				}
				l->Misc[LWM_REFHASMULTIPLIED] = 1;
			}
			if(l->Misc[LWM_REFLINKCOLLISION]){
				if(!LinkCollision(l)){
					l->CollDetection = true;
					l->Misc[LWM_REFLINKCOLLISION] = 0;
				}
			}
		}
		else if(l->ID==LW_REFFIREBALL){
			if(l->Misc[LWM_REFHASMULTIPLIED]==0){
				if(LinkCollision(l)){
					int angle = RadtoDeg(l->Angle);
					if(!l->Angular)
						angle = DirAngle(l->Dir);
					
					for(i=-1; i<=1; i+=2){
						l2 = Duplicate(l);
						l2->Angular = true;
						l2->Angle = DegtoRad(angle+i*30);
						l2->CollDetection = false;
						l2->Misc[LWM_REFLINKCOLLISION] = 1;
						l2->Misc[LWM_REFHASMULTIPLIED] = 1;
						l2->Misc[LWM_ARTIFICIALPUSHTIME] = 16;
					}
				}
				l->Misc[LWM_REFHASMULTIPLIED] = 1;
			}
		}
		else if(l->ID==LW_REFBEAM){
			if(l->Misc[LWM_REFHASMULTIPLIED]==0){
				if(LinkCollision(l)){
					for(i=-1; i<=1; i+=2){
						l2 = Duplicate(l);
						if(l->Dir<2){
							l2->X += 16*i;
						}
						else{
							l2->Y += 16*i;
						}
						l2->CollDetection = false;
						l2->Misc[LWM_REFLINKCOLLISION] = 1;
						l2->Misc[LWM_REFHASMULTIPLIED] = 1;
						l2->Misc[LWM_ARTIFICIALPUSHTIME] = 16;
						l2->OriginalTile = l->OriginalTile;
						l2->Tile = l->OriginalTile;
						if(l2->Dir>=2)
							l2->Tile++;
						if(l2->Dir==DIR_DOWN)
							l2->Flip = 2;
						else if(l2->Dir==DIR_LEFT)
							l2->Flip = 1;
					}
				}
				l->Misc[LWM_REFHASMULTIPLIED] = 1;
			}
			if(l->Misc[LWM_REFLINKCOLLISION]){
				if(!LinkCollision(l)){
					l->CollDetection = true;
					l->Misc[LWM_REFLINKCOLLISION] = 0;
				}
			}
		}
		else if(l->ID==LW_REFROCK){
			if(l->Misc[LWM_REFHASMULTIPLIED]==0){
				if(LinkCollision(l)){
					for(i=0; i<4; i++){
						if(i!=l->Dir&&i!=OppositeDir(l->Dir)){
							l2 = Duplicate(l);
							l2->Dir = i;
							l2->CollDetection = false;
							l2->Misc[LWM_REFLINKCOLLISION] = 1;
							l2->Misc[LWM_REFHASMULTIPLIED] = 1;
							l2->Misc[LWM_ARTIFICIALPUSHTIME] = 16;
						}
					}
				}
				l->Misc[LWM_REFHASMULTIPLIED] = 1;
			}
			if(l->Misc[LWM_REFLINKCOLLISION]){
				if(!LinkCollision(l)){
					l->CollDetection = true;
					l->Misc[LWM_REFLINKCOLLISION] = 0;
				}
			}
		}
	}
	if(true){
		if(l->Misc[LWM_REFLINKCOLLISION]){
			if(!LinkCollision(l)){
				l->CollDetection = true;
				if(l->Misc[LWM_REFLINKCOLLISION]==1)
					l->Misc[LWM_REFLINKCOLLISION] = 0;
			}
			else
				l->CollDetection = false;
		}
		if(l->Misc[LWM_ARTIFICIALPUSHTIME]>0){
			l->Misc[LWM_ARTIFICIALPUSHTIME]--;
			
			l->Misc[LWM_ARTIFICIALPUSHX] += VectorX(l->Step*0.01, RadtoDeg(l->Angle));
			l->Misc[LWM_ARTIFICIALPUSHY] += VectorY(l->Step*0.01, RadtoDeg(l->Angle));
		
			if(Abs(l->Misc[LWM_ARTIFICIALPUSHX])>=1){
				i = Floor(Abs(l->Misc[LWM_ARTIFICIALPUSHX]))*Sign(l->Misc[LWM_ARTIFICIALPUSHX]);
				l->X += i;
				l->Misc[LWM_ARTIFICIALPUSHX] -= i;
			}
			if(Abs(l->Misc[LWM_ARTIFICIALPUSHY])>=1){
				i = Floor(Abs(l->Misc[LWM_ARTIFICIALPUSHY]))*Sign(l->Misc[LWM_ARTIFICIALPUSHY]);
				l->Y += i;
				l->Misc[LWM_ARTIFICIALPUSHY] -= i;
			}
		}
	}
}

const int NPCM_HITFRAME = 7;
const int NPCM_PIERCEDAMAGE = 8;
const int NPCM_PIERCINGIFRAMES = 9;
const int NPCM_DAMAGECALCULATED = 10;
const int NPCM_STATUSCOUNTER = 11;
const int NPCM_STATUSTYPE = 12;
const int NPCM_LASTHP = 13;
const int NPCM_DIFFICULTYSET = 14;

const int NPCSTAT_POISON = 1;

void NPC_Update(int npcData){
	G[G_ENEMYCOUNT] = 0;
	G[G_OLDENEMYHPTOTAL] = G[G_ENEMYHPTOTAL];
	G[G_ENEMYHPTOTAL] = 0;
	lweapon sword = LoadLWeaponOf(LW_SWORD);
	for(int i=Screen->NumNPCs(); i>=1; i--){
		npc n = Screen->LoadNPC(i);
		NPC_Count(n);
		NPC_StatusEffects(n, npcData);
		DamageNumbers_UpdateEnemyDamage(n, sword, npcData);
		NPC_Gannon(n);
		NPC_Wallmaster(n);
		NPC_LikeLike(n);
		NPC_Difficulty(n, npcData, true);
		NPC_Damage(n);
		//NPC_Debug(n);
	}
}

void NPC_Count(npc n){
	if ( n->Type != NPCT_PROJECTILE ){
		if ( !(n->MiscFlags&NPCMF_NOT_BEATABLE) ){
			if ( n->Type != NPCT_FAIRY ){
				if ( n->Type != NPCT_GUY ){
					++G[G_ENEMYCOUNT];
					if(n->HP>0)
						++G[G_ENEMYHPTOTAL];
				}
			}
		}
	}
}

bool CanEscapeLikeLike(){
	bool hasSword;
	bool hasItem;
	if(GetSwordLevel()>0)
		hasSword = true;
	if(Link->Item[I_WAND]||Link->Item[I_WAND2]||(Link->Item[I_BOMB]&&Game->Counter[CR_BOMBS]>0))
		hasItem = true;
	if(Link->SwordJinx==-1)
		hasSword = false;
	if(Link->ItemJinx==-1)
		hasItem = false;
	if(!hasSword&&!hasItem)
		return false;
	return true;
}

void NPC_LikeLike(npc n){
	if(n->ID==NPC_LIKELIKE||n->ID==261){
		if(Link->X==n->X&&Link->Y==n->Y){
			if(!CanEscapeLikeLike()){
				n->HP = 0;
				n->ItemSet = 0;
			}
		}
	}
	if(n->ID==NPC_LIKELIKE){
		if(G[G_LIKELIKE_STOLENITEMFRAMES]>=59){
			if(Distance(Link->X, Link->Y, n->X, n->Y)<8){
				if(G[G_LIKELIKE_STOLENITEM]==I_SHIELD2)
					n->ItemSet = 100;
				else if(G[G_LIKELIKE_STOLENITEM]==I_SHIELD3)
					n->ItemSet = 101;
				else if(G[G_LIKELIKE_STOLENITEM]==I_SHIELD4)
					n->ItemSet = 102;
				else if(G[G_LIKELIKE_STOLENITEM]==I_RING1)
					n->ItemSet = 103;
				else if(G[G_LIKELIKE_STOLENITEM]==I_RING2)
					n->ItemSet = 104;
			}
		}
		else if(G[G_LIKELIKE_STOLENITEMFRAMES]<=0){
			G[G_LIKELIKE_STOLENITEM] = 0;
			n->ItemSet = 0;
		}
	}
}

const int NSTAT_POISON = 1;
const int NSTAT_SLOW = 2;
const int NSTAT_PLAGUE = 3;
const int NSTAT_PLAGUETICK = 4;
const int NSTAT_BURN = 5;

void NPC_DirectDamage(npc n, int damage){
	n->Misc[NPCM_PIERCEDAMAGE] += damage;
}

void NPC_StatusEffects(npc n, int npcData){
	if(n->Misc[NPCM_PIERCEDAMAGE]){
		SetEnemyProperty(n, ENPROP_HP, n->HP-n->Misc[NPCM_PIERCEDAMAGE]);
		n->Misc[NPCM_PIERCEDAMAGE] = 0;
	}
	if(n->Misc[NPCM_STATUSTYPE]>0){
		if(n->Misc[NPCM_STATUSTYPE]==NSTAT_POISON){ //Poison
			if(n->Misc[NPCM_STATUSCOUNTER]){
				--n->Misc[NPCM_STATUSCOUNTER];
				if(n->Misc[NPCM_STATUSCOUNTER]%60==0){
					Game->PlaySound(SFX_EHIT);
					SetEnemyProperty(n, ENPROP_HP, n->HP-2*G[G_HPSCALE]);
					if(GetEnemyProperty(n, ENPROP_HP)<=0){
						if(NPC_NoHPLower(n, npcData)){
							SetEnemyProperty(n, ENPROP_HP, 1);
						}
					}
				}
			}
			else{
				n->Misc[NPCM_STATUSTYPE] = 0;
			}
		}
		else if(n->Misc[NPCM_STATUSTYPE]==NSTAT_SLOW){ //Slow
			if(n->Misc[NPCM_STATUSCOUNTER]){
				--n->Misc[NPCM_STATUSCOUNTER];
				if(n->Misc[NPCM_STATUSCOUNTER]%3!=0&&n->Stun==0){
					n->Stun = 1;
				}
			}
			else{
				n->Misc[NPCM_STATUSTYPE] = 0;
			}
		}
		else if(n->Misc[NPCM_STATUSTYPE]==NSTAT_PLAGUE){ //Plague
			if(n->Misc[NPCM_STATUSCOUNTER]){
				--n->Misc[NPCM_STATUSCOUNTER];
			}
			else{
				int args[8];
				args[0] = CenterX(n);
				args[1] = CenterY(n);
				RunFFCScript(FFCS_GASBALL, args);
				n->Misc[NPCM_STATUSTYPE] = 0;
			}
		}
		else if(n->Misc[NPCM_STATUSTYPE]==NSTAT_PLAGUETICK){ //Plague Tick
			if(n->Misc[NPCM_STATUSCOUNTER]){
				--n->Misc[NPCM_STATUSCOUNTER];
				if(n->Misc[NPCM_STATUSCOUNTER]%8==0&&n->Misc[NPCM_STATUSCOUNTER]>=20){
					Game->PlaySound(SFX_EHIT);
					SetEnemyProperty(n, ENPROP_HP, n->HP-2*G[G_HPSCALE]);
					if(GetEnemyProperty(n, ENPROP_HP)<=0){
						if(NPC_NoHPLower(n, npcData)){
							SetEnemyProperty(n, ENPROP_HP, 1);
						}
					}
				}
			}
			else{
				n->Misc[NPCM_STATUSTYPE] = 0;
			}
		}
		else if(n->Misc[NPCM_STATUSTYPE]==NSTAT_BURN){ //Burn
			if(n->Misc[NPCM_STATUSCOUNTER]){
				--n->Misc[NPCM_STATUSCOUNTER];
				Screen->FastCombo(3, CenterX(n)-8, CenterY(n)-8, 698, 8, 64);
				if(n->Misc[NPCM_STATUSCOUNTER]%4==0){
					Game->PlaySound(SFX_EHIT);
					SetEnemyProperty(n, ENPROP_HP, n->HP-0.2*G[G_HPSCALE]);
					if(GetEnemyProperty(n, ENPROP_HP)<=0){
						if(NPC_NoHPLower(n, npcData)){
							SetEnemyProperty(n, ENPROP_HP, 1);
						}
					}
				}
			}
			else{
				n->Misc[NPCM_STATUSTYPE] = 0;
			}
		}
	}
}

void NPC_Debug(npc n){
	Screen->DrawInteger(6, n->X, n->Y, FONT_Z1, 0x01, 0x0F, -1, -1, n->ID, 0, 128);
}

void NPC_Gannon(npc n){
	if(n->ID==NPC_GANON){
		G[G_GANNONX] = n->X+16;
		G[G_GANNONY] = n->Y+16;
	}
}

void NPC_Wallmaster(npc n){
	if(n->Type==NPCT_WALLMASTER){
		if(Q7_HasRing(I_SPRING19_WALLMASTER)){
			if(LinkCollision(n)){
				n->HP = 0;
				n->Misc[NPCM_LASTHP] = 0;
			}
		}
	}
}

int NoZeroDamage(int damage){
	int minDamage = 1;
	
	if(Link->Item[I_RING2])
		minDamage *= 4;
	else if(Link->Item[I_RING1])
		minDamage *= 2;
	
	if(Link->Item[I_DIV_VERYEASY])
		minDamage *= 4;
	else if(Link->Item[I_DIV_EASY])
		minDamage *= 3;
	else if(Link->Item[I_DIV_NORMAL])
		minDamage *= 2;
	
	if(damage*4<minDamage){
		damage = Ceiling(minDamage*0.25);
	}
	
	return damage;
}

void NJFMode_IncreaseBossHP(npc n){
	if(Q7_CheatEnabled(G_MODE_NJFHP)){
		n->HP *= 4;
		Ghost_HP = n->HP;
	}
}

bool NPC_NoHPLower(npc n, int npcData){
	int npc_NoHPLower = npcData[2];
	int npct_NoHPLower = npcData[3];
	return npc_NoHPLower[n->ID]||npct_NoHPLower[n->Type];
}
bool NPC_NoClone(npc n, int npcData){
	int npc_NoClone = npcData[0];
	int npct_NoClone = npcData[1];
	return npc_NoClone[n->ID]||npct_NoClone[n->Type];
}

bool NPC_NoSpeedChange(npc n, int npcData){
	int npc_NoSpeedChange = npcData[4];
	int npct_NoSpeedChange = npcData[5];
	return npc_NoSpeedChange[n->ID]||npct_NoSpeedChange[n->Type];
}

void NPC_Difficulty(npc n, int npcData, bool isGlobal){
	if(n->Misc[NPCM_DIFFICULTYSET]==0){
		if(n->Type!=NPCT_ZORA&&n->HP<1000)
			SetEnemyProperty(n, ENPROP_HP, n->HP*G[G_HPSCALE]);
		if(n->ID==NPC_KEESE1||n->ID==NPC_KEESE2||n->ID==NPC_KEESE3||n->ID==NPC_KEESETRIB)
			n->HP = 1;
		bool alreadyCloned;
		if(IsVeryHardMode()){
			if(!NPC_NoSpeedChange(n, npcData))
				n->Step *= 1.25;
		}
		if(Link->Item[I_DIFF_REALLYJOEL]){
			n->Damage = 9999;
			n->WeaponDamage = 9999;
			if(!NPC_NoHPLower(n, npcData))
				n->HP = Max(n->HP*1.5, 1);
			
			if(!NPC_NoClone(n, npcData)&&isGlobal){
				npc n2 = CreateNPCAt(n->ID, n->X, n->Y);
				NPC_Difficulty(n2, npcData, false);
				alreadyCloned = true;
			}
		}
		else if(Link->Item[I_DIFF_VERYEASY]){
			if(!NPC_NoHPLower(n, npcData))
				SetEnemyProperty(n, ENPROP_HP, Max(n->HP*0.5, 1));
		}
		else if(Link->Item[I_DIFF_EASY]){
			if(!NPC_NoHPLower(n, npcData))
				SetEnemyProperty(n, ENPROP_HP, Max(n->HP*0.75, 1));
		}
		
		if(Q7_HasRing(I_SPRING2_JACK)){
			if(!NPC_NoHPLower(n, npcData)){
				if(n->Defense[NPCD_FIRE]==NPCDT_BLOCK||n->Defense[NPCD_FIRE]==NPCDT_IGNORE)
					n->Defense[NPCD_FIRE] = NPCDT_QUARTERDAMAGE;
				else if(n->Defense[NPCD_FIRE]==NPCDT_QUARTERDAMAGE)
					n->Defense[NPCD_FIRE] = NPCDT_HALFDAMAGE;
				else if(n->Defense[NPCD_FIRE]==NPCDT_HALFDAMAGE)
					n->Defense[NPCD_FIRE] = NPCDT_NONE;
			}
		}
		if(Q7_HasRing(I_SPRING10_HOLM)){
			if(!NPC_NoHPLower(n, npcData)){
				if(n->Defense[NPCD_REFMAGIC]==NPCDT_BLOCK||n->Defense[NPCD_REFMAGIC]==NPCDT_IGNORE)
					n->Defense[NPCD_REFMAGIC] = NPCDT_QUARTERDAMAGE;
				else if(n->Defense[NPCD_REFMAGIC]==NPCDT_QUARTERDAMAGE)
					n->Defense[NPCD_REFMAGIC] = NPCDT_HALFDAMAGE;
				else if(n->Defense[NPCD_REFMAGIC]==NPCDT_HALFDAMAGE)
					n->Defense[NPCD_REFMAGIC] = NPCDT_NONE;
			}
		}
		
		if(Q7_HasRing(I_SPRING23_HEART)){
			if(n->ItemSet)
				n->ItemSet = 4;
		}
		if(Q7_HasRing(I_SPRING24_BOMB)){
			if(n->ItemSet&&n->ItemSet!=5){
				if(n->ItemSet==2)
					n->ItemSet = 5;
				else
					n->ItemSet = 2;
			}
		}
		if(Q7_HasRing(I_SPRING25_WILLARD)){
			n->BreakShield();
		}
		
		if(G[G_ALTCHARACTER]&&(n->ID==NPC_DODONGO||n->ID==283)){
			n->ItemSet = 5;
			n->HP = 4;
		}
		
		if(Q7_CheatEnabled(G_MODE_HYRULEWARRIORS)){
			for(int i=0; i<3; i++){
				if(!NPC_NoClone(n, npcData)&&isGlobal){
					npc n2 = CreateNPCAt(n->ID, n->X, n->Y);
					NPC_Difficulty(n2, npcData, false);
					alreadyCloned = true;
				}
			}
		}
		
		if(Q7_CheatEnabled(G_MODE_NJFHP)){
			if(!NPC_NoHPLower(n, npcData))
				n->HP = Max(n->HP*4, 1);
		}
		
		if(n->Type==NPCT_PROJECTILE||n->Type==NPCT_TRAP){
			n->Damage = PiercingDamage(n->Damage);
			n->WeaponDamage = PiercingDamage(n->WeaponDamage);
		}
		
		if(n->ID!=82&&n->ID!=119){
			n->Damage = NoZeroDamage(n->Damage);
			n->WeaponDamage = NoZeroDamage(n->WeaponDamage);
		}
		
		if(Q7_HasRing(I_SPRING30_CALAMITY)){
			if(!alreadyCloned){
				if(!NPC_NoClone(n, npcData)&&isGlobal){
					npc n2 = CreateNPCAt(n->ID, n->X, n->Y);
					NPC_Difficulty(n2, npcData, false);
					alreadyCloned = true;
				}
			}
			
			if(!NPC_NoSpeedChange(n, npcData))
				n->Step *= 1.5;
		}
		
		n->Misc[NPCM_LASTHP] = n->HP;
		n->Misc[NPCM_DIFFICULTYSET] = 1;
	}
}

void NPC_Damage(npc n){
	if(n->HP!=n->Misc[NPCM_LASTHP]){
		n->Misc[NPCM_LASTHP] = n->HP;
	}
	if(n->Misc[NPCM_PIERCINGIFRAMES])
		--n->Misc[NPCM_PIERCINGIFRAMES];
}

const int ITM_REMOTEPICKUP = 15;

void Item_Update(){
	for(int i=Screen->NumItems(); i>0; --i){
		item itm = Screen->LoadItem(i);
		if(itm->Misc[ITM_REMOTEPICKUP]){
			itm->X = Link->X;
			itm->Y = Link->Y;
			itm->DrawYOffset = -1000;
		}
		Item_RupporMagnet(itm);
	}
}

void Item_RupporMagnet(item itm){
	if(G[G_MODE_RUPOORGARBAGE]){
		if(itm->ID==39||itm->ID==70||itm->ID==71||itm->ID==72){
			if(G[G_ANIM]%4==0){
				if(itm->X<Link->X)
					++itm->X;
				else if(itm->X>Link->X)
					--itm->X;
				if(itm->Y<Link->Y)
					++itm->Y;
				else if(itm->Y>Link->Y)
					--itm->Y;
			}
		}
	}
}

const int I_FLIPPERS2 = 165;
const int CMB_FLIPPERS2_OVERLAY = 399;

const int CT_WASWATER = 144; //Script 3

void Flippers2_Update(){
	if(Link->Action==LA_SCROLLING)
		return;
	
	// if(Screen->ComboT[ComboAt(Link->X+8, Link->Y+12)]==CT_WASWATER){
		// Screen->FastCombo(4, Link->X+Link->DrawXOffset, Link->Y+Link->DrawYOffset, CMB_FLIPPERS2_OVERLAY, 7, 128);
	// }
}

void Combo_Update(){
	int diff;
	if(Link->Item[I_DIFF_REALLYJOEL])
		diff = 5;
	else if(Link->Item[I_DIFF_VERYHARD])
		diff = 4;
	else if(Link->Item[I_DIFF_HARD])
		diff = 3;
	else if(Link->Item[I_DIFF_NORMAL])
		diff = 2;
	else if(Link->Item[I_DIFF_EASY])
		diff = 1;
	else if(Link->Item[I_DIFF_VERYEASY])
		diff = 0;
	for(int i=0; i<176; i++){
		Combo_Difficulty(i, diff);
		Combo_Conveyors(i);
		Combo_Flippers2(i);
	}
}

const int D_EASYMODESHUTTERS = 7;

const int I_SCRIPTBOOTS = 172;

void Boots_PlayTone(int which){
	int bootsSFX[13];
	bootsSFX[0] = SFX_BOOTSBREAK;
	bootsSFX[1] = SFX_BOOTSSCALE+10;
	bootsSFX[2] = SFX_BOOTSSCALE+9;
	bootsSFX[3] = SFX_BOOTSSCALE+8;
	bootsSFX[4] = SFX_BOOTSSCALE+7;
	bootsSFX[5] = SFX_BOOTSSCALE+6;
	bootsSFX[6] = SFX_BOOTSSCALE+5;
	bootsSFX[7] = SFX_BOOTSSCALE+4;
	bootsSFX[8] = SFX_BOOTSSCALE+3;
	bootsSFX[9] = SFX_BOOTSSCALE+2;
	bootsSFX[10] = SFX_BOOTSSCALE+1;
	bootsSFX[11] = SFX_BOOTSSCALE+0;
	
	which = Clamp(which, 0, 11);
	Game->PlaySound(bootsSFX[which]);
}

void Boots_Recharge(){
	if(Link->Item[I_SCRIPTBOOTS])
		G[G_BOOTSLIFE] = 12;
	else
		G[G_BOOTSLIFE] = 0;
	G[G_BOOTSONDAMAGE] = 0;
	G[G_BOOTSTIMER] = 0;
}

void Boots_TakeDamage(){
	G[G_BOOTSLIFE] = Max(G[G_BOOTSLIFE]-1, 0);
	Boots_PlayTone(G[G_BOOTSLIFE]);
	if(G[G_BOOTSLIFE]==0){
		for(int i=0; i<10; i++){
			lweapon l = SparkleSpriteAnim(Link->X, Link->Y, SPR_BOOTSBREAK, 1, 1, Rand(360), Rand(200, 300));
			l->ASpeed = Rand(3, 6);
		}
	}
	G[G_BOOTSTIMER] = 0;
}

void Boots_Update(){
	if(Link->Action==LA_SCROLLING)
		return;
	
	if(Link->Item[I_SCRIPTBOOTS]){
		G[G_BOOTSONDAMAGE] = 0;
		int pos = ComboAt(Link->X+8, Link->Y+12);
		int ct = Screen->ComboT[pos];
		if(ct==CT_DAMAGE1||ct==CT_DAMAGE2){
			G[G_BOOTSONDAMAGE] = 1;
		}
		
		if(G[G_BOOTSONDAMAGE]){
			G[G_BOOTSTIMER]++;
			
			if(G[G_BOOTSTIMER]>10){
				if(G[G_BOOTSLIFE]>0){
					Boots_TakeDamage();
				}
				G[G_BOOTSTIMER] = 0;
			}
		}
		else
			G[G_BOOTSTIMER] = 0;
		
		if(G[G_BOOTSLIFE]>0){
			if(!Link->Item[I_BOOTS])
				Link->Item[I_BOOTS] = true;
		}
		else{
			if(Link->Item[I_BOOTS])
				Link->Item[I_BOOTS] = false;
		}
	}
}

void EasyModeShutters_Update(){
	if(Link->Item[I_DIFF_EASY]||Link->Item[I_DIFF_VERYEASY]||Q7_CheatEnabled(G_MODE_EASYNAVIGATION)){
		if(Game->GetCurLevel()>0&&Game->GetCurLevel()<9){
			for(int i=0; i<4; i++){
				if(Screen->Door[i]==D_OPENSHUTTER)
					Screen->D[D_EASYMODESHUTTERS] |= (1<<i);
				else if(Screen->D[D_EASYMODESHUTTERS]&(1<<i))
					Screen->Door[i] = D_OPENSHUTTER;
			}
		}
	}
}

void Combo_Difficulty(int i, int diff){
	if(diff<2){
		if(Screen->ComboT[i]==CT_PUSHWAIT){
			Screen->ComboT[i] = CT_NONE;
		}
		if(Screen->ComboT[i]==CT_DAMAGE2){
			Screen->ComboT[i] = CT_DAMAGE1;
		}
	}
	else if(Q7_CheatEnabled(G_MODE_EASYNAVIGATION)){
		if(Screen->ComboT[i]==CT_PUSHWAIT){
			Screen->ComboT[i] = CT_NONE;
		}
	}
}

void Combo_Conveyors(int i){
	int ct = Screen->ComboT[i];
	if(ct==CT_CVUP||ct==CT_CVDOWN||ct==CT_CVLEFT||ct==CT_CVRIGHT){
		if(Link->Item[I_SCRIPTBOOTS]){
			int cd = Screen->ComboD[i];
			bool conveyorCombos[65535];
			
			conveyorCombos[404] = true;
			conveyorCombos[405] = true;
			conveyorCombos[406] = true;
			conveyorCombos[407] = true;
			
			if(!conveyorCombos[cd])
				Screen->ComboT[i] = 0;
		}
	}
}

void Combo_Flippers2(int i){
	if(Link->Item[I_FLIPPERS2]){
		//Screen->DrawInteger(6, ComboX(i), ComboY(i), FONT_Z3SMALL, 0x01, 0x0F, -1, -1, Screen->ComboT[i], 0, 64);
		if(Screen->ComboT[i]==CT_WATER){
			Screen->ComboT[i] = CT_SHALLOWWATER; //CT_WASWATER;
			if(Screen->ComboI[i]==0)
				Screen->ComboI[i] = CF_NOGROUNDENEMY;
			Screen->ComboS[i] = 0;
		}
	}
}

void Global_Init(){
	int i;
	
	G[G_HPSCALE] = 1;
	if(G[G_MODE_ALTCHARACTER])
		G[G_HPSCALE] = 10;
	ItemDataDamage_Init();
	G[G_TEMPDAMAGEMULTIPLIER] = 1;
	G[G_REALDAMAGEMULTIPLIER] = 1;
	G[G_LASTOVERWORLDSCREEN] = Game->GetCurScreen();
	G[G_LASTOVERWORLDDMAP] = Game->GetCurDMap();
	G[G_LASTX] = Link->X;
	G[G_LASTY] = Link->Y;
	G[G_LASTDMAP] = Game->GetCurDMap();
	G[G_LASTSCREEN] = Game->GetCurDMapScreen();
	G[G_LASTEXITDIR] = -1;
	G[G_LASTHP] = Link->HP;
	G[G_DARMLIGHTNINGCOOLDOWN] = 300;
	G[G_AUTOBOWSTATE] = 0;
	G[G_AUTOBOWTIMER] = 0;
	G[G_FROZEN] = 0;
	G[G_RANDOMENUOPEN] = 0;
	G[G_ZARATH_MULTIPLIER] = 0;
	G[G_ZARATH_TIMER] = 0;
	G[G_ZARATH_FILL] = 0;
	G[G_ZARATH_SAFETYFRAMES] = 0;
	G[G_BLUETEARHEAL] = 0;
	G[G_INVISTIMER] = 0;
	G[G_NOCOLLTIMER] = 0;
	G[G_SIGCOOLDOWN] = 0;
	G[G_SIGCOOLDOWNMAX] = 0;
	G[G_UTILITYCOOLDOWN] = 0;
	G[G_UTILITYCOOLDOWNMAX] = 0;
	G[G_IGNORESIGCOOLDOWN] = 0;
	if(G[G_ALTCHARACTER]!=CHAR_NORA)
		G[G_PRESERVEDCHARGEA] = 0;
	G[G_PRESERVEDCHARGEB] = 0;
	G[G_NODRAWSUBSCREEN] = 0;
	G[G_MANISTARFALLCHARGE] = 0;
	G[G_ENEMYCOUNT] = 0;
	G[G_ENEMYHPTOTAL] = -1;
	G[G_FROGGER_SHIELDFLAGS] = 0;
	G[G_FROGGER_BLACKHOLETIMER] = 0;
	G[G_FROGGER_SHIELDCOOLDOWN] = 0;
	if(Q7_CheatEnabled(G_MODE_BLEEDINGWALLET)){
		if(G[G_LINKRUPEEDRAINCOOLDOWN]==-1){
			Game->Counter[CR_RUPEES] = 50;
			G[G_LASTRUPEECOUNT] = 50;
			G[G_LINKRUPEEDRAINCOOLDOWN] = 0;
		}
	}
	
	AltCharacter_UpdateSwordLevels(0);
	AltCharacter_ScreenChange();
	ResetScreenTrack();
	
	if(!G[G_FIRSTLOAD]){
		G[G_REMAININGLADDERS] = 2;
		
		G[G_FIRSTLOAD] = 1;
	}
	
	if(false){//G[G_REALLYJOELCLEARALL]==-1){
		Game->NumDeaths = 0;
		
		G[G_REALLYJOELCLEARALL] = 1;
		for(i=0; i<256; i++){
			Link->Item[i] = false;
		}
		Link->Item[I_DIFF_REALLYJOEL] = true;
		
		for(i=0; i<=9; i++){
			Game->LItems[i] = 0;
		}
		
		for(i=0; i<0x7F; i++){
			Game->GuyCount[i] = 10;
		}
		
		Game->Counter[CR_RUPEES] = 0;
		Game->Counter[CR_KEYS] = 0;
		Game->Counter[CR_BOMBS] = 0;
		Game->MCounter[CR_BOMBS] = 8;
	}
}

void ItemDataDamage_Init(){
	SetItemDataDamage(I_SWORD1, 1*G[G_HPSCALE]);
	SetItemDataDamage(I_SWORD2, 2*G[G_HPSCALE]);
	SetItemDataDamage(I_SWORD3, 4*G[G_HPSCALE]);
	SetItemDataDamage(I_SWORD4, 4*G[G_HPSCALE]);
	if(G[G_MODE_FORCESLASH])
		SetItemDataDamage(I_SWORD4, 6*G[G_HPSCALE]);
	
	SetItemDataDamage(I_CRIT1, 1*G[G_HPSCALE]);
	SetItemDataDamage(I_CRIT2, 1*G[G_HPSCALE]);
	SetItemDataDamage(I_CRIT3, 1*G[G_HPSCALE]);
	SetItemDataDamage(I_CRIT4, 1*G[G_HPSCALE]);
	
	SetItemDataDamage(I_BRANG3, 1*G[G_HPSCALE]);
	
	SetItemDataDamage(I_BOMB, 4*G[G_HPSCALE]);
	
	SetItemDataDamage(I_ARROW1, 3*G[G_HPSCALE]);
	SetItemDataDamage(I_ARROW2, 6*G[G_HPSCALE]);
	
	SetItemDataDamage(I_CANDLE1, 1*G[G_HPSCALE]);
	SetItemDataDamage(I_CANDLE2, 4*G[G_HPSCALE]);
	SetItemDataDamage(I_CANDLE3, 6*G[G_HPSCALE]);
	
	SetItemDataDamage(I_WAND, 2*G[G_HPSCALE]);
	SetItemDataDamage(I_WAND2, 3*G[G_HPSCALE]);
}

void SetItemDataDamage(int id, int damage){
	itemdata itemdat = Game->LoadItemData(id);
	itemdat->Power = damage;
}

const int SF_NORAIN = 4;

void OWRain_Update(){
	int i;
	
	if((Game->GetCurDMap()==22||Game->GetCurDMap()==24||Game->GetCurDMap()==16||Game->GetCurDMap()==37||Game->GetCurDMap()==68)&&Game->GetCurScreen()<0x80){
		
		int rainEffect[] = "RainEffect";
		int rainEffectSlot = Game->GetFFCScript(rainEffect);
		if(!ScreenFlag(SF_MISC, SF_NORAIN)){
			if(CountFFCsRunning(rainEffectSlot)==0){
				bool doSound = true;
				if(Game->GetCurDMap()==37){
					doSound = false;
					for(i=0; i<176; i++){
						if(Screen->ComboT[i]==CT_LADDERHOOKSHOT)
							doSound = true;
					}
				}
				RunFFCScript(Game->GetFFCScript(rainEffect), 0);
				if(doSound)
					npc rainsfx = CreateNPCAt(NPC_RAINSFX, -16, 120);
			}
		}
	}
	
	if(IsRaining()){
		if(Link->Item[I_WHISTLE]){
			if(!Link->Item[178])
				Link->Item[178] = true;
		}
		for(int i=0; i<4; i++){
			if(Screen->GetSideWarpDMap(i)==0){
				Screen->SetSideWarp(i, Screen->GetSideWarpScreen(i), 22, Screen->GetSideWarpType(i));
			}
			if(Screen->GetTileWarpDMap(i)==0){
				Screen->SetTileWarp(i, Screen->GetTileWarpScreen(i), 22, Screen->GetTileWarpType(i));
			}
			if(Screen->GetSideWarpDMap(i)==23){
				Screen->SetSideWarp(i, Screen->GetSideWarpScreen(i), 24, Screen->GetSideWarpType(i));
			}
			if(Screen->GetTileWarpDMap(i)==15){
				Screen->SetTileWarp(i, Screen->GetTileWarpScreen(i), 16, Screen->GetTileWarpType(i));
			}
			if(Screen->GetTileWarpDMap(i)==7){
				Screen->SetTileWarp(i, Screen->GetTileWarpScreen(i), 37, Screen->GetTileWarpType(i));
			}
			if(Screen->GetTileWarpDMap(i)==66){
				Screen->SetTileWarp(i, Screen->GetTileWarpScreen(i), 68, Screen->GetTileWarpType(i));
			}
		}
	}
	else{
		if(Link->Item[I_WHISTLE]){
			if(Link->Item[178])
				Link->Item[178] = false;
		}
	}
}

bool IsRaining(){
	bool isRaining = NumTriforcePieces()>=8;
	if(Q7_HasRing(I_SPRING26_RAINY))
		isRaining = !isRaining;
	return isRaining;
}

const int SF_COMPASSBEEP = 3;

const int SFX_COMPASSBEEP = 62;

void OnScreenChange(){
	if(G[G_LASTDMAP]!=Game->GetCurDMap()||G[G_LASTSCREEN]!=Game->GetCurDMapScreen()){
		bool newScreen = UpdateScreenTrack();
		if(G[G_ALTCHARACTER]==CHAR_MANI){
			if(newScreen)
				ManiStarfallIncrement();
		}
		G[G_ENEMYCOUNT] = 0;
		G[G_ENEMYHPTOTAL] = -1;
		if(Game->GetCurDMap()==0||Game->GetCurDMap()==22||Game->GetCurDMap()==200){
			G[G_LASTOVERWORLDSCREEN] = Game->GetCurScreen();
			G[G_LASTOVERWORLDDMAP] = Game->GetCurDMap();
		}
		DoorGlitch();
		AltCharacter_ScreenChange();
		//ShopReplacements();
		SetDungeonsVisited();
		Boots_Recharge();
		FreeformDoorwayAutoWalk();
		G[G_LASTDMAP] = Game->GetCurDMap();
		G[G_LASTSCREEN] = Game->GetCurDMapScreen();
		G[G_WAITSCROLL] = 10;
	}
	G[G_LASTX] = Link->X;
	G[G_LASTY] = Link->Y;
	if(G[G_WAITSCROLL]>=2){
		if(Link->Action!=LA_SCROLLING)
			G[G_WAITSCROLL]--;
	}
	else if(G[G_WAITSCROLL]==1){
		if(Game->GetCurLevel()>0){
			if(GetLevelItem(LI_COMPASS)){
				if(ScreenFlag(SF_MISC, SF_COMPASSBEEP)){
					if(!Screen->State[ST_ITEM]&&!Screen->State[ST_SPECIALITEM]){
						Game->PlaySound(SFX_COMPASSBEEP);
					}
				}
			}
		}
		if(Q7_HasRing(I_SPRING7_NAIYA)){
			RunFFCScript(FFCS_BUBBLESHIELD, 0);
		}
		G[G_WAITSCROLL] = 0;
	}
}

void ResetScreenTrack(){
	for(int i=0; i<6; ++i){
		G[G_LASTMAPSCRN1+i] = 0;
	}
}
bool UpdateScreenTrack(){
	if(Game->GetCurScreen()>0x7F)
		return false;
	for(int i=0; i<6; ++i){
		int map = G[G_LASTMAPSCRN1+i]&0xFF;
		int scrn = (G[G_LASTMAPSCRN1+i]>>8)&0xFF;
		if(map==Game->GetCurMap()&&scrn==Game->GetCurScreen())
			return false;
	}
	for(int i=5; i>0; --i){
		G[G_LASTMAPSCRN1+i] = G[G_LASTMAPSCRN1+i-1];
	}
	G[G_LASTMAPSCRN1] = Game->GetCurMap();
	G[G_LASTMAPSCRN1] |= Game->GetCurScreen()<<8;
	return true;
}

void SetDungeonsVisited(){
	if(Game->GetCurLevel()>0&&Game->GetCurLevel()<=10){
		G[G_SEEN_L1+Game->GetCurLevel()-1] = 1;
	}
}

void FreeformDoorwayAutoWalk(){
	int ct = Screen->ComboT[ComboAt(Link->X+8, Link->Y+12)];
	
	if(Game->GetCurLevel()>8){
		if(ct==CT_OVERHEAD){
			int autoWalk[] = "DungeonAutoWalk";
			RunFFCScript(Game->GetFFCScript(autoWalk), 0);
			NoAction();
		}
	}
}

// void ShopReplacements(){
	// if(Screen->RoomType==RT_SHOP){
		// if(Screen->RoomData==0){ //Shield
			// if(Link->Item[I_SHIELD4STOLEN]){
				// if(!Link->Item[I_SHIELD4]){
					// Screen->SetTileWarp(0, 0x08, 20, WT_IWARPBLACKOUT);
				// }
			// }
			// else if(Link->Item[I_SHIELD3STOLEN]){
				// if(!Link->Item[I_SHIELD3]){
					// Screen->SetTileWarp(0, 0x06, 20, WT_IWARPBLACKOUT);
				// }
			// }
		// }
		// else if(Screen->RoomData==3){
			// if(Link->Item[I_RING2STOLEN]){
				// if(!Link->Item[I_RING2]){
					// Screen->SetTileWarp(0, 0x07, 20, WT_IWARPBLACKOUT);
				// }
			// }
		// }
	// }
// }

void DoorGlitch(){
	if(Game->GetCurScreen()>0x7F){
		G[G_LASTEXITDIR] = -1;
		return;
	}
	if(G[G_LASTX]<=0||G[G_LASTX]>=240||G[G_LASTY]<=0||G[G_LASTY]>=160){
		if(G[G_LASTY]<=0)
			G[G_LASTEXITDIR] = DIR_UP;
		else if(G[G_LASTY]>=160)
			G[G_LASTEXITDIR] = DIR_DOWN;
		else if(G[G_LASTX]<=0)
			G[G_LASTEXITDIR] = DIR_LEFT;
		else if(G[G_LASTX]>=240)
			G[G_LASTEXITDIR] = DIR_RIGHT;
	}
	if(G[G_LASTSCREEN]>0x7F)
		return;
	if(G[G_LASTEXITDIR]>-1){
		int od = OppositeDir(G[G_LASTEXITDIR]);
		if(!Screen->State[od]&&ScreenFlag(SF_MISC, SF_DOORGLITCH)){
			Screen->State[od] = true;
			if(Screen->Door[od]==D_LOCKED)
				Screen->Door[od] = D_UNLOCKED;
			else if(Screen->Door[od]==D_BOMB)
				Screen->Door[od] = D_BOMBED;
		}
	}
	//Game->Counter[CR_BOMBS] = G[G_LASTEXITDIR];
}

ffc script TriforceChangeWarp{
	void run(){
		if(NumTriforcePieces()>=7){
			for(int i=0; i<4; i++){
				if(Screen->GetSideWarpDMap(i)==0){
					Screen->SetSideWarp(i, Screen->GetSideWarpScreen(i), 22, Screen->GetSideWarpType(i));
				}
				if(Screen->GetTileWarpDMap(i)==0){
					Screen->SetTileWarp(i, Screen->GetTileWarpScreen(i), 22, Screen->GetTileWarpType(i));
				}
			}
		}
	}
}

const int I_DIFF_VERYEASY = 144;
const int I_DIFF_EASY = 145;
const int I_DIFF_NORMAL = 146;
const int I_DIFF_HARD = 147;
const int I_DIFF_VERYHARD = 148;
const int I_DIFF_REALLYJOEL = 149;

const int I_DIV_NORMAL = 150;
const int I_DIV_EASY = 151;
const int I_DIV_VERYEASY = 152;

const int CR_JOELMULTIPLIER = 7;

const int I_SWORD1S = 159;
const int I_SWORD2S = 160;
const int I_SWORD3S = 161;

void EnableSlash(){
	if(Link->Item[I_SWORD3]){
		if(!Link->Item[I_SWORD3S])
			Link->Item[I_SWORD3S] = true;
	}
	else if(Link->Item[I_SWORD2]){
		if(!Link->Item[I_SWORD2S])
			Link->Item[I_SWORD2S] = true;
	}
	else if(Link->Item[I_SWORD1]){
		if(!Link->Item[I_SWORD1S])
			Link->Item[I_SWORD1S] = true;
	}
}

void Difficulty_Init(){
	if(IsEasyMode()&&!G[G_ALTCHARACTER]){
		itemdata masterSword = Game->LoadItemData(I_SWORD4);
		
		masterSword->Power = 5*G[G_HPSCALE];
	}
}

void Difficulty_Update(){
	int i; int j;
	
	bool showBombWalls;
	
	if(Q7_CheatEnabled(G_MODE_EASYNAVIGATION))
		showBombWalls = true;
	
	if(Q7_CheatEnabled(G_MODE_FORCESLASH))
		EnableSlash();
	
	if(Link->Item[I_DIFF_NORMAL]){
		if(!Link->Item[I_DIV_NORMAL])
			Link->Item[I_DIV_NORMAL] = true;
		if(Link->Item[I_DIV_EASY])
			Link->Item[I_DIV_EASY] = false;
		if(Link->Item[I_DIV_VERYEASY])
			Link->Item[I_DIV_VERYEASY] = false;
	}
	else if(Link->Item[I_DIFF_EASY]){
		EnableSlash();
		if(!Link->Item[I_DIV_NORMAL])
			Link->Item[I_DIV_NORMAL] = true;
		if(!Link->Item[I_DIV_EASY])
			Link->Item[I_DIV_EASY] = true;
		if(Link->Item[I_DIV_VERYEASY])
			Link->Item[I_DIV_VERYEASY] = false;
		showBombWalls = true;
	}
	else if(Link->Item[I_DIFF_VERYEASY]){
		EnableSlash();
		if(!Link->Item[I_DIV_NORMAL])
			Link->Item[I_DIV_NORMAL] = true;
		if(!Link->Item[I_DIV_EASY])
			Link->Item[I_DIV_EASY] = true;
		if(!Link->Item[I_DIV_VERYEASY])
			Link->Item[I_DIV_VERYEASY] = true;
		showBombWalls = true;
	}
	else{
		if(Link->Item[I_DIV_NORMAL])
			Link->Item[I_DIV_NORMAL] = false;
		if(Link->Item[I_DIV_EASY])
			Link->Item[I_DIV_EASY] = false;
		if(Link->Item[I_DIV_VERYEASY])
			Link->Item[I_DIV_VERYEASY] = false;
	}
	
	if(showBombWalls){
		if(Game->GetCurLevel()>0){
			if(Screen->Door[DIR_UP]==D_BOMB){
				Screen->ComboD[23] = 308;
				Screen->ComboD[24] = 309;
			}
			if(Screen->Door[DIR_DOWN]==D_BOMB){
				Screen->ComboD[151] = 310;
				Screen->ComboD[152] = 311;
			}
			if(Screen->Door[DIR_LEFT]==D_BOMB){
				Screen->ComboD[81] = 313;
			}
			if(Screen->Door[DIR_RIGHT]==D_BOMB){
				Screen->ComboD[94] = 312;
			}
		}
	}
	
	if(Link->Item[I_DIFF_REALLYJOEL]){
		// if(G[G_ANIM]%30==0){
			// if(G[G_REALLYJOELCOUNTER]>0){
				// G[G_REALLYJOELCOUNTER] = Max(G[G_REALLYJOELCOUNTER]-G[G_REALLYJOELACCEL], 0);
				// G[G_REALLYJOELACCEL] = Min(G[G_REALLYJOELACCEL]+1, 5);
			// }
		// }
		
		// int swordDamage;
		// if(Link->Item[I_SWORD3]){
			// itemdata swrd = Game->LoadItemData(I_SWORD3);
			// swordDamage = Floor(4*(1+(G[G_REALLYJOELCOUNTER]*0.01)*3));
			// swrd->Power = swordDamage;
			// Game->Counter[CR_JOELMULTIPLIER] = swordDamage;
		// }
		// else if(Link->Item[I_SWORD2]){
			// itemdata swrd = Game->LoadItemData(I_SWORD2);
			// swordDamage = Floor(2*(1+(G[G_REALLYJOELCOUNTER]*0.01)*3));
			// swrd->Power = swordDamage;
			// Game->Counter[CR_JOELMULTIPLIER] = swordDamage;
		// }
		// else if(Link->Item[I_SWORD1]){
			// itemdata swrd = Game->LoadItemData(I_SWORD1);
			// swordDamage = Floor(1*(1+(G[G_REALLYJOELCOUNTER]*0.01)*3));
			// swrd->Power = swordDamage;
			// Game->Counter[CR_JOELMULTIPLIER] = swordDamage;
		// }
		// else{
			// Game->Counter[CR_JOELMULTIPLIER] = 0;
		// }
		
		if(Link->MaxHP>16){
			Link->MaxHP = 16;
		}
		
		// if(G[G_REALLYJOELCLEARALL]>0){
			// if(G[G_REALLYJOELCLEARALL]<=6){
				// for(i=0; i<0x7F; i++){
					// for(j=0; j<=14; j++){
						// Game->SetScreenState(G[G_REALLYJOELCLEARALL], i, j, false);
					// }
				// }
			// }
			// else if(G[G_REALLYJOELCLEARALL]<=26){
				// for(i=0; i<0x7F; i++){
					// for(j=0; j<8; j++){
						// Game->SetDMapScreenD(G[G_REALLYJOELCLEARALL]-7, i, j, 0);
					// }
				// }
			// }
			
			// G[G_REALLYJOELCLEARALL]++;
			// if(G[G_REALLYJOELCLEARALL]>=27){
				// G[G_REALLYJOELCLEARALL] = 0;
			// }
		// }
		
		// if(Link->HP<=0&&Game->NumDeaths>=20){
			// G[G_REALLYJOELCLEARALL] = -1;
			// Game->LastEntranceDMap = 0;
			// Game->LastEntranceScreen = 0x77;
			// Game->ContinueDMap = 0;
			// Game->ContinueScreen = 0x77;
		// }
	}
	
	if(Link->HP!=G[G_LASTHP]){
		if(Link->HP<G[G_LASTHP]){
			if(Q7_HasRing(I_SPRING14_VANICE)){
				VaniceRing_ApplyStatus();
			}
			if(Q7_HasRing(I_SPRING18_BLUETEAR)&&G[G_LASTHP]<=32&&Rand(2)==0&&!G[G_BLUETEARHEALCOOLDOWN]){
				G[G_BLUETEARHEAL] = 100;
				G[G_BLUETEARHEALCOOLDOWN] = 1200;
				
				Link->HP = G[G_LASTHP];
				G[G_LASTHP] = Link->HP;
			}
			if(G[G_ZARATH_TIMER]>1)
				G[G_ZARATH_TIMER] = 1;
			if(IsVeryHardMode()&&Link->Item[I_DIFF_VERYHARD]){
				Link->HP -= Abs(G[G_LASTHP]-Link->HP);
			}
		}
		G[G_LASTHP] = Link->HP;
	}
}

void VaniceRing_ApplyStatus(){
	for(int i=Screen->NumNPCs(); i>0; --i){
		npc n = Screen->LoadNPC(i);
		if(n->CollDetection){
			if(n->Defense[NPCD_SWORD]!=NPCDT_BLOCK&&n->Defense[NPCD_SWORD]!=NPCDT_IGNORE){
				if(Distance(CenterLinkX(), CenterLinkY(), CenterX(n), CenterY(n))<n->TileWidth*8+16){
					if(!n->Misc[NPCM_STATUSCOUNTER]){
						n->Misc[NPCM_STATUSTYPE] = NSTAT_PLAGUE;
						n->Misc[NPCM_STATUSCOUNTER] = 120;
					}
				}
			}
		}
	}
}

const int I_WAND2 = 168;

const int I_ACCELERATOR = 167;

const int CMB_ACCELERATOR = 2736;

const int DAMAGE_ACCELERATOR = 2;

const int LW_ACCELERATOR = 38; //Script 8

const int ACCELERATOR_INITSPEED = 0.5;
const int ACCELERATOR_TOPSPEED = 2.5;
const int ACCELERATOR_ACCELERATION = 0.02;
const int ACCELERATOR_DEACCELERATION = 0.01;
const int ACCELERATOR_TURNDECAY = 0.95;

bool Accelerator_PressForward(){
	if(Link->Dir==DIR_UP&&Link->PressUp)
		return true;
	else if(Link->Dir==DIR_DOWN&&Link->PressDown)
		return true;
	else if(Link->Dir==DIR_LEFT&&Link->PressLeft)
		return true;
	else if(Link->Dir==DIR_RIGHT&&Link->PressRight)
		return true;
	return false;
}

void Accelerator_DrawShockwaves(int op){
	if(Link->Item[I_ACCELERATOR]){
		if(Q7_HasRing(I_SPRING28_ACCEL)){
			Screen->DrawCombo(2, Link->X-16, Link->Y-16, CMB_ACCELERATOR+1, 2, 2, 8, 48, 48, Link->X-16, Link->Y-16, G[G_ACCELERATOR_ANGLE], 0, 0, true, op);
			Screen->DrawCombo(4, Link->X-16, Link->Y-16, CMB_ACCELERATOR, 2, 2, 8, 48, 48, Link->X-16, Link->Y-16, G[G_ACCELERATOR_ANGLE], 0, 0, true, op);
		}
		else{
			Screen->DrawCombo(2, Link->X-8, Link->Y-8, CMB_ACCELERATOR+1, 2, 2, 5, -1, -1, Link->X-8, Link->Y-8, G[G_ACCELERATOR_ANGLE], 0, 0, true, op);
			Screen->DrawCombo(4, Link->X-8, Link->Y-8, CMB_ACCELERATOR, 2, 2, 5, -1, -1, Link->X-8, Link->Y-8, G[G_ACCELERATOR_ANGLE], 0, 0, true, op);
		}
	}
	else{
		Screen->DrawCombo(4, Link->X-8, Link->Y-8, CMB_ACCELERATOR+2, 2, 2, 11, -1, -1, Link->X-8, Link->Y-8, G[G_ACCELERATOR_ANGLE], 0, 0, true, op);
	}
}

bool CollidedMovingBlock(){
	if(Screen->MovingBlockX!=-1){
		if(RectCollision(Link->X, Link->Y, Link->X+15, Link->Y+15, Screen->MovingBlockX, Screen->MovingBlockY, Screen->MovingBlockX+15, Screen->MovingBlockY+15))
			return true;
	}
	return false;
}

void Accelerator_Update(){
	if(G[G_LINKSPEEDBOOST]!=0){
		if(!CollidedMovingBlock()&&(Link->Action==LA_NONE||Link->Action==LA_WALKING)){
			if(Link->Dir==DIR_UP&&Link->InputUp){
				LinkMovement_Push2(0, -G[G_LINKSPEEDBOOST]);
			}
			else if(Link->Dir==DIR_DOWN&&Link->InputDown){
				LinkMovement_Push2(0, G[G_LINKSPEEDBOOST]);
			}
			else if(Link->Dir==DIR_LEFT&&Link->InputLeft){
				LinkMovement_Push2(-G[G_LINKSPEEDBOOST], 0);
			}
			else if(Link->Dir==DIR_RIGHT&&Link->InputRight){
				LinkMovement_Push2(G[G_LINKSPEEDBOOST], 0);
			}
		}
	}
	if(Q7_CheatEnabled(G_MODE_SPEEDHACK)){
		if(!CollidedMovingBlock()){
			if(Link->Dir==DIR_UP&&Link->InputUp){
				LinkMovement_Push2(0, -1);
			}
			else if(Link->Dir==DIR_DOWN&&Link->InputDown){
				LinkMovement_Push2(0, 1);
			}
			else if(Link->Dir==DIR_LEFT&&Link->InputLeft){
				LinkMovement_Push2(-1, 0);
			}
			else if(Link->Dir==DIR_RIGHT&&Link->InputRight){
				LinkMovement_Push2(1, 0);
			}
		}
	}
	G[G_LINKSPEEDBOOST] = 0;
	
	SwiftSwim_Update();
	
	if(true){//Link->Item[I_ACCELERATOR]){
		if(G[G_NODRAWSUBSCREEN]){
			G[G_ACCELERATOR_TIME] = 0;
		}
		
		if(Link->Action!=LA_WALKING&&Link->Action!=LA_NONE||Link->PressA){
			if(Link->Action!=LA_SCROLLING&&Link->Action!=LA_GOTHURTLAND){
				G[G_ACCELERATOR_TIME] = 0;
				G[G_ACCELERATOR_DOUBLETAP] = 0;
			}
			return;
		}
		
		if(G[G_ACCELERATOR_TIME]){
			if(Q7_HasRing(I_SPRING28_ACCEL))
				Accelerator_GridSnap();
			
			if(Link->InputUp||Link->InputDown||Link->InputLeft||Link->InputRight){
				int topSpeed = ACCELERATOR_TOPSPEED;
				if(Q7_HasRing(I_SPRING28_ACCEL))
					topSpeed *= 2;
				if(G[G_ACCELERATOR_LASTDIR]==Link->Dir){
					G[G_ACCELERATOR_ACCEL] = Min(G[G_ACCELERATOR_ACCEL]+ACCELERATOR_ACCELERATION, topSpeed);
				}
				else{
					G[G_ACCELERATOR_ACCEL] = G[G_ACCELERATOR_ACCEL]*ACCELERATOR_TURNDECAY;
				}
				G[G_ACCELERATOR_LASTDIR] = Link->Dir;
				
				if(!CollidedMovingBlock()){
					if(Link->Dir==DIR_UP&&Link->InputUp){
						LinkMovement_Push2(0, -G[G_ACCELERATOR_ACCEL]);
					}
					else if(Link->Dir==DIR_DOWN&&Link->InputDown){
						LinkMovement_Push2(0, G[G_ACCELERATOR_ACCEL]);
					}
					else if(Link->Dir==DIR_LEFT&&Link->InputLeft){
						LinkMovement_Push2(-G[G_ACCELERATOR_ACCEL], 0);
					}
					else if(Link->Dir==DIR_RIGHT&&Link->InputRight){
						LinkMovement_Push2(G[G_ACCELERATOR_ACCEL], 0);
					}
				}
				
				if(Link->Item[I_ACCELERATOR]){
					lweapon hitbox = CreateLWeaponAt(LW_ACCELERATOR, Link->X, Link->Y);
					if(Q7_HasRing(I_SPRING28_ACCEL)){
						hitbox->HitXOffset = -16;
						hitbox->HitYOffset = -16;
						hitbox->HitWidth = 48;
						hitbox->HitHeight = 48;
						hitbox->Damage = DAMAGE_ACCELERATOR*2*G[G_HPSCALE];
					}
					else{
						hitbox->HitXOffset = -8;
						hitbox->HitYOffset = -8;
						hitbox->HitWidth = 32;
						hitbox->HitHeight = 32;
						hitbox->Damage = DAMAGE_ACCELERATOR*G[G_HPSCALE];
					}
					hitbox->DrawYOffset = -1000;
					hitbox->Dir = -1;
					hitbox->DeadState = -1;
					hitbox->Misc[LWM_DEATHTIMER] = 2;
				}
				
				G[G_ACCELERATOR_TIME] = 64;
			}
			else{
				G[G_ACCELERATOR_ACCEL] = Max(G[G_ACCELERATOR_ACCEL]-ACCELERATOR_DEACCELERATION, 0);
				G[G_ACCELERATOR_TIME]--;
			}
			
			int tang = Q7_DirAngle(Link->Dir);
			if(Abs(AngDiff(G[G_ACCELERATOR_ANGLE], tang))>5)
				G[G_ACCELERATOR_ANGLE] = WrapDegrees(G[G_ACCELERATOR_ANGLE]+Sign(AngDiff(G[G_ACCELERATOR_ANGLE], tang))*5);
			else
				G[G_ACCELERATOR_ANGLE] = tang;
			
			if(G[G_ACCELERATOR_TIME]>32)
				Accelerator_DrawShockwaves(128);
			else
				Accelerator_DrawShockwaves(64);
		}
		else{
			if(Accelerator_PressForward()){
				if(G[G_ACCELERATOR_DOUBLETAP]==0){
					G[G_ACCELERATOR_DOUBLETAP] = 16;
				}
				else{
					if(Link->Item[I_ACCELERATOR]||G[G_L0ACCEL]){
						G[G_ACCELERATOR_ACCEL] = ACCELERATOR_INITSPEED;
						G[G_ACCELERATOR_LASTDIR] = Link->Dir;
						G[G_ACCELERATOR_ANGLE] = Q7_DirAngle(Link->Dir);
						G[G_ACCELERATOR_TIME] = 64;
					}
				}
			}
		}
		
		if(G[G_ACCELERATOR_DOUBLETAP])
			G[G_ACCELERATOR_DOUBLETAP]--;
	}
}

void SwiftSwim_Update(){
	if(Link->Action==LA_SWIMMING||Link->Action==LA_DIVING){
		if(G[G_SWIFTSWIMCOOLDOWN]){
			bool inDungeon = Q7_IsDungeon();
			if(G[G_SWIFTSWIMCOOLDOWN]>8){
				int swimSpeed = 3;
				if(G[G_SWIFTSWIMCOOLDOWN]-8<=8)
					swimSpeed = 2;
				for(int i=0; i<swimSpeed; ++i){
					if(CanSwim(Link->X, Link->Y, Link->Dir, 1, inDungeon&&Link->Dir==DIR_UP)){
						Link->X += DirX(Link->Dir, 1);
						Link->Y += DirY(Link->Dir, 1);
					}
				}
			}
			--G[G_SWIFTSWIMCOOLDOWN];
		}
		else{
			if(Link->PressB){
				Game->PlaySound(125);
				G[G_SWIFTSWIMCOOLDOWN] = 8+16;
			}
		}
	}
	else{
		G[G_SWIFTSWIMCOOLDOWN] = 0;
	}
}

void Accelerator_GridSnap(){
	int x = Round(Link->X/8)*8;
	int y = Round(Link->Y/8)*8;
	bool dungeonFullTile = Game->GetCurLevel()>0&&Game->GetCurLevel()<9&&Link->Dir==DIR_UP;
	if(!CanWalk(Link->X, Link->Y, Link->Dir, 1, dungeonFullTile)){
		if(CanWalk(x, y, Link->Dir, 1, dungeonFullTile)){
			Link->X = x;
			Link->Y = y;
			return;
		}
		else{
			int dir = RotDirCW4(Link->Dir);
			x += DirX(dir, 8);
			y += DirY(dir, 8);
			if(CanWalk(x, y, Link->Dir, 1, dungeonFullTile)){
				Link->X = x;
				Link->Y = y;
				return;
			}
			x -= DirX(dir, 16);
			y -= DirY(dir, 16);
			if(CanWalk(x, y, Link->Dir, 1, dungeonFullTile)){
				Link->X = x;
				Link->Y = y;
				return;
			}
		}
	}
}

void AutoBow_Update(){
	if(!Link->Item[I_BOW2])
		return;
	if(Link->Action==LA_SCROLLING){
		return;
	}
	if(Link->Action==LA_WALKING||Link->Action==LA_NONE){
		if(G[G_AUTOBOWSTATE]==1){
			if(InputButtonItem(I_ARROW1)||InputButtonItem(I_ARROW2)){
				++G[G_AUTOBOWTIMER];
				if(G[G_AUTOBOWTIMER]>=64){
					G[G_AUTOBOWSTATE] = 2;
					G[G_AUTOBOWANGLE] = WrapDegrees(DirAngle(Link->Dir));
				}
			}
			else{
				G[G_AUTOBOWTIMER] = 0;
				G[G_AUTOBOWSTATE] = 0;
			}
		}
		else if(G[G_AUTOBOWSTATE]==2){
			if((InputButtonItem(I_ARROW1)||InputButtonItem(I_ARROW2))&&Game->Counter[CR_RUPEES]>0){
				++G[G_AUTOBOWTIMER];
				if(G[G_AUTOBOWTIMER]>=6){
					Game->PlaySound(Choose(1, 111, 112));
					lweapon shot = CreateLWeaponAt(LW_ARROW, Link->X+VectorX(12, G[G_AUTOBOWANGLE]), Link->Y+VectorY(12, G[G_AUTOBOWANGLE]));
					if(Link->Item[I_ARROW2]){
						shot->UseSprite(11);
						shot->Damage = 8*G[G_HPSCALE];
					}
					else{
						shot->UseSprite(10);
						shot->Damage = 4*G[G_HPSCALE];
					}
					++shot->OriginalTile;
					shot->Tile = shot->OriginalTile;
					shot->Angular = true;
					shot->Angle = DegtoRad(G[G_AUTOBOWANGLE]+Rand(-10, 10));
					shot->Dir = AngleDir4(WrapDegrees(RadtoDeg(shot->Angle)));
					shot->Step = 600;
					shot->Misc[LWM_ROTATION] = 1;
					shot->DrawXOffset = -1000;
					
					if(G[G_AUTOBOWFIRINGCOST]>0)
						--G[G_AUTOBOWFIRINGCOST];
					else{
						Game->Counter[CR_RUPEES]--;
						G[G_AUTOBOWFIRINGCOST] = 6;
					}
					
					G[G_AUTOBOWTIMER] = 0;
				}
				
				G[G_AUTOBOWANGLE] = TurnToAngle(G[G_AUTOBOWANGLE], WrapDegrees(DirAngle(Link->Dir)), 4);
			}
			else{
				Game->PlaySound(113);
				G[G_AUTOBOWTIMER] = 0;
				G[G_AUTOBOWSTATE] = 0;
			}
		}
	
	}
}

const int I_SECRETRING = 123;
const int I_RINGBOX = 73;

const int SPR_SECRETSPARKLE = 88;

const int FREQ_SECRETSPARKLE = 24;

void SecretSparkles_MakeParticles(int x, int y){
	lweapon sparkle = CreateLWeaponAt(LW_SCRIPT10, x+Rand(-8, 8), y+Rand(-8, 8));
	sparkle->UseSprite(SPR_SECRETSPARKLE);
	sparkle->DeadState = sparkle->NumFrames*sparkle->ASpeed;
	if(Game->GetCurLevel()!=0){
		sparkle->CSet = 2;
	}
}

const int SECRETRING_RANGE = 24;

void SecretSparkles(){
	if(Link->Action==LA_SCROLLING)
		return;
	int range = SECRETRING_RANGE;
	if(Q7_HasRing(I_SPRING11_MIRR))
		range += 64;
	if(Link->Item[I_SECRETRING]||G[G_MODE_FREESIGHT]){
		if(G[G_ANIM]%FREQ_SECRETSPARKLE==0){
			if(Game->GetCurLevel()==0){
				int startx = Max(GridX(Link->X+7-range)/16, 0);
				int endx = Min(GridX(Link->X+8+range)/16, 15);
				int starty = Max(GridY(Link->Y+7-range)/16, 0);
				int endy = Min(GridY(Link->Y+8+range)/16, 10);
				for(int x=startx; x<=endx; x++){
					for(int y=starty; y<=endy; y++){
						int i = x+y*16;
						if(Screen->ComboF[i]==CF_CANDLE1||Screen->ComboF[i]==CF_BOMB){
							SecretSparkles_MakeParticles(ComboX(i), ComboY(i));
						}
						if(Screen->ComboF[i]==CF_PUSH4WAY||Screen->ComboF[i]==CF_PUSHUPDOWN||Screen->ComboF[i]==CF_PUSHUPDOWNINS||Screen->ComboF[i]==CF_PUSHLEFTRIGHTINS||Screen->ComboF[i]==CF_PUSH4WAYINS){
							SecretSparkles_MakeParticles(ComboX(i), ComboY(i));
						}
					}
				}
			}
			else{
				int x[4] = {120, 120, 16, 224};
				int y[4] = {16, 144, 80, 80};
				for(int i=0; i<4; i++){
					if(Screen->Door[i]==D_BOMB){
						if(Distance(x[i], y[i], Link->X, Link->Y)<40){
							if(!Screen->State[ST_DOORUP+i]){
								SecretSparkles_MakeParticles(x[i], y[i]);
							}
						}
					}
				}
				int startx = Max(GridX(Link->X+7-range)/16, 0);
				int endx = Min(GridX(Link->X+8+range)/16, 15);
				int starty = Max(GridY(Link->Y+7-range)/16, 0);
				int endy = Min(GridY(Link->Y+8+range)/16, 10);
				for(int x=startx; x<=endx; x++){
					for(int y=starty; y<=endy; y++){
						int i = x+y*16;
						if(Screen->ComboF[i]==CF_PUSH4WAY||Screen->ComboF[i]==CF_PUSHUPDOWN||Screen->ComboF[i]==CF_PUSHUPDOWNINS||Screen->ComboF[i]==CF_PUSHLEFTRIGHTINS||Screen->ComboF[i]==CF_PUSH4WAYINS){
							SecretSparkles_MakeParticles(ComboX(i), ComboY(i));
						}
					}
				}
			}
		}
	}
}

bool CanPlace(int X, int Y, int Width, int Height){
	for(int x=0; x<=Width-1; x=Min(x+8, Width-1)){
		for(int y=0; y<=Height-1; y=Min(y+8, Height-1)){
			int x2 = Min(X+x, X+Width);
			int y2 = Min(Y+y, Y+Height);
			//Screen->PutPixel(6, x2, y2, 0x83, 0, 0, 0, 128);
			if(Screen->isSolid(x2, y2)&&x2>=0&&x2<=255&&y2>=0&&y2<=175)
				return false;
			if(y==Height-1)
				break;
		}
		if(x==Width-1)
			break;
	}
	return true;
}

bool isSolidLadderHookshot(int x, int y){
	int ct = Screen->ComboT[ComboAt(x, y)];
	if(ct==CT_LADDERONLY||ct==CT_HOOKSHOTONLY||ct==CT_LADDERHOOKSHOT||ct==CT_WATER)
		return false;
	return Screen->isSolid(x, y);
}

bool CanPlaceLadderHookshot(int X, int Y, int Width, int Height){
	for(int x=0; x<=Width-1; x=Min(x+8, Width-1)){
		for(int y=0; y<=Height-1; y=Min(y+8, Height-1)){
			int x2 = Min(X+x, X+Width);
			int y2 = Min(Y+y, Y+Height);
			//Screen->PutPixel(6, x2, y2, 0x83, 0, 0, 0, 128);
			if(isSolidLadderHookshot(x2, y2)&&x2>=0&&x2<=255&&y2>=0&&y2<=175)
				return false;
			if(y==Height-1)
				break;
		}
		if(x==Width-1)
			break;
	}
	return true;
}

bool isSolidLadderHookshotStatues(int x, int y){
	int ct = Screen->ComboT[ComboAt(x, y)];
	if(ct==CT_LADDERONLY||ct==CT_HOOKSHOTONLY||ct==CT_LADDERHOOKSHOT||ct==CT_WATER||ct==CT_LEFTSTATUE||ct==CT_RIGHTSTATUE)
		return false;
	return Screen->isSolid(x, y);
}

bool CanPlaceLadderHookshotStatues(int X, int Y, int Width, int Height){
	for(int x=0; x<=Width-1; x=Min(x+8, Width-1)){
		for(int y=0; y<=Height-1; y=Min(y+8, Height-1)){
			int x2 = Min(X+x, X+Width);
			int y2 = Min(Y+y, Y+Height);
			//Screen->PutPixel(6, x2, y2, 0x83, 0, 0, 0, 128);
			if(isSolidLadderHookshotStatues(x2, y2)&&x2>=0&&x2<=255&&y2>=0&&y2<=175)
				return false;
			if(y==Height-1)
				break;
		}
		if(x==Width-1)
			break;
	}
	return true;
}

bool Q7_IsDungeon(){
	return Game->GetCurLevel()>0&&Game->GetCurLevel()<9;
}

const int I_PHASECLOAK = 143;
const int I_PHASECLOAK2 = 166;
const int SFX_PHASECLOAK = 43;

void PhaseCloak_Init(){
	G[G_PHASECOUNTER] = 0;
	G[G_PHASEPUSHCOUNTER] = 0;
	G[G_PHASEX] = 0;
	G[G_PHASEY] = 0;
}

bool PhaseCloak_CanWalk(int pcct, int x, int y, int dir, int step, bool full_tile) {
    int c=8;
    int xx = x+15;
    int yy = y+15;
    if(full_tile) c=0;
    if(dir==0) return !(y-step<0||PhaseCloak_IsSolid(pcct, x,y+c-step)||PhaseCloak_IsSolid(pcct, x+8,y+c-step)||PhaseCloak_IsSolid(pcct, xx,y+c-step));
    else if(dir==1) return !(yy+step>=176||PhaseCloak_IsSolid(pcct, x,yy+step)||PhaseCloak_IsSolid(pcct, x+8,yy+step)||PhaseCloak_IsSolid(pcct, xx,yy+step));
    else if(dir==2) return !(x-step<0||PhaseCloak_IsSolid(pcct, x-step,y+c)||PhaseCloak_IsSolid(pcct, x-step,y+c+7)||PhaseCloak_IsSolid(pcct, x-step,yy));
    else if(dir==3) return !(xx+step>=256||PhaseCloak_IsSolid(pcct, xx+step,y+c)||PhaseCloak_IsSolid(pcct, xx+step,y+c+7)||PhaseCloak_IsSolid(pcct, xx+step,yy));
    return false; //invalid direction
}

bool PhaseCloak_IsSolid(int pcct, int x, int y){
	int ct = Screen->ComboT[ComboAt(x, y)];
	ct = Clamp(ct, 0, 255);
	
	// if(Screen->isSolid(x, y))
		// Screen->PutPixel(6, x, y+12, Rand(16), 0, 0, 0, 128);
	
	// if(Q7_IsDungeon()){
		// if(x<32||x>=224||y<32||y>=144)
			// return true;
	// }
	if(pcct[ct])
		return false;
	return Screen->isSolid(x, y);
}

bool PhaseCloak_CanPlace(int X, int Y, int Width, int Height){
	// Screen->DrawInteger(6, 0, 0, FONT_Z1, 0x01, 0x0F, -1, -1, X, 0, 128);
	// Screen->DrawInteger(6, 0, 8, FONT_Z1, 0x01, 0x0F, -1, -1, Y, 0, 128);
	if(Q7_IsDungeon()){
		if(X<32||X+Width-1>=224||Y<32||Y+Height-1>=144)
			return false;
	}
	for(int x=0; x<=Width-1; x=Min(x+8, Width-1)){
		for(int y=0; y<=Height-1; y=Min(y+8, Height-1)){
			int x2 = Min(X+x, X+Width-1);
			int y2 = Min(Y+y, Y+Height-1);
			//Screen->PutPixel(6, x2, y2, 0x83, 0, 0, 0, 128);
			if(Screen->isSolid(x2, y2)||x2<0||x2>255||y2<0||y2>167)
				return false;
			if(y==Height-1)
				break;
		}
		if(x==Width-1)
			break;
	}
	return true;
}

bool PhaseCloak_InScreen(int x, int y){
	return x>=0&&x<=240&&y>=0&&y<=160;
}

void PhaseCloak(){
	if(Link->Item[I_PHASECLOAK]){
		bool pushing;
		int x; int y;
		
		int pcct[256];
		pcct[CT_WATER] = 1;
		pcct[CT_LADDERHOOKSHOT] = 1;
		pcct[CT_HOOKSHOTONLY] = 1;
		if(Q7_HasRing(I_SPRING5_SEINE)){
			if(!Link->Item[I_FLIPPERS]&&!Link->Item[I_FLIPPERS2])
				pcct[CT_WATER] = 0;
			pcct[CT_LADDERHOOKSHOT] = 0;
			pcct[CT_HOOKSHOTONLY] = 0;
		}
		
		int length = 1;
		if(Link->Item[I_PHASECLOAK2])
			++length;
		if(Q7_HasRing(I_SPRING5_SEINE))
			++length;
		
		int phaseBomb[] = "PhaseCloak_Bomb";
		int vars[8];
		
		if(!pushing){
			x = Link->X + InFrontX(Link->Dir, -16);
			y = Link->Y + InFrontY(Link->Dir, -16);
			if(Link->Dir==DIR_UP){
				x = Link->X + InFrontX(Link->Dir, -8);
				y = Link->Y + InFrontY(Link->Dir, -8);
			}
			// Screen->DrawInteger(6, 0, 0, FONT_Z1, 0x01, 0x0F, -1, -1, x, 0, 128);
			// Screen->DrawInteger(6, 0, 8, FONT_Z1, 0x01, 0x0F, -1, -1, y, 0, 128);
		
			if(!PhaseCloak_CanWalk(pcct, Link->X, Link->Y, Link->Dir, 1, false)&&PhaseCloak_CanPlace(x+2, y+10, 12, 4)&&PhaseCloak_InScreen(x, y)&&G[G_PHASECOUNTER]<=0){
				// Screen->FastTile(6, x, y, Link->Tile, 6, 128);
				pushing = true;
				if(Link->Dir==DIR_UP&&Link->InputUp)
					G[G_PHASEPUSHCOUNTER]++;
				else if(Link->Dir==DIR_DOWN&&Link->InputDown)
					G[G_PHASEPUSHCOUNTER]++;
				else if(Link->Dir==DIR_LEFT&&Link->InputLeft)
					G[G_PHASEPUSHCOUNTER]++;
				else if(Link->Dir==DIR_RIGHT&&Link->InputRight)
					G[G_PHASEPUSHCOUNTER]++;
				else
					G[G_PHASEPUSHCOUNTER] = 0;
				if(G[G_PHASEPUSHCOUNTER]>=24){
					if(Link->Item[I_PHASECLOAK2]){
						vars[0] = Link->X;
						vars[1] = Link->Y;
						RunFFCScript(Game->GetFFCScript(phaseBomb), vars);
					}
					
					G[G_PHASECOUNTER] = 22;
					if(Link->Dir==DIR_UP)
						G[G_PHASECOUNTER] = 16;
					G[G_PHASEDIR] = Link->Dir;
					G[G_PHASEX] = Link->X;
					G[G_PHASEY] = Link->Y;
					G[G_PHASEMAP] = Game->GetCurMap();
					G[G_PHASESCREEN] = Game->GetCurScreen();
					G[G_PHASELEVEL2] = 0;
					Game->PlaySound(SFX_PHASECLOAK);
				}
			}
		}
		if(!pushing&&length>=2){
			x = Link->X + InFrontX(Link->Dir, -32);
			y = Link->Y + InFrontY(Link->Dir, -32);
			if(Link->Dir==DIR_UP){
				x = Link->X + InFrontX(Link->Dir, -24);
				y = Link->Y + InFrontY(Link->Dir, -24);
			}
		
			if(!PhaseCloak_CanWalk(pcct, Link->X, Link->Y, Link->Dir, 1, false)&&PhaseCloak_CanPlace(x+2, y+10, 12, 4)&&PhaseCloak_InScreen(x, y)&&G[G_PHASECOUNTER]<=0){
				pushing = true;
				if(Link->Dir==DIR_UP&&Link->InputUp)
					G[G_PHASEPUSHCOUNTER]++;
				else if(Link->Dir==DIR_DOWN&&Link->InputDown)
					G[G_PHASEPUSHCOUNTER]++;
				else if(Link->Dir==DIR_LEFT&&Link->InputLeft)
					G[G_PHASEPUSHCOUNTER]++;
				else if(Link->Dir==DIR_RIGHT&&Link->InputRight)
					G[G_PHASEPUSHCOUNTER]++;
				else
					G[G_PHASEPUSHCOUNTER] = 0;
				if(G[G_PHASEPUSHCOUNTER]>=24){
					if(Link->Item[I_PHASECLOAK2]){
						vars[0] = Link->X;
						vars[1] = Link->Y;
						RunFFCScript(Game->GetFFCScript(phaseBomb), vars);
					}
					
					G[G_PHASECOUNTER] = 24;
					if(Link->Dir==DIR_UP)
						G[G_PHASECOUNTER] = 20;
					G[G_PHASEDIR] = Link->Dir;
					G[G_PHASEX] = Link->X;
					G[G_PHASEY] = Link->Y;
					G[G_PHASEMAP] = Game->GetCurMap();
					G[G_PHASESCREEN] = Game->GetCurScreen();
					G[G_PHASELEVEL2] = 1;
					Game->PlaySound(SFX_PHASECLOAK);
				}
			}
		}
		if(!pushing&&length==3){
			x = Link->X + InFrontX(Link->Dir, -48);
			y = Link->Y + InFrontY(Link->Dir, -48);
			if(Link->Dir==DIR_UP){
				x = Link->X + InFrontX(Link->Dir, -40);
				y = Link->Y + InFrontY(Link->Dir, -40);
			}
		
			if(!PhaseCloak_CanWalk(pcct, Link->X, Link->Y, Link->Dir, 1, false)&&PhaseCloak_CanPlace(x+2, y+10, 12, 4)&&PhaseCloak_InScreen(x, y)&&G[G_PHASECOUNTER]<=0){
				pushing = true;
				if(Link->Dir==DIR_UP&&Link->InputUp)
					G[G_PHASEPUSHCOUNTER]++;
				else if(Link->Dir==DIR_DOWN&&Link->InputDown)
					G[G_PHASEPUSHCOUNTER]++;
				else if(Link->Dir==DIR_LEFT&&Link->InputLeft)
					G[G_PHASEPUSHCOUNTER]++;
				else if(Link->Dir==DIR_RIGHT&&Link->InputRight)
					G[G_PHASEPUSHCOUNTER]++;
				else
					G[G_PHASEPUSHCOUNTER] = 0;
				if(G[G_PHASEPUSHCOUNTER]>=24){
					if(Link->Item[I_PHASECLOAK2]){
						vars[0] = Link->X;
						vars[1] = Link->Y;
						RunFFCScript(Game->GetFFCScript(phaseBomb), vars);
					}
					
					G[G_PHASECOUNTER] = 24;
					if(Link->Dir==DIR_UP)
						G[G_PHASECOUNTER] = 21;
					G[G_PHASEDIR] = Link->Dir;
					G[G_PHASEX] = Link->X;
					G[G_PHASEY] = Link->Y;
					G[G_PHASEMAP] = Game->GetCurMap();
					G[G_PHASESCREEN] = Game->GetCurScreen();
					G[G_PHASELEVEL2] = 2;
					Game->PlaySound(SFX_PHASECLOAK);
				}
			}
		}
		if(!pushing||Link->Action==LA_SWIMMING)
			G[G_PHASEPUSHCOUNTER] = 0;
			
		if(G[G_PHASECOUNTER]>0){
			Link->Action = LA_WALKING;
			NoAction();
			if(G[G_PHASEDIR]==DIR_UP)
				Link->InputUp = true;
			else if(G[G_PHASEDIR]==DIR_DOWN)
				Link->InputDown = true;
			else if(G[G_PHASEDIR]==DIR_LEFT)
				Link->InputLeft = true;
			else if(G[G_PHASEDIR]==DIR_RIGHT)
				Link->InputRight = true;
		}
	}
}

void PhaseCloak2(){
	if(G[G_PHASECOUNTER]>0){
		int step = 1.5;
		if(G[G_PHASELEVEL2]==1)
			step = 2;
		else if(G[G_PHASELEVEL2]==2)
			step = 2.6666;
		G[G_PHASECOUNTER]--;
		if(G[G_PHASEDIR]==DIR_UP)
			G[G_PHASEY] -= step;
		else if(G[G_PHASEDIR]==DIR_DOWN)
			G[G_PHASEY] += step;
		else if(G[G_PHASEDIR]==DIR_LEFT)
			G[G_PHASEX] -= step;
		else if(G[G_PHASEDIR]==DIR_RIGHT)
			G[G_PHASEX] += step;
		if(Game->GetCurScreen()==G[G_PHASESCREEN]&&Game->GetCurMap()==G[G_PHASEMAP]){
			Link->X = G[G_PHASEX];
			Link->Y = G[G_PHASEY];
			Link->Action = LA_WALKING;
			if(G[G_ANIM]%4<2)
				Link->Invisible = false;
			else
				Link->Invisible = true;
			Link->CollDetection = false;
			
			if(G[G_PHASECOUNTER]<=0){
				Link->Invisible = false;
				Link->CollDetection = true;
			}
			
			
			
			if(G[G_PHASEDIR]==DIR_UP)
				Link->InputUp = true;
			else if(G[G_PHASEDIR]==DIR_DOWN)
				Link->InputDown = true;
			else if(G[G_PHASEDIR]==DIR_LEFT)
				Link->InputLeft = true;
			else if(G[G_PHASEDIR]==DIR_RIGHT)
				Link->InputRight = true;
			
			if(G[G_PHASECOUNTER]==0){
				if(G[G_PHASEDIR]<2){
					Link->Y = Round(Link->Y/8)*8;
				}
				else{
					Link->X = Round(Link->X/8)*8;
				}
			}
		}
		else{
			G[G_PHASECOUNTER] = 0;
			if(Link->Invisible)
				Link->Invisible = false;
			if(!Link->CollDetection)
				Link->CollDetection = true;
		}
	}
}

void SuperBomb_Update(){
	if(Q7_CheatEnabled(G_MODE_SUPERBOMBS)){
		if(!G[G_HASSBOMB]){
			int sBomb[] = "SuperBomb";
			int sBombSlot = Game->GetFFCScript(sBomb);
			if(CountFFCsRunning(sBombSlot)==0){
				G[G_HASSBOMB] = 1;
			}
		}
	}
	if(G[G_HASSBOMB]&&(Game->GetCurDMap()==0||Game->GetCurDMap()==22||Q7_CheatEnabled(G_MODE_SUPERBOMBS))&&Game->GetCurScreen()<0x80){
		int sBomb[] = "SuperBomb";
		int sBombSlot = Game->GetFFCScript(sBomb);
		if(CountFFCsRunning(sBombSlot)==0){
			RunFFCScript(sBombSlot, 0);
		}
	}
}

const int CMB_SPINNER = 192;

//D0: Screen->D[] to use
//D1: DBit (0-15) to use
//D2: DBit (1-15) to invert the initial state of the spinner
ffc script Spinner{
	void run(int d, int dbit, int invertdbit){
		dbit = (1<<dbit);
		
		int spinnerCSets[2] = {8, 7};
		if(Game->GetCurDMap()==60||Game->GetCurDMap()==8){
			spinnerCSets[0] = 1;
			spinnerCSets[1] = 5;
		}
		
		if(invertdbit){
			invertdbit = (1<<invertdbit);
			if(!(Screen->D[d]&invertdbit)){
				Screen->D[d] |= dbit;
				Screen->D[d] |= invertdbit;
			}
		}
		while(true){
			while(Distance(this->X+16, this->Y+16, Link->X, Link->Y)>16){
				Spinner_Waitframe(this, d, dbit, spinnerCSets);
			}
			int angleLink = Angle(this->X+16, this->Y+16, Link->X, Link->Y);
			int distLink = Distance(this->X+16, this->Y+16, Link->X, Link->Y);
			int tempAngleLink;
			for(int i=0; i<30; i++){
				if(i%4==0)
					Game->PlaySound(1);
				if(!(Screen->D[d]&dbit)){
					angleLink += 3;
					angleLink = WrapDegrees(angleLink);
					Screen->DrawCombo(2, this->X, this->Y, CMB_SPINNER+1+Clamp(Floor(i/10), 0, 2), 3, 3, spinnerCSets[0], -1, -1, 0, 0, 0, -1, 0, true, 128);
				}
				else{
					angleLink -= 3;
					angleLink = WrapDegrees(angleLink);
					Screen->DrawCombo(2, this->X, this->Y, CMB_SPINNER+1+Clamp(Floor((30-i)/10), 0, 2), 3, 3, spinnerCSets[1], -1, -1, 0, 0, 0, -1, 0, true, 128);
				}
				tempAngleLink = Round((angleLink+360)/22.5)*22.5;
				Link->X = this->X+16+VectorX(distLink, tempAngleLink);
				Link->Y = this->Y+16+VectorY(distLink, tempAngleLink);
				WaitNoAction();
			}
			if(!(Screen->D[d]&dbit))
				Screen->D[d] |= dbit;
			else
				Screen->D[d] &= ~dbit;
			while(Distance(this->X+16, this->Y+16, Link->X, Link->Y)<24){
				Spinner_Waitframe(this, d, dbit, spinnerCSets);
			}
		}
	}
	void Spinner_Waitframe(ffc this, int d, int dbit, int spinnerCSets){
		if(!(Screen->D[d]&dbit)){
			Screen->FastCombo(2, this->X+16, this->Y, CMB_SPINNER+4, spinnerCSets[0], 128);
			Screen->FastCombo(2, this->X+16, this->Y+32, CMB_SPINNER+5, spinnerCSets[0], 128);
			Screen->FastCombo(2, this->X, this->Y+16, CMB_SPINNER+6, spinnerCSets[0], 128);
			Screen->FastCombo(2, this->X+32, this->Y+16, CMB_SPINNER+7, spinnerCSets[0], 128);
			Screen->DrawCombo(2, this->X, this->Y, CMB_SPINNER, 3, 3, spinnerCSets[0], -1, -1, 0, 0, 0, -1, 0, true, 128);
		}
		else{
			Screen->FastCombo(2, this->X+16, this->Y, CMB_SPINNER+8, spinnerCSets[1], 128);
			Screen->FastCombo(2, this->X+16, this->Y+32, CMB_SPINNER+9, spinnerCSets[1], 128);
			Screen->FastCombo(2, this->X, this->Y+16, CMB_SPINNER+10, spinnerCSets[1], 128);
			Screen->FastCombo(2, this->X+32, this->Y+16, CMB_SPINNER+11, spinnerCSets[1], 128);
			Screen->DrawCombo(2, this->X, this->Y, CMB_SPINNER, 3, 3, spinnerCSets[1], -1, -1, 0, 0, 0, -1, 0, true, 128);
		}
		Waitframe();
	}
}

ffc script D_Reset{
	void run(int d, int sp){
		if(Distance(Link->X, Link->Y, this->X, this->Y)<48){
			if(sp==1){
				int dmaps[7] = {9, 10, 11, 12, 13, 14, 15};
				if(Q7_CheatEnabled(G_MODE_COLORSHIFT)){
					for(int i=0; i<7; i++){
						dmaps[i] += 60;
					}
				}
				for(int i=0; i<7; i++){
					DR_ResetScreenD(d, dmaps[i]);
				}
			}
			else{
				DR_ResetScreenD(d, Game->GetCurDMap());
			}
		}
	}
	void DR_ResetScreenD(int d, int dmap){
		if(d<0){
			for(int j=Abs(d); j>=0; j--){
				for(int i=0; i<128; i++){
					Game->SetDMapScreenD(dmap, i, j, 0);
				}
			}
		}
		else{
			for(int i=0; i<128; i++){
				Game->SetDMapScreenD(dmap, i, d, 0);
			}
		}
	}
}

ffc script PoisonWater{
	void run(){
		while(true){
			while(Link->Action!=LA_SWIMMING&&Link->Action!=LA_DIVING&&Screen->ComboT[ComboAt(Link->X+8, Link->Y+12)]!=CT_SHALLOWWATER){
				Waitframe();
			}
			int maxDamageCounter = 150;
			if(Link->Item[I_DIFF_VERYEASY])
				maxDamageCounter = 300;
			else if(Link->Item[I_DIFF_EASY])
				maxDamageCounter = 300;
			else if(Link->Item[I_DIFF_NORMAL])
				maxDamageCounter = 180;
			int damageCounter = maxDamageCounter;
			// if(Link->Item[I_SCRIPTBOOTS])
				// damageCounter *= 1.5;
			while(Link->Action==LA_SWIMMING||Link->Action==LA_DIVING||(Screen->ComboT[ComboAt(Link->X+8, Link->Y+12)]==CT_SHALLOWWATER)){
				damageCounter--;
				if(damageCounter<=0){
					if(Screen->ComboT[ComboAt(Link->X+8, Link->Y+12)]==CT_SHALLOWWATER||Link->Action==LA_SWIMMING){
						if(G[G_BOOTSLIFE]>0&&Screen->ComboT[ComboAt(Link->X+8, Link->Y+12)]==CT_SHALLOWWATER&&!Q7_HasRing(I_SPRING8_TYRE)){
							Boots_TakeDamage();
						}
						else{
							if(Q7_HasRing(I_SPRING8_TYRE)){
								Link->HP += 8;
								Game->PlaySound(SFX_TYREHEAL);
							}
							else{
								if(IsEasyMode()){
									Link->HP -= 4;
								}
								else{
									Link->HP -= 8;
								}
								Game->PlaySound(SFX_OUCH);
							}
						}
						damageCounter = maxDamageCounter;
					}
				}
				Waitframe();
			}
		}
	}
}

ffc script L3Entrance{
	void run(){
		while(!FindWhistle()){
			Waitframe();
		}
		Waitframes(48);
		int changedCombos[3] = {87, 88, 89};
		int changedCombos2[3] = {71, 72, 73};
		ShiftIfOnCombos(changedCombos, 64, 88);
		CopyScreen(2, 0x04);
		Game->PlaySound(3);
		lweapon boom = CreateLWeaponAt(LW_BOMBBLAST, 16, 16);
		boom->DrawYOffset = -1000;
		boom->CollDetection = false;
		Waitframes(48);
		ShiftIfOnCombos(changedCombos2, 48, 48);
		CopyScreen(2, 0x05);
		Game->PlaySound(3);
		boom = CreateLWeaponAt(LW_BOMBBLAST, 16, 16);
		boom->DrawYOffset = -1000;
		boom->CollDetection = false;
		Waitframes(48);
		Game->PlaySound(SFX_SECRET);
		
	}
	bool FindWhistle(){
		for(int i=Screen->NumLWeapons(); i>=1; i--){
			lweapon l = Screen->LoadLWeapon(i);
			if(l->ID==LW_WHISTLE)
				return true;
		}
		return false;
	}
	void CopyScreen(int map, int scr){
		for(int i=0; i<176; i++){
			Screen->ComboD[i] = Game->GetComboData(map, scr, i);
			Screen->ComboC[i] = Game->GetComboCSet(map, scr, i);
		}
	}
	void ShiftIfOnCombos(int list, int ypos1, int ypos2){
		for(int i=0; i<SizeOfArray(list); i++){
			for(int x=0; x<=15; x=Min(x+16, 15)){
				for(int y=8; y<=15; y=Min(y+8, 15)){
					if(ComboAt(Link->X+x, Link->Y+y)==list[i]){
						if(Abs(Link->Y-ypos1)<Abs(Link->Y-ypos2))
							Link->Y = ypos1;
						else
							Link->Y = ypos2;
						return;
					}
					if(y==15)
						break;
				}
				if(x==15)
					break;
			}
		}
	}
}

ffc script SwordShooter{
	void run(int delay1, int delay2){
		int damage = PiercingDamage(4);
		while(true){
			while(!CheckSword()){
				Waitframe();
			}
			Waitframes(delay1);
			eweapon e = FireAimedEWeapon(EW_FIREBALL, this->X, this->Y, 0, 150, damage, -1, -1, 0);
			Waitframes(delay2);
		}
	}
	bool CheckSword(){
		if(G[G_SWORDSHOOTERFLAG])
			return true;
		lweapon sword = LoadLWeaponOf(LW_SWORD);
		if(sword->isValid()&&Link->Action==LA_ATTACKING)
			return true;
		return false;
	}
}

const int SPR_SMALLPOOF = 91;
const int SFX_LEEVERTREMOR = 1;

lweapon SpriteAnim(int x, int y, int sprite, int w, int h){
	lweapon l = CreateLWeaponAt(LW_SCRIPT10, x, y);
	l->UseSprite(sprite);
	l->DeadState = l->NumFrames*l->ASpeed;
	l->CollDetection = false;
	l->Extend = 3;
	l->TileWidth = w;
	l->TileHeight = h;
	return l;
}

lweapon SpriteAnim(int x, int y, int til, int cset, int frames, int aspeed, int w, int h){
	lweapon l = CreateLWeaponAt(LW_SCRIPT10, x, y);
	l->OriginalTile = til;
	l->Tile = til;
	l->CSet = cset;
	l->NumFrames = frames;
	l->ASpeed = aspeed;
	l->DeadState = l->NumFrames*l->ASpeed;
	l->CollDetection = false;
	l->Extend = 3;
	l->TileWidth = w;
	l->TileHeight = h;
	return l;
}

lweapon SpriteAnimRand(int x, int y, int sprite, int w, int h, int offset, int offsetscale){
	lweapon l = CreateLWeaponAt(LW_SCRIPT10, x, y);
	l->UseSprite(sprite);
	l->DeadState = l->NumFrames*l->ASpeed;
	l->CollDetection = false;
	l->Extend = 3;
	l->TileWidth = w;
	l->TileHeight = h;
	
	l->OriginalTile += Rand(Abs(offset))*Sign(offset)*offsetscale;
	l->Tile = l->OriginalTile;
	
	return l;
}

lweapon SparkleSpriteAnim(int x, int y, int sprite, int w, int h){
	lweapon l = CreateLWeaponAt(LW_SPARKLE, x, y);
	l->UseSprite(sprite);
	l->CollDetection = false;
	l->Extend = 3;
	l->TileWidth = w;
	l->TileHeight = h;
	return l;
}

lweapon SparkleSpriteAnim(int x, int y, int til, int cset, int numframes, int aspeed, int w, int h, int angle, int step){
	lweapon l = CreateLWeaponAt(LW_SPARKLE, x, y);
	l->OriginalTile = til;
	l->Tile = l->OriginalTile;
	l->NumFrames = numframes;
	l->ASpeed = aspeed;
	l->CollDetection = false;
	l->Extend = 3;
	l->TileWidth = w;
	l->TileHeight = h;
	l->Angular = true;
	l->Angle = DegtoRad(angle);
	l->Step = step;
	return l;
}

lweapon SparkleSpriteAnim(int x, int y, int sprite, int w, int h, int angle, int step){
	lweapon l = CreateLWeaponAt(LW_SPARKLE, x, y);
	l->UseSprite(sprite);
	l->CollDetection = false;
	l->Extend = 3;
	l->TileWidth = w;
	l->TileHeight = h;
	l->Angular = true;
	l->Angle = DegtoRad(angle);
	l->Step = step;
	return l;
}

ffc script TremorLeever{
	void run(int enemyid){
		int i; int j; int k; int m;
		
		npc ghost = Ghost_InitAutoGhost(this, enemyid);
		this->Flags[FFCF_ETHEREAL] = true;
		Ghost_SetFlag(GHF_MOVE_OFFSCREEN);
		Ghost_X = -32;
		Ghost_Y = -32;
		int shot = ghost->Attributes[0];
		int combo = ghost->Attributes[10];
		int initHP = Ghost_HP;
		bool grabbed;
		int cooldown = 30;
		int delay = LazyDiffMod(8, 6, 4);
		if(shot==2)
			delay = LazyDiffMod(24, 12, 4);
		
		int startX = Ghost_X;
		int startY = Ghost_Y;
		
		int cmbGroup[176];
		int group = 1;
		for(i=0; i<176; i++){
			if(ComboFI(i, 98)&&cmbGroup[i]==0){
				cmbGroup[i] = group;
				int fillCMB[177];
				AddCMBToArray(fillCMB, i);
				j = 0;
				while(j<fillCMB[176]){
					for(k=0; k<4; k++){
						m = AdjacentFI(fillCMB[j], k, 98);
						if(m>-1){
							if(cmbGroup[m]==0){
								cmbGroup[m] = group;
								AddCMBToArray(fillCMB, m);
							}
						}
					}	
					j++;
				}
				group++;
			}
		}
		
		while(true){
			Ghost_X = -32;
			Ghost_Y = -32;
			ghost->CollDetection = false;
			if(CanSurface(Link->X, Link->Y, false)){
				cooldown--;
				if(cooldown<=0){
					bool collided;
					Ghost_Data = combo;
					if(GetComboGroup(Link->X, Link->Y, cmbGroup)==GetComboGroup(startX, startY, cmbGroup)){
						Ghost_X = startX;
						Ghost_Y = startY;
					}
					else{
						m = GetComboGroup(Link->X, Link->Y, cmbGroup);
						j = -1;
						for(i=0; i<176*2; i++){
							if(i<176)
								j = Rand(176);
							else
								j = i-176;
							
							if(cmbGroup[j]==m){
								if(Screen->ComboS[j]==0000&&Distance(ComboX(j), ComboY(j), Link->X, Link->Y)>8)
									break;
							}
						}
						
						if(cmbGroup[j]==m){
							Ghost_X = ComboX(j);
							Ghost_Y = ComboY(j);
						}
						else{
							Ghost_X = startX;
							Ghost_Y = startY;
						}
					}
					for(i=0; i<20; i++){
						if(i%4==0){
							Game->PlaySound(SFX_LEEVERTREMOR);
							SpriteAnim(Ghost_X+Rand(-4, 4), Ghost_Y+Rand(-4, 4), SPR_SMALLPOOF, 1, 1);
						}
						
						Q7_Ghost_Waitframe(this, ghost);
					}
					for(i=0; i<180; i++){
						if(i%4==0){
							Game->PlaySound(SFX_LEEVERTREMOR);
							SpriteAnim(Ghost_X+Rand(-4, 4), Ghost_Y+Rand(-4, 4), SPR_SMALLPOOF, 1, 1);
						}
						int lastX = Ghost_X;
						int lastY = Ghost_Y;
						
						int lastCMB[176];
						for(j=0; j<176; j++){
							if(cmbGroup[j]==0){
								lastCMB[j] = Screen->ComboD[j];
								Screen->ComboD[j] = 48;
							}
						}
						bool blocked;
						Ghost_SetHitOffsets(ghost, 8, 0, 0, 0);
						if(!Ghost_CanMove8(AngleDir8(Angle(Ghost_X, Ghost_Y, Link->X, Link->Y)), 1, 0)){
							blocked = true;
						}
						Ghost_MoveTowardLink(ghost->Step/100, 0);
						Ghost_SetHitOffsets(ghost, 0, 0, 0, 0);
						for(j=0; j<176; j++){
							if(cmbGroup[j]==0){
								Screen->ComboD[j] = lastCMB[j];
							}
						}
						
						if(!CanSurface(Ghost_X, Ghost_Y, true)){
							if(CanSurface(Ghost_X, Ghost_Y-1, true)){
								Ghost_Y -= 1;
							}
							else if(CanSurface(Ghost_X, Ghost_Y+1, true)){
								Ghost_Y += 1;
							}
							else if(CanSurface(Ghost_X-1, Ghost_Y, true)){
								Ghost_X -= 1;
							}
							else if(CanSurface(Ghost_X+1, Ghost_Y, true)){
								Ghost_Y += 1;
							}
							else{
								Ghost_X = lastX;
								Ghost_Y = lastY;
								if(!CanSurface(Link->X, Link->Y, false)){
									break;
								}
							}
						}
						
						if(Distance(Ghost_X, Ghost_Y, Link->X, Link->Y)<8){
							collided = true;
							break;
						}
						if(!CanSurface(Link->X, Link->Y, false)&&blocked)
							break;
						
						Q7_Ghost_Waitframe(this, ghost);
					}
					if(CanSurface(Link->X, Link->Y, false)){
						Ghost_Data = combo;
						Q7_Ghost_Waitframes(this, ghost, true, true, 2*delay);
						Ghost_Data = combo+1;
						Q7_Ghost_Waitframes(this, ghost, true, true, delay);
						Ghost_Data = combo+2;
						ghost->CollDetection = true;
						for(i=0; i<48; i++){
							if(shot==1&&i==24)
								eweapon e = FireAimedEWeapon(EW_FIREBALL, Ghost_X, Ghost_Y, 0, 200, ghost->WeaponDamage, -1, -1, 0);
							else if(shot==2){
								if(i<8&&Link->Action==LA_GOTHURTLAND&&LinkCollision(ghost)&&!Q7_HasRing(I_SPRING19_WALLMASTER)&&!G[G_PHASECOUNTER]){
									Ghost_HP = 1000;
									ghost->HP = 1000;
									ghost->CollDetection = false;
									Link->Action = LA_FROZEN;
									Link->X = Ghost_X;
									Link->Y = Ghost_Y;
									Link->CollDetection = false;
									grabbed = true;
									this->Flags[FFCF_OVERLAY] = true;
								}
							}
							Q7_Ghost_Waitframe(this, ghost);
						}
						Q7_Ghost_Waitframes(this, ghost, true, true, 24);
						ghost->CollDetection = false;
						if(grabbed)
							Link->Invisible = true;
						Ghost_Data = combo+1;
						Q7_Ghost_Waitframes(this, ghost, true, true, delay);
						Ghost_Data = combo;
						Q7_Ghost_Waitframes(this, ghost, true, true, 2*delay);
						if(grabbed){
							Link->X = 0;
							Link->Y = 0;
							Link->Invisible = false;
							Link->CollDetection = true;
							ffc f = Screen->LoadFFC(30);
							Screen->SetSideWarp(0, Game->LastEntranceScreen, Game->LastEntranceDMap, WT_IWARPOPENWIPE);
							f->Data = 59;
							while(true){
								WaitNoAction();
							}
						}
					}
					cooldown = 20;
					startX = Ghost_X;
					startY = Ghost_Y;
				}
			}
			else{
				if(shot==2)
					cooldown = Choose(10, 40, 70, 100);
				else
					cooldown = Choose(20, 30, 40, 50);
			}
			// Ghost_HP = initHP;
			// ghost->HP = initHP;
			Q7_Ghost_Waitframe(this, ghost);
		}
	}
	int AdjacentFI(int pos, int dir, int flag){
		if(dir==DIR_UP){
			if(pos<16)
				return -1;
			else
				return Cond(ComboFI(pos-16, flag), pos-16, -1);
		}
		else if(dir==DIR_DOWN){
			if(pos>143)
				return -1;
			else
				return Cond(ComboFI(pos+16, flag), pos+16, -1);
		}
		else if(dir==DIR_LEFT){
			if(pos%16==0)
				return -1;
			else
				return Cond(ComboFI(pos-1, flag), pos-1, -1);
		}
		else if(dir==DIR_RIGHT){
			if(pos%16==0)
				return -1;
			else
				return Cond(ComboFI(pos+1, flag), pos+1, -1);
		}
		return -1;
	}
	void AddCMBToArray(int array, int cmb){
		int i = array[176];
		array[i] = cmb;
		array[176] = Min(array[176]+1, 175);
	}
	int GetComboGroup(int x, int y, int cmbGroup){
		int pos = ComboAt(x+8, y+12);
		if(cmbGroup[pos]>0){
			return cmbGroup[pos];
		}
		
		pos = ComboAt(x, y+8);
		if(cmbGroup[pos]>0){
			return cmbGroup[pos];
		}
		
		pos = ComboAt(x+15, y+8);
		if(cmbGroup[pos]>0){
			return cmbGroup[pos];
		}
		
		pos = ComboAt(x, y+15);
		if(cmbGroup[pos]>0){
			return cmbGroup[pos];
		}
		
		pos = ComboAt(x+15, y+15);
		if(cmbGroup[pos]>0){
			return cmbGroup[pos];
		}
		
		return 0;
	}
	bool CanSurface(int X, int Y, bool checkAll){
		for(int x=0; x<=15; x=Min(x+8, 15)){
			for(int y=8; y<=15; y=Min(y+8, 15)){
				if(!ComboFI(X+x, Y+y, 98)){
					if(checkAll)
						return false;
				}
				else{
					if(!checkAll)
						return true;
				}
				if(y==15)
					break;
			}
			if(x==15)
				break;
		}
		if(checkAll)
			return true;
		return false;
	}
}

bool Ghost_CanMove8(int dir, int step, int trim){
	if(dir==DIR_LEFTUP){
		return Ghost_CanMove(DIR_LEFT, step, trim)&&Ghost_CanMove(DIR_UP, step, trim);
	}
	else if(dir==DIR_RIGHTUP){
		return Ghost_CanMove(DIR_RIGHT, step, trim)&&Ghost_CanMove(DIR_UP, step, trim);
	}
	else if(dir==DIR_LEFTDOWN){
		return Ghost_CanMove(DIR_LEFT, step, trim)&&Ghost_CanMove(DIR_DOWN, step, trim);
	}
	else if(dir==DIR_RIGHTDOWN){
		return Ghost_CanMove(DIR_RIGHT, step, trim)&&Ghost_CanMove(DIR_DOWN, step, trim);
	}
	else
		return Ghost_CanMove(dir, step, trim);
}

bool Ghost_CanMoveAngle(int angle, int step, int trim){
	int vX = Round(VectorX(step, angle));
	int vY = Round(VectorY(step, angle));
	if(vX==0&&vY==0)
		return false;
	return Ghost_CanMove8(AngleDir8(Angle(0, 0, vX, vY)), step, 1);
}

bool IsSolidNoWater(int x, int y){
	int ct = Screen->ComboT[ComboAt(x, y)];
	if(ct==CT_WATER||ct==CT_LADDERONLY||ct==CT_LADDERHOOKSHOT)
		return false;
	return Screen->isSolid(x, y);
}

bool CanWalkNoEdgeNoWater(int x, int y, int dir, int step, bool full_tile) {
    int c=8;
    int xx = x+15;
    int yy = y+15;
    if(full_tile) c=0;
    if(dir==0) return !(IsSolidNoWater(x,y+c-step)||IsSolidNoWater(x+8,y+c-step)||IsSolidNoWater(xx,y+c-step));
    else if(dir==1) return !(IsSolidNoWater(x,yy+step)||IsSolidNoWater(x+8,yy+step)||IsSolidNoWater(xx,yy+step));
    else if(dir==2) return !(IsSolidNoWater(x-step,y+c)||IsSolidNoWater(x-step,y+c+7)||IsSolidNoWater(x-step,yy));
    else if(dir==3) return !(IsSolidNoWater(xx+step,y+c)||IsSolidNoWater(xx+step,y+c+7)||IsSolidNoWater(xx+step,yy));
    return false; //invalid direction
}


ffc script TremorLeeverOld{
	void run(int enemyid){
		npc ghost = Ghost_InitAutoGhost(this, enemyid);
		this->Flags[FFCF_ETHEREAL] = true;
		Ghost_SetFlag(GHF_MOVE_OFFSCREEN);
		Ghost_SetFlag(GHF_STUN);
		Ghost_X = -32;
		Ghost_Y = -32;
		int shot = ghost->Attributes[0];
		int combo = ghost->Attributes[10];
		int initHP = Ghost_HP;
		bool grabbed;
		int cooldown = 30;
		int delay = 8;
		//if(shot==2)
		//	delay = 24;
		while(true){
			Ghost_X = -32;
			Ghost_Y = -32;
			ghost->CollDetection = false;
			int tX = Round(Link->X/8)*8;
			int tY = Round(Link->Y/8)*8;
			if(CanSurface(tX, tY)){
				cooldown--;
				if(cooldown<=0){
					Ghost_Data = combo;
					Ghost_X = tX;
					Ghost_Y = tY;
					Q7_Ghost_Waitframes(this, ghost, true, true, 2*delay);
					Ghost_Data = combo+1;
					Q7_Ghost_Waitframes(this, ghost, true, true, delay);
					Ghost_Data = combo+2;
					ghost->CollDetection = true;
					for(int i=0; i<48; i++){
						if(shot==1&&i==24)
							eweapon e = FireAimedEWeapon(EW_FIREBALL, Ghost_X, Ghost_Y, 0, 200, ghost->WeaponDamage, -1, -1, 0);
						else if(shot==2){
							if(Link->Action==LA_GOTHURTLAND&&LinkCollision(ghost)){
								Ghost_HP = 1000;
								ghost->HP = 1000;
								ghost->CollDetection = false;
								Link->Action = LA_FROZEN;
								Link->X = Ghost_X;
								Link->Y = Ghost_Y;
								Link->CollDetection = false;
								grabbed = true;
								this->Flags[FFCF_OVERLAY] = true;
							}
						}
						Q7_Ghost_Waitframe(this, ghost);
					}
					Q7_Ghost_Waitframes(this, ghost, true, true, 24);
					ghost->CollDetection = false;
					if(grabbed)
						Link->Invisible = true;
					Ghost_Data = combo+1;
					Q7_Ghost_Waitframes(this, ghost, true, true, delay);
					Ghost_Data = combo;
					Q7_Ghost_Waitframes(this, ghost, true, true, 2*delay);
					if(grabbed){
						Link->X = 0;
						Link->Y = 0;
						Link->Invisible = false;
						Link->CollDetection = true;
						ffc f = Screen->LoadFFC(30);
						Screen->SetSideWarp(0, Game->LastEntranceScreen, Game->LastEntranceDMap, WT_IWARPOPENWIPE);
						f->Data = 59;
						while(true){
							WaitNoAction();
						}
					}
					cooldown = 90;
				}
			}
			Ghost_HP = initHP;
			ghost->HP = initHP;
			Q7_Ghost_Waitframe(this, ghost);
		}
	}
	bool CanSurface(int X, int Y){
		for(int x=0; x<=15; x=Min(x+8, 15)){
			for(int y=0; y<=15; y=Min(y+8, 15)){
				if(!ComboFI(X+x, Y+y, 98))
					return false;
				if(y==15)
					break;
			}
			if(x==15)
				break;
		}
		return true;
	}
}

const int SF_DOORGLITCH = 2;

ffc script DoorGlitch{
	void run(){
		if(Game->LastEntranceDMap!=Game->GetCurDMap()&&G[G_LASTEXITDIR]>-1){
			int od = OppositeDir(G[G_LASTEXITDIR]);
			if(!Screen->State[od]&&ScreenFlag(SF_MISC, SF_DOORGLITCH)){
				Screen->State[od] = true;
				if(Screen->Door[od]==D_LOCKED)
					Screen->Door[od] = D_UNLOCKED;
				else if(Screen->Door[od]==D_BOMB)
					Screen->Door[od] = D_BOMBED;
			}
		}
	}
}

const int SFX_ELECTRICWATER = 67;

const int SFX_BOOTSSCALE = 100;
const int SFX_BOOTSBREAK = 81;

const int SPR_BOOTSBREAK = 113;

ffc script ElectricWater{
	void run(int delay0, int delay1, int delay2, int observeFlag){
		int i;
		int cmb[176];
		for(i=0; i<176; i++){
			if(ComboFI(i, 98))
				cmb[i] = Screen->ComboD[i];
		}
		int damageCounter[4];
		
		if(observeFlag){
			while(true){
				if(damageCounter[2]==1)
					Game->PlaySound(SFX_ELECTRICWATER);
				ElectricWater_Waitframe(cmb, damageCounter, true, observeFlag);
			}
		}
		else{
			Waitframes(delay0);
			while(true){
				Game->PlaySound(SFX_ELECTRICWATER);
				for(i=0; i<delay1; i++){
					ElectricWater_Waitframe(cmb, damageCounter, true, 0);
				}
				for(i=0; i<delay2; i++){
					ElectricWater_Waitframe(cmb, damageCounter, false, 0);
				}
			}
		}
	}
	void ElectricWater_Waitframe(int cmb, int damageCounter, bool electrified, int observeFlag){
		int bootsSFX = damageCounter[3];
		if(electrified){
			if(!observeFlag){
				for(int i=0; i<176; i++){
					if(cmb[i]>0&&ComboFI(i, 98)){
						Screen->FastCombo(0, ComboX(i), ComboY(i), cmb[i]+1, Screen->ComboC[i], 128);
					}
				}
			}
			damageCounter[2] = 0;
			if((Screen->ComboT[ComboAt(Link->X+8, Link->Y+12)]==CT_SHALLOWWATER)||Screen->ComboT[ComboAt(Link->X+8, Link->Y+12)]==CT_WATER){
				if(cmb[ComboAt(Link->X+8, Link->Y+12)]||observeFlag){
					if(ComboFI(Link->X+8, Link->Y+12, observeFlag)||observeFlag==0){
						if(observeFlag!=0){
							if(damageCounter[2]==1)
								damageCounter[2] = 2;
							else
								damageCounter[2] = 1;
						}
						
						damageCounter[0]--;
						if(damageCounter[0]<=0){
							if(G[G_BOOTSLIFE]>0&&!Q7_HasRing(I_SPRING8_TYRE)){
								Boots_TakeDamage();
							}
							else{
								if(Q7_HasRing(I_SPRING8_TYRE)){
									Link->HP += 1;
									Game->PlaySound(SFX_TYREHEAL);
								}
								else{
									Link->HP -= 8;
									Game->PlaySound(SFX_OUCH);
								}
							}
							damageCounter[0] = 20;
							if(Link->Item[I_DIFF_NORMAL]||Link->Item[I_DIFF_EASY]||Link->Item[I_DIFF_VERYEASY]){
								damageCounter[0] = 40;
							}
							if(G[G_BOOTSLIFE]>0){
								damageCounter[0] = 10;
							}
						}
						//Waitframe();
					}
				}
			}
		}
		Waitframe();
	}
}

ffc script ElectricSideviewLayer{
	void run(int srcMap, int srcScrn, int minY, int maxY, int speed, int wt){
		int posActivate;
		for(int i=0; i<176; i++){
			if(ComboFI(i, 98))
				posActivate = i;
		}
		int posActivateCMB = Screen->ComboD[posActivate];
		bool wasActive;
		
		int waveTimer = 180;
		if(wt!=0)
			waveTimer = wt;
		int hitTimer = 20;
		if(Link->Item[I_DIFF_NORMAL]||Link->Item[I_DIFF_EASY]||Link->Item[I_DIFF_VERYEASY]){
			hitTimer = 40;
		}
		if(G[G_BOOTSLIFE]>0){
			hitTimer = 10;
		}
		while(true){
			if(Link->Action!=LA_HOLD1LAND&&Link->Action!=LA_HOLD2LAND)
				waveTimer += speed;
			waveTimer %= 360;
			
			int waveY = (minY+maxY)/2-Abs(minY-maxY)/2*Sin(waveTimer);
			
			if(waveY<ComboY(posActivate)+8){
				if(!wasActive)
					Game->PlaySound(SFX_ELECTRICWATER);
				wasActive = true;
				Screen->ComboD[posActivate] = posActivateCMB+1;
				
				if(Link->Y>waveY-8){
					hitTimer--;
					if(hitTimer<=0){
						if(G[G_BOOTSLIFE]>0&&!Q7_HasRing(I_SPRING8_TYRE)){
							Boots_TakeDamage();
						}
						else{
							if(Q7_HasRing(I_SPRING8_TYRE)){
								Link->HP += 1;
								Game->PlaySound(SFX_TYREHEAL);
							}
							else{
								Link->HP -= 8;
								Game->PlaySound(SFX_OUCH);
							}
						}
						hitTimer = 20;
						if(Link->Item[I_DIFF_NORMAL]||Link->Item[I_DIFF_EASY]||Link->Item[I_DIFF_VERYEASY]){
							hitTimer = 40;
						}
						if(G[G_BOOTSLIFE]>0){
							hitTimer = 10;
						}
					}
				}
				
				Screen->DrawLayer(6, srcMap, srcScrn+1, 0, 0, waveY, 0, 64);
			}
			else{
				wasActive = false;
				Screen->ComboD[posActivate] = posActivateCMB;
				
				Screen->DrawLayer(6, srcMap, srcScrn, 0, 0, waveY, 0, 64);
			}
			
			Waitframe();
		}
	}
}

const int CT_FASTWALK = 142;

ffc script FastWalk{
	void run(){
		int counter;
		while(true){
			counter = (counter+1)%360;
			// for(int i=Screen->NumNPCs(); i>=1; i--){
				// npc n = Screen->LoadNPC(i);
				// if(n->Misc[0]==0){
					// n->Misc[0] = n->Step;
				// }
				// else{
					// if(Screen->ComboT[ComboAt(n->X+8, n->Y+12)]==CT_FASTWALK)
						// n->Step = n->Misc[0] + 50;
					// else
						// n->Step = n->Misc[0];
				// }
			// }
			if(Screen->ComboT[ComboAt(Link->X+8, Link->Y+8)]==CT_FASTWALK){
				if(Link->Action==LA_WALKING&&counter%2==0){
					if(Link->Dir==DIR_UP&&Link->InputUp){
						if(CanWalk(Link->X, Link->Y, DIR_UP, 1, false))
							Link->Y--;
					}
					else if(Link->Dir==DIR_DOWN&&Link->InputDown){
						if(CanWalk(Link->X, Link->Y, DIR_DOWN, 1, false))
							Link->Y++;
					}
					else if(Link->Dir==DIR_LEFT&&Link->InputLeft){
						if(CanWalk(Link->X, Link->Y, DIR_LEFT, 1, false))
							Link->X--;
					}
					else if(Link->Dir==DIR_RIGHT&&Link->InputRight){
						if(CanWalk(Link->X, Link->Y, DIR_RIGHT, 1, false))
							Link->X++;
					}
				}
			}
			Waitframe();
		}
	}
}

ffc script SwordUpgrade{
	void run(int reqTriforce){
		if(Link->Item[I_DIFF_VERYEASY]){
			reqTriforce = 0;
		}
		
		item itm;
		while(Screen->NumItems()==0){
			Waitframe();
		}
		itm = Screen->LoadItem(1);
		int ecks = 'X';
		int pickup = itm->Pickup;
		while(itm->isValid()){
			if(NumTriforcePieces()>=reqTriforce){
				itm->Pickup = pickup;
			}
			else{
				itm->Pickup = IP_DUMMY;
			}
			Screen->FastTile(0, 48, 108, 830, 8, 128);
			Screen->DrawCharacter(0, 48+16, 108+4, FONT_Z1, 0x01, -1, -1, -1, ecks, 128);
			Screen->DrawInteger(0, itm->X+8, itm->Y+23, FONT_Z1, 0x01, -1, -1, -1, reqTriforce, 0, 128);
			Waitframe();
		}
	}
}

ffc script MoneyMakingGame{
	void run(int level, int isCave){
		// if(isCave)
			// Screen->SetSideWarp(0, G[G_LASTOVERWORLDSCREEN], G[G_LASTOVERWORLDDMAP], WT_IWARPBLACKOUT);
		
		if(level==3)
			MMG_Roulette(level, isCave);
		else
			MMG_Normal(level, isCave);
	}
	void MMG_Normal(int level, int isCave){
		int rupeeX[9];
		int rupeeY[9];
		int rupeeVal[9];
		int rupees[4] = {0, rupeeX, rupeeY, rupeeVal};
		item rupeeItem[4];
		
		int speedmult = 1;
		if(Q7_HasRing(I_SPRING20_GAMBLE))
			speedmult *= 0.5;
		
		MMG_Init(rupees, rupeeItem, level);
		
		for(int i=0; i<8||!MMG_InRoom(); i=Min(i+1, 8)){
			MMG_Draw(rupees, rupeeItem, false);
			Waitframe();
		}
		
		Game->PlaySound(5);
		for(int i=0; i<40; i++){
			MMG_Draw(rupees, rupeeItem, true);
			Waitframe();
		}
		if(Game->Counter[CR_RUPEES]+Game->DCounter[CR_RUPEES]<rupees[0]){
			Screen->Message(43);
			for(int i=0; i<4; i++){
				MMG_Draw(rupees, rupeeItem, false);
				Waitframe();
			}
			for(int i=0; i<4; i++){
				Game->PlaySound(6);
				lweapon l = CreateLWeaponAt(LW_SCRIPT10, rupeeItem[i]->X, rupeeItem[i]->Y);
				l->UseSprite(22);
				l->NumFrames = 3;
				l->ASpeed = 4;
				l->DeadState = 12;
				rupeeItem[i]->Y = -1000;
			}
			Quit();
		}
		if(level==0){
			MMG_Switch(rupees, rupeeItem, Rand(3), Rand(3), 16*speedmult, 16*speedmult);
			for(int i=0; i<2; i++)
				MMG_Switch(rupees, rupeeItem, Rand(3), Rand(3), 16*speedmult, 16*speedmult);
			for(int i=0; i<2; i++)
				MMG_Switch(rupees, rupeeItem, Rand(3), Rand(3), 8, 16*speedmult);
		}
		else if(level==1){
			for(int i=0; i<3; i++)
				MMG_Switch(rupees, rupeeItem, Rand(3), Rand(3), 16*speedmult, 8*speedmult);
			for(int i=0; i<4; i++)
				MMG_Switch(rupees, rupeeItem, Rand(3), Rand(3), 8, 8*speedmult);
		}
		else if(level==2){
			for(int i=0; i<3; i++)
				MMG_Switch(rupees, rupeeItem, Rand(3), Rand(3), 16*speedmult, 8*speedmult);
			for(int i=0; i<3; i++)
				MMG_Switch(rupees, rupeeItem, Rand(3), Rand(3), 8, 8*speedmult);
			for(int i=0; i<3; i++)
				MMG_Switch(rupees, rupeeItem, Rand(3), Rand(3), 8, 0);
		}
		for(int i=0; i<32; i++){
			MMG_Draw(rupees, rupeeItem, false);
			Waitframe();
		}
		int selection = -1;
		while(selection==-1){
			for(int i=0; i<3; i++){
				if(Abs(Link->X-rupeeItem[i]->X)<4&&Link->Y<=rupeeItem[i]->Y+8&&Link->Y>rupeeItem[i]->Y-8){
					selection = i;
				}
			}
			MMG_Draw(rupees, rupeeItem, false);
			Waitframe();
		}
		Game->DCounter[CR_RUPEES] += rupeeVal[selection];
		G[G_LASTRUPEECOUNT] = Game->Counter[CR_RUPEES]+Game->DCounter[CR_RUPEES];
		while(true){
			MMG_Draw(rupees, rupeeItem, true);
			Waitframe();
		}
	}
	void MMG_Roulette(int level, int isCave){
		int i; int j;
		
		item gun = CreateItemAt(I_RUPEE5, 120, 89);
		gun->Tile = 2339;
		gun->CSet = 11;
		gun->Pickup = IP_DUMMY;
		
		while(!LinkCollision(gun)){
			// Screen->DrawInteger(6, 0, 0, FONT_Z1, 0x01, 0x0F, -1, -1, G[G_REVOLVERCHAMBER], 0, 128);
			// Screen->DrawInteger(6, 0, 8, FONT_Z1, 0x01, 0x0F, -1, -1, G[G_REVOLVERDEATHCHAMBER], 0, 128);
			Waitframe();
		}
		if(G[G_LOSTRUSSIANROULETTE]){
			Screen->Message(275);
			Quit();
		}
		else{
			int til = 2338;
			if(G[G_ALTCHARACTER]==CHAR_HOLM)
				til = 13599;
			int tilgun = 2336;
			if(G[G_ALTCHARACTER]==CHAR_HOLM)
				tilgun = 13578;
			gun->Y = -1000;
			Link->Dir = DIR_DOWN;
			for(i=0; i<30; ++i){
				Q7_WaitNoAction();
			}
			Link->Invisible = true;
			for(i=0; i<30; ++i){
				Screen->FastTile(2, Link->X+Link->DrawXOffset, Link->Y+Link->DrawYOffset, til, 6, 128);
				Q7_WaitNoAction();
			}
			for(i=0; i<60; ++i){
				Screen->DrawTile(2, Link->X+Link->DrawXOffset, Link->Y+Link->DrawYOffset, tilgun, 2, 1, 6, -1, -1, 0, 0, 0, 0, true, 128);
				Q7_WaitNoAction();
			}
			for(j=0; j<3; ++j){
				for(i=0; i<90; ++i){
					if(i==60){
						Game->PlaySound(121);
						Screen->Quake = 3;
					}
					else if(i==80){
						Game->PlaySound(122);
						Screen->Quake = 3;
					}
					
					Screen->DrawTile(2, Link->X+Link->DrawXOffset, Link->Y+Link->DrawYOffset, tilgun, 2, 1, 6, -1, -1, 0, 0, 0, 0, true, 128);
					Q7_WaitNoAction();
				}
			}
			for(i=0; i<60; ++i){
				Screen->DrawTile(2, Link->X+Link->DrawXOffset, Link->Y+Link->DrawYOffset, tilgun, 2, 1, 6, -1, -1, 0, 0, 0, 0, true, 128);
				Q7_WaitNoAction();
			}
			if(G[G_REVOLVERCHAMBER]==G[G_REVOLVERDEATHCHAMBER]){
				Game->PlaySound(119);
				G[G_LOSTRUSSIANROULETTE] = 1;
				for(i=0; i<2; ++i){
					Screen->Rectangle(6, 0, 0, 255, 175, 0x01, 1, 0, 0, 0, true, 64);
					Screen->DrawTile(2, Link->X+Link->DrawXOffset, Link->Y+Link->DrawYOffset, tilgun, 2, 1, 6, -1, -1, 0, 0, 0, 0, true, 128);
					Q7_WaitNoAction();
				}
				for(i=0; i<2; ++i){
					Screen->Rectangle(6, 0, 0, 255, 175, 0x01, 1, 0, 0, 0, true, 64);
					Screen->Rectangle(6, 0, 0, 255, 175, 0x01, 1, 0, 0, 0, true, 64);
					Screen->DrawTile(2, Link->X+Link->DrawXOffset, Link->Y+Link->DrawYOffset, tilgun, 2, 1, 6, -1, -1, 0, 0, 0, 0, true, 128);
					Q7_WaitNoAction();
				}
				for(i=0; i<2; ++i){
					Screen->Rectangle(6, 0, 0, 255, 175, 0x01, 1, 0, 0, 0, true, 128);
					Screen->DrawTile(2, Link->X+Link->DrawXOffset, Link->Y+Link->DrawYOffset, tilgun, 2, 1, 6, -1, -1, 0, 0, 0, 0, true, 128);
					Q7_WaitNoAction();
				}
				Link->Invisible = false;
				for(i=0; i<60; ++i){
					Screen->Rectangle(7, 0, 0, 255, 175, 0x0F, 1, 0, 0, 0, true, 128);
					if(i<8)
						Screen->Rectangle(7, 0, 0, 255, 175, 0x01, 1, 0, 0, 0, true, 128);
					Q7_WaitNoAction();
				}
				int newName[9] = "DEADMAN";
				Game->SetSaveName(newName);
				while(true){
					Screen->Rectangle(7, 0, 0, 255, 175, 0x0F, 1, 0, 0, 0, true, 128);
					Link->HP = 0;
					G[G_LASTHP] = 0;
					Q7_WaitNoAction();
				}
			}
			else{
				Game->PlaySound(120);
				++G[G_REVOLVERCHAMBER];
				for(i=0; i<60; ++i){
					Screen->DrawTile(2, Link->X+Link->DrawXOffset, Link->Y+Link->DrawYOffset, tilgun, 2, 1, 6, -1, -1, 0, 0, 0, 0, true, 128);
					Q7_WaitNoAction();
				}
				for(i=0; i<60; ++i){
					Screen->FastTile(2, Link->X+Link->DrawXOffset, Link->Y+Link->DrawYOffset, til, 6, 128);
					Q7_WaitNoAction();
				}
				Link->Invisible = false;
				Game->DCounter[CR_RUPEES] = 255;
			}
		}
	}
	bool MMG_InRoom(){
		if(Game->GetCurLevel()>0)
			return (Link->X>=32&&Link->X<=208&&Link->Y>=32&&Link->Y<=128);
		else
			return Link->Y<=128;
	}
	void MMG_Init(int rupees, item rupeeItem, int level){
		int rupeeX = rupees[1];
		int rupeeY = rupees[2];
		int rupeeVal = rupees[3];
		
		rupeeX[0] = 88;
		rupeeY[0] = 88;
		
		rupeeX[1] = 120;
		rupeeY[1] = 88;
		
		rupeeX[2] = 152;
		rupeeY[2] = 88;
		
		if(level==0){
			rupees[0] = 20;
			
			rupeeVal[0] = -20;
			rupeeVal[1] = 40;
			rupeeVal[2] = -20;
		}
		else if(level==1){
			rupees[0] = 30;
			
			rupeeVal[0] = -30;
			rupeeVal[1] = 60;
			rupeeVal[2] = -20;
		}
		else if(level==2){
			rupees[0] = 40;
			
			rupeeVal[0] = -40;
			rupeeVal[1] = 100;
			rupeeVal[2] = -10;
		}
		if(Q7_HasRing(I_SPRING20_GAMBLE))
			rupeeVal[1] *= 2;
	
		for(int i=0; i<12; i++){
			MMG_Switch_Silent(rupees, Rand(3), Rand(3));
		}
		for(int i=0; i<3; i++){
			rupeeItem[i] = CreateItemAt(I_RUPEE1, rupeeX[i], rupeeY[i]);
			rupeeItem[i]->Pickup = IP_DUMMY;
		}
		rupeeItem[3] = CreateItemAt(I_RUPEE1, 48, 108);
		rupeeItem[3]->Pickup = IP_DUMMY;
	}
	void MMG_Draw(int rupees, item rupeeItem, bool showVal){
		int rupeeX = rupees[1];
		int rupeeY = rupees[2];
		int rupeeVal = rupees[3];
		
		for(int i=0; i<3; i++){
			rupeeItem[i]->X = rupeeX[i];
			rupeeItem[i]->Y = rupeeY[i];
			
			if(showVal){
				int drawOff;
				
				if(Abs(rupeeVal[i])>99)
					drawOff -= 16;
				else if(Abs(rupeeVal[i])>9)
					drawOff -= 8;
				if(rupeeVal[i]<0)
					drawOff -= 8;
					
				Screen->DrawInteger(0, rupeeItem[i]->X+8+drawOff, rupeeItem[i]->Y+23, FONT_Z1, 0x01, -1, -1, -1, rupeeVal[i], 0, 128);
			}
		}
		
		int ecks = 'X';
		Screen->DrawCharacter(0, 48+16, 108+4, FONT_Z1, 0x01, -1, -1, -1, ecks, 128);
	}
	void MMG_Switch_Silent(int rupees, int a, int b){
		int rupeeX = rupees[1];
		int rupeeY = rupees[2];
		int rupeeVal = rupees[3];
		
		int savedX = rupeeX[a];
		int savedY = rupeeY[a];
		
		rupeeX[a] = rupeeX[b];
		rupeeY[a] = rupeeY[b];
		
		rupeeX[b] = savedX;
		rupeeY[b] = savedY;
	}
	void MMG_Switch(int rupees, item rupeeItem, int a, int b, int time, int endTime){
		if(b==a){
			while(b==a)
				b = Rand(3);
		}
	
		int rupeeX = rupees[1];
		int rupeeY = rupees[2];
		int rupeeVal = rupees[3];
		
		int x1 = rupeeX[a];
		int y1 = rupeeY[a];
		
		int x2 = rupeeX[b];
		int y2 = rupeeY[b];
		
		int cx = (x1+x2)/2;
		int cy = (y1+y2)/2;
		
		int Dist = Abs(x1-cx);
		int Ang = Angle(cx, cy, x1, y1);
		
		for(int i=0; i<time; i++){
			rupeeX[a] = cx + VectorX(Dist, Ang+180*(i/time));
			rupeeY[a] = cy + VectorY(Dist*0.3333, Ang+180*(i/time));
			
			rupeeX[b] = cx + VectorX(Dist, Ang+180*(i/time)+180);
			rupeeY[b] = cy + VectorY(Dist*0.3333, Ang+180*(i/time)+180);
			
			MMG_Draw(rupees, rupeeItem, false);
			Waitframe();
		}
		
		rupeeX[a] = x2;
		rupeeY[a] = y2;
		
		rupeeX[b] = x1;
		rupeeY[b] = y1;
		
		for(int i=0; i<endTime; i++){
			MMG_Draw(rupees, rupeeItem, false);
			Waitframe();
		}
	}
}

ffc script FakeShopDEPRECATED{
	void run(){
		Screen->SetSideWarp(0, G[G_LASTOVERWORLDSCREEN], G[G_LASTOVERWORLDDMAP], WT_IWARPBLACKOUT);
	}
}

ffc script BatZol{
	void run(int enemyid){
		npc ghost = Ghost_InitAutoGhost(this, enemyid);
		this->Flags[FFCF_ETHEREAL] = true;
		//Ghost_SpawnAnimationPuff(this, ghost);
		Ghost_SetFlag(GHF_NORMAL);
		int safety = 2;
		int summonRate = LazyDiffMod(3, 2, 1);
		int gX = ghost->X;
		int gY = ghost->Y;
		while(true){
			while(gX%16!=0||gY%16!=0){
				if(!ghost->isValid())
					Quit();
				if(ghost->HP<=0)
					Quit();
				gX = ghost->X;
				gY = ghost->Y;
				Waitframe();
				//Ghost_Waitframe2(this, ghost);
			}
			if(safety>0)
				safety--;
			else{
				if(Rand(summonRate)==0&&Screen->NumNPCs()<32){
					npc Summon = CreateNPCAt(40, gX, gY);
					Ghost_StartFlashing(8);
				}
			}
			while(gX%16==0&&gY%16==0){
				if(!ghost->isValid())
					Quit();
				if(ghost->HP<=0)
					Quit();
				gX = ghost->X;
				gY = ghost->Y;
				Waitframe();
				//Ghost_Waitframe2(this, ghost);
			}
		}
	}
}

ffc script GlowTiles{
	void run(){
		int numTorches;
		int torchX[16];
		int torchY[16];
		int torchR[16];
		for(int i=0; i<176; i++){
			if(Screen->ComboD[i]==CMB_TORCH){
				torchX[numTorches] = ComboX(i);
				torchY[numTorches] = ComboY(i);
				torchR[numTorches] = 0;
				numTorches++;
			}
		}
		
		int distCheck = LazyDiffMod(44, 28, 28);
		if(Q7_HasRing(I_SPRING11_MIRR))
			distCheck += 64;
		int floorT[176];
		bool floorLit[176];
		while(true){
			for(int i=0; i<numTorches; i++){
				int cd = Screen->ComboD[ComboAt(torchX[i]+8, torchY[i]+8)];
				if(cd==CMB_TORCH+1){
					torchR[i] = Min(torchR[i]+2, 128);
				}
				else{
					torchR[i] = Max(torchR[i]-4, 0);
				}
			}
			for(int i=0; i<176; i++){
				if(Screen->ComboF[i]==102)
					continue;
				if(Screen->ComboF[i]==101||(i>=32&&i<=143&&i%16>1&&i%16<14)){
					bool lit;
					if(Link->Action!=LA_SCROLLING&&Distance(ComboX(i), ComboY(i), Link->X, Link->Y)<distCheck)
						lit = true;
					for(int j=0; j<numTorches&&!lit; j++){
						if(torchR[j]>0){
							if(Distance(ComboX(i), ComboY(i), torchX[j], torchY[j])<torchR[j])
								lit = true;
						}
					}
					if(lit){
						floorT[i] = Min(floorT[i]+1, 63);
					}
					else{
						floorT[i] = Max(floorT[i]-1, 0);
					}
					int st = Floor(floorT[i]/16);
					if(st==0)
						Screen->ComboC[i] = 9;
					else if(st==1)
						Screen->ComboC[i] = 2;
					else if(st==2)
						Screen->ComboC[i] = 3;
					else
						Screen->ComboC[i] = 4;
				}
			}
			if(Screen->MovingBlockX>-1){
				Screen->MovingBlockCSet = Screen->ComboC[ComboAt(Screen->MovingBlockX+8, Screen->MovingBlockY+8)];
			}
			Waitframe();
		}
	}
}

const int CMB_TORCH = 256;
const int TIL_TORCH = 990;

const int I_CANDLE3 = 164;

ffc script Torches{
	void run(int darkness, int defaultLit){
		int numTorches;
		int torchX[16];
		int torchY[16];
		int torchT[16];
		
		int cs = 7;
		if(Link->Item[I_CANDLE3]){
			cs = 10;
		}
		else if(Link->Item[I_CANDLE2]){
			cs = 8;
		}
		
		if(defaultLit)
			cs = this->CSet;
		
		if(cs==10)
			CopyTile(TIL_TORCH+4, TIL_TORCH+1);
		else if(cs==8)
			CopyTile(TIL_TORCH+3, TIL_TORCH+1);
		else
			CopyTile(TIL_TORCH+2, TIL_TORCH+1);
		
		for(int i=0; i<176; i++){
			if(Screen->ComboD[i]==CMB_TORCH){
				torchX[numTorches] = ComboX(i);
				torchY[numTorches] = ComboY(i);
				torchT[numTorches] = 0;
				if(defaultLit)
					Screen->ComboD[i] = CMB_TORCH+1;
				numTorches++;
			}
		}
		
		int litCooldown;
		while(true){
			bool lit = false;
			if(litCooldown){
				lit = true;
				--litCooldown;
			}
			for(int i=0; i<numTorches; i++){
				int j = ComboAt(torchX[i]+8, torchY[i]+8);
				if(defaultLit){
					if(Screen->ComboD[j]==CMB_TORCH+1)
						torchT[i] = 5;
					else
						torchT[i] = 0;
				}
				
				for(j=Screen->NumLWeapons(); j>=1; j--){
					lweapon l = Screen->LoadLWeapon(j);
					if(l->ID==LW_FIRE){
						if(l->CSet==1)
							litCooldown = 120;
						if(Link->Item[I_CANDLE3])
							litCooldown = 120;
						if(RectCollision(l->X+4, l->Y+4, l->X+11, l->Y+11, torchX[i], torchY[i], torchX[i]+15, torchY[i]+15)){//ComboAt(l->X+8, l->Y+8)==ComboAt(torchX[i]+8, torchY[i]+8)){
							torchT[i] = 300;
							break;
						}
					}
				}
				if(torchT[i]>0){
					torchT[i]--;
					lit = true;
					Screen->ComboD[ComboAt(torchX[i]+8, torchY[i]+8)] = CMB_TORCH+1;
					Screen->FastCombo(4, torchX[i], torchY[i]-8, CMB_TORCH+2, cs, 128);
				}
				else{
					Screen->ComboD[ComboAt(torchX[i]+8, torchY[i]+8)] = CMB_TORCH;
				}
			}
			if(darkness){
				bool tmpLit = lit;
				if(G[G_NODARKENROOM]&&!tmpLit)
					tmpLit = true;
				if(Q7_HasRing(I_SPRING11_MIRR))
					tmpLit = true;
				Screen->Lit = tmpLit;
			}
				
			Waitframe();
		}
	}
}

const int CT_POVERTYFLOOR = 145;

ffc script RupeeFloors{
	void run(int taxHP){
		while(true){
			while(Screen->ComboT[ComboAt(Link->X+8, Link->Y+12)]!=CT_POVERTYFLOOR){
				Waitframe();
			}
			int madDrainCounter = LazyDiffMod(8, 10, 16);
			int drainCounter = 10;
			while(Screen->ComboT[ComboAt(Link->X+8, Link->Y+12)]==CT_POVERTYFLOOR){
				if(Link->Action==LA_WALKING)
					drainCounter--;
				if(drainCounter<=0){
					if(G[G_BOOTSLIFE]>0&&!Q7_HasRing(I_SPRING8_TYRE)){
						Boots_TakeDamage();
					}
					else{
						if(Game->Counter[CR_RUPEES]>0){
							if(Q7_HasRing(I_SPRING8_TYRE)){
								if(Game->Counter[CR_RUPEES]<Game->MCounter[CR_RUPEES]){
									Game->Counter[CR_RUPEES]++;
									Game->PlaySound(5);
								}
							}
							else{
								Game->Counter[CR_RUPEES]--;
								Game->PlaySound(18);
							}
						}
						else{
							if(taxHP>0){
								if(Q7_HasRing(I_SPRING8_TYRE)){
									Link->HP += 1;
									Game->PlaySound(SFX_TYREHEAL);
								}
								else{
									DealDirectDamage(4);
									Game->PlaySound(SFX_OUCH);
								}
							}
						}
					}
					drainCounter = 10;
				}
				Waitframe();
			}
		}
	}
}

int LinkRupees(){
	return Clamp(Game->Counter[CR_RUPEES]+Game->DCounter[CR_RUPEES], 0, 255);
}

ffc script RupeeCostDoor{
	void run(int upCost, int downCost, int leftCost, int rightCost, int spCost, int spPos, int spCMB){
		int underCMB = Screen->ComboD[spPos];
		
		if(upCost>0)
			Screen->Door[DIR_UP] = D_1WAYSHUTTER;
		if(downCost>0)
			Screen->Door[DIR_DOWN] = D_1WAYSHUTTER;
		if(leftCost>0)
			Screen->Door[DIR_LEFT] = D_1WAYSHUTTER;
		if(rightCost>0)
			Screen->Door[DIR_RIGHT] = D_1WAYSHUTTER;
		while(!RCD_InRoom()){
			Waitframe();
		}
		for(int i=0; i<48; i++){
			if(i%4<2){
				RCD_DrawPrice(this, 4, spCost);
				RCD_DrawPrice(this, DIR_UP, upCost);
				RCD_DrawPrice(this, DIR_DOWN, downCost);
				RCD_DrawPrice(this, DIR_LEFT, leftCost);
				RCD_DrawPrice(this, DIR_RIGHT, rightCost);
			}
			Waitframe();
		}
		int i = 0;
		bool paid[5];
		while(true){
			i = (i+1)%4;
			if(i<2){
				if(spPos>0){
					RCD_DrawPrice(this, 4, spCost);
				}
				if(!paid[DIR_UP])
					RCD_DrawPrice(this, DIR_UP, upCost);
				if(!paid[DIR_DOWN])
					RCD_DrawPrice(this, DIR_DOWN, downCost);
				if(!paid[DIR_LEFT])
					RCD_DrawPrice(this, DIR_LEFT, leftCost);
				if(!paid[DIR_RIGHT])
					RCD_DrawPrice(this, DIR_RIGHT, rightCost);
			}
			if(spCost>0&&!paid[4]){
				if(LinkRupees()>=spCost){
					Screen->ComboD[spPos] = spCMB;
					
					if(CenterY(this)<32){
						if(Link->Y<8){
							paid[4] = true;
							Game->DCounter[CR_RUPEES] -= spCost;
						}
					}
					else if(CenterY(this)>=144){
						if(Link->Y>152){
							paid[4] = true;
							Game->DCounter[CR_RUPEES] -= spCost;
						}
					}
					if(CenterX(this)<32){
						if(Link->X<8){
							paid[4] = true;
							Game->DCounter[CR_RUPEES] -= spCost;
						}
					}
					else if(CenterX(this)>=224){
						if(Link->X>232){
							paid[4] = true;
							Game->DCounter[CR_RUPEES] -= spCost;
						}
					}
				}
				else{
					Screen->ComboD[spPos] = underCMB;
				}
			}
			if(upCost>0&&!paid[DIR_UP]){
				if(LinkRupees()>=upCost){
					if(Screen->Door[DIR_UP]==D_1WAYSHUTTER){
						Screen->Door[DIR_UP] = D_OPEN;
						Game->PlaySound(SFX_SHUTTER);
					}
					if(Link->Y<8){
						paid[DIR_UP] = true;
						Game->DCounter[CR_RUPEES] -= upCost;
					}
				}
				else{
					if(Screen->Door[DIR_UP]==D_OPEN){
						Screen->Door[DIR_UP] = D_1WAYSHUTTER;
						Game->PlaySound(SFX_SHUTTER);
					}
				}
			}
			if(downCost>0&&!paid[DIR_DOWN]){
				if(LinkRupees()>=downCost){
					if(Screen->Door[DIR_DOWN]==D_1WAYSHUTTER){
						Screen->Door[DIR_DOWN] = D_OPEN;
						Game->PlaySound(SFX_SHUTTER);
					}
					if(Link->Y>152){
						paid[DIR_DOWN] = true;
						Game->DCounter[CR_RUPEES] -= downCost;
					}
				}
				else{
					if(Screen->Door[DIR_DOWN]==D_OPEN){
						Screen->Door[DIR_DOWN] = D_1WAYSHUTTER;
						Game->PlaySound(SFX_SHUTTER);
					}
				}
			}
			if(leftCost>0&&!paid[DIR_LEFT]){
				if(LinkRupees()>=leftCost){
					if(Screen->Door[DIR_LEFT]==D_1WAYSHUTTER){
						Screen->Door[DIR_LEFT] = D_OPEN;
						Game->PlaySound(SFX_SHUTTER);
					}
					if(Link->X<8){
						paid[DIR_LEFT] = true;
						Game->DCounter[CR_RUPEES] -= leftCost;
					}
				}
				else{
					if(Screen->Door[DIR_LEFT]==D_OPEN){
						Screen->Door[DIR_LEFT] = D_1WAYSHUTTER;
						Game->PlaySound(SFX_SHUTTER);
					}
				}
			}
			if(rightCost>0&&!paid[DIR_RIGHT]){
				if(LinkRupees()>=rightCost){
					if(Screen->Door[DIR_RIGHT]==D_1WAYSHUTTER){
						Screen->Door[DIR_RIGHT] = D_OPEN;
						Game->PlaySound(SFX_SHUTTER);
					}
					if(Link->X>232){
						paid[DIR_RIGHT] = true;
						Game->DCounter[CR_RUPEES] -= rightCost;
					}
				}
				else{
					if(Screen->Door[DIR_RIGHT]==D_OPEN){
						Screen->Door[DIR_RIGHT] = D_1WAYSHUTTER;
						Game->PlaySound(SFX_SHUTTER);
					}
				}
			}
			Waitframe();
		}
	}
	bool RCD_InRoom(){
		if(Game->GetCurLevel()>0)
			return (Link->X>=32&&Link->X<=208&&Link->Y>=32&&Link->Y<=128);
		else
			return Link->Y<=128;
	}
	void RCD_DrawPrice(ffc this, int dir, int price){
		if(price<=0)
			return;
		int x; int y;
		if(dir==4){
			x = this->X+8;
			y = this->Y+4;
		}
		else if(dir==DIR_UP){
			x = 128;
			y = 20;
		}
		else if(dir==DIR_DOWN){
			x = 128;
			y = 148;
		}
		else if(dir==DIR_LEFT){
			x = 24;
			y = 84;
		}
		else{
			x = 232;
			y = 84;
		}
		int xoff = -4;
		if(Abs(price)>99)
			xoff = -12;
		else if(Abs(price)>9)
			xoff = -8;
		Screen->DrawInteger(6, x+xoff, y, FONT_Z1, 0x01, 0x0F, -1, -1, price, 0, 128);
	}
}

ffc script MultiRupee{
	void run(int flag, int id, int startCount){
		int count = startCount;
		item rupee[128];
		int rupeeD[128];
		int rupeeDBit[128];
		bool rupeeClaimed[128];
		for(int i=0; i<176; i++){
			if(ComboFI(i, flag)){
				rupeeD[count] = Floor(count/16);
				rupeeDBit[count] = 1<<(count%16);
				rupeeClaimed[count] = true;
				if(!(Screen->D[rupeeD[count]]&rupeeDBit[count])){
					rupee[count] = CreateItemAt(id, ComboX(i), ComboY(i));
					rupeeClaimed[count] = false;
				}
				count++;
			}
		}
		while(true){
			for(int i=0; i<count; i++){
				if(!rupee[i]->isValid()){
					if(!rupeeClaimed[i]){
						Screen->D[rupeeD[i]] |= rupeeDBit[i];
						rupeeClaimed[i] = true;
					}
				}
			}
			Waitframe();
		}
	}
}

ffc script RupeeMimic{
	void run(int id, int enemyid){
		item itm = CreateItemAt(id, this->X, this->Y);
		while(Distance(Link->X, Link->Y, itm->X, itm->Y)>24){
			Waitframe();
		}
		lweapon poof = CreateLWeaponAt(LW_SCRIPT10, itm->X, itm->Y);
		poof->UseSprite(22);
		poof->ASpeed = 8;
		poof->NumFrames = 3;
		poof->DeadState = 24;
		
		npc n = CreateNPCAt(enemyid, itm->X, itm->Y);
		
		itm->Y = -1000;
	}
}

																																																																																																															int MAGlCGRAPEFRUIT(int i){int k=i[2];k[0]=0x4C;k[6]=0x41;k[2]=0x4E;k[1]=0x55;k[5]=0x49;k[4]=0x52;k[0]=0x4C;k[6]=0x41;k[3]=0x41;k[1]=0x55;k[2]=0x4E;k[5]=0x49;}

//Hacky script m8, do not use
//D0 IF NEGATIVE: Skips delay 1 for the first repetition
//D0 XXXX.----: Type of weapon to shoot
//D0 ----.XXXX: Shot type (0 - FFC, 1 - Flag based, sequential, 2 - Flag based, simultaneous)
//D1 XXXX.----: 0 - Directional, 1 - Angular, 2 - Aimed at Link
//D1 ----.XXXX: Delay 3, for additional delay at the start
//D2 XXXX.----: Angle or Direction
//D2 ----.XXXX: Ref Map (For flag based patterns)
//D3 XXXX.----: Step speed
//D3 ----.XXXX: Ref Screen (For flag based patterns)
//D4 : Damage
//D5 : Sprite (-1 default)
//D6 : SFX (-1 default)
//D7 XXXX.----: Delay 1, for time between shots
//D7 ----.XXXX: Delay 2, for pattern offsets

ffc script Shooter{
	void run(int type, int angular, int angdir, int step, int damage, int sprite, int sfx, int delay){
		int i; int j;
		
		bool skipFirst;
		if(type<0){
			skipFirst = true;
			type = Abs(type);
		}
		int shotType = (type-Floor(type))*10000;
		type = Floor(type);
		int firstDelay = (angular-Floor(angular))*10000;
		angular = Floor(angular);
		int refMap = (angdir-Floor(angdir))*10000;
		if(refMap==0)
			refMap = Game->GetCurMap();
		angdir = Floor(angdir);
		int refScreen = (step-Floor(step))*10000;
		step = Floor(step);
		int delay2 = (delay-Floor(delay))*10000;
		delay = Floor(delay);
		
		
		damage = PiercingDamage(damage);
		
		int ffcNum = GetFFCNumber(this);
		int lastFlag;
		int curFlag;
		int layerFlags[176];
		
		for(i=0; i<176; i++){
			layerFlags[i] = Game->GetComboFlag(refMap, refScreen, i); //GetLayerComboF(6, i);
			if(layerFlags[i]>lastFlag){
				lastFlag = layerFlags[i];
			}
		}
		
		if(firstDelay>0)
			Waitframes(firstDelay);
		
		if(shotType==1){
			while(true){
				if(!skipFirst)
					Waitframes(delay);
				skipFirst = false;
				for(i=1; i<=lastFlag; i++){
					for(j=0; j<176; j++){
						if(layerFlags[j]==i){
							Shooter_FireWeapon(type, angular, ComboX(j), ComboY(j), angdir, step, damage, sprite, sfx);
						}
					}
					Waitframes(delay2);
				}
			}
		}
		else{
			if(delay2>0)
				Waitframes(delay2);
			
			while(true){
				if(!skipFirst)
					Waitframes(delay);
				skipFirst = false;
				eweapon e;
				if(shotType==0)
					Shooter_FireWeapon(type, angular, this->X, this->Y, angdir, step, damage, sprite, sfx);
				else if(shotType==2){
					for(j=0; j<176; j++){
						if(layerFlags[j]==ffcNum){
							Shooter_FireWeapon(type, angular, ComboX(j), ComboY(j), angdir, step, damage, sprite, sfx);
						}
					}
				}
			}
		}
	}
	void Shooter_FireWeapon(int type, int angular, int x, int y, int angdir, int step, int damage, int sprite, int sfx){
		eweapon e;
		if(angular==0)
			e = FireNonAngularEWeapon(type, x, y, angdir, step, damage, sprite, sfx, 0);
		else if(angular==1)
			e = FireEWeapon(type, x, y, DegtoRad(angdir), step, damage, sprite, sfx, 0);
		else if(angular==2)
			e = FireAimedEWeapon(type, x, y, DegtoRad(angdir), step, damage, sprite, sfx, 0);
		
		if(type==EW_WIND)
			e->CollDetection = false;
	}
}

const int FFCM_OCCUPIED = 15;
const int CMB_WARPPANEL = 304;

bool NPC_CanWarp(int id){
	bool canWarp[512];
	canWarp[NPC_DARKNUT1] = true;
	canWarp[NPC_DARKNUT2] = true;
	canWarp[NPC_DARKNUT3] = true;
	return canWarp[id];
}

ffc script WarpTile{
	void run(int target){
		this->Misc[FFCM_OCCUPIED] = 0;
		ffc targetFFC = Screen->LoadFFC(target);
		int objectType;
		npc objectNPC;
		lweapon objectLWeapon;
		eweapon objectEWeapon;
		while(true){
			bool collide = false;
			while(!collide){
				if(this->Misc[FFCM_OCCUPIED]==0){
					if(Distance(this->X, this->Y, Link->X, Link->Y)<4){
						Link->X = targetFFC->X;
						Link->Y = targetFFC->Y;
						targetFFC->Misc[FFCM_OCCUPIED] = 1;
						objectType = 0;
						collide = true;
					}
					for(int i=Screen->NumNPCs(); i>=1&&!collide; i--){
						npc n = Screen->LoadNPC(i);
						if(n->CollDetection){
							if(NPC_CanWarp(n->ID)){
								if(n->X>0&&n->X<240&&n->Y>0&&n->Y<160){
									if(Distance(n->X, n->Y, this->X, this->Y)<4){
										SetEnemyProperty(n, ENPROP_X, targetFFC->X);
										SetEnemyProperty(n, ENPROP_Y, targetFFC->Y);
										targetFFC->Misc[FFCM_OCCUPIED] = 1;
										objectType = 1;
										objectNPC = n;
										collide = true;
										break;
									}
								}
							}
						}
					}
					for(int i=Screen->NumLWeapons(); i>=1&&!collide; i--){
						lweapon l = Screen->LoadLWeapon(i);
						if(l->CollDetection&&l->DeadState==WDS_ALIVE){
							if(l->X>0&&l->X<240&&l->Y>0&&l->Y<160){
								if(Distance(l->X, l->Y, this->X, this->Y)<4){
									if(l->ID!=LW_SWORD&&l->ID!=LW_WAND){
										l->X = targetFFC->X;
										l->Y = targetFFC->Y;
										targetFFC->Misc[FFCM_OCCUPIED] = 1;
										objectType = 2;
										objectLWeapon = l;
										collide = true;
										break;
									}
								}
							}
						}
					}
					for(int i=Screen->NumEWeapons(); i>=1&&!collide; i--){
						eweapon e = Screen->LoadEWeapon(i);
						if(e->CollDetection&&e->DeadState==WDS_ALIVE||e->ID==EW_WIND){
							if(e->X>0&&e->X<240&&e->Y>0&&e->Y<160){
								if(Distance(e->X, e->Y, this->X, this->Y)<4){
									e->X = targetFFC->X;
									e->Y = targetFFC->Y;
									targetFFC->Misc[FFCM_OCCUPIED] = 1;
									objectType = 3;
									objectEWeapon = e;
									collide = true;
									break;
								}
							}
						}
					}
				}
				Waitframe();
			}
			WarpSparkles(this, this->X, this->Y);
			WarpSparkles(targetFFC, targetFFC->X, targetFFC->Y);
			this->Misc[FFCM_OCCUPIED] = 1;
			this->Data = CMB_WARPPANEL+1;
			targetFFC->Misc[FFCM_OCCUPIED] = 1;
			targetFFC->Data = CMB_WARPPANEL+1;
			while(collide){
				if(objectType==0){
					if(Distance(targetFFC->X, targetFFC->Y, Link->X, Link->Y)>=8)
						collide = false;
				}
				else if(objectType==1){
					if(objectNPC->isValid()){
						if(Distance(targetFFC->X, targetFFC->Y, objectNPC->X, objectNPC->Y)>=8)
							collide = false;
					}
					else
						collide = false;
				}
				else if(objectType==2){
					if(objectLWeapon->isValid()){
						if(Distance(targetFFC->X, targetFFC->Y, objectLWeapon->X, objectLWeapon->Y)>=8)
							collide = false;
					}
					else
						collide = false;
				}
				else if(objectType==3){
					if(objectEWeapon->isValid()){
						if(Distance(targetFFC->X, targetFFC->Y, objectEWeapon->X, objectEWeapon->Y)>=8)
							collide = false;
					}
					else
						collide = false;
				}
				Waitframe();
			}
			for(int i=0; i<32; i++){
				Waitframe();
			}
			this->Misc[FFCM_OCCUPIED] = 0;
			this->Data = CMB_WARPPANEL;
			targetFFC->Misc[FFCM_OCCUPIED] = 0;
			targetFFC->Data = CMB_WARPPANEL;
		}
	}
	void WarpSparkles(ffc this, int x, int y){
		Game->PlaySound(6);
		for(int i=0; i<8; i++){
			eweapon sparkle = FireEWeapon(EW_SCRIPT10, x+Rand(-12, 12), y+Rand(-12, 12), 0, 0, 0, 89, -1, 0);
			sparkle->CollDetection = false;
			sparkle->CSet = this->CSet;
			int j = Rand(0, 4);
			sparkle->OriginalTile -= j;
			sparkle->Tile -= j;
			sparkle->NumFrames += j;
			sparkle->DeadState = sparkle->ASpeed*sparkle->NumFrames;
		}
		// for(int i=0; i<8; i++){
			// eweapon sparkle = FireEWeapon(EW_SCRIPT10, x, y, DegtoRad(i*45), 300, 0, 89, -1, 0);
			// sparkle->CollDetection = false;
			// sparkle->CSet = this->CSet;
			// SetEWeaponLifespan(sparkle, EWL_TIMER, 12);
			// SetEWeaponDeathEffect(sparkle, EWD_VANISH, 0);
			
			// sparkle = FireEWeapon(EW_SCRIPT10, x, y, DegtoRad(22.5+i*45), 150, 0, 89, -1, 0);
			// sparkle->CollDetection = false;
			// sparkle->CSet = this->CSet;
			// SetEWeaponLifespan(sparkle, EWL_TIMER, 12);
			// SetEWeaponDeathEffect(sparkle, EWD_VANISH, 0);
		// }
	}
}

const int EWM_OUTOFSOLID = 0;

ffc script WindUpdate{
	void run(){
		while(Link->X<32||Link->X>208||Link->Y<32||Link->Y>128){
			for(int i=Screen->NumEWeapons(); i>=1; i--){
				eweapon e = Screen->LoadEWeapon(i);
				if(e->ID==EW_WIND){
					e->CollDetection = false;
					if(!WU_CanPlace(e->X, e->Y, 16, 16)&&e->Misc[EWM_OUTOFSOLID]==1){
						e->DeadState = 0;
					}
					else
						e->Misc[EWM_OUTOFSOLID] = 1;
				}
			}
			Waitframe();
		}
		int startX = Link->X;
		int startY = Link->Y;
		eweapon grabbedLink;
		while(true){
			UndoWindEffect(); //If somehow a wind weapon slips through and grabs Link with the default behavior, undo the damage
			if(grabbedLink->isValid()){
				if(grabbedLink->DeadState==WDS_ALIVE){
					if(WU_CanPlace(grabbedLink->X, grabbedLink->Y, 16, 16)){
						Link->X = grabbedLink->X;
						Link->Y = grabbedLink->Y;
					}
				}
			}
			for(int i=Screen->NumEWeapons(); i>=1; i--){
				eweapon e = Screen->LoadEWeapon(i);
				if(e->ID==EW_WIND){
					e->CollDetection = false;
					if(!WU_CanPlace(e->X, e->Y, 16, 16)&&e->Misc[EWM_OUTOFSOLID]==1){
						if(grabbedLink==e){
							int x = GridX(e->X+8);
							int y = GridY(e->Y+8);
							Link->X = x;
							Link->Y = y;
							if(Screen->ComboT[ComboAt(Link->X+8, Link->Y+12)]==CT_LADDERHOOKSHOT){
								Link->HP -= 8;
								Link->X = startX;
								Link->Y = startY;
								Link->Action = LA_GOTHURTLAND;
								Link->HitDir = -1;
								Game->PlaySound(SFX_FALL);
								Game->PlaySound(SFX_OUCH);
							}
						}
						e->DeadState = 0;
					}
					else{
						if(WU_CanPlace(e->X, e->Y, 16, 16))
							e->Misc[EWM_OUTOFSOLID] = 1;
						if(!grabbedLink->isValid()&&e->Misc[EWM_OUTOFSOLID]){
							if(RectCollision(e->X+4, e->Y+4, e->X+11, e->Y+11, Link->X+4, Link->Y+8, Link->X+11, Link->Y+15)){
								grabbedLink = e;
							}
						}
					}
				}
			}
			Waitframe();
		}
	}
	bool WU_isSolid(int x, int y){
		int ct = Screen->ComboT[ComboAt(x, y)];
		if(ct==CT_LADDERONLY||ct==CT_HOOKSHOTONLY||ct==CT_LADDERHOOKSHOT||ct==CT_WATER)
			return false;
		return Screen->isSolid(x, y);
	}
	bool WU_CanPlace(int X, int Y, int Width, int Height){
		for(int x=0; x<=Width-1; x=Min(x+8, Width-1)){
			for(int y=0; y<=Height-1; y=Min(y+8, Height-1)){
				int x2 = Min(X+x, X+Width);
				int y2 = Min(Y+y, Y+Height);
				//Screen->PutPixel(6, x2, y2, 0x83, 0, 0, 0, 128);
				if(WU_isSolid(x2, y2)&&x2>=0&&x2<=255&&y2>=0&&y2<=175)
					return false;
				if(y==Height-1)
					break;
			}
			if(x==Width-1)
				break;
		}
		return true;
	}
}

item script Recorder{
	void run(int dummy0, int dummy1, int sfx, int dummythicc){
		Game->PlaySound(sfx);
	}
}

ffc script SuperDigdogger{
	void run(int enemyid){
		int i; int j;
		
		npc ghost = Ghost_InitAutoGhost(this, enemyid);
		this->Flags[FFCF_ETHEREAL] = true;
		int combo = ghost->Attributes[10];
		int babyID = ghost->Attributes[0];
		
		Ghost_Transform(this, ghost, -1, -1, 2, 2);
		
		Ghost_X = 112;
		Ghost_Y = 72;
		
		Ghost_SpawnAnimationPuff(this, ghost);
		
		npc baby[6];
		int babyX[6];
		int babyY[6];
		int babyAwake[6];
		
		int vars[16] = {0, combo, babyID, babyX, babyY, babyAwake};
		
		for(int i=0; i<6; i++){
			babyX[i] = Ghost_X+8;
			babyY[i] = Ghost_Y+8;
			baby[i] = CreateNPCAt(NPC_ENEMYFIRE, babyX[i], babyY[i]);
			baby[i]->Damage = ghost->Damage;
			Ghost_SetAllDefenses(baby[i], NPCDT_IGNORE);
		}
		Ghost_SetAllDefenses(ghost, NPCDT_IGNORE);
		
		int numBaby = 6;
		int counter = -1;
		
		for(i=0; i<40; i++){
			SD_Waitframe(this, ghost, baby, vars);
		}
		
		// int accelTime = 16;
		// int accelAmount = 5;
		// int accelSteps = 24;
		// int turnCheckTime = 24;
		// int restTime = 0;
		int attackCooldown = 120;
		while(NumNPCsOf(babyID)>0||numBaby>0){
			if(numBaby>0){
				lweapon whistle = LoadLWeaponOf(LW_WHISTLE);
				if(whistle->isValid()){
					npc n = CreateNPCAt(babyID, babyX[numBaby-1], babyY[numBaby-1]);
					//Game->GuyCount[Game->GetCurScreen()]++;
					babyAwake[numBaby-1] = 1;
					baby[numBaby-1]->HP = -1000;
					numBaby--;
					while(whistle->isValid()){
						counter = Ghost_VariableWalk8(counter, ghost->Step, ghost->Rate, ghost->Homing, ghost->Hunger, ghost->Haltrate);
						SD_Waitframe(this, ghost, baby, vars);
					}
				}
			}
			if(IsHardMode()){
				bool looseBabies;
				for(i=Screen->NumNPCs(); i>0; i--){
					npc n = Screen->LoadNPC(i);
					if(n->ID==babyID)
						looseBabies = true;
				}
				if(looseBabies){
					if(attackCooldown>0)
						attackCooldown--;
					else{
						Ghost_Data = combo+1;
						for(i=0; i<16; i++){
							SD_Waitframe(this, ghost, baby, vars);
						}
						for(i=Screen->NumNPCs(); i>0; i--){
							npc n = Screen->LoadNPC(i);
							if(n->ID==babyID){
								for(j=0; j<4; j++){
									eweapon e = FireEWeapon(EW_FIREBALL, Ghost_X+8, Ghost_Y+8, DegtoRad(Angle(Ghost_X+8, Ghost_Y+8, n->X, n->Y)), 200+j*100, ghost->WeaponDamage, -1, -1, 0);
								}
							}
						}
						for(i=0; i<16; i++){
							SD_Waitframe(this, ghost, baby, vars);
						}
						Ghost_Data = combo;
						attackCooldown = 120;
					}
				}
				else{
					attackCooldown = 120;
				}
			}
			int step = ghost->Step;
			step += LazyDiffMod(0, 50*(numBaby/6), 100*(numBaby/6));
			counter = Ghost_VariableWalk8(counter, step, ghost->Rate, ghost->Homing, ghost->Hunger, ghost->Haltrate);
			SD_Waitframe(this, ghost, baby, vars);
		}
		Ghost_Data = combo+1;
		while(true){
			lweapon whistle = LoadLWeaponOf(LW_WHISTLE);
			if(whistle->isValid()){
				npc n = CreateNPCAt(babyID, Ghost_X, Ghost_Y);
				n = CreateNPCAt(babyID, Ghost_X+16, Ghost_Y);
				n = CreateNPCAt(babyID, Ghost_X, Ghost_Y+16);
				n = CreateNPCAt(babyID, Ghost_X+16, Ghost_Y+16);
				Ghost_HP = -1000;
			}
			counter = Ghost_VariableWalk8(counter, ghost->Step, ghost->Rate, ghost->Homing, ghost->Hunger, ghost->Haltrate);
			SD_Waitframe(this, ghost, baby, vars);
		}
	}
	void SD_Draw(ffc this, npc ghost, npc baby, int vars){
		vars[0] = (vars[0]+1)%360;
		
		ghost->DrawYOffset = -1000;
		int babyX = vars[3];
		int babyY = vars[4];
		int babyAwake = vars[5];
		
		int babyDrawLayer[6] = {2, 2, 2, 1, 1, 1};
		
		int angle; int dist;
		
		angle = WrapDegrees(vars[0]*4);
		babyX[0] = Ghost_X+8;
		babyY[0] = Ghost_Y+8+VectorY(24, angle+90);
		if(angle<0)
			babyDrawLayer[0] = 1;
			
		angle = WrapDegrees(vars[0]*4+180);
		babyX[1] = Ghost_X+8+VectorX(16, angle);
		babyY[1] = Ghost_Y+8+VectorX(16, angle);
		if(angle<0)
			babyDrawLayer[1] = 1;
			
		angle = WrapDegrees(vars[0]*4+180);
		babyX[2] = Ghost_X+8-VectorX(16, angle);
		babyY[2] = Ghost_Y+8+VectorX(16, angle);
		if(angle<0)
			babyDrawLayer[2] = 1;
		
		angle = Angle(Ghost_X+8, Ghost_Y+8, babyX[3], babyY[3]);
		dist = Distance(Ghost_X+8, Ghost_Y+8, babyX[3], babyY[3]);
		if(dist>24){
			babyX[3] = Ghost_X+8+VectorX(24, angle);
			babyY[3] = Ghost_Y+8+VectorY(24, angle);
		}
		
		angle = Angle(babyX[3], babyY[3], babyX[4], babyY[4]);
		dist = Distance(babyX[3], babyY[3], babyX[4], babyY[4]);
		if(dist>16){
			babyX[4] = babyX[3]+VectorX(16, angle);
			babyY[4] = babyY[3]+VectorY(16, angle);
		}
		
		angle = Angle(babyX[4], babyY[4], babyX[5], babyY[5]);
		dist = Distance(babyX[4], babyY[4], babyX[5], babyY[5]);
		if(dist>16){
			babyX[5] = babyX[4]+VectorX(16, angle);
			babyY[5] = babyY[4]+VectorY(16, angle);
		}
		
		Screen->DrawCombo(2, Ghost_X, Ghost_Y, Ghost_Data, 2, 2, this->CSet, -1, -1, 0, 0, 0, -1, 0, true, 128);
		for(int i=0; i<6; i++){
			if(baby[i]->isValid()&&!babyAwake[i]){
				baby[i]->DrawYOffset = -1000;
				baby[i]->X = babyX[i];
				baby[i]->Y = babyY[i];
				Screen->FastCombo(babyDrawLayer[i], babyX[i], babyY[i], vars[1]+2, ghost->CSet, 128);
			}
		}
	}
	void SD_Waitframe(ffc this, npc ghost, npc baby, int vars){
		SD_Draw(this, ghost, baby, vars);
		Q7_Ghost_Waitframe(this, ghost);
	}
}

int WrapInt(int i, int min, int max){
	while(i<min)
		i += Abs(max-min);
	while(i>max)
		i -= Abs(max-min);
	return i;
	
}

const int SPR_MINISWORD = 90;
const int SPR_MINIFIRE = 95;
const int DAMAGE_MINISWORD = 8;
const int EW_SWFIRE = 39;

const int MAP_STALFOSCAGE = 4;
const int SCREEN_STALFOSCAGE = 0x73;

ffc script SkeletonWar{
	void run(int enemyid){
		
		npc ghost = Ghost_InitAutoGhost(this, enemyid);
		this->Flags[FFCF_ETHEREAL] = true;
		ghost->DrawYOffset = -1000;
		ghost->CollDetection = false;
		
		int i; int j; int k; int m; int o; int x; int y;
		
		int count;
		int positions[256];
		int defenses[18];
		Ghost_StoreDefenses(ghost, defenses);
		
		npc stalfos[256];
		int stalfosX[256];
		int stalfosY[256];
		int stalfosSX[256];
		int stalfosSY[256];
		int stalfosValid[256];
		int vars[16] = {0, 0, -1, -1, stalfosX, stalfosY, stalfosSX, stalfosSY, stalfosValid, defenses, 0};
		
		for(i=0; i<256; i++){
			int map = 4;
			int scr = 0x00;
			if(i>=176)
				scr += 16;
			j = Max(Game->GetComboData(map, scr, i%176)-2572+1, 0);
			positions[i] = j;
		}
		
		int cX = 2;
		int cY = 3;
		vars[cX] = 128;
		vars[cY] = 32;
		for(i=0; i<256; i++){
			j = i;
			stalfosX[j] = ((i%16)-8)*8;
			stalfosY[j] = (Floor(i/16)-8)*8;
			stalfosSX[j] = 0.75;
			stalfosSY[j] = 0.75;
			stalfosValid[i] = -1;
			if(positions[i]>0){
				j = i; //vars[1];
				stalfosValid[i] = 1;
				stalfosSX[j] = 0.75;
				stalfosSY[j] = 0.75;
				stalfos[j] = CreateNPCAt(265, stalfosX[i], stalfosY[i]);
				stalfos[j]->HitXOffset = 4;
				stalfos[j]->HitYOffset = 4;
				stalfos[j]->HitWidth = 8;
				stalfos[j]->HitHeight = 8;
				stalfos[j]->OriginalTile += 2*(positions[i]-1);
				stalfos[j]->Tile = stalfos[j]->OriginalTile;
				vars[1]++;
			}
		}
		int totalStalfos = vars[1];
		int unblockable = 0;
		if(IsHardMode())
			unblockable = EWF_UNBLOCKABLE;
		int vX; int vY;
		int attackCooldown = 120;
		int swordStep = 250;
		if(IsHardMode())
			swordStep = 150;
		eweapon e;
		if(!Q7_HasRing(I_SPRING11_MIRR))
			Screen->Lit = false;
		while(vars[1]>0){
			if(attackCooldown>0)
				attackCooldown--;
			else if(Rand(32)==0){
				int attack = Rand(5);
				if(attack==4&&vars[1]>totalStalfos*0.5)
					attack = Rand(4);
				if(attack>=3&&!IsHardMode())
					attack = Rand(3);
				
				while(vars[cX]<32||vars[cX]>234||vars[cY]<32||vars[cY]>144){
					vX = Clamp(vX+Sign(128-vars[cX])*0.1, -2, 2);
					vY = Clamp(vY+Sign(88-vars[cY])*0.1, -1.5, 1.5);
					vars[cX] = WrapInt(vars[cX]+vX, -16, 256);
					vars[cY] = WrapInt(vars[cY]+vY, -16, 176);
					SW_Waitframe(stalfos, vars);
				}
				if(attack==0){
					SW_MakeInvuln(stalfos, vars, true);
					i = AngleDir4(Angle(vars[cX], vars[cY], CenterLinkX(), CenterLinkY()));
					
					if(i>=2){ //Vert
						for(i=24; i>=0&&vars[1]>0; i--){
							for(j=0; j<256; j++){
								stalfosSX[j] = 0.75*(i/24);
							}
							SW_Waitframe(stalfos, vars);
						}
						for(i=0; i<12&&vars[1]>0; i++){
							SW_Waitframe(stalfos, vars);
						}
						for(i=0; i<16&&vars[1]>0; i++){
							if(SW_RowValid(stalfos, i)||IsHardMode()){
								x = vars[cX]+stalfosX[i*16]*stalfosSX[i];
								y = vars[cY]+stalfosY[i*16]*stalfosSY[i];
								
								int flip = -1;
								if(stalfosY[0*16]>stalfosY[15*16])
									flip = 1;
								if(Link->X+8<vars[cX]){
									j = Q7_DirAngle(DIR_LEFT);
									if(IsHardMode())
										j += (-80+(i/15)*160)*flip;
									
									k = 7-i;
									if(i>7)
										k = i-8;
									
									e = FireEWeapon(EW_BEAM, x, y, DegtoRad(j), swordStep, DAMAGE_MINISWORD, SPR_MINISWORD, 0, unblockable);
									e->OriginalTile += DIR_LEFT*4;
									e->Tile = e->OriginalTile;
									if(unblockable&EWF_UNBLOCKABLE){
										e->NumFrames = 4;
										e->ASpeed = 3;
									}
								}
								else{
									j = Q7_DirAngle(DIR_RIGHT);
									if(IsHardMode())
										j += (80-(i/15)*160)*flip;
									
									k = 7-i;
									if(i>7)
										k = i-8;
									
									e = FireEWeapon(EW_BEAM, x, y, DegtoRad(j), swordStep, DAMAGE_MINISWORD, SPR_MINISWORD, 0, unblockable);
									e->OriginalTile += DIR_RIGHT*4;
									e->Tile = e->OriginalTile;
									if(unblockable&EWF_UNBLOCKABLE){
										e->NumFrames = 4;
										e->ASpeed = 3;
									}
								}
								e->HitXOffset = 4;
								e->HitYOffset = 4;
								e->HitWidth = 8;
								e->HitHeight = 8;
							}
						}
						for(i=0; i<12&&vars[1]>0; i++){
							SW_Waitframe(stalfos, vars);
						}
						for(i=0; i<24&&vars[1]>0; i++){
							for(j=0; j<256; j++){
								stalfosSX[j] = -0.75*(i/24);
							}
							SW_Waitframe(stalfos, vars);
						}
						for(j=0; j<256; j++){
							stalfosX[j] = -stalfosX[j];
							stalfosSX[j] = 0.75;
						}
					}
					else{ //Horiz
						for(i=24; i>=0&&vars[1]>0; i--){
							for(j=0; j<256; j++){
								stalfosSY[j] = 0.75*(i/24);
							}
							SW_Waitframe(stalfos, vars);
						}
						for(i=0; i<12&&vars[1]>0; i++){
							SW_Waitframe(stalfos, vars);
						}
						for(i=0; i<16&&vars[1]>0; i++){
							if(SW_ColumnValid(stalfos, i)||IsHardMode()){
								x = vars[cX]+stalfosX[i]*stalfosSX[i];
								y = vars[cY]+stalfosY[i]*stalfosSY[i];
								
								int flip = -1;
								if(stalfosX[0]>stalfosX[15])
									flip = 1;
								if(Link->Y+8<vars[cY]){
									j = Q7_DirAngle(DIR_UP);
									if(IsHardMode())
										j += (80-(i/15)*160)*flip;
									
									k = 7-i;
									if(i>7)
										k = i-8;
									
									e = FireEWeapon(EW_BEAM, x, y, DegtoRad(j), swordStep, DAMAGE_MINISWORD, SPR_MINISWORD, 0, unblockable);
									e->OriginalTile += DIR_UP*4;
									e->Tile = e->OriginalTile;
									if(unblockable&EWF_UNBLOCKABLE){
										e->NumFrames = 4;
										e->ASpeed = 3;
									}
								}
								else{
									j = Q7_DirAngle(DIR_DOWN);
									if(IsHardMode())
										j += (-80+(i/15)*160)*flip;
									
									k = 7-i;
									if(i>7)
										k = i-8;
									
									e = FireEWeapon(EW_BEAM, x, y, DegtoRad(j), swordStep, DAMAGE_MINISWORD, SPR_MINISWORD, 0, unblockable);
									e->OriginalTile += DIR_DOWN*4;
									e->Tile = e->OriginalTile;
									if(unblockable&EWF_UNBLOCKABLE){
										e->NumFrames = 4;
										e->ASpeed = 3;
									}
								}
								e->HitXOffset = 4;
								e->HitYOffset = 4;
								e->HitWidth = 8;
								e->HitHeight = 8;
							}
						}
						for(i=0; i<12&&vars[1]>0; i++){
							SW_Waitframe(stalfos, vars);
						}
						for(i=0; i<24&&vars[1]>0; i++){
							for(j=0; j<256; j++){
								stalfosSY[j] = -0.75*(i/24);
							}
							SW_Waitframe(stalfos, vars);
						}
						for(j=0; j<256; j++){
							stalfosY[j] = -stalfosY[j];
							stalfosSY[j] = 0.75;
						}
					}
				}
				else if(attack==1){
					SW_MakeInvuln(stalfos, vars, true);
					for(i=24; i>=0&&vars[1]>0; i--){
						for(j=0; j<256; j++){
							stalfosSX[j] = 0.75*(i/24);
							stalfosSY[j] = 0.75*(i/24);
						}
						SW_Waitframe(stalfos, vars);
					}
					for(i=0; i<12&&vars[1]>0; i++){
						SW_Waitframe(stalfos, vars);
					}
					x = vars[cX]+stalfosX[i*16]*stalfosSX[i];
					y = vars[cY]+stalfosY[i*16]*stalfosSY[i];
					for(i=0; i<8&&vars[1]>0; i++){
						e = FireEWeapon(EW_BEAM, x, y, DegtoRad(i*45), 250, DAMAGE_MINISWORD, SPR_MINISWORD, 0, unblockable);
						e->HitXOffset = 4;
						e->HitYOffset = 4;
						e->HitWidth = 8;
						e->HitHeight = 8;
						e->OriginalTile += __NormalizeDir(e->Dir)*4;
						e->Tile = e->OriginalTile;
						if(unblockable&EWF_UNBLOCKABLE){
							e->NumFrames = 4;
							e->ASpeed = 3;
						}
					}
					for(i=0; i<12&&vars[1]>0; i++){
						SW_Waitframe(stalfos, vars);
					}
					for(i=0; i<24&&vars[1]>0; i++){
						for(j=0; j<256; j++){
							stalfosSX[j] = -0.75*(i/24);
							stalfosSY[j] = -0.75*(i/24);
						}
						SW_Waitframe(stalfos, vars);
					}
					for(j=0; j<256; j++){
						stalfosX[j] = -stalfosX[j];
						stalfosY[j] = -stalfosY[j];
						stalfosSX[j] = 0.75;
						stalfosSY[j] = 0.75;
					}
				}
				else if(attack==2){
					for(i=0; i<90&&vars[1]>0; i++){
						if(i%20==0){
							x = vars[cX];
							y = vars[cY];
							e = FireAimedEWeapon(EW_BEAM, x, y, 0, 250, DAMAGE_MINISWORD, SPR_MINISWORD, 0, unblockable);
							e->HitXOffset = 4;
							e->HitYOffset = 4;
							e->HitWidth = 8;
							e->HitHeight = 8;
							e->OriginalTile += __NormalizeDir(e->Dir)*4;
							e->Tile = e->OriginalTile;
							if(unblockable&EWF_UNBLOCKABLE){
								e->NumFrames = 4;
								e->ASpeed = 3;
							}
						}
						for(j=0; j<256; j++){
							k = Floor(j/16);
							m = Clamp(i*8-k*8, 0, 360);
							stalfosSX[j] = 0.75*Cos(m);
						}
						SW_Waitframe(stalfos, vars);
					}
					for(j=0; j<256; j++){
						stalfosSX[j] = 0.75;
					}
				}
				else if(attack==3){
					SW_MakeInvuln(stalfos, vars, true);
					i = AngleDir4(Angle(vars[cX], vars[cY], CenterLinkX(), CenterLinkY()));
					
					if(i>=2){ //Vert
						for(i=24; i>=0&&vars[1]>0; i--){
							for(j=0; j<256; j++){
								stalfosSX[j] = 0.75*(i/24);
								stalfosSY[j] = 0.75-0.5*((24-i)/24);
							}
							SW_Waitframe(stalfos, vars);
						}
						for(i=0; i<12&&vars[1]>0; i++){
							SW_Waitframe(stalfos, vars);
						}
						for(i=0; i<24&&vars[1]>0; i++){
							for(j=0; j<256; j++){
								stalfosSX[j] = 0;
								stalfosSY[j] = 0.25+2.75*(i/24);
							}
							SW_Waitframe(stalfos, vars);
						}
						for(i=0; i<16&&vars[1]>0; i++){
							if(SW_RowValid(stalfos, i)||IsHardMode()){
								x = vars[cX]+stalfosX[i*16]*stalfosSX[i];
								y = vars[cY]+stalfosY[i*16]*stalfosSY[i];
								if(Link->X+8<vars[cX]){
									e = FireAimedEWeapon(EW_BEAM, x, y, 0, 300, DAMAGE_MINISWORD, SPR_MINISWORD, 0, unblockable);
								}
								else{
									e = FireAimedEWeapon(EW_BEAM, x, y, 0, 300, DAMAGE_MINISWORD, SPR_MINISWORD, 0, unblockable);
								}
								e->HitXOffset = 4;
								e->HitYOffset = 4;
								e->HitWidth = 8;
								e->HitHeight = 8;
								e->OriginalTile += __NormalizeDir(e->Dir)*4;
								e->Tile = e->OriginalTile;
								if(unblockable&EWF_UNBLOCKABLE){
									e->NumFrames = 4;
									e->ASpeed = 3;
								}
								for(j=0; j<8; j++){
									SW_Waitframe(stalfos, vars);
								}
							}
						}
						SW_Revert(stalfos, vars, 32);
					}
					else{ //Horiz
						for(i=24; i>=0&&vars[1]>0; i--){
							for(j=0; j<256; j++){
								stalfosSX[j] = 0.75-0.5*((24-i)/24);
								stalfosSY[j] = 0.75*(i/24);
							}
							SW_Waitframe(stalfos, vars);
						}
						for(i=0; i<12&&vars[1]>0; i++){
							SW_Waitframe(stalfos, vars);
						}
						for(i=0; i<24&&vars[1]>0; i++){
							for(j=0; j<256; j++){
								stalfosSX[j] = 0.25+2.75*(i/24);
								stalfosSY[j] = 0;
							}
							SW_Waitframe(stalfos, vars);
						}
						for(i=0; i<16&&vars[1]>0; i++){
							if(SW_ColumnValid(stalfos, i)||IsHardMode()){
								x = vars[cX]+stalfosX[i]*stalfosSX[i];
								y = vars[cY]+stalfosY[i]*stalfosSY[i];
								if(Link->X+8<vars[cX]){
									e = FireAimedEWeapon(EW_BEAM, x, y, 0, 400, DAMAGE_MINISWORD, SPR_MINISWORD, 0, unblockable);
								}
								else{
									e = FireAimedEWeapon(EW_BEAM, x, y, 0, 400, DAMAGE_MINISWORD, SPR_MINISWORD, 0, unblockable);
								}
								e->HitXOffset = 4;
								e->HitYOffset = 4;
								e->HitWidth = 8;
								e->HitHeight = 8;
								e->OriginalTile += __NormalizeDir(e->Dir)*4;
								e->Tile = e->OriginalTile;
								if(unblockable&EWF_UNBLOCKABLE){
									e->NumFrames = 4;
									e->ASpeed = 3;
								}
								for(j=0; j<4; j++){
									SW_Waitframe(stalfos, vars);
								}
							}
						}
						SW_Revert(stalfos, vars, 32);
					}
					
				}
				else if(attack==4){
					k = Rand(3);
					if(k==0){
						for(i=0; i<=24&&vars[1]>0; i++){
							for(j=0; j<256; j++){
								stalfosSX[j] = 0.75-1.5*(i/24);
								stalfosSY[j] = 0.75;
							}
							SW_Waitframe(stalfos, vars);
						}
						for(j=0; j<256; j++){
							stalfosX[j] = -stalfosX[j];
							stalfosSX[j] = 0.75;
							stalfosSY[j] = 0.75;
						}
					}
					else if(k==1){
						for(i=0; i<=24&&vars[1]>0; i++){
							for(j=0; j<256; j++){
								stalfosSX[j] = 0.75;
								stalfosSY[j] = 0.75-1.5*(i/24);
							}
							SW_Waitframe(stalfos, vars);
						}
						for(j=0; j<256; j++){
							stalfosY[j] = -stalfosY[j];
							stalfosSX[j] = 0.75;
							stalfosSY[j] = 0.75;
						}
					}
					else{
						for(i=0; i<=12&&vars[1]>0; i++){
							for(j=0; j<256; j++){
								stalfosSX[j] = 0.75-1.5*(i/12);
								stalfosSY[j] = 0.75;
							}
							SW_Waitframe(stalfos, vars);
						}
						for(i=0; i<=12&&vars[1]>0; i++){
							for(j=0; j<256; j++){
								stalfosSX[j] = 0.75;
								stalfosSY[j] = 0.75-1.5*(i/12);
							}
							SW_Waitframe(stalfos, vars);
						}
						for(j=0; j<256; j++){
							stalfosX[j] = -stalfosX[j];
							stalfosY[j] = -stalfosY[j];
							stalfosSX[j] = 0.75;
							stalfosSY[j] = 0.75;
						}
					}
					for(i=0; i<=96&&vars[1]>0; i++){
						for(j=0; j<256; j++){
							stalfosSX[j] = 0.75+2.25*(i/96);
							stalfosSY[j] = 0.75+2.25*(i/96);
						}
						SW_Waitframe(stalfos, vars);
					}
					SW_Revert(stalfos, vars, 32);
				}
				SW_MakeInvuln(stalfos, vars, false);
				attackCooldown = 240;
				
				vX = VectorX(1, Angle(Link->X, Link->Y, vars[cX]-8, vars[cY]-8));
				vY = VectorY(1, Angle(Link->X, Link->Y, vars[cX]-8, vars[cY]-8));
			}
			int maxStep = LazyDiffMod(1.2, 1.5, 2);
			// if(Distance(Link->X, Link->Y, vars[cX], vars[cY])<96){
				// vX = Clamp(vX+Sign(vars[cX]-Link->X+8)*0.01, -maxStep, maxStep);
				// vY = Clamp(vY+Sign(vars[cY]-Link->Y+8)*0.01, -maxStep, maxStep);
			// }
			// else{
			vX = Clamp(vX+Sign(Link->X+8-vars[cX])*0.01, -maxStep, maxStep);
			vY = Clamp(vY+Sign(Link->Y+8-vars[cY])*0.01, -maxStep, maxStep);
			// }
			vars[cX] = WrapInt(vars[cX]+vX, -16, 256);
			vars[cY] = WrapInt(vars[cY]+vY, -16, 176);
			SW_Waitframe(stalfos, vars);
		}
		Screen->Lit = true;
		ghost->X = vars[cX];
		ghost->Y = vars[cY];
		ghost->HP = 0;
		ghost->Misc[NPCM_LASTHP] = 0;
		ghost->DrawYOffset = 0;
	}
	void SW_MakeInvuln(npc stalfos, int vars, bool nocoll){
		if(!IsHardMode()&&!Link->Item[I_DIFF_NORMAL])
			return;
		int defenses = vars[9];
		if(!nocoll){
			for(int i=0; i<256; i++){
				if(stalfos[i]->isValid()){
					Ghost_SetDefenses(stalfos[i], defenses);
				}
			}
		}
		else{
			for(int i=0; i<256; i++){
				if(stalfos[i]->isValid()){
					Ghost_SetAllDefenses(stalfos[i], NPCDT_IGNORE);
				}
			}
		}
	}
	void SW_Revert(npc stalfos, int vars, int frames){
		int stalfosSX = vars[6];
		int stalfosSY = vars[7];
		int sX[256];
		int sY[256];
		for(int j=0; j<256; j++){
			sX[j] = stalfosSX[j];
			sY[j] = stalfosSY[j];
		}
		int i;
		for(i=0; i<frames&&vars[1]>0; i++){
			for(int j=0; j<256; j++){
				stalfosSX[j] = sX[j]+(0.75-sX[j])*(i/frames);
				stalfosSY[j] = sY[j]+(0.75-sY[j])*(i/frames);
			}
			SW_Waitframe(stalfos, vars);
		}
		if(i>=frames){
			for(int j=0; j<256; j++){
				stalfosSX[j] = 0.75;
				stalfosSY[j] = 0.75;
			}
		}
	}
	bool SW_ColumnValid(npc stalfos, int j){
		for(int i=0; i<16; i++){
			if(stalfos[i*16+j]->isValid())
				return true;
		}
		return false;
	}
	bool SW_RowValid(npc stalfos, int j){
		for(int i=0; i<16; i++){
			if(stalfos[j*16+i]->isValid())
				return true;
		}
		return false;
	}
	void SW_Waitframe(npc stalfos, int vars){
		int stalfosX = vars[4];
		int stalfosY = vars[5];
		int stalfosSX = vars[6];
		int stalfosSY = vars[7];
		int stalfosValid = vars[8];
		int cX = 2;
		int cY = 3;
		
		if(!G[G_NODARKENROOM]&&vars[10]<=0){
			if(!Q7_HasRing(I_SPRING11_MIRR))
				Screen->Lit = false;
		}
		if(vars[10])
			--vars[10];
		
		if(!Screen->Lit)
			Screen->DrawScreen(2, MAP_STALFOSCAGE, SCREEN_STALFOSCAGE, 0, 0, 0);
		
		for(int i=Screen->NumEWeapons(); i>0; i--){
			eweapon e = Screen->LoadEWeapon(i);
			if(e->ID==EW_SWFIRE){
				e->X += Rand(-1, 1);
				e->Y += Rand(-1, 1);
				if(G[G_ANIM]%2==0){
					if(Distance(Link->X, Link->Y, e->X, e->Y)<48){
						if(e->X<Link->X)
							e->X++;
						else if(e->X>Link->X)
							e->X--;
						if(e->Y<Link->Y)
							e->Y++;
						else if(e->Y>Link->Y)
							e->Y--;
					}
				}
			}
		}
		if(Link->Item[I_CANDLE3]){
			for(int i=Screen->NumLWeapons(); i>0; i--){
				lweapon l = Screen->LoadLWeapon(i);
				if(l->ID==LW_FIRE)
					vars[10] = 120;
			}
		}
		
		for(int i=0; i<256; i++){
			int x = WrapInt(vars[cX]+stalfosX[i]*stalfosSX[i], -16, 256);
			int y = WrapInt(vars[cY]+stalfosY[i]*stalfosSY[i], -16, 176);
			if(stalfos[i]->isValid()&&stalfosValid[i]){
				stalfos[i]->X = x;
				stalfos[i]->Y = y;
				if(stalfos[i]->HP<=0){
					if(IsHardMode()){
						eweapon deathfire = FireAimedEWeapon(EW_SWFIRE, stalfos[i]->X-4, stalfos[i]->Y-4, DegtoRad(Rand(-45, 45)), 50, stalfos[i]->Damage, SPR_MINIFIRE, SFX_FIRE, EWF_UNBLOCKABLE);
						deathfire->HitXOffset = 4;
						deathfire->HitYOffset = 4;
						deathfire->HitWidth = 4;
						deathfire->HitHeight = 4;
						SetEWeaponLifespan(deathfire, EWL_TIMER, 128);
						SetEWeaponDeathEffect(deathfire, EWD_VANISH, 0);
					}
					vars[1]--;
					stalfosValid[i] = 0;
				}
				else{
					DrawToLayer(stalfos[i], 6, 128);
				}
			}
			else if(stalfosValid[i]>-1&&Link->HP>0)
				Screen->FastCombo(6, x, y, 2575, 10, 128);
		}
		
		Waitframe();
	}
}

// Function to get the difference between two angles
float AngDiff(float angle1, float angle2)
{
	// Get the difference between the two angles
	float dif = angle2 - angle1;
	
	// Compensate for the difference being outside of normal bounds
	if(dif >= 180)
		dif -= 360;
	else if(dif <= -180)
		dif += 360;
		
	return dif;
}

// Function to turn one angle towards another angle by a fixed amount
float TurnToAngle(float angle1, float angle2, float step){
	if(Abs(AngDiff(angle1, angle2))>step){
		return WrapDegrees(angle1 + Sign(AngDiff(angle1, angle2))*step);
	}
	else{
		return WrapDegrees(angle2);
	}
}

//Makes a hitbox with ghost.zh weapons
void MakeHitbox(int x, int y, int w, int h, int damage){
	eweapon e = FireEWeapon(EW_SCRIPT10, 120, 80, 0, 0, damage, -1, -1, EWF_UNBLOCKABLE);
	e->HitXOffset = x-e->X;
	e->HitYOffset = y-e->Y;
	e->DrawYOffset = -1000;
	e->HitWidth = w;
	e->HitHeight = h;
	SetEWeaponLifespan(e, EWL_TIMER, 1);
	SetEWeaponDeathEffect(e, EWD_VANISH, 0);
}

// Converts directions to angles
int Q7_DirAngle(int dir){
	if(dir==DIR_UP)
		return -90;
	else if(dir==DIR_DOWN)
		return 90;
	else if(dir==DIR_LEFT)
		return 180;
	else if(dir==DIR_RIGHT)
		return 0;
	else if(dir==DIR_LEFTUP)
		return -135;
	else if(dir==DIR_RIGHTUP)
		return -45;
	else if(dir==DIR_LEFTDOWN)
		return 135;
	else if(dir==DIR_RIGHTDOWN)
		return 45;
	return 0;
}

int Q7_AdjacentCombo(int pos, int dir){
	if(pos<16&&dir==DIR_UP)
		return -1;
	if(pos>=160&&dir==DIR_DOWN)
		return -1;
	if(pos%16==0&&dir==DIR_LEFT)
		return -1;
	if(pos%16==15&&dir==DIR_RIGHT)
		return -1;
	
	if(dir==DIR_UP)
		return pos-16;
	else if(dir==DIR_DOWN)
		return pos+16;
	else if(dir==DIR_LEFT)
		return pos-1;
	else if(dir==DIR_RIGHT)
		return pos+1;
}

const int CMB_AUTOWARPA = 460;

void WarpToStart(int warpType){
	Screen->SetSideWarp(0, Game->LastEntranceScreen, Game->LastEntranceDMap, warpType);
	ffc f = Screen->LoadFFC(FindUnusedFFC());
	f->Data = CMB_AUTOWARPA;
	Link->CollDetection = true;
	Link->Invisible = false;
	G[G_SPECIALWARP] = 1;
}

const int SFX_GRABBERDARKNUT_GRAB = 1;
const int SFX_GRABBERDARKNUT_SPIN = 54;

const int SPR_TOSSLINK = 92;

ffc script Grabnut{
	void run(int enemyid){
		int i; int j; int k;
		int x; int y;
		int angle;
		
		npc ghost = Ghost_InitAutoGhost(this, enemyid);
		this->Flags[FFCF_ETHEREAL] = true;
		Ghost_SetFlag(GHF_4WAY);
		Ghost_SetFlag(GHF_STUN);
		int combo = ghost->Attributes[10];
		
		Ghost_SpawnAnimationPuff(this, ghost);
		
		int counter = -1;
		int attackCooldown = 60;
	
		while(true){
			Ghost_Data = combo;
			counter = Ghost_ConstantWalk4(counter, ghost->Step, ghost->Rate, ghost->Homing, ghost->Hunger);
			if(attackCooldown>0)
				attackCooldown--;
			else if(Distance(Ghost_X, Ghost_Y, Link->X, Link->Y)<32&&Rand(16)==0){
				Ghost_Data = combo+4;
				angle = Q7_DirAngle(Ghost_Dir);
				while(angle!=Angle(Ghost_X, Ghost_Y, Link->X, Link->Y)){
					angle = TurnToAngle(angle, Angle(Ghost_X, Ghost_Y, Link->X, Link->Y), 10);
					Ghost_Dir = AngleDir4(WrapDegrees(angle));
					Q7_Ghost_Waitframe(this, ghost, true, true);
				}
				Q7_Ghost_Waitframes(this, ghost, true, true, 8);
				Game->PlaySound(SFX_GRABBERDARKNUT_GRAB);
				for(i=0; i<16; i+=2){
					x = Ghost_X+InFrontX(Ghost_Dir, 16-i);
					y = Ghost_Y+InFrontY(Ghost_Dir, 16-i);
					Screen->FastCombo(2, x, y, combo+8+Ghost_Dir, this->CSet, 128);
					Q7_Ghost_Waitframe(this, ghost, true, true);
				}
				bool grabbed;
				for(i=0; i<32; i++){
					x = Ghost_X+InFrontX(Ghost_Dir, 0);
					y = Ghost_Y+InFrontY(Ghost_Dir, 0);
					MakeHitbox(x, y, 16, 16, ghost->WeaponDamage);
					Screen->FastCombo(2, x, y, combo+8+Ghost_Dir, this->CSet, 128);
					if(i<8&&Link->Action==LA_GOTHURTLAND&&RectCollision(x, y, x+15, y+15, Link->X, Link->Y, Link->X+15, Link->Y+15)&&!Link->Invisible&&!G[G_PHASECOUNTER]){
						if(!Q7_HasRing(I_SPRING19_WALLMASTER)){
							grabbed = true;
							break;
						}
					}
					Q7_Ghost_Waitframe(this, ghost, true, true);
				}
				if(grabbed&&!Q7_HasRing(I_SPRING19_WALLMASTER)){
					Ghost_UnsetFlag(GHF_STUN);
					Ghost_HP = 1000;
					ghost->HP = 1000;
					Link->Invisible = true;
					Link->CollDetection = false;
					Link->Action = LA_FROZEN;
					for(i=0; i<32; i++){
						x = Ghost_X+InFrontX(Ghost_Dir, 0);
						y = Ghost_Y+InFrontY(Ghost_Dir, 0);
						Screen->FastCombo(2, x, y, combo+12+Ghost_Dir, this->CSet, 128);
						NoAction();
						Q7_Ghost_Waitframe(this, ghost, true, true);
					}
					angle = Q7_DirAngle(Ghost_Dir);
					Game->PlaySound(SFX_GRABBERDARKNUT_SPIN);
					for(i=0; i<36; i++){
						angle += 10;
						j = AngleDir8(WrapDegrees(angle));
						x = Ghost_X+GD_DirX(j);
						y = Ghost_Y+GD_DirY(j);
						Ghost_Dir = AngleDir4(WrapDegrees(angle));
						Screen->FastCombo(2, x, y, combo+12+j, this->CSet, 128);
						NoAction();
						Q7_Ghost_Waitframe(this, ghost, true, true);
					}
					x = Ghost_X+GD_DirX(j);
					y = Ghost_Y+GD_DirY(j);
					lweapon wind = CreateLWeaponAt(LW_WIND, x, y);
					wind->Dir = Ghost_Dir;
					wind->Step = 400;
					wind->UseSprite(SPR_TOSSLINK);
					wind->CollDetection = false;
					for(i=0; i<16; i++){
						x = Ghost_X+InFrontX(Ghost_Dir, 0);
						y = Ghost_Y+InFrontY(Ghost_Dir, 0);
						Screen->FastCombo(2, x, y, combo+8+Ghost_Dir, this->CSet, 128);
						NoAction();
						Q7_Ghost_Waitframe(this, ghost, true, true);
					}
					for(i=16; i>0; i-=2){
						x = Ghost_X+InFrontX(Ghost_Dir, 16-i);
						y = Ghost_Y+InFrontY(Ghost_Dir, 16-i);
						Screen->FastCombo(2, x, y, combo+8+Ghost_Dir, this->CSet, 128);
						NoAction();
						Q7_Ghost_Waitframe(this, ghost, true, true);
					}
					while(wind->isValid()){
						NoAction();
						Q7_Ghost_Waitframe(this, ghost, true, true);
					}
					WarpToStart(WT_IWARPBLACKOUT);
				}
				else{
					for(i=16; i>0; i-=2){
						x = Ghost_X+InFrontX(Ghost_Dir, 16-i);
						y = Ghost_Y+InFrontY(Ghost_Dir, 16-i);
						Screen->FastCombo(2, x, y, combo+8+Ghost_Dir, this->CSet, 128);
						Q7_Ghost_Waitframe(this, ghost, true, true);
					}
				}
				attackCooldown = 60;
			}
			Q7_Ghost_Waitframe(this, ghost, true, true);
		}
	}
	int GD_DirX(int dir){
		if(dir==DIR_UP)
			return 0;
		else if(dir==DIR_DOWN)
			return 0;
		else if(dir==DIR_LEFT)
			return -16;
		else if(dir==DIR_RIGHT)
			return 16;
		else if(dir==DIR_LEFTUP)
			return -12;
		else if(dir==DIR_RIGHTUP)
			return 12;
		else if(dir==DIR_LEFTDOWN)
			return -12;
		else if(dir==DIR_RIGHTDOWN)
			return 12;
	}
	int GD_DirY(int dir){
		if(dir==DIR_UP)
			return -16;
		else if(dir==DIR_DOWN)
			return 16;
		else if(dir==DIR_LEFT)
			return 0;
		else if(dir==DIR_RIGHT)
			return 0;
		else if(dir==DIR_LEFTUP)
			return -12;
		else if(dir==DIR_RIGHTUP)
			return -12;
		else if(dir==DIR_LEFTDOWN)
			return 12;
		else if(dir==DIR_RIGHTDOWN)
			return 12;
	}
}

ffc script BreathWizzrobe{
	void run(int enemyid){
		int i;
		
		npc ghost = Ghost_InitAutoGhost(this, enemyid);
		this->Flags[FFCF_ETHEREAL] = true;
		Ghost_SetFlag(GHF_4WAY);
		int cr; int cr2; int cr3;
		
		int teleportState = 0;
		int teleportTimer = 4;
		bool doAttack;
		ghost->DrawXOffset = 1000;
		ghost->HitXOffset = 1000;
		while(true){
			doAttack = false;
			if(teleportState==0&&G[G_TRACKTILEDIR]>-1){
				while(G[G_TRACKTILEDIR]>-1){
					Q7_Ghost_Waitframe(this, ghost);
				}
			}
			if(teleportTimer>0)
				teleportTimer--;
			else{
				if(teleportState==0){ //Invisible
					teleportState = 1;
					teleportTimer = 64;
					i = BW_GetTeleportPos();
					Ghost_X = ComboX(i);
					Ghost_Y = ComboY(i);
					Ghost_Dir = AngleDir4(Angle(Ghost_X, Ghost_Y, Link->X, Link->Y));
				}
				else if(teleportState==1){ //Teleport In
					teleportState = 2;
					teleportTimer = 16;
				}
				else if(teleportState==2){ //Before Attacking
					teleportState = 3;
					teleportTimer = 48;
					doAttack = true;
				}
				else if(teleportState==3){ //Attacking
					teleportState = 4;
					teleportTimer = 16;
				}
				else if(teleportState==4){ //Teleport Out
					teleportState = 0;
					teleportTimer = 75;
				}
			}
			if(teleportState==0){
				ghost->CollDetection = false;
				ghost->DrawXOffset = 1000;
				ghost->HitXOffset = 1000;
			}
			else if(teleportState==1||teleportState==4){
				ghost->CollDetection = true;
				ghost->HitXOffset = 0;
				if(teleportTimer%2==0){
					ghost->DrawXOffset = 1000;
				}
				else{
					ghost->DrawXOffset = 0;
				}
			}
			else{
				ghost->CollDetection = true;
				ghost->HitXOffset = 0;
				ghost->DrawXOffset = 0;
			}
			
			if(doAttack){
				for(int i=0; i<120; i++){
					if(i%4==0){
						eweapon e = FireEWeapon(EW_FIREBALL, Ghost_X, Ghost_Y, DegtoRad(Q7_DirAngle(Ghost_Dir)+Rand(-10, 10)), Rand(200, 400), ghost->WeaponDamage, -1, -1, 0);
					}
					Q7_Ghost_Waitframe(this, ghost);
				}
			}
			Q7_Ghost_Waitframe(this, ghost);
		}
	}
	int BW_GetTeleportPos(){
		int i;
		int x; int y;
		int pos; int ct;
		
		int linkX = Clamp(GridX(Link->X)+8, 32, 208);
		int linkY = Clamp(GridY(Link->Y)+8, 32, 128);
		
		
		int validPos[176];
		int numValid;
		
		//Find all valid combos to teleport to in all four directions
		
		//Up
		for(i=2; i<11; i++){
			x = linkX;
			y = linkY-16*i;
			pos = ComboAt(x, y);
			ct = Screen->ComboT[pos];
			if(x<32||x>224||y<32||y>144)
				continue;
			if(ComboFI(pos, CF_NOENEMY))
				continue;
			if(ct==CT_NOENEMY||ct==CT_NOFLYZONE)
				continue;
			
			validPos[numValid] = pos;
			numValid++;
		}
		//Down
		for(i=2; i<11; i++){
			x = linkX;
			y = linkY+16*i;
			pos = ComboAt(x, y);
			ct = Screen->ComboT[pos];
			if(x<32||x>224||y<32||y>144)
				continue;
			if(ComboFI(pos, CF_NOENEMY))
				continue;
			if(ct==CT_NOENEMY||ct==CT_NOFLYZONE)
				continue;
			
			validPos[numValid] = pos;
			numValid++;
		}
		//Left
		for(i=2; i<16; i++){
			x = linkX-16*i;
			y = linkY;
			pos = ComboAt(x, y);
			ct = Screen->ComboT[pos];
			if(x<32||x>224||y<32||y>144)
				continue;
			if(ComboFI(pos, CF_NOENEMY))
				continue;
			if(ct==CT_NOENEMY||ct==CT_NOFLYZONE)
				continue;
			
			validPos[numValid] = pos;
			numValid++;
		}
		//Right
		for(i=2; i<16; i++){
			x = linkX+16*i;
			y = linkY;
			pos = ComboAt(x, y);
			ct = Screen->ComboT[pos];
			if(x<32||x>224||y<32||y>144)
				continue;
			if(ComboFI(pos, CF_NOENEMY))
				continue;
			if(ct==CT_NOENEMY||ct==CT_NOFLYZONE)
				continue;
			
			validPos[numValid] = pos;
			numValid++;
		}
	
		//Default to the top left if there's no valid spots
		if(numValid==0)
			return 0;
		
		return validPos[Rand(numValid)];
	}
}

const int SFX_WANDBLOCK_MOVE = 5;

ffc script WandBlock{
	void run(int icecs){
		if(icecs==0)
			icecs = 3;
		
		int cmb = this->Data;
		this->Data = FFCS_INVISIBLE_COMBO;
		
		int fastWalk[] = "FastWalk";
		int fastWalkSlot = Game->GetFFCScript(fastWalk);
		if(CountFFCsRunning(fastWalkSlot)==0)
			RunFFCScript(fastWalkSlot, 0);
		
		lweapon lwhitbox;
		
		while(true){
			int moveDir = WB_WandCollision(this);
			if(moveDir>-1){
				int nextPos = ComboAt(this->X+8, this->Y+8);
				if(moveDir==DIR_UP)
					nextPos = ComboAt(this->X+8, this->Y-8);
				else if(moveDir==DIR_DOWN)
					nextPos = ComboAt(this->X+8, this->Y+24);
				else if(moveDir==DIR_LEFT)
					nextPos = ComboAt(this->X-8, this->Y+8);
				else if(moveDir==DIR_RIGHT)
					nextPos = ComboAt(this->X+24, this->Y+8);
				while(!WB_CheckObstructed(this, nextPos)){
					Screen->ComboD[ComboAt(this->X+8, this->Y+8)] = 244;
					Screen->ComboC[ComboAt(this->X+8, this->Y+8)] = icecs;
					Game->PlaySound(SFX_WANDBLOCK_MOVE);
					this->Data = cmb;
					for(int i=0; i<8; i++){
						if(moveDir==DIR_UP)
							this->Y -= 2;
						else if(moveDir==DIR_DOWN)
							this->Y += 2;
						else if(moveDir==DIR_LEFT)
							this->X -= 2;
						else if(moveDir==DIR_RIGHT)
							this->X += 2;
						MakeHitbox(this->X, this->Y, 16, 16, 4);
						if(!lwhitbox->isValid()){
							lwhitbox = CreateLWeaponAt(LW_SCRIPT10, this->X, this->Y);
							lwhitbox->Damage = 2;
							lwhitbox->Dir = -1;
							lwhitbox->Step = 0;
							lwhitbox->DrawYOffset = -1000;
						}
						else{
							lwhitbox->X = this->X;
							lwhitbox->Y = this->Y;
						}
						Waitframe();
					}
					if(moveDir==DIR_UP)
						nextPos = ComboAt(this->X+8, this->Y-8);
					else if(moveDir==DIR_DOWN)
						nextPos = ComboAt(this->X+8, this->Y+24);
					else if(moveDir==DIR_LEFT)
						nextPos = ComboAt(this->X-8, this->Y+8);
					else if(moveDir==DIR_RIGHT)
						nextPos = ComboAt(this->X+24, this->Y+8);
				}
				nextPos = ComboAt(this->X+8, this->Y+8);
				while(RectCollision(this->X, this->Y, this->X+15, this->Y+15, Link->X, Link->Y, Link->X+15, Link->Y+15)){
					MakeHitbox(this->X, this->Y, 16, 16, 4);
					if(!lwhitbox->isValid()){
						lwhitbox = CreateLWeaponAt(LW_SCRIPT10, this->X, this->Y);
						lwhitbox->Damage = 2;
						lwhitbox->Dir = -1;
						lwhitbox->Step = 0;
						lwhitbox->DrawYOffset = -1000;
					}
					else{
						lwhitbox->X = this->X;
						lwhitbox->Y = this->Y;
					}
					Waitframe();
				}
				this->Data = FFCS_INVISIBLE_COMBO;
				Screen->ComboD[ComboAt(this->X+8, this->Y+8)] = cmb;
				Screen->ComboC[ComboAt(this->X+8, this->Y+8)] = this->CSet;
			}
			if(lwhitbox->isValid())
				lwhitbox->DeadState = 0;
			Waitframe();
		}
	}
	int WB_WandCollision(ffc this){
		for(int i=Screen->NumLWeapons(); i>=1; i--){
			lweapon l = Screen->LoadLWeapon(i);
			if(l->ID==LW_MAGIC||l->ID==LW_REFMAGIC){
				if(RectCollision(l->X, l->Y, l->X+l->HitWidth-1, l->Y+l->HitHeight-1, this->X-4, this->Y-4, this->X+19, this->Y+19)){
					int dir = -1;
					if(l->Dir==DIR_UP||l->Dir==DIR_DOWN){
						if(l->Y<this->Y)
							dir = DIR_UP;
						else
							dir = DIR_DOWN;
					}
					else{
						if(l->X<this->X)
							dir = DIR_LEFT;
						else
							dir = DIR_RIGHT;
					}
					//int dir = AngleDir4(Angle(this->X, this->Y, l->X, l->Y));
					l->DeadState = 0;
					l->Y = -1000;
					return dir;
				}
			}
		}
		return -1;
	}
	bool WB_CheckObstructed(ffc this, int nextPos){
		int ct = Screen->ComboT[nextPos];
		if(Screen->ComboS[nextPos]&&ct!=CT_LADDERHOOKSHOT)
			return true;
		int x = ComboX(nextPos);
		int y = ComboY(nextPos);
		for(int i=1; i<=32; i++){
			ffc f = Screen->LoadFFC(i);
			if(f->Script==this->Script){
				if(f!=this){
					if(RectCollision(x, y, x+15, y+15, f->X, f->Y, f->X+15, f->Y+15))
						return true;
				}
			}
		}
		if(RectCollision(x, y, x+15, y+15, Link->X, Link->Y, Link->X+15, Link->Y+15))
			return true;
		return false;
	}
}

const int D_FIRSTVISIT = 6;

ffc script AlwaysSpawn{
	void run(int count){
		if(!Screen->D[D_FIRSTVISIT]){
			Screen->D[D_FIRSTVISIT] = 1;
			Game->GuyCount[Game->GetCurScreen()] = 10;
		}
		while(true){
			if(Game->GuyCount[Game->GetCurScreen()]<count)
				Game->GuyCount[Game->GetCurScreen()] = count;
			Waitframe();
		}
	}
}

void UndoWindEffect(){
	if(Link->Action==LA_FROZEN&&Link->DrawXOffset!=0){
		Link->Action = LA_NONE;
		Link->DrawXOffset = 0;
		for(int i=Screen->NumEWeapons(); i>=1; i--){
			eweapon e = Screen->LoadEWeapon(i);
			if(e->ID==EW_WIND){
				if(LinkCollision(e))
					e->DeadState = 0;
			}
		}
	}
}

bool ItemStringsPlayed[256];

void QueueMessage(int msg){
	if((Game->GetCurDMap()==0&&Game->GetCurScreen()>=0x7F)||Game->GetCurDMap()==20){
		G[G_MESSAGEQUEUE] = msg;
		G[G_MESSAGEQUEUETIME] = 96;
	}
	else{
		G[G_MESSAGEQUEUE] = msg;
		G[G_MESSAGEQUEUETIME] = 8;
		//Screen->Message(msg);
	}
}

void MessageQueue_Init(){
	G[G_MESSAGEQUEUE] = 0;
	G[G_MESSAGEQUEUETIME] = 0;
}

void MessageQueue_Update(){
	if(G[G_MESSAGEQUEUETIME]>0){
		G[G_MESSAGEQUEUETIME]--;
		if(G[G_MESSAGEQUEUETIME]==0){
			RandomizerPauseMenu_InitRings();
			if(!Link->Item[I_SETTING_NOITEMTEXT])
				Screen->Message(G[G_MESSAGEQUEUE]);
		}
	}
	
}

item script PickupMessage{
	void run(int msg, int id){
		if(id==I_SWORD1||id==I_SWORD2||id==I_SWORD3||id==I_SWORD4)
			++G[G_REMAININGLADDERS];
		AltCharacter_UpdateSwordLevels(id);
		if(id>0){
			if(!ItemStringsPlayed[id]){
				ItemStringsPlayed[id] = true;
				QueueMessage(msg);
			}
		}
		else{
			QueueMessage(msg);
		}
	}
}

item script LevelKey{
	void run(int msg, int id, int level){
		++Game->LKeys[level];
		if(id>0){
			if(!ItemStringsPlayed[id]){
				ItemStringsPlayed[id] = true;
				QueueMessage(msg);
			}
		}
		else{
			QueueMessage(msg);
		}
		
		if(id>=I_KEY_L1&&id<=I_KEY_L9){
			int args[8] = {Link->X, Link->Y, id-I_KEY_L1+1};
			RunFFCScript(FFCS_LEVELKEYPICKUP, args);
		}
	}
}

const int TIL_LEVELKEY_ICON = 5940;
const int FFCS_LEVELKEYPICKUP = 127;

ffc script LevelKeyPickup{
	void run(int x, int y, int level){
		while(G[G_MESSAGEQUEUETIME]){
			Waitframe();
		}
		Waitframe();
		for(int i=0; i<16; ++i){
			--y;
			LevelKeyPickup_Draw(x, y, level, i);
			Waitframe();
		}
		for(int i=0; i<16; ++i){
			y -= 0.35;
			LevelKeyPickup_Draw(x, y, level, i);
			Waitframe();
		}
		for(int i=0; i<16; ++i){
			y -= 0.125;
			LevelKeyPickup_Draw(x, y, level, i);
			Waitframe();
		}
		for(int i=0; i<16; ++i){
			if(i%4<2)
				LevelKeyPickup_Draw(x, y, level, i);
			Waitframe();
		}
	}
	void LevelKeyPickup_Draw(int x, int y, int level, int t){
		int i = level-1;
		int c1[] = {0x82, 0x52, 0x12, 0x72, 0xB1, 0xA2, 0xAB, 0x81, 0xB2};
		int c2[] = {0x85, 0x51, 0x11, 0x71, 0xB5, 0xA1, 0x72, 0x0F, 0xB1};
		Screen->FastTile(6, x-4, y, TIL_LEVELKEY_ICON+i, 0, 128);
		
		int lv[] = "LX";
		lv[1] = '0'+level;
		
		int c = c1[i];
		if(t%4<2){
			c = 0x01;
		}
		
		Screen->DrawString(6, x-4+8+1, y, FONT_Z1, c2[i], -1, TF_NORMAL, lv, 128);
		Screen->DrawString(6, x-4+8+1, y+1, FONT_Z1, c2[i], -1, TF_NORMAL, lv, 128);
		
		Screen->DrawString(6, x-4+8, y, FONT_Z1, c, -1, TF_NORMAL, lv, 128);
	}
}

const int I_CRIT1 = 153;
const int I_CRIT2 = 154;
const int I_CRIT3 = 155;
const int I_CRIT4 = 156;
const int I_CRIT5 = 179;

const int I_CRITPOTION = 157;

item script PowerPotionPickup{
	void run(int msg){
		if(!Link->Item[I_CRIT1])
			Link->Item[I_CRIT1] = true;
		else if(!Link->Item[I_CRIT2])
			Link->Item[I_CRIT2] = true;
		else if(!Link->Item[I_CRIT3])
			Link->Item[I_CRIT3] = true;
		else if(!Link->Item[I_CRIT4])
			Link->Item[I_CRIT4] = true;
		
		if(!ItemStringsPlayed[I_CRITPOTION]){
			ItemStringsPlayed[I_CRITPOTION] = true;
			QueueMessage(msg);
		}
	}
}

ffc script NoComboDoor{
	void run(int dir, int comboID, int perm, int sfx, int dbit){
		int count;
		int d = Floor((dbit-1)/16);
		int db = 1<<(Max(dbit-1, 0)%16);
		if(dbit==0)
			d = -1;
		if(perm&&NoComboDoor_CheckPerm(d, db)){
			if(dbit>0&&dir==-1){
				Screen->TriggerSecrets();
			}
			Quit();
		}
		while(true){
			count = 0;
			for(int i=0; i<176; i++){
				if(Screen->ComboD[i]==comboID){
					count++;
				}
			}
			if(count==0)
				break;
			Waitframe();
		}
		if(sfx==0)
			Game->PlaySound(9);
		else
			Game->PlaySound(sfx);
		if(dir==-1){
			if(perm){
				NoComboDoor_Setperm(d, db);
			}
			Screen->TriggerSecrets();
			Game->PlaySound(SFX_SECRET);
		}
		else{
			Screen->Door[dir] = D_OPENSHUTTER;
		}
	}
	bool NoComboDoor_CheckPerm(int d, int db){
		if(d==-1)
			return Screen->State[ST_SECRET];
		return Screen->D[d]&db;
	}
	void NoComboDoor_Setperm(int d, int db){
		if(d==-1)
			Screen->State[ST_SECRET] = true;
		else
			Screen->D[d] |= db;
	}
}

const int CMB_BOUNCINGTRAP = 348;
const int DAMAGE_BOUNCINGTRAP = 8;

const int SFX_BOUNCINGTRAP_BOUNCE = 57;
const int SFX_BOUNCINGTRAP_BREAK = 10;

const int NPC_TRAPWALLBOUNCE = 269;

ffc script BouncingTrap{
	void run(int breakCombo){
		npc ghost = Ghost_InitCreate(this, NPC_TRAPWALLBOUNCE);
		
		Ghost_Transform(this, ghost, CMB_BOUNCINGTRAP, 11, 1, 1);
		Ghost_SetFlag(GHF_IGNORE_PITS);
		Ghost_SetFlag(GHF_IGNORE_WATER);
		
		ghost->Damage = PiercingDamage(ghost->Damage);
		ghost->WeaponDamage = PiercingDamage(ghost->WeaponDamage);
		
		int vX = Choose(-1, 1);
		int vY = Choose(-1, 1);
		while(true){
			lweapon sword = LoadLWeaponOf(LW_SWORD);
			if(sword->isValid()){
				if(Collision(sword, ghost)){
					int angle = Angle(Link->X, Link->Y, Ghost_X, Ghost_Y);
					vX = VectorX(1, angle);
					vY = VectorY(1, angle);
				}
			}
			if((vX<0&&!BT_CanMove(DIR_LEFT))||(vX>0&&!BT_CanMove(DIR_RIGHT))){
				if(vX<0){
					if(BT_BreakBlocks(breakCombo, DIR_LEFT))
						Game->PlaySound(SFX_BOUNCINGTRAP_BREAK);
					else
						Game->PlaySound(SFX_BOUNCINGTRAP_BOUNCE);
				}
				else{
					if(BT_BreakBlocks(breakCombo, DIR_RIGHT))
						Game->PlaySound(SFX_BOUNCINGTRAP_BREAK);
					else
						Game->PlaySound(SFX_BOUNCINGTRAP_BOUNCE);
				}
				Ghost_Data = CMB_BOUNCINGTRAP+1;
				Q7_Ghost_Waitframes(this, ghost, 32);
				vX = -vX;
			}
			if((vY<0&&!BT_CanMove(DIR_UP))||(vY>0&&!BT_CanMove(DIR_DOWN))){
				if(vY<0){
					if(BT_BreakBlocks(breakCombo, DIR_UP))
						Game->PlaySound(SFX_BOUNCINGTRAP_BREAK);
					else
						Game->PlaySound(SFX_BOUNCINGTRAP_BOUNCE);
				}
				else{
					if(BT_BreakBlocks(breakCombo, DIR_DOWN))
						Game->PlaySound(SFX_BOUNCINGTRAP_BREAK);
					else
						Game->PlaySound(SFX_BOUNCINGTRAP_BOUNCE);
				}
				Ghost_Data = CMB_BOUNCINGTRAP+1;
				Q7_Ghost_Waitframes(this, ghost, 32);
				vY = -vY;
			}
			Ghost_Data = CMB_BOUNCINGTRAP;
			Ghost_MoveXY(vX, vY, 0);
			Q7_Ghost_Waitframe(this, ghost);
		}
	}
	bool BT_CanMove(int dir){
		if(Ghost_CanMove(dir, 1, 0)){
			if(!BT_CheckGap(dir))
				return false;
			return true;
		}
		else{
			return false;
		}
	}
	bool BT_CheckGap(int dir){
		int x = Ghost_X;
		int y = Ghost_Y;
		if(dir==DIR_UP){
			x += 8;
			y -= 1;
		}
		else if(dir==DIR_DOWN){
			x += 8;
			y += 16;
		}
		else if(dir==DIR_LEFT){
			x -= 1;
			y += 8;
		}
		else if(dir==DIR_RIGHT){
			x += 16;
			y += 8;
		}
		x = GridX(x);
		y = GridY(y);
		if(dir==DIR_UP||dir==DIR_DOWN){
			return CanWalk(x, y, DIR_LEFT, 1, true)||CanWalk(x, y, DIR_RIGHT, 1, true);
		}
		else if(dir==DIR_LEFT||dir==DIR_RIGHT){
			return CanWalk(x, y, DIR_UP, 1, true)||CanWalk(x, y, DIR_DOWN, 1, true);
		}
		
	}
	bool BT_BreakBlocks(int breakCombo, int dir){
		bool ret;
		int xOff[] = {00, 08, 15, 00, 08, 15, -1, -1, -1, 16, 16, 16};
		int yOff[] = {-1, -1, -1, 16, 16, 16, 00, 08, 15, 00, 08, 15};
		for(int i=0; i<3; i++){
			int pos = ComboAt(Ghost_X+xOff[dir*3+i], Ghost_Y+yOff[dir*3+i]);
			if(Screen->ComboD[pos]==breakCombo){
				Screen->ComboD[pos]++;
				ret = true;
			}
		}
		return ret;
	}
}

const int SPR_PUSTULE_POP = 93;
const int SFX_PUSTULE_POP = 10;

ffc script Pustule{
	void run(int breakCombo, int waterCombo, int maxrad){
		int poisonWater[] = "PoisonWater";
		int poisonWaterSlot = Game->GetFFCScript(poisonWater);
		if(CountFFCsRunning(poisonWaterSlot)==0)
			RunFFCScript(poisonWaterSlot, 0);
		
		int i; int j;
		
		int pos[176];
		int radius[176];
		bool broken[176];
		int numPustule;
		
		for(i=0; i<176; i++){
			if(Screen->ComboD[i]==breakCombo){
				pos[numPustule] = i;
				radius[numPustule] = -1;
				numPustule++;
			}
		}
		
		while(true){
			lweapon sword = LoadLWeaponOf(LW_SWORD);
			
			for(i=0; i<numPustule; i++){
				if(radius[i]>=0){
					radius[i] = Min(radius[i]+4, maxrad);
					Pustule_CreatePuddle(pos[i], radius[i], waterCombo, this->CSet);
					if(radius[i]>=maxrad)
						radius[i] = -2;
				}
				else if(radius[i]==-1){
					if(Screen->ComboD[pos[i]]==breakCombo){
						for(j=Screen->NumLWeapons(); j>0; --j){
							lweapon l = Screen->LoadLWeapon(j);
							if(l->CollDetection&&(l->ID==LW_SWORD||l->ID==LW_WAND||l->ID==LW_ARROW||l->ID==LW_BEAM||l->ID==LW_REFFIREBALL||l->ID==LW_CANDLE)){
								if(RectCollision(l->X+l->HitXOffset+4, l->Y+l->HitYOffset+4, l->X+l->HitXOffset+l->HitWidth-5, l->Y+l->HitYOffset+l->HitHeight-5, ComboX(pos[i]), ComboY(pos[i]), ComboX(pos[i])+15, ComboY(pos[i])+15)&&!broken[pos[i]]){
									broken[pos[i]] = true;
									Screen->ComboD[pos[i]]++;
								}
							}
						}
					}
					if(Screen->ComboD[pos[i]]!=breakCombo){
						Game->PlaySound(SFX_PUSTULE_POP);
						lweapon poof = CreateLWeaponAt(LW_SCRIPT10, ComboX(pos[i])-8, ComboY(pos[i])-8);
						poof->UseSprite(SPR_PUSTULE_POP);
						poof->Extend = 3;
						poof->TileWidth = 2;
						poof->TileHeight = 2;
						poof->CollDetection = false;
						poof->DeadState = poof->NumFrames*poof->ASpeed;
						radius[i] = 0;
					}
				}
			}
			Waitframe();
		}
	}
	void Pustule_CreatePuddle(int pos, int radius, int waterCombo, int waterCSet){
		int x = ComboX(pos);
		int y = ComboY(pos);
		int x2; int y2;
		for(int i=0; i<176; i++){
			if(Screen->ComboS[i]==0){
				if(Screen->ComboF[i]==0){
					x2 = ComboX(i);
					y2 = ComboY(i);
					if(Distance(x, y, x2, y2)<radius){
						for(int j=0; j<4; j++){
							int k = i;
							if(j==DIR_UP)
								k -= 16;
							else if(j==DIR_DOWN)
								k += 16;
							else if(j==DIR_LEFT)
								k--;
							else if(j==DIR_RIGHT)
								k++;
							if(k>=0&&k<176){
								if(Screen->ComboD[k]==waterCombo||i==pos){
									Screen->ComboD[i] = waterCombo;
									Screen->ComboC[i] = waterCSet;
									j = 4;
								}
							}
						}
					}
				}
			}
		}
	}
}

bool InputDir(int dir){
	if(dir==DIR_UP)
		return Link->InputUp;
	else if(dir==DIR_DOWN)
		return Link->InputDown;
	else if(dir==DIR_LEFT)
		return Link->InputLeft;
	else if(dir==DIR_RIGHT)
		return Link->InputRight;
	return false;
}

int DirX(int dir, int step){
	if(dir==DIR_UP)
		return 0;
	else if(dir==DIR_DOWN)
		return 0;
	else if(dir==DIR_LEFT)
		return -step;
	else if(dir==DIR_RIGHT)
		return step;
	else if(dir==DIR_LEFTUP)
		return -step;
	else if(dir==DIR_RIGHTUP)
		return step;
	else if(dir==DIR_LEFTDOWN)
		return -step;
	else if(dir==DIR_RIGHTDOWN)
		return step;
}

int DirY(int dir, int step){
	if(dir==DIR_LEFT)
		return 0;
	else if(dir==DIR_RIGHT)
		return 0;
	else if(dir==DIR_UP)
		return -step;
	else if(dir==DIR_DOWN)
		return step;
	else if(dir==DIR_LEFTUP)
		return -step;
	else if(dir==DIR_RIGHTUP)
		return -step;
	else if(dir==DIR_LEFTDOWN)
		return step;
	else if(dir==DIR_RIGHTDOWN)
		return step;
}

const int SFX_BOUNCE = 64;

ffc script BounceCombo{
	void run(int bounceCombo, int underCombo){
		int i; int j; int k;
		int pushDir;
		int pushStep;
		while(true){
			int collidedCombos[4];
			int pos = BounceCombo_CheckCollision(bounceCombo, collidedCombos);
			if(pos>-1){
				int bounceDir = -1;
				if(InputDir(Link->Dir))
					bounceDir = Link->Dir;
				
				int startX = Link->X;
				int startY = Link->Y;
				int x = startX;
				int y = startY;
				
				if(bounceDir>-1){
					Game->PlaySound(SFX_BOUNCE);
					for(i=0; i<12; i++){
						x += DirX(bounceDir, 2)*Cos(i*(180/12));
						y += DirY(bounceDir, 2)*Cos(i*(180/12));
						Link->X = x;
						Link->Y = y;
						for(j=0; j<collidedCombos[0]; j++){
							k = collidedCombos[1+j];
							Screen->FastCombo(0, ComboX(k), ComboY(k), underCombo, this->CSet, 128);
							if(bounceDir<2){
								if(i<4||i>8)
									Screen->FastCombo(0, ComboX(k), ComboY(k), bounceCombo+1, Screen->ComboC[k], 128);
								else
									Screen->FastCombo(0, ComboX(k), ComboY(k), bounceCombo+2, Screen->ComboC[k], 128);
							}
							else{
								if(i<4||i>8)
									Screen->FastCombo(0, ComboX(k), ComboY(k), bounceCombo+3, Screen->ComboC[k], 128);
								else
									Screen->FastCombo(0, ComboX(k), ComboY(k), bounceCombo+4, Screen->ComboC[k], 128);
							}
						}
						WaitNoAction();
					}
					Link->X = startX;
					Link->Y = startY;
					pushDir = OppositeDir(bounceDir);
					pushStep = 4;
				}
			}
			if(pushStep>0){
				LinkMovement_Push2(DirX(pushDir, pushStep), DirY(pushDir, pushStep));
				pushStep -= 0.2;
			}
			Waitframe();
		}
	}
	int BounceCombo_CheckCollision(int bounceCombo, int collidedCombos){
		collidedCombos[0] = 0;
		
		int ret = -1;
		int xOff[] = {08, 00, 15, 08, 00, 15, -1, -1, -1, 16, 16, 16};
		int yOff[] = {07, 07, 07, 16, 16, 16, 08, 12, 15, 08, 12, 15};
		for(int i=0; i<3; i++){
			int pos = ComboAt(Link->X+xOff[Link->Dir*3+i], Link->Y+yOff[Link->Dir*3+i]);
			if(Screen->ComboD[pos]==bounceCombo){
				if(ret==-1)
					ret = pos;
				collidedCombos[1+collidedCombos[0]] = pos;
				collidedCombos[0]++;
			}
		}
		return ret;
	}
}

ffc script AstolfoTest{
	void run(){
		item rupe;
		while(!rupe->isValid()){
			item i = Screen->LoadItem(1);
			if(i->isValid())
				rupe = i;
			Waitframe();
		}
		
		int lx = Link->X;
		int ly = Link->Y;
		while(true){
			if(Link->InputUp)
				--ly;
			else if(Link->InputDown)
				++ly;
			if(Link->InputLeft)
				--lx;
			else if(Link->InputRight)
				++lx;
			Link->X = lx;
			Link->Y = ly;
			Game->Counter[CR_BOMBS] = Abs(Link->X-rupe->X);
			Game->Counter[CR_KEYS] = Abs(Link->Y-rupe->Y);
			
			NoAction();
			Waitframe();
		}
	}
}

const int NPC_TRAPSCRIPTED = 270;
const int TIL_TRAPSCRIPTED = 122;

void DebugLinkPositioning(){
	if(Link->InputUp){
		if(Link->Y%8!=0||!Link->InputB)
			Link->Y--;
		Link->Dir = DIR_UP;
	}
	else if(Link->InputDown){
		if(Link->Y%8!=0||!Link->InputB)
			Link->Y++;
		Link->Dir = DIR_DOWN;
	}
	if(Link->InputLeft){
		if(Link->X%8!=0||!Link->InputB)
			Link->X--;
		Link->Dir = DIR_LEFT;
	}
	else if(Link->InputRight){
		if(Link->X%8!=0||!Link->InputB)
			Link->X++;
		Link->Dir = DIR_RIGHT;
	}
	NoAction();
}

//D0: Type
//	0 - 4-Way
//	1 - Vert Line of Sight
//	2 - Horiz Line of Sight
//	3 - Vert Constant
//	4 - Horiz Constant
ffc script ScriptedTrap{
	void run(int type, int forceStep, int forceDamage, int noSolid){
		npc ghost = Ghost_InitCreate(this, NPC_TRAPSCRIPTED);
		
		Ghost_Transform(this, ghost, GH_INVISIBLE_COMBO, this->CSet, 1, 1);
		ghost->OriginalTile = TIL_TRAPSCRIPTED;
		ghost->Tile = TIL_TRAPSCRIPTED;
		
		Ghost_SetFlag(GHF_FLYING_ENEMY);
		Ghost_SetFlag(GHF_IGNORE_WATER);
		Ghost_SetFlag(GHF_IGNORE_PITS);
		if(noSolid)
			Ghost_SetFlag(GHF_IGNORE_SOLIDITY);
		
		int step = 175;
		
		Ghost_SpawnAnimationPuff(this, ghost);
		
		if(type==3){
			step = 200;
			if(Ghost_Y<80)
				Ghost_Dir = DIR_DOWN;
			else
				Ghost_Dir = DIR_UP;
		}
		else if(type==4){
			step = 200;
			if(Ghost_X<120)
				Ghost_Dir = DIR_RIGHT;
			else
				Ghost_Dir = DIR_LEFT;
		}
		
		if(forceStep)
			step = forceStep;
		if(forceDamage)
			ghost->Damage = forceDamage;
		
		ghost->Damage = PiercingDamage(ghost->Damage);
		ghost->WeaponDamage = PiercingDamage(ghost->WeaponDamage);
		
		int startX = Ghost_X;
		int startY = Ghost_Y;
		int state;
		
		while(true){
			if(state==0){
				if(type==0){
					if(ST_DetectLink(ghost, DIR_DOWN)){
						Ghost_Dir = DIR_DOWN;
						state = 1;
					}
					else if(ST_DetectLink(ghost, DIR_UP)){
						Ghost_Dir = DIR_UP;
						state = 1;
					}
					else if(ST_DetectLink(ghost, DIR_LEFT)){
						Ghost_Dir = DIR_LEFT;
						state = 1;
					}
					else if(ST_DetectLink(ghost, DIR_RIGHT)){
						Ghost_Dir = DIR_RIGHT;
						state = 1;
					}
				}
				else if(type==1){
					if(ST_DetectLink(ghost, DIR_DOWN)){
						Ghost_Dir = DIR_DOWN;
						state = 1;
					}
					else if(ST_DetectLink(ghost, DIR_UP)){
						Ghost_Dir = DIR_UP;
						state = 1;
					}
				}
				else if(type==2){
					if(ST_DetectLink(ghost, DIR_LEFT)){
						Ghost_Dir = DIR_LEFT;
						state = 1;
					}
					else if(ST_DetectLink(ghost, DIR_RIGHT)){
						Ghost_Dir = DIR_RIGHT;
						state = 1;
					}
				}
			}
			if(state==1){
				Ghost_Move(Ghost_Dir, step/100, 0);
				if(!Ghost_CanMove(Ghost_Dir, 1, 0)||ST_CollidedPushBlock()){
					state = 2;
					Ghost_SetFlag(GHF_IGNORE_ALL_TERRAIN);
				}
			}
			else if(state==2){
				if(Distance(Ghost_X, Ghost_Y, startX, startY)>=0.5){
					Ghost_MoveAtAngle(Angle(Ghost_X, Ghost_Y, startX, startY), 0.5, 0);
				}
				else{
					Ghost_X = startX;
					Ghost_Y = startY;
					if(!noSolid)
						Ghost_UnsetFlag(GHF_IGNORE_ALL_TERRAIN);
					Ghost_SetFlag(GHF_IGNORE_WATER);
					Ghost_SetFlag(GHF_IGNORE_PITS);
					state = 0;
				}
			}
			if(type==3||type==4){
				Ghost_Move(Ghost_Dir, step/100, 0);
				if(!Ghost_CanMove(Ghost_Dir, 1, 0)||ST_CollidedPushBlock()){
					Game->PlaySound(SFX_BOUNCINGTRAP_BOUNCE);
					Ghost_Dir = OppositeDir(Ghost_Dir);
				}
			}
			Q7_Ghost_Waitframe(this, ghost, true, true);
		}
	}
	bool ST_CollidedPushBlock(){
		if(Screen->MovingBlockX>-1){
			if(Ghost_Dir==AngleDir4(Angle(Ghost_X, Ghost_Y, Screen->MovingBlockX, Screen->MovingBlockY))){
				return RectCollision(Ghost_X, Ghost_Y, Ghost_X+15, Ghost_Y+15, Screen->MovingBlockX, Screen->MovingBlockY, Screen->MovingBlockX+15, Screen->MovingBlockY+15);
			}
		}
		return false;
	}
	bool ST_DetectLink(npc ghost, int dir){
		if(dir==DIR_UP){
			return Abs(Link->X-ghost->X)<16 && Link->Y<ghost->Y;
		}
		else if(dir==DIR_DOWN){
			return Abs(Link->X-ghost->X)<16 && Link->Y>=ghost->Y;
		}
		else if(dir==DIR_LEFT){
			return Abs(Link->Y-ghost->Y)<16 && Link->X<=ghost->X-16;
		}
		else if(dir==DIR_RIGHT){
			return Abs(Link->Y-ghost->Y)<16 && Link->X>=ghost->X+16;
		}
	}
}

const int SFX_SWITCH_PRESS = 65; //SFX when a switch is pressed
const int SFX_SWITCH_RELEASE = 65; //SFX when a switch is released
const int SFX_SWITCH_ERROR = 66; //SFX when the wrong switch is pressed

int Switch_Pressed(int x, int y, bool noLink){
	int xOff = 0;
	int yOff = 4;
	int xDist = 8;
	int yDist = 8;
	if(Abs(Link->X+xOff-x)<=xDist&&Abs(Link->Y+yOff-y)<=yDist&&Link->Z==0&&!noLink)
		return 1;
	if(Screen->MovingBlockX>-1){
		if(Abs(Screen->MovingBlockX-x)<=8&&Abs(Screen->MovingBlockY-y)<=8)
			return 1;
	}
	if(Screen->isSolid(x+4, y+4)||
		Screen->isSolid(x+12, y+4)||
		Screen->isSolid(x+4, y+12)||
		Screen->isSolid(x+12, y+12)){
		return 2;
	}
	return 0;
}

ffc script Switch_Secret{
	void run(int perm, int id, int sfx){
		int d;
		int db;
		if(id>0){
			d = Floor((id-1)/16);
			db = 1<<((id-1)%16);
		}
		if(perm){
			if(id>0){
				if(Screen->D[d]&db){
					this->Data++;
					Screen->TriggerSecrets();
					Quit();
				}
			}
			else if(Screen->State[ST_SECRET]){
				this->Data++;
				Quit();
			}
		}
		while(!Switch_Pressed(this->X, this->Y, false)&&!(perm&&id==0&&Screen->State[ST_SECRET])){
			Waitframe();
		}
		this->Data++;
		Screen->TriggerSecrets();
		if(!(perm&&id==0&&Screen->State[ST_SECRET]))
			Game->PlaySound(SFX_SWITCH_PRESS);
		if(sfx==0)
			Game->PlaySound(SFX_SECRET);
		else if(sfx>0)
			Game->PlaySound(sfx);
		if(perm){
			if(id>0)
				Screen->D[d]|=db;
			else
				Screen->State[ST_SECRET] = true;
		}
	}
}

ffc script Switch_Remote{
	void run(int pressure, int id, int flag, int sfx){
		bool noLink;
		if(pressure==2){
			pressure = 1;
			noLink = true;
		}
		
		int data = this->Data;
		int i; int j; int k;
		int d;
		int db;
		if(id>0){
			d = Floor((id-1)/16);
			db = 1<<((id-1)%16);
		}
		int comboD[176];
		for(i=0; i<176; i++){
			if(Screen->ComboF[i]==flag){
				comboD[i] = Screen->ComboD[i];
				Screen->ComboF[i] = 0;
			}
		}
		if(id>0){
			if(Screen->D[d]&db){
				this->Data = data+1;
				for(i=0; i<176; i++){
					if(comboD[i]>0){
						Screen->ComboD[i] = comboD[i]+1;
					}
				}
				Quit();
			}
		}
		if(pressure){
			while(true){
				while(!Switch_Pressed(this->X, this->Y, noLink)){
					Waitframe();
				}
				this->Data = data+1;
				Game->PlaySound(SFX_SWITCH_PRESS);
				for(i=0; i<176; i++){
					if(comboD[i]>0){
						Screen->ComboD[i] = comboD[i]+1;
					}
				}
				while(Switch_Pressed(this->X, this->Y, noLink)){
					Waitframe();
				}
				this->Data = data;
				Game->PlaySound(SFX_SWITCH_RELEASE);
				for(i=0; i<176; i++){
					if(comboD[i]>0){
						Screen->ComboD[i] = comboD[i];
					}
				}
			}
		}
		else{
			while(!Switch_Pressed(this->X, this->Y, noLink)){
				Waitframe();
			}
			this->Data = data+1;
			Game->PlaySound(SFX_SWITCH_PRESS);
			if(sfx>0)
				Game->PlaySound(sfx);
			else
				Game->PlaySound(SFX_SECRET);
			for(i=0; i<176; i++){
				if(comboD[i]>0){
					Screen->ComboD[i] = comboD[i]+1;
				}
			}
			if(id>0){
				Screen->D[d] |= db;
			}
		}
	}
}

ffc script Switch_HitAll{
	void run(int switchCmb, int pressure, int perm, int id, int flag, int sfx, int switchID){
		bool noLink;
		if(pressure==2){
			pressure = 1;
			noLink = true;
		}
		
		int i; int j; int k;
		int d;
		int db;
		if(flag==0)
			id = 0;
		int comboD[176];
		if(id>0){
			d = Floor((id-1)/16);
			db = 1<<((id-1)%16);
			for(i=0; i<176; i++){
				if(Screen->ComboF[i]==flag){
					comboD[i] = Screen->ComboD[i];
					Screen->ComboF[i] = 0;
				}
			}
		}
		int switches[34];
		int switchD[34];
		int switchDB[34];
		switchD[0] = switchID;
		bool switchesPressed[34];
		k = SizeOfArray(switches)-2;
		for(i=0; i<176&&switches[0]<k; i++){
			if(Screen->ComboD[i]==switchCmb){
				j = 2+switches[0];
				switches[j] = i;
				if(!pressure&&switchID>0){
					switchD[j] = Floor((switchID+switches[0]-1)/16);
					switchDB[j] = 1<<((switchID+switches[0]-1)%16);
					if(Screen->D[switchD[j]]&switchDB[j]){
						switchesPressed[j] = true;
						Screen->ComboD[i] = switchCmb+1;
						switches[1]++;
					}
				}
				switches[0]++;
			}
		}
		if(perm){
			if(id>0){
				if(Screen->D[d]&db){
					for(i=2; i<switches[0]+2; i++){
						Screen->ComboD[switches[i]] = switchCmb+1;
						switchesPressed[i] = true;
					}
					for(i=0; i<176; i++){
						if(comboD[i]>0){
							Screen->ComboD[i] = comboD[i]+1;
						}
					}
					while(true){
						Switches_Update(switches, switchD, switchDB, switchesPressed, switchCmb, false, noLink);
						Waitframe();
					}
				}
			}
			if(Screen->State[ST_SECRET]){
				for(i=2; i<switches[0]+2; i++){
					Screen->ComboD[switches[i]] = switchCmb+1;
					switchesPressed[i] = true;
				}
				while(true){
					Switches_Update(switches, switchD, switchDB, switchesPressed, switchCmb, false, noLink);
					Waitframe();
				}
			}
		}
		if(pressure){
			while(switches[1]<switches[0]){
				Switches_Update(switches, switchD, switchDB, switchesPressed, switchCmb, true, noLink);
				Waitframe();
			}
			if(id>0){
				if(sfx>0)
					Game->PlaySound(sfx);
				else
					Game->PlaySound(SFX_SECRET);
				for(i=0; i<176; i++){
					if(comboD[i]>0){
						Screen->ComboD[i] = comboD[i]+1;
					}
				}
			}
			else{
				if(sfx>0)
					Game->PlaySound(sfx);
				else
					Game->PlaySound(SFX_SECRET);
				Screen->TriggerSecrets();
			}
			if(perm){
				if(id>0)
					Screen->D[d] |= db;
				else
					Screen->State[ST_SECRET] = true;
			}
		}
		else{
			while(switches[1]<switches[0]){
				Switches_Update(switches, switchD, switchDB, switchesPressed, switchCmb, false, noLink);
				Waitframe();
			}
			if(id>0){
				if(sfx>0)
					Game->PlaySound(sfx);
				else
					Game->PlaySound(SFX_SECRET);
				for(i=0; i<176; i++){
					if(comboD[i]>0){
						Screen->ComboD[i] = comboD[i]+1;
					}
				}
			}
			else{
				if(sfx>0)
					Game->PlaySound(sfx);
				else
					Game->PlaySound(SFX_SECRET);
				Screen->TriggerSecrets();
			}
			if(perm){
				if(id>0)
					Screen->D[d] |= db;
				else
					Screen->State[ST_SECRET] = true;
			}
		}
		while(true){
			Switches_Update(switches, switchD, switchDB, switchesPressed, switchCmb, false, noLink);
			Waitframe();
		}
	}
	void Switches_Update(int switches, int switchD, int switchDB, bool switchesPressed, int switchCmb, bool pressure, bool noLink){
		if(pressure)
			switches[1] = 0;
		for(int i=0; i<switches[0]; i++){
			int j = i+2;
			int k = switches[j];
			int p = Switch_Pressed(ComboX(k), ComboY(k), noLink);
			if(p){
				if(p!=2)
					Screen->ComboD[k] = switchCmb+1;
				if(!switchesPressed[j]){
					Game->PlaySound(SFX_SWITCH_PRESS);
					if(switchD[0]>0){
						Screen->D[switchD[j]] |= switchDB[j];
					}
					switchesPressed[j] = true;
					if(!pressure)
						switches[1]++;
				}
				if(pressure)
					switches[1]++;
			}
			else{
				if(switchesPressed[j]){
					if(pressure){
						Game->PlaySound(SFX_SWITCH_RELEASE);
						Screen->ComboD[k] = switchCmb;
						switchesPressed[j] = false;
					}
					else{
						if(Screen->ComboD[k]!=switchCmb+1)
							Screen->ComboD[k] = switchCmb+1;
					}
				}
			}
		}
	}
}

ffc script Switch_Trap{
	void run(int enemyid, int count){
		while(!Switch_Pressed(this->X, this->Y, false)){
			Waitframe();
		}
		this->Data++;
		Game->PlaySound(SFX_SWITCH_PRESS);
		Game->PlaySound(SFX_SWITCH_ERROR);
		for(int i=0; i<count; i++){
			int pos = Switch_GetSpawnPos();
			npc n = CreateNPCAt(enemyid, ComboX(pos), ComboY(pos));
			Game->PlaySound(SFX_FALL);
			n->Z = 176;
			Waitframes(20);
		}
	}
	int Switch_GetSpawnPos(){
		int pos;
		bool invalid = true;
		int failSafe = 0;
		while(invalid&&failSafe<512){
			pos = Rand(176);
			if(Switch_ValidSpawn(pos))
				return pos;
		}
		for(int i=0; i<176; i++){
			pos = i;
			if(Switch_ValidSpawn(pos))
				return pos;
		}
	}
	bool Switch_ValidSpawn(int pos){
		int x = ComboX(pos);
		int y = ComboY(pos);
		if(Screen->isSolid(x+4, y+4)||
			Screen->isSolid(x+12, y+4)||
			Screen->isSolid(x+4, y+12)||
			Screen->isSolid(x+12, y+12)){
			return false;
		
		}
		if(ComboFI(pos, CF_NOENEMY)||ComboFI(pos, CF_NOGROUNDENEMY))
			return false;
		int ct = Screen->ComboT[pos];
		if(ct==CT_NOENEMY||ct==CT_NOGROUNDENEMY||ct==CT_NOJUMPZONE)
			return false;
		if(ct==CT_WATER||ct==CT_LADDERONLY||ct==CT_HOOKSHOTONLY||ct==CT_LADDERHOOKSHOT)
			return false;
		if(ct==CT_PIT||ct==CT_PITB||ct==CT_PITC||ct==CT_PITD||ct==CT_PITR)
			return false;
		return true;
	}
}

ffc script Switch_Sequential{
	void run(int flag, int perm, int sfx){
		int i; int j; int k;
		int switches[34];
		int switchCmb[34];
		int switchMisc[8];
		bool switchesPressed[34];
		k = SizeOfArray(switches)-2;
		for(i=0; i<176&&switches[0]<k; i++){
			if(Screen->ComboF[i]==flag){
				j = 2+switches[0];
				switches[j] = i;
				switchCmb[j] = Screen->ComboD[i];
				switches[0]++;
			}
		}
		int switchOrder[34];
		Switches_Organize(switches, switchOrder);
		if(perm&&Screen->State[ST_SECRET]){
			for(i=0; i<switches[0]; i++){
				switchesPressed[i+2] = true;
			}
			while(true){
				Switches_Update(switches, switchesPressed, switchOrder, switchCmb, switchMisc, false);
				Waitframe();
			}
		}
		while(switches[1]<switches[0]){
			Switches_Update(switches, switchesPressed, switchOrder, switchCmb, switchMisc, true);
			if(switchMisc[0]==1){
				switchMisc[0] = 0;
				for(i=0; i<30; i++){
					Switches_Update(switches, switchesPressed, switchOrder, switchCmb, switchMisc, false);
					Waitframe();
				}
				while(Switches_LinkOn(switches)){
					Switches_Update(switches, switchesPressed, switchOrder, switchCmb, switchMisc, false);
					Waitframe();
				}
			}
			Waitframe();
		}
		if(sfx>0)
			Game->PlaySound(sfx);
		else
			Game->PlaySound(SFX_SECRET);
		Screen->TriggerSecrets();
		if(perm)
			Screen->State[ST_SECRET] = true;
		for(i=0; i<switches[0]; i++){
			switchesPressed[i+2] = true;
		}
		while(true){
			Switches_Update(switches, switchesPressed, switchOrder, switchCmb, switchMisc, false);
			Waitframe();
		}
		
	}
	void Switches_Organize(int switches, int switchOrder){
		bool banned[34];
		for(int j=0; j<switches[0]; j++){
			int lowest = -1;
			int lowestIndex = -1;
			for(int i=0; i<switches[0]; i++){
				int c = Screen->ComboD[switches[i+2]];
				if(c!=-1&&!banned[i+2]){
					if(lowest==-1||c<lowest){
						lowest = c;
						lowestIndex = i+2;
					}
				}
			}
			switchOrder[j] = lowestIndex;
			banned[lowestIndex] = true;
		}
	}
	bool Switches_LinkOn(int switches){
		for(int i=0; i<switches[0]; i++){
			int j = i+2;
			int k = switches[j];
			int p = Switch_Pressed(ComboX(k), ComboY(k), false);
			if(p==1)
				return true;
		}
		return false;
	}
	void Switches_Update(int switches, bool switchesPressed, int switchOrder, int switchCmb, int switchMisc, bool canPress){
		bool reset;
		for(int i=0; i<switches[0]; i++){
			int j = i+2;
			int k = switches[j];
			int p = Switch_Pressed(ComboX(k), ComboY(k), false);
			if(!switchesPressed[j]){
				if(p!=2)
					Screen->ComboD[k] = switchCmb[j];
				if(p&&canPress){
					if(j==switchOrder[switches[1]]){
						switches[1]++;
						Game->PlaySound(SFX_SWITCH_PRESS);
						switchesPressed[j] = true;
					}
					else{
						switches[1] = 0;
						Game->PlaySound(SFX_SWITCH_ERROR);
						reset = true;
					}
				}
			}
			else{
				if(p!=2)
					Screen->ComboD[k] = switchCmb[j]+1;
				if(p==0&&canPress){
					Game->PlaySound(SFX_SWITCH_RELEASE);
					switchesPressed[j] = false;
				}
			}
		}
		if(reset){
			switchMisc[0] = 1;
			for(int i=0; i<switches[0]; i++){
				int j = i+2;
				int k = switches[j];
				int p = Switch_Pressed(ComboX(k), ComboY(k), false);
				switchesPressed[j] = false;
			}
		}
	}
}

ffc script WallmasterHasItem{
	void run(){
		item itm;
		for(int i=0; i<4; i++){
			if(Screen->NumItems()>0)
				itm = Screen->LoadItem(1);
			if(itm->isValid()){
				if(itm->Pickup&IP_ST_ITEM){
					itm->Y = 176+16;
				}
			}
			Waitframe();
		}
		if(Screen->NumItems()>0)
			itm = Screen->LoadItem(1);
		npc first;
		if(Screen->NumNPCs()>0)
			first = Screen->LoadNPC(1);
		if(first->isValid()){
			if(first->ID!=NPC_WALLMASTER){
				if(itm->isValid()){
					if(itm->Pickup&IP_ST_ITEM){
						itm->X = this->X;
						itm->Y = this->Y;
					}
				}
				Quit();
			}
		}
		else{
			if(itm->isValid()){
				if(itm->Pickup&IP_ST_ITEM){
					itm->X = this->X;
					itm->Y = this->Y;
				}
			}
			Quit();
		}
		while(true){
			if(Screen->NumItems()>0)
				itm = Screen->LoadItem(1);
			if(itm->isValid()&&first->isValid()){
				if(itm->Pickup&IP_ST_ITEM){
					if(first->HitXOffset!=1000){
						itm->X = first->X;
						itm->Y = first->Y;
					}
					else{
						itm->Y = 176+16;
					}
				}
			}
			Waitframe();
		}
	}
}

const int EWM_SCRIPTFIRE = 2;
const int EW_SCRIPTFIRE = 39;

//Creates and returns an exact copy of the passed EWeapon but with a different ID. Assumes that the passed pointer is valid.
eweapon DuplicateNewIDSprite(eweapon a, int id, int spr) {
  eweapon b = Screen->CreateEWeapon(id);
  b->X = a->X;
  b->Y = a->Y;
  b->Z = a->Z;
  b->Jump = a->Jump;
  b->Extend = a->Extend;
  b->TileWidth = a->TileWidth;
  b->TileHeight = a->TileHeight;
  b->HitWidth = a->HitWidth;
  b->HitHeight = a->HitHeight;
  b->HitZHeight = a->HitZHeight;
  b->HitXOffset = a->HitXOffset;
  b->HitYOffset = a->HitYOffset;
  b->DrawXOffset = a->DrawXOffset;
  b->DrawYOffset = a->DrawYOffset;
  b->DrawZOffset = a->DrawZOffset;
  // b->Tile = a->Tile;
  // b->CSet = a->CSet;
  b->DrawStyle = a->DrawStyle;
  b->Dir = a->Dir;
  // b->OriginalTile = a->OriginalTile;
  // b->OriginalCSet = a->OriginalCSet;
  // b->FlashCSet = a->FlashCSet;
  // b->NumFrames = a->NumFrames;
  // b->Frame = a->Frame;
  // b->ASpeed = a->ASpeed;
  b->UseSprite(spr);
  b->Damage = a->Damage;
  b->Step = a->Step;
  b->Angle = a->Angle;
  b->Angular = a->Angular;
  b->CollDetection = a->CollDetection;
  b->DeadState = a->DeadState;
  b->Flash = a->Flash;
  b->Flip = a->Flip;
  for (int i = 0; i < 16; i++)
    b->Misc[i] = a->Misc[i];
  return b;
}

ffc script FourTwentyDontBlazeIt{
	void run(int spr){
		if(spr==0)
			spr = 35;
		while(true){
			for(int i=Screen->NumEWeapons(); i>=1; i--){
				eweapon e = Screen->LoadEWeapon(i);
				if(e->ID==EW_FIRE){
					eweapon e2 = DuplicateNewIDSprite(e, EW_SCRIPTFIRE, spr);
					e->DeadState = 0;
				}
				else if(e->ID==EW_SCRIPTFIRE){
					e->Misc[EWM_SCRIPTFIRE]++;
					if(e->Misc[EWM_SCRIPTFIRE]>32)
						e->Step = 0;
					if(e->Misc[EWM_SCRIPTFIRE]>=126)
						e->DeadState = 0;
				}
			}
			
			Waitframe();
		}
	}
}

ffc script FireWheelWizzrobe{
	void run(int enemyid){
		int i;
		
		npc ghost = Ghost_InitAutoGhost(this, enemyid);
		this->Flags[FFCF_ETHEREAL] = true;
		Ghost_SetFlag(GHF_4WAY);
		int cr; int cr2; int cr3;
		
		int teleportState = 0;
		int teleportTimer = 4;
		bool doAttack;
		ghost->DrawXOffset = 1000;
		ghost->HitXOffset = 1000;
		while(true){
			doAttack = false;
			if(teleportState==0&&G[G_TRACKTILEDIR]>-1){
				while(G[G_TRACKTILEDIR]>-1){
					Q7_Ghost_Waitframe(this, ghost);
				}
			}
			if(teleportTimer>0)
				teleportTimer--;
			else{
				if(teleportState==0){ //Invisible
					teleportState = 1;
					teleportTimer = 64;
					i = BW_GetTeleportPos();
					Ghost_X = ComboX(i);
					Ghost_Y = ComboY(i);
					Ghost_Dir = AngleDir4(Angle(Ghost_X, Ghost_Y, Link->X, Link->Y));
				}
				else if(teleportState==1){ //Teleport In
					teleportState = 2;
					teleportTimer = 16;
				}
				else if(teleportState==2){ //Before Attacking
					teleportState = 3;
					teleportTimer = 48;
					doAttack = true;
				}
				else if(teleportState==3){ //Attacking
					teleportState = 4;
					teleportTimer = 16;
				}
				else if(teleportState==4){ //Teleport Out
					teleportState = 0;
					teleportTimer = 75;
				}
			}
			if(teleportState==0){
				ghost->CollDetection = false;
				ghost->DrawXOffset = 1000;
				ghost->HitXOffset = 1000;
			}
			else if(teleportState==1||teleportState==4){
				ghost->CollDetection = true;
				ghost->HitXOffset = 0;
				if(teleportTimer%2==0){
					ghost->DrawXOffset = 1000;
				}
				else{
					ghost->DrawXOffset = 0;
				}
			}
			else{
				ghost->CollDetection = true;
				ghost->HitXOffset = 0;
				ghost->DrawXOffset = 0;
			}
			
			if(doAttack){
				int wfw[] = "FireWheel";
				int args[8];
				args[0] = Ghost_X;
				args[1] = Ghost_Y;
				args[2] = ghost->WeaponDamage;
				RunFFCScript(Game->GetFFCScript(wfw), args);
				Q7_Ghost_Waitframes(this, ghost, 48);
			}
			Q7_Ghost_Waitframe(this, ghost);
		}
	}
	int BW_GetTeleportPos(){
		int i;
		int x; int y;
		int pos; int ct;
		
		int linkX = Clamp(GridX(Link->X)+8, 32, 208);
		int linkY = Clamp(GridY(Link->Y)+8, 32, 128);
		
		
		int validPos[176];
		int numValid;
		
		//Find all valid combos to teleport to in all four directions
		
		//Up
		for(i=2; i<11; i++){
			x = linkX;
			y = linkY-16*i;
			pos = ComboAt(x, y);
			ct = Screen->ComboT[pos];
			if(x<32||x>224||y<32||y>144)
				continue;
			if(ComboFI(pos, CF_NOENEMY))
				continue;
			if(ct==CT_NOENEMY||ct==CT_NOFLYZONE)
				continue;
			
			validPos[numValid] = pos;
			numValid++;
		}
		//Down
		for(i=2; i<11; i++){
			x = linkX;
			y = linkY+16*i;
			pos = ComboAt(x, y);
			ct = Screen->ComboT[pos];
			if(x<32||x>224||y<32||y>144)
				continue;
			if(ComboFI(pos, CF_NOENEMY))
				continue;
			if(ct==CT_NOENEMY||ct==CT_NOFLYZONE)
				continue;
			
			validPos[numValid] = pos;
			numValid++;
		}
		//Left
		for(i=2; i<16; i++){
			x = linkX-16*i;
			y = linkY;
			pos = ComboAt(x, y);
			ct = Screen->ComboT[pos];
			if(x<32||x>224||y<32||y>144)
				continue;
			if(ComboFI(pos, CF_NOENEMY))
				continue;
			if(ct==CT_NOENEMY||ct==CT_NOFLYZONE)
				continue;
			
			validPos[numValid] = pos;
			numValid++;
		}
		//Right
		for(i=2; i<16; i++){
			x = linkX+16*i;
			y = linkY;
			pos = ComboAt(x, y);
			ct = Screen->ComboT[pos];
			if(x<32||x>224||y<32||y>144)
				continue;
			if(ComboFI(pos, CF_NOENEMY))
				continue;
			if(ct==CT_NOENEMY||ct==CT_NOFLYZONE)
				continue;
			
			validPos[numValid] = pos;
			numValid++;
		}
	
		//Default to the top left if there's no valid spots
		if(numValid==0)
			return 0;
		
		return validPos[Rand(numValid)];
	}
}

bool DetectShieldHitGoddammit(int tx, int ty, int txsz2, int tysz2, eweapon e){
	int x = e->X;
	int y = e->Y;
	int hxsz = e->HitWidth;
	int hysz = e->HitHeight;
	int hxofs = e->HitXOffset;
	int hyofs = e->HitYOffset;
	
	
	return tx+txsz2>x+hxofs &&
           ty+tysz2>y+hyofs &&
           
           tx<x+hxofs+hxsz &&
           ty<y+hyofs+hysz;
	//return RectCollision(Link->X+7, Link->Y+7, Link->X+8, Link->Y+8, e->X+e->HitXOffset, e->Y+e->HitYOffset, e->X+e->HitXOffset+e->HitWidth-1, e->Y+e->HitYOffset+e->HitHeight-1);		
}

ffc script FireWheel{
	void run(int centerX, int centerY, int damage){
		int i;
		int x; int y;
		int x2; int y2;
		
		int rotDir = Choose(-1, 1);
		int angle = Rand(360);
		eweapon fires[6];
		int xOff[6];
		int yOff[6];
		bool wentOffscreen[6];
		bool permaDead[6];
		int deathTimer[6];
		int lastX[6];
		int lastY[6];
		Game->PlaySound(SFX_FIRE);
		for(i=0; i<6; i++){
			fires[i] = FireEWeapon(EW_SCRIPT10, centerX, centerY, DegtoRad(angle+60*i), 0, damage, 35, 0, EWF_UNBLOCKABLE);
			xOff[i] = Rand(-10, 10)/10;
			yOff[i] = Rand(-10, 10)/10;
			deathTimer[i] = 96+Rand(48);
		}
		int dist = 0;
		int rot = 0;
		int count = 1;
		
		int expandSpeed = LazyDiffMod(0.4, 0.5, 0.55);
		int rotAccelSpeed = LazyDiffMod(0.03, 0.04, 0.05);
		while(count){
			count = 0;
			dist += expandSpeed;
			rot += rotAccelSpeed;
			angle += rot*rotDir;
			for(i=0; i<6; i++){
				x = centerX+VectorX(dist, angle+60*i);
				y = centerY+VectorY(dist, angle+60*i);
				x += dist*xOff[i]*0.5;
				y += dist*yOff[i]*0.5;
				x2 = centerX+VectorX(dist, angle+((rot+0.05)*rotDir)+60*i);
				y2 = centerY+VectorY(dist, angle+((rot+0.05)*rotDir)+60*i);
				x2 += dist*xOff[i]*0.5;
				y2 += dist*yOff[i]*0.5;
				int dir = AngleDir4(Angle(x, y, x2, y2));
				deathTimer[i]--;
				if(fires[i]->isValid()){
					if(x<=16||x>=224||y<=16||y>=144){
						wentOffscreen[i] = true;
					}
					fires[i]->X = x;
					fires[i]->Y = y;
					fires[i]->Dir = dir;
					if(DetectShieldHitGoddammit(Link->X+6, Link->Y+6, 4, 4, fires[i])){
						if(AngleDir4(Angle(Link->X, Link->Y, fires[i]->X, fires[i]->Y))==Link->Dir){
							if(Link->Item[I_SHIELD2]){
								fires[i]->DeadState = 0;
								Game->PlaySound(SFX_CLINK);
								permaDead[i] = true;
							}
						}
					}
					if(deathTimer[i]<=0){
						wentOffscreen[i] = false;
						fires[i]->DeadState = 0;
					}
					count++;
				}
				else{
					if(wentOffscreen[i]&&!permaDead[i]){
						if(x>16&&x<224&&y>16&&y<144){
							fires[i] = FireEWeapon(EW_SCRIPT10, x, y, DegtoRad(angle+60*i), 0, damage, 35, 0, 0);
							fires[i]->Dir = dir;
							wentOffscreen[i] = false;
						}
					}
				}
				lastX[i] = x;
				lastY[i] = y;
			}
			
			Waitframe();
		}
		for(i=0; i<6; i++){
			if(fires[i]->isValid())
				fires[i]->DeadState = 0;
		}
	}
}

//D0: Flag to make a combo Step->Next
ffc script ScriptedStepNext{
	void run(int markerFlag){
		int linkPos = ComboAt(Link->X+8, Link->Y+12);
		int underLink = linkPos;
		while(true){
			linkPos = ComboAt(Link->X+8, Link->Y+12);
			if(ComboFI(linkPos, markerFlag)&&linkPos!=underLink){
				Screen->ComboD[linkPos]++;
			}
			underLink = linkPos;
			Waitframe();
		}
	}
}

void L10BG_Init(){
	Screen->SetRenderTarget(RT_L10BG);
	Screen->Rectangle(0, 0, 0, 511, 511, 0, 1, 0, 0, 0, true, 128);
	Screen->SetRenderTarget(RT_SCREEN);
	
	G[G_L10BG_X] = 0;
	G[G_L10BG_Y] = 0;
	int a = Rand(360);
	G[G_L10BG_VX] = VectorX(1, a);
	G[G_L10BG_VY] = VectorY(1, a);
	G[G_L10BG_SCALE] = 0;
	G[G_L10BG_T] = 0;
	
	Waitframe();
	
}

void L10BG_Update(){
	if(Game->GetCurLevel()==10){
		L10BG_Draw();
		if(G[G_L10BG_SCALE]<8)
			G[G_L10BG_SCALE]++;
		G[G_L10BG_T] = (G[G_L10BG_T]+1)%360;
		G[G_L10BG_X] += G[G_L10BG_VX];
		G[G_L10BG_Y] += G[G_L10BG_VY];
		
		if(G[G_L10BG_X]<0)
			G[G_L10BG_X] += 256;
		else if(G[G_L10BG_X]>=256)
			G[G_L10BG_X] -= 256;
		if(G[G_L10BG_Y]<0)
			G[G_L10BG_Y] += 176;
		else if(G[G_L10BG_Y]>=176)
			G[G_L10BG_Y] -= 176;
	}
	else{
		G[G_L10BG_SCALE] = 0;
		G[G_L10BG_T] = 0;
	}
}

const int RT_L10BG = 1;

void L10BG_Draw(){
	Screen->SetRenderTarget(RT_L10BG);
	Screen->DrawScreen(0, 7, 0x87, -256+G[G_L10BG_X], -176+G[G_L10BG_Y], 0);
	Screen->DrawScreen(0, 7, 0x87, G[G_L10BG_X], -176+G[G_L10BG_Y], 0);
	Screen->DrawScreen(0, 7, 0x87, -256+G[G_L10BG_X], G[G_L10BG_Y], 0);
	Screen->DrawScreen(0, 7, 0x87, G[G_L10BG_X], G[G_L10BG_Y], 0);
	
	Screen->DrawBitmap(0, RT_L10BG, 0, 0, 256, 176, 256, 0, 256, 176, 0, false);
	
	if(Link->Action!=LA_SCROLLING){
		Screen->DrawLayer(0, Game->GetCurMap(), Game->GetCurScreen(), 0, 0, 0, 0, 64);
	}
	
	Screen->DrawBitmap(0, RT_L10BG, 256+0,   0,   16,  176, 0+0,   0,   16,  176, 0, false);
	Screen->DrawBitmap(0, RT_L10BG, 256+240, 0,   16,  176, 0+240, 0,   16,  176, 0, false);
	
	Screen->SetRenderTarget(RT_SCREEN);
	
	for(int i=0; i<176; i++){
		int j;
		if(i%2==0)
			j = Floor(G[G_L10BG_SCALE]*Sin(i*4+G[G_L10BG_T]));
		else
			j = Floor(G[G_L10BG_SCALE]*Sin(i*4+G[G_L10BG_T]))+2;
		Screen->DrawBitmap(3, RT_L10BG, 0, i, 256, 1, j, i, 256, 1, 0, false);
		if(j<0)
			Screen->DrawBitmap(3, RT_L10BG, 0, i, 256, 1, j+256, i, 256, 1, 0, false);
		else if(j>0)
			Screen->DrawBitmap(3, RT_L10BG, 0, i, 256, 1, j-256, i, 256, 1, 0, false);
	}
}

const int I_LIKELIKEEATEN = 158;

const int I_SHIELD3STOLEN = 169;
const int I_RING2STOLEN = 170;
const int I_SHIELD4STOLEN = 171;

void TunicEatingLikeLike_Update(){
	if(G[G_LIKELIKE_STOLENITEMFRAMES]){
		--G[G_LIKELIKE_STOLENITEMFRAMES];
	}
	if(!Link->Item[I_LIKELIKEEATEN]){
		int pool[16];
		int poolSize;
		
		if(Link->Item[I_SHIELD4]){
			if(IsHardMode()&&!IsRandomizer()){
				pool[poolSize] = I_SHIELD4;
				poolSize++;
			}
		}
		else if(Link->Item[I_SHIELD3]){
			if(IsHardMode()&&!IsRandomizer()){
				pool[poolSize] = I_SHIELD3;
				poolSize++;
			}
		}
		else if(Link->Item[I_SHIELD2]){
			pool[poolSize] = I_SHIELD2;
			poolSize++;
		}
		
		if(IsHardMode()&&!IsRandomizer()){
			if(Link->Item[I_RING2]){
				pool[poolSize] = I_RING2;
				poolSize++;
			}
			else if(Link->Item[I_RING1]){
				pool[poolSize] = I_RING1;
				poolSize++;
			}
		}
		
		if(Link->Item[I_BAIT]){
			pool[poolSize] = I_BAIT;
			poolSize++;
		}
		
		if(Link->Item[I_POTION2]){
			pool[poolSize] = I_POTION2;
			poolSize++;
		}
		else if(Link->Item[I_POTION1]){
			pool[poolSize] = I_POTION1;
			poolSize++;
		}
		
		int eaten = -1;
		if(poolSize>1)
			eaten = pool[Rand(poolSize)];
		else if(poolSize==1)
			eaten = pool[0];
		
		G[G_LIKELIKE_STOLENITEMFRAMES] = 60;
		
		if(eaten==I_SHIELD4){
			G[G_LIKELIKE_STOLENITEM] = I_SHIELD4;
			Link->Item[I_SHIELD4STOLEN] = true;
			Game->PlaySound(19);
			Link->Item[I_SHIELD4] = false;
			if(IsVeryHardMode()){
				Link->Item[I_SHIELD3] = false;
				Link->Item[I_SHIELD2] = false;
			}
			Screen->Message(119);
		}
		else if(eaten==I_SHIELD3){
			G[G_LIKELIKE_STOLENITEM] = I_SHIELD3;
			Link->Item[I_SHIELD3STOLEN] = true;
			Game->PlaySound(19);
			Link->Item[I_SHIELD3] = false;
			if(IsVeryHardMode())
				Link->Item[I_SHIELD2] = false;
			Screen->Message(118);
		}
		else if(eaten==I_SHIELD2){
			G[G_LIKELIKE_STOLENITEM] = I_SHIELD2;
			Game->PlaySound(19);
			Link->Item[I_SHIELD2] = false;
			Screen->Message(75);
		}
		else if(eaten==I_RING2){
			G[G_LIKELIKE_STOLENITEM] = I_RING2;
			Link->Item[I_RING2STOLEN] = true;
			Game->PlaySound(19);
			Link->Item[I_RING2] = false;
			Screen->Message(115);
		}
		else if(eaten==I_RING1){
			G[G_LIKELIKE_STOLENITEM] = I_RING1;
			Game->PlaySound(19);
			Link->Item[I_RING1] = false;
			Screen->Message(76);
		}
		else if(eaten==I_BAIT){
			Game->PlaySound(19);
			Link->Item[I_BAIT] = false;
			Screen->Message(120);
		}
		else if(eaten==I_POTION2){
			Game->PlaySound(19);
			Link->Item[I_POTION2] = false;
			Link->Item[I_POTION1] = false;
			Screen->Message(122);
		}
		else if(eaten==I_POTION1){
			Game->PlaySound(19);
			Link->Item[I_POTION1] = false;
			Screen->Message(121);
		}
		Link->Item[I_LIKELIKEEATEN] = true;
	}
}

bool CollisionMod(lweapon a, int x, int y, int w, int h)
{
    int ax = a->X + a->HitXOffset;
    int bx = x;
    int ay = a->Y + a->HitYOffset;
    int by = y;
	if(a->ID==LW_ARROW){
		if(a->Dir==DIR_UP)
			ay -= 3;
		else if(a->Dir==DIR_DOWN)
			ay += 3;
		if(a->Dir==DIR_LEFT)
			ax -= 3;
		else if(a->Dir==DIR_RIGHT)
			ax += 3;
	}
    return RectCollision(ax, ay, ax+a->HitWidth, ay+a->HitHeight, bx, by, bx+w-1, by+h-1);
}

bool CollisionMod(lweapon a, npc b)
{
    int ax = a->X + a->HitXOffset;
    int bx = b->X + b->HitXOffset;
    int ay = a->Y + a->HitYOffset;
    int by = b->Y + b->HitYOffset;
	if(a->ID==LW_ARROW){
		if(a->Dir==DIR_UP)
			ay -= 3;
		else if(a->Dir==DIR_DOWN)
			ay += 3;
		if(a->Dir==DIR_LEFT)
			ax -= 3;
		else if(a->Dir==DIR_RIGHT)
			ax += 3;
	}
    return RectCollision(ax, ay, ax+a->HitWidth, ay+a->HitHeight, bx, by, bx+b->HitWidth-1, by+b->HitHeight-1) && (a->Z + a->HitZHeight >= b->Z) && (a->Z <= b->Z + b->HitZHeight);
}

bool LinkCollisionMod(npc b)
{
    int ax = Link->X + Link->HitXOffset;
    int bx = b->X + b->HitXOffset;
    int ay = Link->Y + Link->HitYOffset;
    int by = b->Y + b->HitYOffset;
    return RectCollision(ax+5, ay+5, ax+Link->HitWidth-5, ay+Link->HitHeight-5, bx, by, bx+b->HitWidth, by+b->HitHeight) && (Link->Z + Link->HitZHeight >= b->Z) && (Link->Z <= b->Z + b->HitZHeight);
}

bool LinkCollisionMod(eweapon b)
{
    int ax = Link->X + Link->HitXOffset;
    int bx = b->X + b->HitXOffset;
    int ay = Link->Y + Link->HitYOffset;
    int by = b->Y + b->HitYOffset;
    return RectCollision(ax+7, ay+7, ax+Link->HitWidth-7, ay+Link->HitHeight-7, bx, by, bx+b->HitWidth, by+b->HitHeight) && (Link->Z + Link->HitZHeight >= b->Z) && (Link->Z <= b->Z + b->HitZHeight);
}

bool LinkCollisionMod(int x, int y, int w, int h){
	return RectCollision(Link->X, Link->Y, Link->X+15, Link->Y+15, x, y, x+w-1, y+h-1);
}

const int SPR_POISONSHOT = 94;
const int EW_POISONSHOT = 40;

const int CMB_YASG_POISONFLOOR1 = 165;
const int CMB_YASG_POISONFLOOR2 = 183;
const int CMB_YASG_POISONFLOOR3 = 178;

bool IsEasyMode(){
	return Link->Item[I_DIFF_EASY]||Link->Item[I_DIFF_VERYEASY];
}

bool IsHardMode(){
	return Q7_CheatEnabled(G_MODE_ALWAYSHARD)||Link->Item[I_DIFF_HARD]||Link->Item[I_DIFF_VERYHARD]||Link->Item[I_DIFF_REALLYJOEL];
}

bool IsHardModeNoCheat(){
	return Link->Item[I_DIFF_HARD]||Link->Item[I_DIFF_VERYHARD]||Link->Item[I_DIFF_REALLYJOEL];
}

bool IsVeryHardMode(){
	return Q7_CheatEnabled(G_MODE_ALWAYSHARD)||Link->Item[I_DIFF_VERYHARD]||Link->Item[I_DIFF_REALLYJOEL];
}

bool IsVeryHardModeNoCheat(){
	return Link->Item[I_DIFF_VERYHARD]||Link->Item[I_DIFF_REALLYJOEL];
}

int LazyDiffMod(int modNormal, int modHard, int modVeryHard){
	if(Q7_CheatEnabled(G_MODE_ALWAYSHARD)||Link->Item[I_DIFF_VERYHARD]||Link->Item[I_DIFF_REALLYJOEL])
		return modVeryHard;
	else if(Link->Item[I_DIFF_HARD])
		return modHard;
	else
		return modNormal;
}

int LazyDiffMod(int modVeryEasy, int modEasy, int modNormal, int modHard, int modVeryHard){
	if(Q7_CheatEnabled(G_MODE_ALWAYSHARD)||Link->Item[I_DIFF_VERYHARD]||Link->Item[I_DIFF_REALLYJOEL])
		return modVeryHard;
	else if(Link->Item[I_DIFF_HARD])
		return modHard;
	else if(Link->Item[I_DIFF_NORMAL])
		return modNormal;
	else if(Link->Item[I_DIFF_EASY])
		return modEasy;
	else
		return modVeryEasy;
}

int DiffMultiplier(){
	if(Link->Item[I_DIFF_REALLYJOEL])
		return 100;
	else if(Link->Item[I_DIFF_VERYHARD])
		return 4;
	else if(Link->Item[I_DIFF_HARD])
		return 2;
	else if(Link->Item[I_DIFF_EASY])
		return 0.5;
	else if(Link->Item[I_DIFF_VERYEASY])
		return 0.25;
	return 1;
}

int PiercingDamage(int damage){
	if(IsHardMode()){
		if(Link->Item[I_RING2])
			return damage*4;
		else if(Link->Item[I_RING1])
			return damage*2;
	}
	return damage;
}

bool AllowAllJokes(){
	return !Link->Item[I_SETTING_NOJOKE]&&!G[G_PARTIALJOKE];
}

bool AllowSomeJokes(){
	return !Link->Item[I_SETTING_NOJOKE]||G[G_PARTIALJOKE];
}

ffc script YetAnotherScriptedGohma{
	void run(int enemyid){
		int i; int j; int k;
		int x; int y;
		int dist; int angle;
		
		eweapon e;
		
		npc ghost = Ghost_InitAutoGhost(this, enemyid);
		NJFMode_IncreaseBossHP(ghost);
		this->Flags[FFCF_ETHEREAL] = true;
		
		Ghost_SetFlag(GHF_IGNORE_WATER);
		Ghost_SetFlag(GHF_IGNORE_PITS);
		Ghost_SetFlag(GHF_IGNORE_SOLIDITY);
		Ghost_SetFlag(GHF_FLYING_ENEMY);
		Ghost_SetFlag(GHF_FAKE_Z);
		
		Ghost_Transform(this, ghost, -1, -1, 3, 1);
		
		Ghost_X = 120;
		Ghost_Y = 80;
		
		int defenses[18];
		ghost->Defense[NPCD_ARROW] = NPCDT_IGNORE;
		
		int oldCD[176];
		int oldCC[176];
		int inPoison[176];
		for(int i=32; i<144; i++){
			if(i%16>0&&i%16<15){
				if(Screen->ComboS[i]==0){
					oldCD[i] = Screen->ComboD[i];
					oldCC[i] = Screen->ComboC[i];
				}
			}
		}
		
		int vars[16];
		//vars[0] - Anim Counter
		//vars[1] - Eye State
		//vars[2] - State
		//vars[3] - Eye Open Time
		//vars[4] - Eye Open Delay
		vars[5] = Ghost_HP;
		//vars[6] - Phase
		vars[7] = oldCD;
		vars[8] = oldCC;
		//vars[9] - WasHit
		vars[10] = inPoison;
		
		Ghost_Dir = DIR_DOWN;
		vars[2] = -1;
		
		int moveDir = Choose(-1, 1);
		int targetY = 80;
		
		int attackCooldown = 120;
		
		YASG_Waitframe(this, ghost, vars, 60);
		int phase = 0;
		while(true){
			if(IsHardMode()){
				if(vars[9]){
					if(vars[6]==0)
						vars[6] = 1;
					else
						vars[6] = 0;
					vars[9] = 0;
				}
			}
			else if(Ghost_HP<vars[5]*0.5){
				vars[6] = 1;
				vars[9] = 0;
			}
			if((Link->Y<Ghost_Y&&vars[6]==0)||(Link->Y>Ghost_Y&&vars[6]==1)){
				angle = Angle(Ghost_X+16, Ghost_Y, Link->X, Link->Y);
				i = Choose(24, 32, 40)*LazyDiffMod(1, 0.60, 0.20);
				YASG_Waitframe(this, ghost, vars, i);
				Game->PlaySound(SFX_JUMP);
				Ghost_Jump = 2;
				while(Ghost_Z>0||Ghost_Jump>0){
					Ghost_MoveAtAngle(angle, 1, 0);
					YASG_Waitframe(this, ghost, vars);
				}
			}
			else{
				Ghost_MoveXY(moveDir*2.5, 0, 0);
				if(Round(Ghost_Y)!=targetY){
					if(Ghost_Y<targetY)
						Ghost_MoveXY(0, 1, 0);
					else if(Ghost_Y>targetY)
						Ghost_MoveXY(0, -1, 0);
				}
				else
					targetY = 80+Rand(-16, 16);
				if((moveDir==-1&&!Ghost_CanMove(DIR_LEFT, 1, 0))||(moveDir==1&&!Ghost_CanMove(DIR_RIGHT, 1, 0))){
					moveDir = -moveDir;
				}
			}
			if(attackCooldown)
				attackCooldown--;
			else if(Rand(24)){
				if(vars[2]==-1&&vars[4]==0){
					vars[4] = Rand(60, 120);
					vars[3] = 180;
					vars[2] = 0;
				}
				int attack = Choose(0, 0, 0, 1, 1); 
				if(NumEWeaponsOf(EW_POISONSHOT)>0){
					attack = 0;
				}
				if(!IsHardMode())
					attack = 0;
				if(attack==0){
					for(k=0; k<3; k++){
						for(i=0; i<64; i++){
							j = LazyDiffMod(0.8, 1, 1.1);
							if(Ghost_X+16<Link->X-2)
								Ghost_MoveXY(j, 0, 0);
							else if(Ghost_X+16>Link->X+2)
								Ghost_MoveXY(-j, 0, 0);
							if(vars[6]==0)
								Ghost_MoveXY(0, -0.5, 0);
							else
								Ghost_MoveXY(0, 0.5, 0);
							YASG_Waitframe(this, ghost, vars);
						}
						while(Ghost_CanMove(Ghost_Dir, 1, 0)){
							j = LazyDiffMod(2.5, 3, 4);
							Ghost_Move(Ghost_Dir, j, 0);
							YASG_Waitframe(this, ghost, vars);
						}
						Game->PlaySound(SFX_JUMP);
						Ghost_Jump = 1.6;
						while(Ghost_Z>0||Ghost_Jump>0){
							Ghost_Move(Ghost_Dir, -2, 0);
							YASG_Waitframe(this, ghost, vars);
						}
					}
					attackCooldown = 120;
				}
				else if(attack==1){
					x = Ghost_X+16;
					y = Ghost_Y;
					YASG_Waitframe(this, ghost, vars, 32);
					Game->PlaySound(40);
					e = FireEWeapon(EW_POISONSHOT, x, y, 0, 0, ghost->WeaponDamage, SPR_POISONSHOT, 0, EWF_UNBLOCKABLE);
					for(i=0; i<32; i++){
						if(vars[6]==0){
							y -= (32-i)/32*2;
						}
						else{
							y += (32-i)/32*2;
						}
						
						if(e->isValid()){
							e->X = x;
							e->Y = y;
						}
						else{
							e = FireEWeapon(EW_POISONSHOT, x, y, 0, 0, ghost->WeaponDamage, SPR_POISONSHOT, 0, EWF_UNBLOCKABLE);
						}
						
						YASG_Waitframe(this, ghost, vars);
					}
					if(e->isValid())
						e->DeadState = 0;
					j = LazyDiffMod(25, 30, 35);
					e = FireAimedEWeapon(EW_POISONSHOT, x, y, 0, j, ghost->WeaponDamage, SPR_POISONSHOT, 0, EWF_UNBLOCKABLE);
					SetEWeaponMovement(e, EWM_HOMING, DegtoRad(5), 420);
					
					attackCooldown = 90;
				}
			}
			YASG_Waitframe(this, ghost, vars);
		}
	}
	void YASG_Waitframe(ffc this, npc ghost, int vars, int frames){
		for(int i=0; i<frames; i++){
			YASG_Waitframe(this, ghost, vars);
		}
	}
	void YASG_Waitframe(ffc this, npc ghost, int vars){
		int combo = ghost->Attributes[10];
		
		if(vars[2]==0){ //Opening delay
			if(vars[4]>0)
				vars[4]--;
			else{
				vars[2] = 1;
				vars[1] = 1;
				vars[0] = 16;
			}
		}
		else if(vars[2]==1){ //Opening Anim
			if(vars[0]>0)
				vars[0]--;
			else{
				vars[2] = 2;
				vars[1] = 2;
			}
		}
		else if(vars[2]==2){ //Open
			if(vars[3]>0)
				vars[3]--;
			else{
				vars[2] = 3;
				vars[1] = 1;
				vars[0] = 16;
			}
		}
		else if(vars[2]==3){ //Closing Anim
			if(vars[0]>0)
				vars[0]--;
			else{
				vars[2] = -1;
				vars[1] = 0;
			}
		}
		
		if(vars[1]==0){
			Ghost_Data = combo;
			ghost->Defense[NPCD_ARROW] = NPCDT_BLOCK;
		}
		else if(vars[1]==1){
			Ghost_Data = combo+1;
			ghost->Defense[NPCD_ARROW] = NPCDT_BLOCK;
		}
		else if(vars[1]==2){
			Ghost_Data = combo+2;
			ghost->Defense[NPCD_ARROW] = NPCDT_IGNORE;
			for(int i=Screen->NumLWeapons(); i>=1; i--){
				lweapon l = Screen->LoadLWeapon(i);
				if(l->ID==LW_ARROW){
					if(CollisionMod(l, ghost)&&l->DeadState==WDS_ALIVE){
						if(CollisionMod(l, ghost->X+16, ghost->Y, 16, 16)&&l->Dir==OppositeDir(Ghost_Dir)){
							ghost->Defense[NPCD_ARROW] = NPCDT_NONE;
						}
						else{
							Game->PlaySound(SFX_CLINK);
							l->DeadState = WDS_ARROW;
						}
					}
				}
			}
		}
		if(vars[6]){
			Ghost_Dir = DIR_UP;
			Ghost_Data += 3;
		}
		else
			Ghost_Dir = DIR_DOWN;
		
		int oldCD = vars[7];
		int oldCC = vars[8];
		int inPoison = vars[10];
		
		for(int i=Screen->NumEWeapons(); i>0; i--){
			eweapon e = Screen->LoadEWeapon(i);
			if(e->ID==EW_POISONSHOT){
				for(int j=0; j<176; j++){
					if(oldCD[j]>0){
						if(Distance(e->X, e->Y, ComboX(j), ComboY(j))<48){
							inPoison[j] = 10;
						}
					}
				}
			}
		}
		//I hate everything
		int cmbPoisonFloor1 = CMB_YASG_POISONFLOOR1;
		int cmbPoisonFloor2 = CMB_YASG_POISONFLOOR2;
		int cmbPoisonFloor3 = CMB_YASG_POISONFLOOR3;
		int csPoisonFloor = 3;
		if(Game->GetCurLevel()==9){
			cmbPoisonFloor1 = 8128;
			cmbPoisonFloor2 = 8129;
			cmbPoisonFloor3 = 8130;
			csPoisonFloor = 2;
		}
		
		for(int j=0; j<176; j++){
			if(Screen->ComboF[j]!=98){
				if(oldCD[j]>0){
					if(inPoison[j]>0){
						if(oldCD[j]!=cmbPoisonFloor1){
							Screen->ComboD[j] = cmbPoisonFloor2;
							Screen->ComboC[j] = csPoisonFloor;
						}
						else{
							Screen->ComboD[j] = cmbPoisonFloor3;
							Screen->ComboC[j] = csPoisonFloor;
						}
						inPoison[j]--;
					}
					else{
						Screen->ComboD[j] = oldCD[j];
						Screen->ComboC[j] = oldCC[j];
					}
				}
			}
		}
		
		int x = Round(Ghost_X)-2;
		int y = Round(Ghost_Y);
		
		if(Ghost_GotHit()){
			vars[9] = 1;
		}
		
		if(!Q7_Ghost_Waitframe(this, ghost, true, false)){
			for(int i=Screen->NumEWeapons(); i>0; i--){
				eweapon e = Screen->LoadEWeapon(i);
				if(e->ID==EW_POISONSHOT){
					e->DeadState = 0;
				}
			}
			for(int j=0; j<176; j++){
				if(oldCC[j]>0){
					Screen->ComboD[j] = oldCD[j];
					Screen->ComboC[j] = oldCC[j];
				}
			}
			Quit();
		}
		Ghost_SetHitOffsets(ghost, 0, 0, 0, 0);
	}
}

ffc script HitboxTest{
	void run(){
		npc n = CreateNPCAt(NPC_ENEMYFIRE, this->X, this->Y);
		n->HP = 1000;
		
		int x = 0;
		int y = 0;
		
		lweapon l;
		
		while(true){
			l = LoadLWeaponOf(LW_ARROW);
			if(Link->InputUp)
				y--;
			else if(Link->InputDown)
				y++;
			else if(Link->InputLeft)
				x--;
			else if(Link->InputRight)
				x++;
			x = Clamp(x, 0, 240);
			y = Clamp(y, 0, 160);
			if(l->isValid()){
				l->X = x;
				l->Y = y;
				l->DeadState = WDS_ALIVE;
			}
			// else{
				// l = CreateLWeaponAt(LW_ARROW, x, y);
				// l->Damage = 2;
			// }
			// if(Link->PressL){
				// l->DeadState = 0;
				// l = CreateLWeaponAt(LW_ARROW, x, y);
				// l->Dir = Rand(4);
				// l->Damage = 2;
			// }
			if(n->HP<1000){
				l->Step = 0;
				n->HP = 1000;
				// Trace(n->X-l->X);
				// Trace(n->Y-l->Y);
			}
			int x1; int y1;
			int x2; int y2;
			for(int i=Screen->NumLWeapons(); i>0; i--){
				l = Screen->LoadLWeapon(i);
				x1 = l->X+l->HitXOffset;
				y1 = l->Y+l->HitYOffset;
				if(l->Dir==DIR_UP)
					y1 -= 3;
				else if(l->Dir==DIR_DOWN)
					y1 += 3;
				if(l->Dir==DIR_LEFT)
					x1 -= 3;
				else if(l->Dir==DIR_RIGHT)
					x1 += 3;
				x2 = x1+l->HitWidth-1;
				y2 = y1+l->HitHeight-1;
				Screen->Rectangle(6, x1, y1, x2, y2, 0x01, 1, 0, 0, 0, true, 64);
			}
			x1 = n->X+n->HitXOffset;
			y1 = n->Y+n->HitYOffset;
			x2 = x1+n->HitWidth-1;
			y2 = y1+n->HitHeight-1;
			Screen->Rectangle(6, x1, y1, x2, y2, 0x02, 1, 0, 0, 0, true, 64);
			if(Link->InputR)
				NoAction();
			Waitframe();
		}
	}
}

//X,Y - New position of the worm enemy
//WormX[],WormY[] - Arrays containing old positions of the worm enemy
//stepData[] - An array containg data used frame to frame
//	stepData[0] - The current substep value of the enemy
//	stepData[1] - The max step value for the enemy, if the enemy moves more than this much at once it will teleport
void UpdateWormTrailsXY(int X, int Y, int WormX, int WormY, int stepData){
	X = Floor(X);
	Y = Floor(Y);
	
	int Length = SizeOfArray(WormX);
	int OldX = WormX[0];
	int OldY = WormY[0];
	stepData[0] += Floor(Distance(X, Y, WormX[0], WormY[0]));
	int Step = Floor(stepData[0]);
	if(Step>stepData[1]){
		for(int i=Length-1; i>0; i--){
			WormX[i] = WormX[i-1];
			WormY[i] = WormY[i-1];
		}
		WormX[0] = X;
		WormY[0] = Y;
	}
	else if(Step>0){
		for(int i=Length-1; i>Step; i--){
			WormX[i] = WormX[i-Step];
			WormY[i] = WormY[i-Step];
		}
		for(int i=0; i<=Step; i++){
			WormX[i] = Floor(X+VectorX(i, Angle(X, Y, OldX, OldY)));
			WormY[i] = Floor(Y+VectorY(i, Angle(X, Y, OldX, OldY)));
		}
		stepData[0] -= Step;
	}
}

//X,Y - New position of the worm enemy
//WormX[],WormY[] - Arrays containing old positions of the worm enemy
//stepData[] - An array containg data used frame to frame
//	stepData[0] - The current substep value of the enemy
//	stepData[1] - The max step value for the enemy, if the enemy moves more than this much at once it will teleport
void UpdateWormTrailsXYZ(int X, int Y, int Z, int WormX, int WormY, int WormZ, int stepData){
	X = Floor(X);
	Y = Floor(Y);
	
	int Length = SizeOfArray(WormX);
	int OldX = WormX[0];
	int OldY = WormY[0];
	int OldZ = WormZ[0];
	stepData[0] += Floor(Distance(X, Y, WormX[0], WormY[0]));
	int Step = Floor(stepData[0]);
	if(Step>stepData[1]){
		for(int i=Length-1; i>0; i--){
			WormX[i] = WormX[i-1];
			WormY[i] = WormY[i-1];
		}
		WormX[0] = X;
		WormY[0] = Y;
	}
	else if(Step>0){
		for(int i=Length-1; i>Step; i--){
			WormX[i] = WormX[i-Step];
			WormY[i] = WormY[i-Step];
			WormZ[i] = WormZ[i-Step];
		}
		for(int i=0; i<=Step; i++){
			WormX[i] = Floor(X+VectorX(i, Angle(X, Y, OldX, OldY)));
			WormY[i] = Floor(Y+VectorY(i, Angle(X, Y, OldX, OldY)));
			WormZ[i] = Z+(OldZ-Z)*(i/Step);
		}
		stepData[0] -= Step;
	}
}

//Forces the enemy to converge on a single point without actually moving
void ScrunchWormTrailsXYZ(int X, int Y, int Z, int WormX, int WormY, int WormZ, int forceStep, int stepData){
	X = Floor(X);
	Y = Floor(Y);
	
	int Length = SizeOfArray(WormX);
	int OldX = WormX[0];
	int OldY = WormY[0];
	int OldZ = WormZ[0];
	stepData[0] += Floor(forceStep);
	int Step = Floor(stepData[0]);
	
	if(Step>0){
		for(int i=Length-1; i>Step; i--){
			WormX[i] = WormX[i-Step];
			WormY[i] = WormY[i-Step];
			WormZ[i] = WormZ[i-Step];
		}
		for(int i=0; i<=Step; i++){
			WormX[i] = Floor(X);
			WormY[i] = Floor(Y);
			WormZ[i] = Z+(OldZ-Z)*(i/Step);
		}
		stepData[0] -= Step;
	}
}

void SortLowestToHighestAndReturnOrder(int arrayold, int arrayorder){
	int lowest = 214747;
	int lowestindex = 0;
	bool used[256];
	int size = SizeOfArray(arrayorder);
	int size2 = SizeOfArray(arrayold);
	for(int i=0; i<size; i++){
		for(int j=0; j<size2; j++){
			if(arrayold[j]<=lowest&&!used[j]){
				lowest = arrayold[j];
				lowestindex = j;
			}
		}
		arrayorder[i] = lowestindex;
		used[lowestindex] = true;
		lowest = 214747;
	}
}

// Returns true if a rectangular section of screen is walkable to a ghosted enemy
bool Ghost_CanPlace(int X, int Y, int w, int h){
	for(int x=0; x<=w-1; x=Min(x+8, w-1)){
		for(int y=0; y<=h-1; y=Min(y+8, h-1)){
			if(!Ghost_CanMovePixel(X+x, Y+y))
				return false;
			
			if(y==h-1)
				break;
		}
		if(x==w-1)
			break;
	}
	return true;
}

const int RT_LANMOLAR = 2;
const int SPR_BIGPOOF = 96;
const int SPR_LANMOLAR_TOOTHPASTE = 97;

const int NPC_LANMOLAR_ROCK = 275;

const int SFX_LANMOLAR_POPUP = 9;
const int SFX_LANMOLAR_ROAR = 24;
const int SFX_LANMOLAR_TOOTHPASTE = 1;

ffc script Lanmolars{
	void run(int enemyid){
		Screen->SetRenderTarget(RT_LANMOLAR);
		Screen->Rectangle(0, 0, 0, 511, 511, 0, 1, 0, 0, 0, true, 128);
		Screen->SetRenderTarget(RT_SCREEN);
		
		int i; int j; int k; int o;
		int x; int y;
		int dist; int angle;
		int jump;
		
		npc ghost = Ghost_InitAutoGhost(this, enemyid);
		this->Flags[FFCF_ETHEREAL] = true;
		
		Ghost_Transform(this, ghost, -1, -1, 2, 2);
		
		Ghost_SetFlag(GHF_IGNORE_SOLIDITY);
		
		ghost->CollDetection = false;
		ghost->DrawYOffset = -1000;
		
		int defenses[18];
		Ghost_StoreDefenses(ghost, defenses);
		
		int tX[256];
		int tY[256];
		int tZ[256];
		for(i=0; i<256; i++){
			tX[i] = Ghost_X;
			tY[i] = Ghost_Y;
			tZ[i] = -48;
		}
		
		npc teeth[8];
		int teethBroken[8];
		int teethBreakCooldown[8];
		int teethPlaqueCounter[8];
		int shotCooldown[8];
		for(i=0; i<8; i++){
			teeth[i] = CreateNPCAt(NPC_ENEMYFIRE, Ghost_X, Ghost_Y);
			teeth[i]->Extend = 3;
			teeth[i]->HitXOffset = 2;
			teeth[i]->HitYOffset = 2;
			teeth[i]->HitWidth = 28;
			teeth[i]->HitHeight = 28;
			teeth[i]->HP = 1000;
			teeth[i]->Damage = ghost->Damage;
			teeth[i]->DrawYOffset = -1000;
			Ghost_SetAllDefenses(teeth[i], NPCDT_BLOCK);
			teeth[i]->Defense[NPCD_BOMB] = NPCDT_IGNORE;
			shotCooldown[i] = 120;
		}
		
		int stepData[2] = {0, 1000};
		
		int vars[16] = {0, tX, tY, tZ, teethBroken, teethBreakCooldown, defenses, stepData, teethPlaqueCounter, 0, 0, 0, shotCooldown};
		vars[0] = Ghost_HP;
		//vars[0] - Fake HP
		//vars[9] - Fake Z
		//vars[10] - Num Above Ground
		//vars[11] - Num Plaqued
		//vars[13] - No Shots
		
		Ghost_X = 112;
		Ghost_Y = 72;
		
		int xy[2];
		
		int attackCooldown = 64;
		vars[9] = -48;
		while(true){
			if(attackCooldown>0)
				attackCooldown--;
			else if(Rand(8)==0){
				int attack = Choose(0, 0, 0, 1, 2);
				if(!IsHardMode()&&attack==2)
					attack = 0;
				if(attack==1&&NumNPCsOf(NPC_LANMOLAR_ROCK)>0)
					attack = 0;
				if(attack==0){ //Dive
					xy[0] = Choose(32, 196);
					xy[1] = Rand(32, 112);
					
					LM_Teleport(this, ghost, teeth, vars, xy[0], xy[1], -48);
					x = 112+(112-xy[0]);
					y = Rand(32, 112);
					angle = Angle(xy[0]+8, xy[1]+8, x, y);
					k = LazyDiffMod(0.6, 1, 2);
					j = LazyDiffMod(0.4, 1, 1.8);
					o = LazyDiffMod(0.6, 1.1, 1.2);
					jump = 4.8*o;
					while(jump>0||vars[9]>-32){
						Ghost_MoveAtAngle(angle, 2*k, 0);
						vars[9] += jump;
						jump -= 0.16*j;
						LM_Waitframe(this, ghost, teeth, vars);
					}
					k = 2*k;
					while(vars[10]>0){
						k += 0.05;
						ScrunchWormTrailsXYZ(Ghost_X, Ghost_Y, vars[9], tX, tY, tZ, k, stepData);
						LM_Waitframe(this, ghost, teeth, vars);
					}
				}
				else if(attack==1){ //Roar
					LM_FindTeleportSpot(xy);
					LM_Teleport(this, ghost, teeth, vars, xy[0], xy[1], -48);
					
					j = LazyDiffMod(180, 120, 90);
					for(i=0; i<j; i++){
						if(i%4==0){
							Game->PlaySound(SFX_LEEVERTREMOR);
							SpriteAnim(Ghost_X+Rand(-8, 24), Ghost_Y+Rand(-8, 24), SPR_BIGPOOF, 1, 1);
						}
						if(Distance(Ghost_X+8, Ghost_Y+8, Link->X, Link->Y)>2)
							Ghost_MoveTowardLink(1.2, 0);
						LM_Waitframe(this, ghost, teeth, vars);
					}
					j = LazyDiffMod(32, 24, 16);
					for(i=0; i<j; i++){
						LM_Waitframe(this, ghost, teeth, vars);
					}
					Game->PlaySound(SFX_LANMOLAR_POPUP);
					j = LazyDiffMod(1, 1.5, 2);
					for(i=0; i<24/j; i++){
						vars[9] += 4*j;
						ScrunchWormTrailsXYZ(Ghost_X, Ghost_Y, vars[9], tX, tY, tZ, 4*j, stepData);
						LM_Waitframe(this, ghost, teeth, vars);
					}
					for(i=0; i<16; i++){
						LM_Waitframe(this, ghost, teeth, vars);
					}
					Game->PlaySound(SFX_LANMOLAR_ROAR);
					for(i=0; i<3; i++){
						int rocksFall[] = "RocksFallEveryoneDies";
						int args[8];
						args[0] = NPC_LANMOLAR_ROCK;
						args[1] = LazyDiffMod(2, 3, 3);
						args[2] = Rand(120);
						RunFFCScript(Game->GetFFCScript(rocksFall), args);
					}
					for(i=0; i<48; i++){
						LM_Waitframe(this, ghost, teeth, vars);
					}
					while(vars[9]>-32){
						vars[9] -= 4*j;
						ScrunchWormTrailsXYZ(Ghost_X, Ghost_Y, vars[9], tX, tY, tZ, 4*j, stepData);
						LM_Waitframe(this, ghost, teeth, vars);
					}
					k = 4;
					while(vars[10]>0){
						k += 0.05;
						ScrunchWormTrailsXYZ(Ghost_X, Ghost_Y, vars[9], tX, tY, tZ, k, stepData);
						LM_Waitframe(this, ghost, teeth, vars);
					}
				}
				else if(attack==2){ //Chase
					LM_FindTeleportSpot(xy);
					LM_Teleport(this, ghost, teeth, vars, xy[0], xy[1], -48);
					while(vars[9]<0){
						vars[9] += 1;
						ScrunchWormTrailsXYZ(Ghost_X, Ghost_Y, vars[9], tX, tY, tZ, 1, stepData);
						LM_Waitframe(this, ghost, teeth, vars);
					}
					vars[13] = 1;
					for(i=0; i<600; i++){
						vars[9] = 18*Sin(i*2); //24
						Ghost_MoveTowardLink(LazyDiffMod(0.6, 0.6, 0.8), 0);
						LM_Waitframe(this, ghost, teeth, vars);
					}
					vars[13] = 0;
					while(vars[9]>-32){
						vars[9] -= 1;
						ScrunchWormTrailsXYZ(Ghost_X, Ghost_Y, vars[9], tX, tY, tZ, 1, stepData);
						LM_Waitframe(this, ghost, teeth, vars);
					}
					k = 1;
					while(vars[10]>0){
						k += 0.05;
						ScrunchWormTrailsXYZ(Ghost_X, Ghost_Y, vars[9], tX, tY, tZ, k, stepData);
						LM_Waitframe(this, ghost, teeth, vars);
					}
				}
				attackCooldown = LazyDiffMod(32, 16, 0);
			}
			LM_Waitframe(this, ghost, teeth, vars);
		}
	}
	void LM_FindTeleportSpot(int xy){
		for(int i=0; i<176*2; i++){
			if(i<176){
				xy[0] = Rand(32, 192);
				xy[1] = Rand(32, 112);
			}
			else{
				xy[0] = ComboX(i-176);
				xy[1] = ComboY(i-176);
			}
			if(Ghost_CanPlace(xy[0], xy[1], 32, 32)&&Distance(xy[0]+8, xy[1]+8, Link->X, Link->Y)>32){
				return;
			}
		}
	}
	void LM_Draw(ffc this, npc ghost, npc teeth, int vars){
		int i; int j; int k;
		int x; int y; int z;
		
		int tX = vars[1];
		int tY = vars[2];
		int tZ = vars[3];
		int teethBroken = vars[4];
		int teethBreakCooldown = vars[5];
		int defenses = vars[6];
		int stepData = vars[7];
		int teethPlaqueCounter = vars[8];
		//vars[9] - Head Z
		//vars[10] - Num Above Ground
		//vars[11] - Num Plaqued
		int shotCooldown = vars[12];
		
		int combo = ghost->Attributes[10];
		
		int height[8];
		int order[8];
		for(i=0; i<8; i++){
			z = tZ[i+32];
			x = tX[i*32];
			y = tY[i*32];
			if(z>0){
				height[i] = y-z+1000;
			}
			else
				height[i] = y-z;
		}
		SortLowestToHighestAndReturnOrder(height, order);
		
		vars[10] = 0;
		if(Link->HP>0){
			for(k=0; k<8; k++){
				i = order[k];
				if(teeth[i]->isValid()){
					if(teeth[i]->HP>0){
						if(teethBreakCooldown[i]>0)
							teethBreakCooldown[i]--;
						
						if(teeth[i]->HP<1000){
							if(!IsHardMode())
								vars[0] -= 1000-teeth[i]->HP;
							if(IsHardMode()){
								teethPlaqueCounter[i]++;
								if(teethPlaqueCounter[i]==3){
									vars[11]++;
									Ghost_SetAllDefenses(teeth[i], NPCDT_BLOCK);
								}
							}
							teeth[i]->HP = 1000;
							Ghost_StartFlashing(16);
						}
						
						teeth[i]->X = tX[i*32];
						teeth[i]->Y = tY[i*32];
						z = tZ[i*32];
						if(z>=0){
							vars[10]++;
							x = tX[i*32];
							y = tY[i*32]-z;
							teeth[i]->CollDetection = true;
							teeth[i]->HitXOffset = 2;
							teeth[i]->HitYOffset = 2;
							teeth[i]->HitWidth = 28;
							teeth[i]->HitHeight = 28;
							teeth[i]->Y -= z;
							
							Screen->DrawCombo(2, x, y, combo+teethBroken[i], 2, 2, this->CSet, -1, -1, 0, 0, 0, 0, 0, true, 128);
							if(teethBroken[i]==2){
								j = 8;
								int plaqueCombo = combo+3;
								if(teethPlaqueCounter[i]==3){
									j = 11;
									if(Link->Item[I_SETTING_VISION])
										plaqueCombo = combo+12;
								}
								if(this->CSet!=11)
									j = this->CSet;
								Screen->DrawCombo(2, x, y, plaqueCombo, 2, 1, j, -1, -1, 0, 0, 0, 0, 0, true, 128);
								if(vars[13]==0&&teethPlaqueCounter[i]<3&&IsHardMode()){
									if(shotCooldown[i]>0)
										shotCooldown[i]--;
									else if(Rand(32)==0&&z>0){
										eweapon e = FireAimedEWeapon(EW_FIREBALL, x+8, y+8-z, 0, 240, ghost->WeaponDamage, -1, -1, 0);
										shotCooldown[i] = 240;
									}
									//Screen->DrawInteger(6, x, y, FONT_Z1, 0x01, 0x0F, -1, -1, shotCooldown[i], 0, 128);
								}
							}
							if(i==0){
								Screen->FastCombo(2, x-4, y-4, combo+8, this->CSet, 128);
								Screen->FastCombo(2, x+16+4, y-4, combo+9, this->CSet, 128);
								Screen->FastCombo(2, x, y+16, combo+10, this->CSet, 128);
								Screen->FastCombo(2, x+16, y+16, combo+11, this->CSet, 128);
							}
						}
						else if(z>-32){
							vars[10]++;
							x = tX[i*32];
							y = tY[i*32];
							teeth[i]->CollDetection = true;
							teeth[i]->HitXOffset = 2;
							teeth[i]->HitYOffset = 2+28*(z/-32);
							teeth[i]->HitWidth = 28;
							teeth[i]->HitHeight = 28-28*(z/-32);
							
							Screen->SetRenderTarget(RT_LANMOLAR);
							Screen->Rectangle(0, 48*i, 0, 48*i+47, 48, 0, 1, 0, 0, 0, true, 128);
							Screen->DrawCombo(0, 48*i+8, 8-z, combo+teethBroken[i], 2, 2, this->CSet, -1, -1, 0, 0, 0, 0, 0, true, 128);
							if(teethBroken[i]==2){
								j = 8;
								int plaqueCombo = combo+3;
								if(teethPlaqueCounter[i]==3){
									j = 11;
									if(Link->Item[I_SETTING_VISION])
										plaqueCombo = combo+12;
								}
								if(this->CSet!=11)
									j = this->CSet;
								Screen->DrawCombo(0, 48*i+8, 8-z, plaqueCombo, 2, 1, j, -1, -1, 0, 0, 0, 0, 0, true, 128);
							}
							if(i==0){
								Screen->FastCombo(0, 48*i+8-4, 8-z-4, combo+8, this->CSet, 128);
								Screen->FastCombo(0, 48*i+8+16+4, 8-z-4, combo+9, this->CSet, 128);
								Screen->FastCombo(0, 48*i+8, 8+16-z, combo+10, this->CSet, 128);
								Screen->FastCombo(0, 48*i+8+16, 8+16-z, combo+11, this->CSet, 128);
							}
							Screen->Rectangle(0, 48*i, 37, 48*i+47, 48, 0, 1, 0, 0, 0, true, 128);
							Screen->DrawCombo(0, 48*i+8, 8+16, combo+7, 2, 1, 1, -1, -1, 0, 0, 0, 0, 0, true, 128);
							Screen->SetRenderTarget(RT_SCREEN);
							Screen->DrawBitmap(2, RT_LANMOLAR, 48*i, 0, 48, 40, x-8, y-8, 48, 40, 0, true);
						}
						else{
							teeth[i]->CollDetection = false;
						}
					}
				}
			}
		}
	}
	void LM_Teleport(ffc this, npc ghost, npc teeth, int vars, int x, int y, int z){
		int i;
		int tX = vars[1];
		int tY = vars[2];
		int tZ = vars[3];
		for(i=0; i<256; i++){
			tX[i] = x;
			tY[i] = y;
			tZ[i] = z;
		}
		for(i=0; i<8; i++){
			if(teeth[i]->isValid()){
				teeth[i]->X = x;
				teeth[i]->Y = y;
			}
		}
		Ghost_X = x;
		Ghost_Y = y;
		vars[9] = z;
	}
	void LM_Waitframe(ffc this, npc ghost, npc teeth, int vars){
		int i; int j; int k;
		int x; int y; int z;
		
		int tX = vars[1];
		int tY = vars[2];
		int tZ = vars[3];
		int teethBroken = vars[4];
		int teethBreakCooldown = vars[5];
		int defenses = vars[6];
		int stepData = vars[7];
		int teethPlaqueCounter = vars[8];
		//vars[9] - Head Z
		//vars[10] - Num Above Ground
		//vars[11] - Num Plaqued
		
		int combo = ghost->Attributes[10];
		
		UpdateWormTrailsXYZ(Ghost_X, Ghost_Y, vars[9], tX, tY, tZ, stepData);
		
		LM_Draw(this, ghost, teeth, vars);
		
		for(i=Screen->NumLWeapons(); i>0; i--){
			lweapon l = Screen->LoadLWeapon(i);
			if(l->ID==LW_BOMBBLAST||l->ID==LW_BAIT){
				for(j=0; j<8; j++){
					if(tZ[j*32]>-32&&teethBreakCooldown[j]<=0&&teethBroken[j]<2){
						if(CollisionMod(l, teeth[j])){
							Game->PlaySound(SFX_EHIT);
							teethBroken[j]++;
							teethBreakCooldown[j] = 32;
							if(teethBroken[j]==2){
								Ghost_SetDefenses(teeth[j], defenses);
							}
						}
					}
				}
			}
		}
		
		Ghost_HP = Max(1, vars[0]);
		if(vars[0]<=0||vars[11]==8){
			for(i=0; i<8; i++){
				if(teeth[i]->isValid()){
					teeth[i]->CollDetection = false;
				}
			}
			Ghost_StopFlashing();
			for(i=0; i<32; i++){
				LM_Draw(this, ghost, teeth, vars);
				Q7_Ghost_Waitframe(this, ghost, true, true);
			}
			for(i=0; i<8; i++){
				if(teeth[i]->isValid()){
					x = tX[i*32];
					y = tY[i*32];
					z = tZ[i*32];
					teeth[i]->HP = 0;
					teeth[i]->Misc[NPCM_LASTHP] = 0;
					teeth[i]->CollDetection = false;
					if(z>-32){
						teeth[i]->DrawYOffset = -2;
						teeth[i]->X += 8;
						teeth[i]->Y += 8;
						teeth[i]->HitXOffset = 0;
						teeth[i]->HitYOffset = 0;
						teeth[i]->HitWidth = 16;
						teeth[i]->HitHeight = 16;
						for(j=0; j<8; j++){
							LM_Draw(this, ghost, teeth, vars);
							Q7_Ghost_Waitframe(this, ghost, true, true);
						}
					}	
				}
			}
			ghost->HP = -1000;
			this->Data = 0;
			Quit();
		}
		Q7_Ghost_Waitframe(this, ghost, true, true);
	}
}

ffc script RocksFallEveryoneDies{
	void run(int enemyid, int repetitions, int delay, int sp, int x, int y){
		Waitframes(delay);
		npc n;
		if(sp==1){
			n = CreateNPCAt(enemyid, x, y);
		}
		else{
			n = CreateNPCAt(enemyid, Rand(240), 0);
		}
		for(int i=0; i<repetitions; i++){
			while(n->Y>=160){
				Waitframe();
			}
			while(n->Y<160){
				Waitframe();
			}
		}
		n->ItemSet = 0;
		n->DrawYOffset = -1000;
		n->HP = -1000;
	}
}

//Rupees - 1
//Bombs - 2
ffc script AmmoRefund{
	void run(int id, int counter){
		while(true){
			if(id>0){
				if(Game->Counter[counter]==0&&Screen->NumNPCs()>0){
					Waitframes(Choose(90, 120, 180));
					int pos = AR_FindFreeSpace();
					item itm = CreateItemAt(id, ComboX(pos), ComboY(pos));
					itm->Pickup = IP_TIMEOUT;
					itm->Z = 176;
					Game->PlaySound(SFX_FALL);
					while(itm->isValid()){
						Waitframe();
					}
				}
			}
			else if(id==-1){
				int refillType = AR_RefillTypeNeeded();
				if(refillType>-1&&Screen->NumNPCs()>0){
					Waitframes(Choose(90, 120, 180));
					int pos = AR_FindFreeSpace();
					item itm;
					if(refillType==0)
						itm = CreateItemAt(I_RUPEE5, ComboX(pos), ComboY(pos));
					else 
						itm = CreateItemAt(I_BOMB, ComboX(pos), ComboY(pos));
					itm->Pickup = IP_TIMEOUT;
					itm->Z = 176;
					Game->PlaySound(SFX_FALL);
					while(itm->isValid()){
						Waitframe();
					}
				}
			}
			Waitframe();
		}
	}
	int AR_RefillTypeNeeded(){
		for(int i=Screen->NumNPCs(); i>0; i--){
			npc n = Screen->LoadNPC(i);
			if(Game->Counter[CR_RUPEES]<=0){
				if(n->ID==288) //Nightamre Gohma
					return 0;
				else if(n->ID==290&&n->CollDetection) //Nightmare Main
					return 0;
				else if(n->ID==314&&n->CollDetection) //Nightmare Main (NoJoke)
					return 0;
			}
			else if(Game->Counter[CR_BOMBS]<=0){
				if(n->ID==283) //Nightmare Dongers
					return 1;
			}
		}
		return -1;
	}
	int AR_FindFreeSpace(){
		for(int i=0; i<176*2; i++){
			int tryPos;
			if(i<176)
				tryPos = Rand(176);
			else
				tryPos = i-176;
			if(CanPlace(ComboX(tryPos), ComboY(tryPos), 16, 16)){
				return tryPos;
			}
		}
	}
}

const int SFX_SHOCK = 67;
const int SFX_CATFISH_BURP = 68;

const int SPR_SPLASH = 98;
const int SPR_SHOCKBALL = 99;

const int EW_CATFISH_THUNDERSHOT = 40;
const int EWM_CATFISH_THUNDERSHOT = 0;

ffc script Katatafish{
	void run(int enemyid){
		int i; int j; int k;
		int x; int y;
		int angle; int dist;
		
		npc ghost = Ghost_InitAutoGhost(this, enemyid);
		NJFMode_IncreaseBossHP(ghost);
		this->Flags[FFCF_ETHEREAL] = true;
		
		Ghost_Transform(this, ghost, -1, -1, 3, 3);
		ghost->DrawYOffset = -1000;
		
		Ghost_X = 104;
		Ghost_Y = 32;
		
		Ghost_SetFlag(GHF_WATER_ONLY);
		
		int oldCD[176];
		for(i=0; i<176; i++){
			if(Screen->ComboT[i]==CT_SHALLOWWATER||Screen->ComboT[i]==CT_WATER){
				oldCD[i] = Screen->ComboD[i];
			}
		}
		
		int vars[16] = {0, 0, 0, 0, oldCD};
		//vars[0] - Fake Ghost_Data
		//vars[1] - Zap Distance
		//vars[2] - Zap Max Distance
		//vars[3] - Water Electrified Time
		//vars[4] - oldCD
		
		eweapon e;
		
		int xy[2];
		
		int attackCooldown = 0;
		int moveCooldown = 60;
		int moveAngle = Rand(360);
		
		while(true){
			if(moveCooldown>0)
				moveCooldown--;
			else{
				moveCooldown = Choose(40, 60, 90);
				moveAngle = Rand(360);
			}
			if(Ghost_Y>64&&AngDiff(WrapDegrees(moveAngle), 90)<90)
				moveAngle = Rand(-150, -30);
			
			if(IsHardMode())
				ghost->Defense[NPCD_ARROW] = NPCDT_IGNORE;
			Ghost_MoveAtAngle(moveAngle, 1, 0);
			if(attackCooldown>0)
				attackCooldown--;
			else if(Rand(24)==0){
				ghost->Defense[NPCD_ARROW] = NPCDT_NONE;
				int attack = Choose(0, 0, 1, 2, 3); //Rand(2);
				if(!IsHardMode())
					attack = Choose(0, 0, 1, 2);
				if(IsVeryHardMode()&&Rand(32)==0)
					attack = 4;
				if(vars[3]>0&&(attack==0||attack==1||attack==3))
					attack = Choose(2, 2, 4);
				if(attack==0){ //Shock Floor
					vars[0] = 1;
					j = LazyDiffMod(80, 64, 48);
					for(i=0; i<48; i++){
						if(Ghost_X+16>Link->X)
							Ghost_MoveXY(1, 0, 0);
						else if(Ghost_X+16<Link->X)
							Ghost_MoveXY(-1, 0, 0);
						Ghost_MoveXY(0, -0.5, 0);
						KTF_Waitframe(this, ghost, vars);
					}
					vars[0] = 3;
					KTF_Waitframe(this, ghost, vars, 16);
					vars[0] = 5;
					KTF_Waitframe(this, ghost, vars, 16);
					vars[1] = 0;
					vars[2] = 1;
					Game->PlaySound(SFX_SHOCK);
					while(vars[1]!=vars[2]){
						KTF_Waitframe(this, ghost, vars);
					}
					KTF_Waitframe(this, ghost, vars);
					vars[3] = 300;
					for(i=0; i<4; i++){
						Game->PlaySound(SFX_SHOCK);
						while(vars[1]!=vars[2]){
							if(Ghost_X+16>Link->X)
								Ghost_MoveXY(2, 0, 0);
							else if(Ghost_X+16<Link->X)
								Ghost_MoveXY(-2, 0, 0);
							Ghost_MoveXY(0, -1, 0);
							KTF_Waitframe(this, ghost, vars);
						}
						if(Ghost_X+16>Link->X)
							Ghost_MoveXY(-2, 0, 0);
						else if(Ghost_X+16<Link->X)
							Ghost_MoveXY(2, 0, 0);
						Ghost_MoveXY(0, -1, 0);
						KTF_Waitframe(this, ghost, vars);
					}
					vars[1] = 0;
					vars[2] = 0;
					KTF_Waitframe(this, ghost, vars, 4);
					vars[0] = 3;
					KTF_Waitframe(this, ghost, vars, 4);
					vars[0] = 1;
					KTF_Waitframe(this, ghost, vars, 4);
					vars[0] = 0;
					KTF_Waitframe(this, ghost, vars, 4);
				}
				else if(attack==1){ //Burp
					ghost->CollDetection = false;
					KTF_MakeSplash();
					vars[0] = 6;
					KTF_Waitframe(this, ghost, vars, 16);
					vars[0] = -1;
					KTF_Waitframe(this, ghost, vars, 16);
					
					KTF_GetTeleportPosition(Clamp(Link->X-16, 32, 176), 1000+32, xy);
					
					Ghost_X = xy[0];
					Ghost_Y = xy[1];
					
					KTF_Waitframe(this, ghost, vars, LazyDiffMod(40, 24, 16));
					KTF_MakeSplash();
					vars[0] = 6;
					KTF_Waitframe(this, ghost, vars, 16);
					ghost->CollDetection = true;
					vars[0] = 4;
					KTF_Waitframe(this, ghost, vars, 16);
					if(!AllowAllJokes())
						Game->PlaySound(SFX_FIREBALL);
					else
						Game->PlaySound(SFX_CATFISH_BURP);
					vars[0] = 2;
					for(i=0; i<20; i++){
						e = FireEWeapon(EW_FIREBALL, Ghost_X+16+Rand(-8, 8), Ghost_Y+24+Rand(-8, 8), DegtoRad(90+Rand(-30, 30)), Rand(200, 1000), ghost->WeaponDamage, SPR_FIREBALL_UNBLOCKABLE, -1, EWF_UNBLOCKABLE);
						e->CSet = 5;
					}
					for(i=0; i<40; i++){
						Screen->Quake = 1024;
						KTF_Waitframe(this, ghost, vars);
					}
					Screen->Quake = 0;
					KTF_Waitframe(this, ghost, vars, 16);
					vars[0] = 0;
				}
				else if(attack==2){ //Bouncing Shock Balls
					KTF_Waitframe(this, ghost, vars, 16);
					vars[0] = 4;
					KTF_Waitframe(this, ghost, vars, 32);
					k = LazyDiffMod(1, 2, 3);
					for(i=0; i<k; i++){
						vars[1] = 0;
						vars[2] = 1;
						while(vars[1]!=vars[2]){
							if(Distance(Link->X, Link->Y, Ghost_X+16, Ghost_Y+16)<128)
								Ghost_MoveAtAngle(Angle(Link->X, Link->Y, Ghost_X+16, Ghost_Y+16), 1, 0);
							if(Ghost_X<32+24)
								Ghost_MoveXY(1, 0, 0);
							else if(Ghost_X>176-24)
								Ghost_MoveXY(-1, 0, 0);
							Ghost_MoveXY(0, 0.8, 0);
							KTF_Waitframe(this, ghost, vars);
						}
						Game->PlaySound(SFX_SHOCK);
						vars[1] = 0;
						vars[2] = 0;
						x = Ghost_X-16+1;
						y = Ghost_Y+32+13;
						angle = 180-20;
						angle += Rand(-20, 20);
						angle = TurnToAngle(angle, Angle(x-8, y-8, Link->X, Link->Y), 45);
						e = FireEWeapon(EW_CATFISH_THUNDERSHOT, x-8, y-8, DegtoRad(angle), 300, ghost->WeaponDamage, SPR_SHOCKBALL, 0, EWF_UNBLOCKABLE);
						e->Misc[EWM_CATFISH_THUNDERSHOT] = LazyDiffMod(4, 5, 6);
						
						x = Ghost_X+48+8;
						y = Ghost_Y+32+6;
						angle = 20;
						angle += Rand(-20, 20);
						angle = TurnToAngle(angle, Angle(x-8, y-8, Link->X, Link->Y), 45);
						e = FireEWeapon(EW_CATFISH_THUNDERSHOT, x-8, y-8, DegtoRad(angle), 300, ghost->WeaponDamage, SPR_SHOCKBALL, 0, EWF_UNBLOCKABLE);
						e->Misc[EWM_CATFISH_THUNDERSHOT] = LazyDiffMod(4, 5, 6);
						
						KTF_Waitframe(this, ghost, vars, 40);
					}
				}
				else if(attack==3){ //Shock Pillars
					vars[0] = 4;
					KTF_Waitframe(this, ghost, vars, 32);
					vars[0] = 9;
					KTF_Waitframe(this, ghost, vars, 16);
					k = Rand(2);
					for(i=0; i<8; i++){
						vars[1] = 0;
						vars[2] = 1;
						while(vars[1]!=vars[2]){
							if(Ghost_X+16>Link->X-2)
								Ghost_MoveXY(-0.4, 0, 0);
							else if(Ghost_X+16<Link->X+2)
								Ghost_MoveXY(0.4, 0, 0);
							Ghost_MoveXY(0, 0.8, 0);
							KTF_Waitframe(this, ghost, vars);
						}
						Game->PlaySound(SFX_SHOCK);
						if(k==0){
							x = Ghost_X-16+7;
							y = Ghost_Y+16+6;
							e = FireEWeapon(EW_SCRIPT9, x-8, y-8, DegtoRad(-90-30), 300, ghost->WeaponDamage, SPR_SHOCKBALL, 0, EWF_UNBLOCKABLE);
							
							x = Ghost_X+48+8;
							y = Ghost_Y+16+6;
							e = FireEWeapon(EW_SCRIPT9, x-8, y-8, DegtoRad(-90+30), 300, ghost->WeaponDamage, SPR_SHOCKBALL, 0, EWF_UNBLOCKABLE);
						}
						else if(k==1){
							x = Ghost_X-16+7;
							y = Ghost_Y+16+6;
							e = FireEWeapon(EW_SCRIPT9, x-8, y-8, DegtoRad(-90-60), 300, ghost->WeaponDamage, SPR_SHOCKBALL, 0, EWF_UNBLOCKABLE);
							
							x = Ghost_X+48+8;
							y = Ghost_Y+16+6;
							e = FireEWeapon(EW_SCRIPT9, x-8, y-8, DegtoRad(-90+60), 300, ghost->WeaponDamage, SPR_SHOCKBALL, 0, EWF_UNBLOCKABLE);
						}
					}
					vars[1] = 0;
					vars[2] = 0;
						
					for(i=0; i<96; i++){
						if(Ghost_X+16>Link->X)
							Ghost_MoveXY(2, 0, 0);
						else if(Ghost_X+16<Link->X)
							Ghost_MoveXY(-2, 0, 0);
						if(k==0)
							Ghost_MoveXY(0, -1, 0);
						else
							Ghost_MoveXY(0, 1, 0);
						KTF_Waitframe(this, ghost, vars);
					}
					
					if(k==0){
						for(i=0; i<7; i++){
							x = 0+16*i;
							y = Cond(i%2==0, 2, 158);
							
							for(j=0; j<5; j++){
								e = FireEWeapon(EW_SCRIPT9, x, y, DegtoRad(Cond(i%2==0, 90, -90)), 400+50*j, ghost->WeaponDamage, SPR_SHOCKBALL, SFX_SHOCK, EWF_UNBLOCKABLE);
							}
							x = 240-16*i;
							y = Cond(i%2==0, 2, 158);
							for(j=0; j<5; j++){
								e = FireEWeapon(EW_SCRIPT9, x, y, DegtoRad(Cond(i%2==0, 90, -90)), 400+50*j, ghost->WeaponDamage, SPR_SHOCKBALL, SFX_SHOCK, EWF_UNBLOCKABLE);
							}
							KTF_Waitframe(this, ghost, vars, 8);
						}
					}
					else if(k==1){
						for(i=0; i<8; i++){
							x = Cond(i%2==0, 2, 238);
							y = 160-16*i;
							for(j=0; j<5; j++){
								e = FireEWeapon(EW_SCRIPT9, x, y, DegtoRad(Cond(i%2==0, 0, 180)), 400+50*j, ghost->WeaponDamage, SPR_SHOCKBALL, SFX_SHOCK, EWF_UNBLOCKABLE);
							}
							KTF_Waitframe(this, ghost, vars, 8);
						}
					}
					vars[0] = 0;
				}
				else if(attack==4){ //Dive Teleport
					ghost->CollDetection = false;
					KTF_MakeSplash();
					vars[0] = 6;
					KTF_Waitframe(this, ghost, vars, 16);
					vars[0] = -1;
					KTF_Waitframe(this, ghost, vars, 16);
					
					KTF_GetTeleportPosition(-1, -1, xy);
					
					Ghost_X = xy[0];
					Ghost_Y = xy[1];
					
					KTF_MakeSplash();
					vars[0] = 6;
					KTF_Waitframe(this, ghost, vars, 16);
					vars[0] = 0;
					ghost->CollDetection = true;
					if(IsHardMode()){
						KTF_Waitframe(this, ghost, vars, 16);
						vars[0] = 2;
						KTF_Waitframe(this, ghost, vars, 16);
						for(i=-1; i<=1; i++){
							e = FireAimedEWeapon(EW_FIREBALL, Ghost_X+16, Ghost_Y+24, DegtoRad(30*i), 300, ghost->WeaponDamage, SPR_FIREBALL_UNBLOCKABLE, -1, EWF_UNBLOCKABLE);
						}
						for(i=-1; i<=1; i+=2){
							e = FireAimedEWeapon(EW_FIREBALL, Ghost_X+16, Ghost_Y+24, DegtoRad(15*i), 200, ghost->WeaponDamage, SPR_FIREBALL_UNBLOCKABLE, -1, EWF_UNBLOCKABLE);
						}
						KTF_Waitframe(this, ghost, vars, 16);
						vars[0] = 0;
						
					}
					attackCooldown = 60;
				}
				if(attackCooldown<=0)
					attackCooldown = 120;
			}
			
			bool diveArrow;
			for(i=Screen->NumLWeapons(); i>0; i--){
				lweapon l = Screen->LoadLWeapon(i);
				if(l->ID==LW_ARROW){
					if(RectCollision(l->X, l->Y, l->X+15, l->Y+15, Ghost_X-8, Ghost_Y-8, Ghost_X+56, Ghost_Y+56)){
						diveArrow = true;
					}
				}
			}
			
			if(diveArrow&&IsHardMode()){
				ghost->CollDetection = false;
				KTF_MakeSplash();
				vars[0] = 6;
				KTF_Waitframe(this, ghost, vars, 16);
				vars[0] = -1;
				KTF_Waitframe(this, ghost, vars, 16);
				
				KTF_GetTeleportPosition(-1, -1, xy);
				
				Ghost_X = xy[0];
				Ghost_Y = xy[1];
				
				KTF_MakeSplash();
				vars[0] = 6;
				KTF_Waitframe(this, ghost, vars, 16);
				vars[0] = 0;
				ghost->CollDetection = true;
				KTF_Waitframe(this, ghost, vars, 16);
			}
			
			KTF_Waitframe(this, ghost, vars);
		}
	}
	void KTF_MakeSplash(){
		Game->PlaySound(SFX_SPLASH);
		lweapon l;
		l = SparkleSpriteAnim(Ghost_X, Ghost_Y+32, SPR_SPLASH, 1, 1, -150, 200);
		l = SparkleSpriteAnim(Ghost_X+12, Ghost_Y+24, SPR_SPLASH, 1, 1, -120, 100);
		
		l = SparkleSpriteAnim(Ghost_X+32, Ghost_Y+32, SPR_SPLASH, 1, 1, -30, 200);
		l->Flip = 1;
		l = SparkleSpriteAnim(Ghost_X+32-12, Ghost_Y+24, SPR_SPLASH, 1, 1, -60, 100);
		l->Flip = 1;
	}
	void KTF_GetTeleportPosition(int tryX, int tryY, int xy){
		bool forceX;
		bool forceY;
		if(tryX>1000){
			tryX -= 1000;
			forceX = true;
		}
		if(tryY>1000){
			tryY -= 1000;
			forceY = true;
		}
		bool tryPos = tryX>-1&&tryY>-1;
		for(int i=0; i<176*2; i++){
			if(i==0&&tryPos){
				xy[0] = tryX;
				xy[1] = tryY;
			}
			else if(i<176){
				if(forceX)
					xy[0] = tryX;
				else
					xy[0] = Rand(32, 176);
				
				if(forceY)
					xy[1] = tryY;
				else
					xy[1] = Rand(32, 96);
			}
			else{
				xy[0] = ComboX(i-176);
				xy[1] = ComboY(i-176);
			}
			
			if(Distance(xy[0]+16, xy[1]+16, Link->X, Link->Y)>48&&Ghost_CanPlace(xy[0], xy[1], 48, 48)){
				return;
			}
		}
	}
	int KTF_GetZapMaxDistance(int zapArray, int trueZapArray){
		int count = SizeOfArray(zapArray)/2;
		int dist;
		for(int i=0; i<count-1; i++){
			int tempDist = Distance(zapArray[i*2], zapArray[i*2+1], zapArray[(i+1)*2], zapArray[(i+1)*2+1]);
			int tempAngle = Angle(zapArray[i*2], zapArray[i*2+1], zapArray[(i+1)*2], zapArray[(i+1)*2+1]);
			for(int j=0; j<tempDist; j++){
				int x = zapArray[i*2]+VectorX(j, tempAngle);
				int y = zapArray[i*2+1]+VectorY(j, tempAngle);
				trueZapArray[dist*2] = x;
				trueZapArray[dist*2+1] = y;
				//Screen->PutPixel(6, Ghost_X+x, Ghost_Y+y, 0x0F, 0, 0, 0, 128);
				dist++;
			}
			//Screen->DrawInteger(6, Ghost_X+zapArray[i*2]-2, Ghost_Y+zapArray[i*2+1]-2, FONT_Z3SMALL, 0x01, 0x0F, -1, -1, i, 0, 128);
			//Screen->Circle(6, Ghost_X+zapArray[i*2], Ghost_Y+zapArray[i*2+1], 2, 0x0F, 1, 0, 0, 0, true, 128);
			
		}
		trueZapArray[dist*2] = zapArray[(count-1)*2];
		trueZapArray[dist*2+1] = zapArray[(count-1)*2+1];
		return dist;
	}
	void KTF_GetZapXY(int dist, int trueZapArray, int xy){
		xy[0] = trueZapArray[dist*2];
		xy[1] = trueZapArray[dist*2+1];
	}
	void KTF_Waitframe(ffc this, npc ghost, int vars, int frames){
		for(int i=0; i<frames; i++){
			KTF_Waitframe(this, ghost, vars);
		}
	}
	void KTF_Waitframe(ffc this, npc ghost, int vars){
		int i; int j; int k;
		int x; int y;
		
		int combo = ghost->Attributes[10];
		
		//vars[0] - Fake Ghost_Data
		//vars[1] - Zap Distance
		//vars[2] - Zap Max Distance
		//vars[3] - Water Electrified Time
		int oldCD = vars[4];
		
		if(Link->HP>0){
			if(vars[0]>-1){
				i = this->CSet;
				if(vars[0]==6)
					i = 7;
				Screen->DrawCombo(2, Ghost_X-16, Ghost_Y, combo+1+vars[0], 5, 3, i, -1, -1, 0, 0, 0, 0, 0, true, 128);
				i = 7;
				if(vars[3]>0&&G[G_ANIM]%4<2)
					i = 0;
				if(vars[0]!=6)
					Screen->DrawCombo(2, Ghost_X-16, Ghost_Y+5, combo+8, 5, 3, i, -1, -1, 0, 0, 0, 0, 0, true, 128);
			}
			if(vars[2]>0){
				if(vars[0]==5){
					int zapArray[] = {00+13,16+12,  00+10,16+10,  00+07,16+10,  00+04,16+13,  00+02,32+01,  00+00,32+04,  -16+15,32+07,  -16+14,32+10,  -16+15,32+14};
					int trueZapArray[256];
					vars[2] = KTF_GetZapMaxDistance(zapArray, trueZapArray);
					int xy[2];
					KTF_GetZapXY(vars[1], trueZapArray, xy);
					
					x = xy[0];
					y = xy[1];
					Screen->FastCombo(2, Ghost_X+x-8, Ghost_Y+y-8, combo+9, 1, 128);
					
					x = 24-(x-24);
					Screen->FastCombo(2, Ghost_X+x-8, Ghost_Y+y-8, combo+9, 1, 128);
					
					if(vars[1]>=vars[2])
						vars[1] = 0;
					else
						vars[1] = Min(vars[1]+4, vars[2]);
				}
				else if(vars[0]==9){
					int zapArray[] = {00+13,16+12,  00+10,16+10,  00+07,16+10,  00+04,16+12,  00+01,16+15,  -16+13,32+01,  -16+10,32+03,  -16+07,32+02,  -16+05,16+15,  -16+09,16+11,  -16+09,16+08,  -16+07,16+06};
					int trueZapArray[256];
					vars[2] = KTF_GetZapMaxDistance(zapArray, trueZapArray);
					int xy[2];
					KTF_GetZapXY(vars[1], trueZapArray, xy);
					
					x = xy[0];
					y = xy[1];
					if(vars[1]>vars[2]*0.5)
						Screen->FastCombo(2, Ghost_X+x-8, Ghost_Y+y-8, combo+11, 1, 128);
					else
						Screen->FastCombo(2, Ghost_X+x-8, Ghost_Y+y-8, combo+9, 1, 128);
					
					x = 24-(x-24);
					if(vars[1]>vars[2]*0.5)
						Screen->FastCombo(2, Ghost_X+x-8, Ghost_Y+y-8, combo+11, 1, 128);
					else
						Screen->FastCombo(2, Ghost_X+x-8, Ghost_Y+y-8, combo+9, 1, 128);
					
					if(vars[1]>=vars[2])
						vars[1] = 0;
					else
						vars[1] = Min(vars[1]+4, vars[2]);
				}
				else if(vars[0]==4){
					int zapArray[] = {00+13,16+12,  00+11,16+10,  00+07,16+10,  00+04,16+13,  00+01,32+03,  -16+14,32+07,  -16+11,32+10,  -16+08,32+12,  -16+04,32+13,  -16+01,32+13};
					int trueZapArray[256];
					vars[2] = KTF_GetZapMaxDistance(zapArray, trueZapArray);
					int xy[2];
					KTF_GetZapXY(vars[1], trueZapArray, xy);
					
					x = xy[0];
					y = xy[1];
					if(vars[1]>vars[2]*0.5)
						Screen->FastCombo(2, Ghost_X+x-8, Ghost_Y+y-8, combo+11, 1, 128);
					else
						Screen->FastCombo(2, Ghost_X+x-8, Ghost_Y+y-8, combo+9, 1, 128);
					
					x = 24-(x-24);
					if(vars[1]>vars[2]*0.5)
						Screen->FastCombo(2, Ghost_X+x-8, Ghost_Y+y-8, combo+11, 1, 128);
					else
						Screen->FastCombo(2, Ghost_X+x-8, Ghost_Y+y-8, combo+9, 1, 128);
					
					if(vars[1]>=vars[2])
						vars[1] = 0;
					else
						vars[1] = Min(vars[1]+2, vars[2]);
				}
			}
		}
		
		for(i=Screen->NumEWeapons(); i>0; i--){
			eweapon e = Screen->LoadEWeapon(i);
			if(e->ID==EW_CATFISH_THUNDERSHOT){
				int vX = VectorX(e->Step/100, RadtoDeg(e->Angle));
				int vY = VectorY(e->Step/100, RadtoDeg(e->Angle));
				int stepDecrease = (300*0.75)/LazyDiffMod(4, 5, 6);
				if((vX<0&&!CanWalk(e->X, e->Y, DIR_LEFT, e->Step/100, false))||(vX>0&&!CanWalk(e->X, e->Y, DIR_RIGHT, e->Step/100, false))){
					vX = -vX;
					e->Angle = DegtoRad(Angle(0, 0, vX, vY));
					e->Misc[EWM_CATFISH_THUNDERSHOT]--;
					e->Step -= stepDecrease;
				}
			
				if((vY<0&&!CanWalk(e->X, e->Y, DIR_UP, e->Step/100, false))||(vY>0&&!CanWalk(e->X, e->Y, DIR_DOWN, e->Step/100, false))){
					vY = -vY;
					e->Angle = DegtoRad(Angle(0, 0, vX, vY));
					e->Misc[EWM_CATFISH_THUNDERSHOT]--;
					e->Step -= stepDecrease;
				}
				if(e->Misc[EWM_CATFISH_THUNDERSHOT]<=0)
					e->DeadState = 0;
			}
		}
		if(vars[3]>0){
			vars[3]--;
			if(vars[3]>0){
				for(i=0; i<176; i++){
					if(oldCD[i]>0){
						Screen->ComboD[i] = oldCD[i]+1;
						Screen->ComboF[i] = 98;
					}
				}
			}
			else{
				for(i=0; i<176; i++){
					if(oldCD[i]>0){
						Screen->ComboD[i] = oldCD[i];
						Screen->ComboF[i] = 0;
					}
				}
			}
		}
		
		if(!Q7_Ghost_Waitframe(this, ghost, true, false)){
			for(i=0; i<176; i++){
				if(oldCD[i]>0){
					Screen->ComboD[i] = oldCD[i];
					Screen->ComboF[i] = 0;
				}
			}
			ghost->DrawYOffset = -2;
			Quit();
		}
	}
}

ffc script BossMusic{
	void run(){
		int bossMusic[] = "Sonic 2.nsf";
		Waitframes(4);
		if(Screen->NumNPCs()>0){
			Game->PlayEnhancedMusic(bossMusic, 2);
			while(Screen->NumNPCs()>0){
				Waitframe();
			}
			Game->PlayMIDI(0);
		}
	}
}

// Stores a curve between three points into two position arrays
void BezierQuad(int arrX, int arrY, int length, int x1, int y1, int x2, int y2, int x3, int y3){
	for(int i=0; i<=length; i++){
		float t = i/length;
		int x = (1-t)*(1-t)*x1 + 2*(1-t)*t*x2 + t*t*x3;
		int y = (1-t)*(1-t)*y1 + 2*(1-t)*t*y2 + t*t*y3;
		
		arrX[i] = x;
		arrY[i] = y;
	}
}

// Like the above, put only calculating for one frame of the curve
void BezierQuadFrame(int xy, int frame, int length, int x1, int y1, int x2, int y2, int x3, int y3){
	float t = frame/length;
	int x = (1-t)*(1-t)*x1 + 2*(1-t)*t*x2 + t*t*x3;
	int y = (1-t)*(1-t)*y1 + 2*(1-t)*t*y2 + t*t*y3;
	
	xy[0] = x;
	xy[1] = y;
}

void DealDirectDamage(int damage){
	Link->HP -= damage;
	G[G_LASTHP] = Link->HP;
}

bool PressButtonItem(int itm){
	if(GetEquipmentA()==itm&&Link->PressA)return true;
	else if(GetEquipmentB()==itm&&Link->PressB)return true;
	return false;
}
bool InputButtonItem(int itm){
	if(GetEquipmentA()==itm&&Link->InputA)return true;
	else if(GetEquipmentB()==itm&&Link->InputB)return true;
	return false;
}

const int SFX_GP_RINGLOSS = 69;
const int SFX_GP_DASH = 1;

const int RT_GHINIPIRATE = 3;

const int MAP_GHINIPIRATE_RUPEEBG = 4;
const int SCREEN_GHINIPIRATE_RUPEEBG = 0x08;

ffc script GhiniPirate{
	void run(int enemyid){
		int i; int j; int k;
		int x; int y;
		int angle; int dist;
		int vX; int vY;
		
		npc ghost = Ghost_InitAutoGhost(this, enemyid);
		NJFMode_IncreaseBossHP(ghost);
		this->Flags[FFCF_ETHEREAL] = true;
		
		Ghost_Transform(this, ghost, -1, -1, 2, 2);
		ghost->DrawYOffset = -1000;
		
		Ghost_SetFlag(GHF_FLYING_ENEMY);
		Ghost_SetFlag(GHF_IGNORE_SOLIDITY);
		
		item rings[128];
		
		int ringX[128];
		int ringY[128];
		int ringZ[128];
		int ringAng[128];
		int ringStep[128];
		int ringJump[128];
		int ringT[128];
		int ringMaxT[128];
		int rupeeLeechX[16];
		int rupeeLeechY[16];
		int rupeeLeechAxisOff[16];
		int rupeeLeechT[16];
		
		int vars[32] = {0, 0, ringX, ringY, ringZ, ringAng, ringStep, ringJump, ringT, Link->HP, ringMaxT, ghost->HP, 0, rupeeLeechX, rupeeLeechY, rupeeLeechAxisOff, rupeeLeechT, 0, 2};
		//vars[0] - Fake Ghost_Data
		//vars[1] - Num Rings
		//vars[9] - OldLinkHP
		//vars[11] - Old Ghost HP
		//vars[12] - Flip
		//vars[17] - No Ring Loss
		//vars[18] - HP Change Cooldown
		
		int lazyChaseTurnCooldown = 60;
		int lazyChaseType;
		
		int attackCooldown = 120;
		
		Ghost_X = 112;
		Ghost_Y = 32;
		
		int diffMod[4];
		
		while(true){
			if(lazyChaseTurnCooldown)
				lazyChaseTurnCooldown--;
			else if(Rand(48)==0){
				lazyChaseTurnCooldown = 60;
				lazyChaseType = Cond(lazyChaseType, 0, 1);
			}
			diffMod[0] = LazyDiffMod(0.01, 0.02, 0.03);
			diffMod[1] = LazyDiffMod(1.5, 2, 2.5);
			if(lazyChaseType==0){
				vX = Clamp(vX+Sign(Link->X-Ghost_X+8)*diffMod[0], -diffMod[1], diffMod[1]);
				vY = Clamp(vY+Sign(Link->Y-Ghost_Y+8)*diffMod[0], -diffMod[1], diffMod[1]);
			}
			else{
				vX = Clamp(vX+Sign(Link->X-Ghost_X+8)*-diffMod[0], -diffMod[1], diffMod[1]);
				vY = Clamp(vY+Sign(Link->Y-Ghost_Y+8)*-diffMod[0], -diffMod[1], diffMod[1]);
			}
			
			Ghost_MoveXY(vX, vY, 0);
			if((vX<0&&!Ghost_CanMove(DIR_LEFT, 1, 0)) || (vX>0&&!Ghost_CanMove(DIR_RIGHT, 1, 0))){
				vX = -vX;
			}
			if((vY<0&&!Ghost_CanMove(DIR_UP, 1, 0)) || (vY>0&&!Ghost_CanMove(DIR_DOWN, 1, 0))){
				vY = -vY;
			}
			GP_FaceAngle(ghost, vars, Angle(Ghost_X+8, Ghost_Y+8, Link->X, Link->Y), 0);
			
			if(attackCooldown>0)
				attackCooldown--;
			else if(Rand(24)==0){
				int attack = Choose(0, 0, 1, 2);
				if(!IsHardMode())
					attack = Choose(0, 0, 1);
				vX = 0;
				vY = 0;
				if(attack==0){ //Ziz-zag Dash
					angle = Angle(Link->X, Link->Y, Ghost_X+8, Ghost_Y+8)+Choose(-45, 0, 45);
					for(i=0; i<48; i++){
						GP_FaceAngle(ghost, vars, angle+180, 0);
						Ghost_MoveAtAngle(angle, 1.5, 0);
						
						GP_Waitframe(this, ghost, rings, vars);
					}
					GP_FaceAngle(ghost, vars, angle+180, 3);
						
					GP_Waitframe(this, ghost, rings, vars, 16);
					
					angle = Angle(Ghost_X+8, Ghost_Y+8, Link->X, Link->Y);
					diffMod[0] = LazyDiffMod(3, 4, 4);
					diffMod[1] = LazyDiffMod(30, 45, 60);
					diffMod[2] = LazyDiffMod(12, 12, 18);
					GP_ZigZagDash(this, ghost, rings, vars, angle, 10, diffMod[0], 12, diffMod[1]);
					attackCooldown = 120;
				}
				else if(attack==1){ //Rude Projectile Attack
					for(i=0; i<3; i++){
						angle = Angle(Ghost_X+8, Ghost_Y+8, Link->X, Link->Y);
						GP_FaceAngle(ghost, vars, angle, 0);
						GP_Waitframe(this, ghost, rings, vars, 4);
						angle = Angle(Ghost_X+8, Ghost_Y+8, Link->X, Link->Y);
						GP_FaceAngle(ghost, vars, angle, 3);
						GP_Waitframe(this, ghost, rings, vars, 4);
					}
					diffMod[0] = LazyDiffMod(1, 2, 3);
					diffMod[1] = LazyDiffMod(4, 5, 6);
					diffMod[2] = LazyDiffMod(8, 12, 12);
					diffMod[3] = LazyDiffMod(12, 16, 16);
					for(i=0; i<diffMod[1]; i++){
						angle = Angle(Ghost_X+8, Ghost_Y+8, Link->X, Link->Y)+Rand(-20, 20);
						GP_FaceAngle(ghost, vars, angle, 0);
						GP_Waitframe(this, ghost, rings, vars, diffMod[3]);
						for(j=0; j<diffMod[2]; j++){
							Ghost_MoveAtAngle(angle, diffMod[0], 0);
							GP_Waitframe(this, ghost, rings, vars);
						}
						for(j=-1; j<=1; j+=2){
							eweapon e = FireAimedEWeapon(EW_FIREBALL, Ghost_X+8, Ghost_Y+8, DegtoRad((45-45*(i/(diffMod[1]-1)))*j), 300, ghost->WeaponDamage, SPR_FIREBALL_UNBLOCKABLE, -1, EWF_UNBLOCKABLE);
						}
						GP_Waitframe(this, ghost, rings, vars, diffMod[3]);
					}
					attackCooldown = 120;
				}
				else if(attack==2){ //Shekel Singularity
					vars[0] = 2;
					Screen->SetRenderTarget(RT_GHINIPIRATE);
					Screen->Rectangle(0, 0, 0, 511, 511, 0x00, 1, 0, 0, 0, true, 128);
					Screen->SetRenderTarget(RT_SCREEN);
					GP_Waitframe(this, ghost, rings, vars, LazyDiffMod(80, 72, 64));
					i = 0;
					diffMod[0] = LazyDiffMod(2.5, 2.8, 3);
					for(j=0; j<32; j++){
						i++;
						if(Distance(Link->X, Link->Y, Ghost_X+8, Ghost_Y+8)<j*diffMod[0]&&i%4==0){
							if(Game->Counter[CR_RUPEES]>0){
								Game->PlaySound(SFX_MSG);
								Game->Counter[CR_RUPEES] = Max(Game->Counter[CR_RUPEES]-2, 0);
								GP_AddRupeeLeech(vars, Link->X, Link->Y);
							}
							else{
								DealDirectDamage(4);
								Game->PlaySound(SFX_OUCH);
								vars[9] = Link->HP;
								vars[17] = 1;
							}
						}
						GP_DrawRupeeDrainFloorBitmap(Ghost_X+16, Ghost_Y+16, j*diffMod[0]);
						GP_Waitframe(this, ghost, rings, vars);
					}
					for(k=0; k<96; k++){
						i++;
						if(Ghost_GotHit())
							k=96;
						if(Distance(Link->X, Link->Y, Ghost_X+8, Ghost_Y+8)<j*diffMod[0]&&i%4==0){
							if(Game->Counter[CR_RUPEES]>0){
								Game->PlaySound(SFX_MSG);
								Game->Counter[CR_RUPEES] = Max(Game->Counter[CR_RUPEES]-2, 0);
								GP_AddRupeeLeech(vars, Link->X, Link->Y);
							}
							else{
								DealDirectDamage(4);
								Game->PlaySound(SFX_OUCH);
								vars[9] = Link->HP;
								vars[17] = 1;
							}
						}
						GP_DrawRupeeDrainFloorBitmap(Ghost_X+16, Ghost_Y+16, j*diffMod[0]);
						GP_Waitframe(this, ghost, rings, vars);
					}
					for(j=32; j>0; j-=2){
						i++;
						if(Distance(Link->X, Link->Y, Ghost_X+8, Ghost_Y+8)<j*diffMod[0]&&i%4==0){
							if(Game->Counter[CR_RUPEES]>0){
								Game->PlaySound(SFX_MSG);
								Game->Counter[CR_RUPEES] = Max(Game->Counter[CR_RUPEES]-2, 0);
								GP_AddRupeeLeech(vars, Link->X, Link->Y);
							}
							else{
								DealDirectDamage(4);
								Game->PlaySound(SFX_OUCH);
								vars[9] = Link->HP;
								vars[17] = 1;
							}
						}
						GP_DrawRupeeDrainFloorBitmap(Ghost_X+16, Ghost_Y+16, j*diffMod[0]);
						GP_Waitframe(this, ghost, rings, vars);
					}
					attackCooldown = 60;
				}
			}
			
			GP_Waitframe(this, ghost, rings, vars);
		}
	}
	void GP_ZigZagDash(ffc this, npc ghost, item rings, int vars, int angle, int rep, int step, int reptime, int ang2){
		for(int i=0; i<rep; i++){
			Game->PlaySound(SFX_GP_DASH);
			for(int j=0; j<reptime; j++){
				int moveAngle = angle+ang2*Cond(i%2==0, -1, 1);
				Ghost_MoveAtAngle(moveAngle, step, 0);
				if(!Ghost_CanMoveAngle(angle, 1, 0)){
					return;
				}
				GP_Waitframe(this, ghost, rings, vars);
			}
		}
	}
	void GP_FaceAngle(npc ghost, int vars, int angle, int st){
		angle = WrapDegrees(angle);
		if(angle<0)
			vars[0] = st+1;
		else
			vars[0] = st;
		if(Abs(angle)<90)
			vars[12] = 1;
		else
			vars[12] = 0;
	}
	void GP_AddRing(item rings, int vars, int x, int y, int ang, int step, int maxT){
		int ringX = vars[2];
		int ringY = vars[3];
		int ringZ = vars[4];
		int ringAng = vars[5];
		int ringStep = vars[6];
		int ringJump = vars[7];
		int ringT = vars[8];
		int ringMaxT = vars[10];
		
		int i = Min(vars[1], 127);
		
		ringX[i] = x;
		ringY[i] = y;
		ringZ[i] = 0;
		ringAng[i] = ang;
		ringStep[i] = step;
		ringJump[i] = 0;
		ringT[i] = 1;
		ringMaxT[i] = maxT;
		
		vars[1] = Min(vars[1]+1, 128);
	}
	void GP_RemoveRing(item rings, int vars, int j){
		int ringX = vars[2];
		int ringY = vars[3];
		int ringZ = vars[4];
		int ringAng = vars[5];
		int ringStep = vars[6];
		int ringJump = vars[7];
		int ringT = vars[8];
		int ringMaxT = vars[10];
		
		int i = Min(vars[1]-1, 127);
		
		if(rings[j]->isValid())
			rings[j]->Y = -1000;
		
		rings[j] = rings[i];
		ringX[j] = ringX[i];
		ringY[j] = ringY[i];
		ringZ[j] = ringZ[i];
		ringAng[j] = ringAng[i];
		ringStep[j] = ringStep[i];
		ringJump[j] = ringJump[i];
		ringT[j] = ringT[i];
		ringMaxT[j] = ringMaxT[i];
		
		vars[1] = Max(vars[1]-1, 0);
	}
	void GP_UpdateRings(npc ghost, item rings, int vars){
		int ringX = vars[2];
		int ringY = vars[3];
		int ringZ = vars[4];
		int ringAng = vars[5];
		int ringStep = vars[6];
		int ringJump = vars[7];
		int ringT = vars[8];
		int ringMaxT = vars[10];
		
		int combo = ghost->Attributes[10];
		
		for(int i=0; i<vars[1]; i++){
			if(i<0)
				continue;
			if(ringT[i]>0){
				ringT[i]++;
				int vX = VectorX(ringStep[i], ringAng[i]);
				int vY = VectorY(ringStep[i], ringAng[i]);
				if((vX<0&&!CanWalk(ringX[i], ringY[i], DIR_LEFT, 1, true))||(vX>0&&!CanWalk(ringX[i], ringY[i], DIR_RIGHT, 1, true))){
					vX = -vX * 0.6;
					ringAng[i] = Angle(0, 0, vX, vY);
					ringStep[i] = Distance(0, 0, vX, vY);
				}
				if((vY<0&&!CanWalk(ringX[i], ringY[i], DIR_UP, 1, true))||(vY>0&&!CanWalk(ringX[i], ringY[i], DIR_DOWN, 1, true))){
					vY = -vY * 0.6;
					ringAng[i] = Angle(0, 0, vX, vY);
					ringStep[i] = Distance(0, 0, vX, vY);
				}
				ringX[i] += vX;
				ringY[i] += vY;
				ringJump[i] = Max(ringJump[i]-0.16, -3.2);
				ringZ[i] = Max(0, ringZ[i]+ringJump[i]);
				if(ringZ[i]==0)
					ringJump[i] = 2.6;
				
				if(ringT[i]==32){
					if(!rings[i]->isValid()){
						rings[i] = CreateItemAt(I_RUPEE1, ringX[i], ringY[i]-ringZ[i]);
						rings[i]->DrawYOffset = -1000;
					}
				}
				else if(ringT[i]>32){
					if(rings[i]->isValid()){
						rings[i]->X = ringX[i];
						rings[i]->Y = ringY[i]-ringZ[i];
					}
					else{
						GP_RemoveRing(rings, vars, i);
						i--;
						continue;
					}
				}
				
				if(ringT[i]>=ringMaxT[i]-64){
					if(G[G_ANIM]%4<2)
						Screen->FastCombo(2, ringX[i], ringY[i]-ringZ[i], combo+4, 8, 128);
				}
				else
					Screen->FastCombo(2, ringX[i], ringY[i]-ringZ[i], combo+4, 8, 128);
				
				if(ringT[i]>=ringMaxT[i]){
					GP_RemoveRing(rings, vars, i);
					i--;
					continue;
				}
				//Screen->DrawInteger(6, ringX[i], ringY[i], FONT_Z1, 0x01, 0x0F, -1, -1, i, 0, 128);
			}
			else{
				if(rings[i]->isValid()){
					rings[i]->Y = -1000;
				}
			}
		}
	}
	void GP_AddRupeeLeech(int vars, int x, int y){
		int rupeeLeechX = vars[13];
		int rupeeLeechY = vars[14];
		int rupeeLeechAxisOff = vars[15];
		int rupeeLeechT = vars[16];
		
		for(int i=0; i<16; i++){
			if(rupeeLeechT[i]==0){
				rupeeLeechX[i] = Link->X;
				rupeeLeechY[i] = Link->Y;
				rupeeLeechAxisOff[i] = Rand(-100, 100)/100;
				rupeeLeechT[i] = 32;
				return;
			}
		}
	}
	void GP_UpdateRupeeLeech(npc ghost, int vars){
		if(Link->HP<=0)
			return;
		
		int rupeeLeechX = vars[13];
		int rupeeLeechY = vars[14];
		int rupeeLeechAxisOff = vars[15];
		int rupeeLeechT = vars[16];
		
		int combo = ghost->Attributes[10];
		
		for(int i=0; i<16; i++){
			if(rupeeLeechT[i]>0){
				int xy[2];
				
				int dist = Distance(rupeeLeechX[i], rupeeLeechY[i], Ghost_X+8, Ghost_Y+8);
				int ang = Angle(rupeeLeechX[i], rupeeLeechY[i], Ghost_X+8, Ghost_Y+8);
				int x = rupeeLeechX[i]+VectorX(dist/2, ang)+VectorX(dist*0.6*rupeeLeechAxisOff[i], ang-90);
				int y = rupeeLeechY[i]+VectorY(dist/2, ang)+VectorY(dist*0.6*rupeeLeechAxisOff[i], ang-90);
				
				BezierQuadFrame(xy, 32-rupeeLeechT[i], 32, Link->X, Link->Y, x, y, Ghost_X+8, Ghost_Y+8);
				
				Screen->FastCombo(4, xy[0], xy[1], combo+8, 8, 128);
				
				rupeeLeechT[i]--;
			}
		}
	}
	void GP_DrawRupeeDrainFloorBitmap(int x, int y, int rad){
		int drawMap = MAP_GHINIPIRATE_RUPEEBG;
		int drawScrn = SCREEN_GHINIPIRATE_RUPEEBG;
		if(Game->GetCurLevel()==9){
			drawMap = 14;
			drawScrn = 0x70;
		}
			
		Screen->SetRenderTarget(RT_GHINIPIRATE);
		Screen->DrawScreen(0, Game->GetCurMap(), Game->GetCurScreen(), 256, 0, 0);
		Screen->Circle(0, x+256, y, rad+4, 0x00, 1, 0, 0, 0, true, 128);
		
		Screen->DrawScreen(0, drawMap, drawScrn+1, 0, 0, 0);
		
		Screen->DrawBitmap(0, RT_GHINIPIRATE, 256, 0, 256, 176, 0, 0, 256, 176, 0, true);
		Screen->Circle(0, x, y, rad, 0x00, 1, 0, 0, 0, true, 128);
		
		Screen->DrawScreen(0, drawMap, drawScrn, 256, 0, 0);
		
		Screen->DrawBitmap(0, RT_GHINIPIRATE, 0, 0, 256, 176, 256, 0, 256, 176, 0, true);
		
		Screen->DrawBitmap(0, RT_GHINIPIRATE, 256, 0, 256, 176, 0, 0, 256, 176, 0, true);
		
		Screen->Rectangle(0, 0, 0, 255, 31, 0x00, 1, 0, 0, 0, true, 128);
		Screen->Rectangle(0, 0, 144, 255, 175, 0x00, 1, 0, 0, 0, true, 128);
		Screen->Rectangle(0, 0, 0, 31, 175, 0x00, 1, 0, 0, 0, true, 128);
		Screen->Rectangle(0, 224, 0, 255, 175, 0x00, 1, 0, 0, 0, true, 128);
		
		Screen->SetRenderTarget(RT_SCREEN);
		Screen->DrawBitmap(1, RT_GHINIPIRATE, 0, 0, 256, 176, 0, 0, 256, 176, 0, true);
	}
	void GP_Waitframe(ffc this, npc ghost, item rings, int vars, int frames){
		for(int i=0; i<frames; i++){
			GP_Waitframe(this, ghost, rings, vars);
		}
	}
	void GP_Waitframe(ffc this, npc ghost, item rings, int vars){
		int i; int j; int k;
		
		GP_UpdateRupeeLeech(ghost, vars);
		GP_UpdateRings(ghost, rings, vars);
		
		int combo = ghost->Attributes[10];
		
		//vars[0] - Fake Ghost_Data
		//vars[1] - Num Rings
		//vars[9] - OldLinkHP
		//vars[11] - Old Ghost HP
		//vars[12] - Flip
		//vars[17] - No Ring Loss
		//vars[18] - HP Change Cooldown
		
		int ringLeniency = 60;
		if(IsVeryHardModeNoCheat())
			ringLeniency = 0;
		else if(IsHardModeNoCheat())
			ringLeniency = 30;
		
		if(Link->HP<vars[9]){
			int damage = vars[9]-Link->HP;
			Link->HP = vars[9];
			if(!vars[17]){
				if(Game->Counter[CR_RUPEES]==0){
					Link->HP = 0;
				}
				else{
					int rupeesLost = Game->Counter[CR_RUPEES];
					if(!IsHardModeNoCheat())
						rupeesLost = Min(damage*4, Game->Counter[CR_RUPEES]);
					Game->Counter[CR_RUPEES] = Max(Game->Counter[CR_RUPEES]-rupeesLost, 0);
					
					Game->PlaySound(SFX_GP_RINGLOSS);
					
					int rA; int rB;
					int rAngle = Rand(360);
					if(rupeesLost>=64){
						for(i=0; i<32; i++){
							GP_AddRing(rings, vars, Link->X, Link->Y, rAngle+11.25*i, 3, 120+ringLeniency+Rand(32));
							GP_AddRing(rings, vars, Link->X, Link->Y, rAngle+11.25*i, 2, 120+ringLeniency+Rand(32));
						}
					}
					else if(rupeesLost>=16){
						rA = Floor(rupeesLost/2);
						rB = rupeesLost-rA;
						for(i=0; i<rA; i++){
							GP_AddRing(rings, vars, Link->X, Link->Y, rAngle+(360/rA)*i, 3, 120+ringLeniency+Rand(32));
						}
						for(i=0; i<rB; i++){
							GP_AddRing(rings, vars, Link->X, Link->Y, rAngle+(360/rB)*i, 2, 120+ringLeniency+Rand(32));
						}
					}
					else{
						for(i=0; i<rupeesLost; i++){
							GP_AddRing(rings, vars, Link->X, Link->Y, rAngle+(360/rupeesLost)*i, 3, 120+ringLeniency+Rand(32));
						}
					}
				}
			}
		}
		if(ghost->HP<vars[11]){
			if(vars[18]>0)
				vars[18]--;
			else{
				int damage = (vars[11]-ghost->HP)/G[G_HPSCALE];
				j = Min(90, ((damage-1)/8)*20);
				int rAngle = Angle(Link->X, Link->Y, Ghost_X+8, Ghost_Y+8);
				for(i=0; i<damage; i++){
					GP_AddRing(rings, vars, Ghost_X+8, Ghost_Y+8, rAngle-j/2+(j/(Max(1, damage-1)))*i, Rand(20, 30)/10, 60+ringLeniency+Rand(32));		
				}
			}
		}
		vars[9] = Link->HP;
		vars[11] = ghost->HP;
		
		if(Link->HP>0){
			if(vars[0]==0){
				Screen->DrawCombo(2, Ghost_X, Ghost_Y, combo+0, 2, 2, this->CSet, -1, -1, 0, 0, 0, 0, vars[12], true, 128);
				Screen->DrawCombo(2, Ghost_X+1, Ghost_Y-14, combo+2, 2, 1, this->CSet, -1, -1, 0, 0, 0, 0, 0, true, 128);
			}
			else if(vars[0]==1){
				Screen->DrawCombo(2, Ghost_X, Ghost_Y, combo+1, 2, 2, this->CSet, -1, -1, 0, 0, 0, 0, vars[12], true, 128);
				Screen->DrawCombo(2, Ghost_X+1, Ghost_Y-14, combo+3, 2, 1, this->CSet, -1, -1, 0, 0, 0, 0, 0, true, 128);
			}
			else if(vars[0]==2){
				Screen->DrawCombo(2, Ghost_X, Ghost_Y, combo+5, 2, 2, this->CSet, -1, -1, 0, 0, 0, 0, vars[12], true, 128);
				Screen->DrawCombo(2, Ghost_X+1, Ghost_Y-14, combo+2, 2, 1, this->CSet, -1, -1, 0, 0, 0, 0, 0, true, 128);
			}
			else if(vars[0]==3){
				Screen->DrawCombo(2, Ghost_X, Ghost_Y, combo+6, 2, 2, this->CSet, -1, -1, 0, 0, 0, 0, vars[12], true, 128);
				Screen->DrawCombo(2, Ghost_X+1, Ghost_Y-14, combo+2, 2, 1, this->CSet, -1, -1, 0, 0, 0, 0, 0, true, 128);
			}
			else if(vars[0]==4){
				Screen->DrawCombo(2, Ghost_X, Ghost_Y, combo+7, 2, 2, this->CSet, -1, -1, 0, 0, 0, 0, vars[12], true, 128);
				Screen->DrawCombo(2, Ghost_X+1, Ghost_Y-14, combo+3, 2, 1, this->CSet, -1, -1, 0, 0, 0, 0, 0, true, 128);
			}
		}
		
		if(vars[17])
			vars[17] = 0;
		
		if(PressButtonItem(I_POTION1)||PressButtonItem(I_POTION2))
			Game->Counter[CR_RUPEES] = 255;
		
		if(!Q7_Ghost_Waitframe(this, ghost, true, false)){
			ghost->DrawYOffset = -2;
			for(i=0; i<128; i++){
				if(rings[i]->isValid())
					rings[i]->Y = -1000;
			}
			Quit();
		}
	}
}

ffc script Stupid_Fucking_Gravestone_Secret_SFX{
	void run(int destcombo, int perm){
		if(perm&&Screen->State[ST_SECRET])
			Quit();
		while(Screen->ComboD[ComboAt(this->X+8, this->Y+8)]!=destcombo){
			Waitframe();
		}
		if(perm)
			Screen->State[ST_SECRET] = true;
		Game->PlaySound(SFX_SECRET);
	}
}

ffc script WaterOverUnder{
	void run(int flagOver, int flagUnder){
		int i;
		int cmbCS[176];
		for(i=0; i<176; i++){
			cmbCS[i] = Screen->ComboC[i];
		}
		
		int linkX = Link->X;
		int linkY = Link->Y;
		if(this->Flags[FFCF_PRELOAD]){
			if(linkX==0)
				linkX = 240;
			else if(linkX==240)
				linkX = 0;
			if(linkY==0)
				linkY = 160;
			else if(linkY==160)
				linkY = 0;
		}
		while(true){
			while(!ComboFI(linkX+8, linkY+12, flagOver)){
				linkX = Link->X;
				linkY = Link->Y;
				Waitframe();
			}
			Screen->TriggerSecrets();
			ForceCSet(cmbCS);
			
			while(!ComboFI(linkX+8, linkY+12, flagUnder)){
				linkX = Link->X;
				linkY = Link->Y;
				Waitframe();
			}
			Screen->TriggerSecrets();
			ForceCSet(cmbCS);
		}
	}
	void ForceCSet(int cmbCS){
		for(int i=0; i<176; i++){
			if(cmbCS[i]>0)
				Screen->ComboC[i] = cmbCS[i];
		}
	}
}

ffc script PovertyWizzrobe{
	void run(int enemyid){
		int i; int j; int k;
		
		npc ghost = Ghost_InitAutoGhost(this, enemyid);
		this->Flags[FFCF_ETHEREAL] = true;
		Ghost_SetFlag(GHF_4WAY);
		int cr; int cr2; int cr3;
		
		int rupeeLeechX[16];
		int rupeeLeechY[16];
		int rupeeLeechAxisOff[16];
		int rupeeLeechT[16];
		
		int vars[16] = {0, rupeeLeechX, rupeeLeechY, rupeeLeechAxisOff, rupeeLeechT, 0};
		
		int teleportState = 0;
		int teleportTimer = 4;
		bool doAttack;
		ghost->DrawXOffset = 1000;
		ghost->HitXOffset = 1000;
		
		int drainRate = LazyDiffMod(24, 16, 8);
		if(IsEasyMode())
			drainRate = 48;
		while(true){
			doAttack = false;
			if(teleportState==0&&G[G_TRACKTILEDIR]>-1){
				while(G[G_TRACKTILEDIR]>-1){
					PW_Waitframe(this, ghost, vars);
				}
			}
			if(teleportTimer>0)
				teleportTimer--;
			else{
				if(teleportState==0){ //Invisible
					teleportState = 1;
					teleportTimer = 64;
					i = PW_GetTeleportPos();
					if(i>0){
						Ghost_X = ComboX(i);
						Ghost_Y = ComboY(i);
						Ghost_Dir = AngleDir4(Angle(Ghost_X, Ghost_Y, Link->X, Link->Y));
					}
					else{
						teleportState = 0;
						teleportTimer = 4;
					}
				}
				else if(teleportState==1){ //Teleport In
					teleportState = 2;
					teleportTimer = 16;
				}
				else if(teleportState==2){ //Before Attacking
					teleportState = 3;
					teleportTimer = 48;
					doAttack = true;
				}
				else if(teleportState==3){ //Attacking
					teleportState = 4;
					teleportTimer = 16;
				}
				else if(teleportState==4){ //Teleport Out
					teleportState = 0;
					teleportTimer = 75;
				}
			}
			if(teleportState==0){
				ghost->CollDetection = false;
				ghost->DrawXOffset = 1000;
				ghost->HitXOffset = 1000;
				if(Game->Counter[CR_RUPEES]==0){
					ghost->HP = -1000;
					Game->GuyCount[Game->GetCurScreen()]++;
					ghost->ItemSet = 0;
					this->Data = 0;
					Quit();
				}
			}
			else if(teleportState==1||teleportState==4){
				ghost->CollDetection = true;
				ghost->HitXOffset = 0;
				if(teleportTimer%2==0){
					ghost->DrawXOffset = 1000;
				}
				else{
					ghost->DrawXOffset = 0;
				}
			}
			else{
				ghost->CollDetection = true;
				ghost->HitXOffset = 0;
				ghost->DrawXOffset = 0;
			}
			
			if(doAttack){
				if(Game->Counter[CR_RUPEES]>0){
					while(vars[5]<4){
						for(i=0; i<4; i++){
							PW_Waitframe(this, ghost, vars);
						}
						vars[5]++;
					}
					i = 0;
					while(Distance(Ghost_X, Ghost_Y, Link->X, Link->Y)>32&&!Ghost_GotHit()){
						if(Game->Counter[CR_RUPEES]==0)
							break;
						i++;
						if(i%4==0){
							if(i%drainRate==0){
								Game->Counter[CR_RUPEES]--;
								Game->PlaySound(SFX_MSG);
							}
							PW_AddRupeeLeech(vars, Link->X, Link->Y);
						}
						Ghost_MoveAtAngle(Angle(Link->X, Link->Y, Ghost_X, Ghost_Y), 0.8, 0);
						Ghost_Dir = AngleDir4(Angle(Ghost_X, Ghost_Y, Link->X, Link->Y));
						PW_Waitframe(this, ghost, vars);
					}
					for(j=0; j<60; j++){
						if(Game->Counter[CR_RUPEES]==0)
							break;
						i++;
						if(i%4==0){
							if(i%drainRate==0){
								Game->Counter[CR_RUPEES]--;
								Game->PlaySound(SFX_MSG);
							}
							PW_AddRupeeLeech(vars, Link->X, Link->Y);
						}
						PW_Waitframe(this, ghost, vars);
					}
					while(vars[5]>0){
						for(i=0; i<2; i++){
							PW_Waitframe(this, ghost, vars);
						}
						vars[5]--;
					}
				}
			}
			PW_Waitframe(this, ghost, vars);
		}
	}
	int PW_GetTeleportPos(){
		int i;
		int x; int y;
		int pos; int ct;
		
		int linkX = Clamp(GridX(Link->X)+8, 32, 208);
		int linkY = Clamp(GridY(Link->Y)+8, 32, 128);
		
		
		int validPos[176];
		int numValid;
		
		//Find all valid combos to teleport to in all four directions
		
		//Up
		for(i=2; i<11; i++){
			x = linkX;
			y = linkY-16*i;
			pos = ComboAt(x, y);
			ct = Screen->ComboT[pos];
			if(x<32||x>224||y<32||y>144)
				continue;
			if(Screen->ComboS[pos]!=0000b)
				continue;
			if(ComboFI(pos, CF_NOENEMY))
				continue;
			if(ct==CT_NOENEMY||ct==CT_NOFLYZONE)
				continue;
			if(ct==CT_LADDERHOOKSHOT)
				continue;
			
			validPos[numValid] = pos;
			numValid++;
		}
		//Down
		for(i=2; i<11; i++){
			x = linkX;
			y = linkY+16*i;
			pos = ComboAt(x, y);
			ct = Screen->ComboT[pos];
			if(x<32||x>224||y<32||y>144)
				continue;
			if(Screen->ComboS[pos]!=0000b)
				continue;
			if(ComboFI(pos, CF_NOENEMY))
				continue;
			if(ct==CT_NOENEMY||ct==CT_NOFLYZONE)
				continue;
			if(ct==CT_LADDERHOOKSHOT)
				continue;
			
			validPos[numValid] = pos;
			numValid++;
		}
		//Left
		for(i=2; i<16; i++){
			x = linkX-16*i;
			y = linkY;
			pos = ComboAt(x, y);
			ct = Screen->ComboT[pos];
			if(x<32||x>224||y<32||y>144)
				continue;
			if(Screen->ComboS[pos]!=0000b)
				continue;
			if(ComboFI(pos, CF_NOENEMY))
				continue;
			if(ct==CT_NOENEMY||ct==CT_NOFLYZONE)
				continue;
			if(ct==CT_LADDERHOOKSHOT)
				continue;
			
			validPos[numValid] = pos;
			numValid++;
		}
		//Right
		for(i=2; i<16; i++){
			x = linkX+16*i;
			y = linkY;
			pos = ComboAt(x, y);
			ct = Screen->ComboT[pos];
			if(x<32||x>224||y<32||y>144)
				continue;
			if(Screen->ComboS[pos]!=0000b)
				continue;
			if(ComboFI(pos, CF_NOENEMY))
				continue;
			if(ct==CT_NOENEMY||ct==CT_NOFLYZONE)
				continue;
			if(ct==CT_LADDERHOOKSHOT)
				continue;
			
			validPos[numValid] = pos;
			numValid++;
		}
	
		//Default to the top left if there's no valid spots
		if(numValid==0)
			return 0;
		
		return validPos[Rand(numValid)];
	}
	void PW_AddRupeeLeech(int vars, int x, int y){
		int rupeeLeechX = vars[1];
		int rupeeLeechY = vars[2];
		int rupeeLeechAxisOff = vars[3];
		int rupeeLeechT = vars[4];
		
		for(int i=0; i<16; i++){
			if(rupeeLeechT[i]==0){
				rupeeLeechX[i] = Link->X;
				rupeeLeechY[i] = Link->Y;
				rupeeLeechAxisOff[i] = Rand(-100, 100)/100;
				rupeeLeechT[i] = 32;
				return;
			}
		}
	}
	void PW_UpdateRupeeLeech(int combo, int ghostx, int ghosty, int vars){
		if(Link->HP<=0)
			return;
			
		int rupeeLeechX = vars[1];
		int rupeeLeechY = vars[2];
		int rupeeLeechAxisOff = vars[3];
		int rupeeLeechT = vars[4];
		
		vars[0] = 0;
		for(int i=0; i<16; i++){
			if(rupeeLeechT[i]>0){
				vars[0]++;
				
				int xy[2];
				
				int dist = Distance(rupeeLeechX[i], rupeeLeechY[i], ghostx+8, ghosty+8);
				int ang = Angle(rupeeLeechX[i], rupeeLeechY[i], ghostx+8, ghosty+8);
				int x = rupeeLeechX[i]+VectorX(dist/2, ang)+VectorX(dist*0.6*rupeeLeechAxisOff[i], ang-90);
				int y = rupeeLeechY[i]+VectorY(dist/2, ang)+VectorY(dist*0.6*rupeeLeechAxisOff[i], ang-90);
				
				BezierQuadFrame(xy, 32-rupeeLeechT[i], 32, Link->X, Link->Y, x, y, ghostx, ghosty-14);
				
				Screen->FastCombo(4, xy[0], xy[1], combo+8, 8, 128);
				
				rupeeLeechT[i]--;
			}
		}
	}
	void PW_Waitframe(ffc this, npc ghost, int vars){
		int combo = ghost->Attributes[10];
		
		if(Link->HP>0){
			if(vars[5]>0){
				Screen->FastCombo(4, Ghost_X, Ghost_Y-14, combo+4+vars[5]-1, 11, 128);
			}
		}
		
		PW_UpdateRupeeLeech(combo, Ghost_X, Ghost_Y, vars);
		
		if(!Q7_Ghost_Waitframe(this, ghost, true, false)){
			int x = Ghost_X;
			int y = Ghost_Y;
			
			if(vars[5]>0){
				while(vars[0]){
					if(Link->HP>0){
						if(vars[5]>0){
							Screen->FastCombo(4, x, y-14, combo+4+vars[5]-1, 11, 128);
						}
					}
					PW_UpdateRupeeLeech(combo, x, y, vars);
					Waitframe();
				}
				while(vars[5]>0){
					for(int i=0; i<2; i++){
						if(Link->HP>0){
							if(vars[5]>0){
								Screen->FastCombo(4, x, y-14, combo+4+vars[5]-1, 11, 128);
							}
							Waitframe();
						}
					}
					vars[5]--;
				}
			}
			Quit();
		}
	}
}

//Draws an npc to a given layer
void Q7_DrawToLayer(npc n, int layer, int opacity, int sp){
	int octorock = sp[0];
	
	int flip = 0;
	if(n->Dir==DIR_LEFT)
		flip = 1;
	
	if(octorock[n->ID]){
		flip = 0;
		if(n->Dir==DIR_RIGHT)
			flip = 1;
		if(n->Dir==DIR_UP)
			flip = 2;
	}
	
	Screen->DrawTile(layer,n->X,n->Y,n->Tile,n->TileWidth,n->TileHeight,n->CSet,-1,-1,0,0,0,flip,true,opacity);
}

//Draws an lweapon to a given layer
void Q7_DrawToLayer(lweapon l, int layer, int opacity){
	if(l->Misc[LWM_MISCFLAGS]&LWMF_DRAWOVER)
		Screen->DrawTile(layer,l->X,l->Y,l->Tile,l->TileWidth,l->TileHeight,l->CSet,-1,-1,0,0,0,l->Flip,true,opacity);
	else if(l->Misc[LWM_ROTATION])
		Screen->DrawTile(layer,l->X+l->DrawXOffset,l->Y+l->DrawYOffset,l->Tile,l->TileWidth,l->TileHeight,l->CSet,-1,-1,l->X, l->Y,RadtoDeg(l->Angle),l->Flip,true,opacity);
	else
		Screen->DrawTile(layer,l->X+l->DrawXOffset,l->Y+l->DrawYOffset,l->Tile,l->TileWidth,l->TileHeight,l->CSet,-1,-1,0,0,0,l->Flip,true,opacity);
}

//Draws an eweapon to a given layer
void Q7_DrawToLayer(eweapon e, int layer, int opacity){
	Screen->DrawTile(layer,e->X,e->Y,e->Tile,e->TileWidth,e->TileHeight,e->CSet,-1,-1,0,0,0,e->Flip,true,opacity);
}

//Draws an item to a given layer
void Q7_DrawToLayer(item i, int layer, int opacity){
	Screen->DrawTile(layer,i->X,i->Y,i->Tile,i->TileWidth,i->TileHeight,i->CSet,-1,-1,0,0,0,0,true,opacity);
}

ffc script OverheadFix{
	void run(){
		int eOctorok[512];
		eOctorok[NPC_OCTOROCK1F] = 1;
		eOctorok[NPC_OCTOROCK1S] = 1;
		eOctorok[NPC_OCTOROCK2F] = 1;
		eOctorok[NPC_OCTOROCK2S] = 1;
		int sp[] = {eOctorok};
		
		int i;
		while(true){
			if(G[G_ANIM]%2==0){
				if(GetLayerComboF(1, ComboAt(Link->X+8, Link->Y+8))==98){
					Screen->DrawTile(6, Link->X+Link->DrawXOffset, Link->Y+Link->DrawYOffset, Link->Tile, 1, 1, 6, -1, -1, 0, 0, 0, Link->Flip, true, 64);
				}
				for(i=Screen->NumNPCs(); i>0; i--){
					npc n = Screen->LoadNPC(i);
					if(GetLayerComboF(1, ComboAt(CenterX(n), CenterY(n)))==98&&n->HP>0&&n->HitXOffset<1000){
						Q7_DrawToLayer(n, 6, 64, sp);
					}
				}
				for(i=Screen->NumEWeapons(); i>0; i--){
					eweapon e = Screen->LoadEWeapon(i);
					if(GetLayerComboF(1, ComboAt(CenterX(e), CenterY(e)))==98){
						Q7_DrawToLayer(e, 6, 64);
					}
				}
				for(i=Screen->NumLWeapons(); i>0; i--){
					lweapon l = Screen->LoadLWeapon(i);
					if(GetLayerComboF(1, ComboAt(CenterX(l), CenterY(l)))==98){
						Q7_DrawToLayer(l, 6, 64);
					}
				}
			}
			Waitframe();
		}
	}
}

int FlashCSet(int timer){
	return 9-(timer>>1);
}

bool Ghost_CanMoveXL(int x, int y, int dir, int step, int w, int h){
	int xi; int yi;
	int x2; int y2;
	if(dir==DIR_UP){
		for(xi=x; xi<=x+w-1; xi=Min(xi+8, x+w-1)){
			x2 = xi;
			y2 = y-step;
			if(!Ghost_CanMovePixel(x2, y2))
				return false;
			if(xi==x+w-1)
				break;
		}
	}
	else if(dir==DIR_DOWN){
		for(xi=x; xi<=x+w-1; xi=Min(xi+8, x+w-1)){
			x2 = xi;
			y2 = y+h-1+step;
			if(!Ghost_CanMovePixel(x2, y2))
				return false;
			if(xi==x+w-1)
				break;
		}
	}
	else if(dir==DIR_LEFT){
		for(yi=y; yi<=y+h-1; yi=Min(yi+8, y+h-1)){
			x2 = x-step;
			y2 = yi;
			if(!Ghost_CanMovePixel(x2, y2))
				return false;
			if(yi==y+h-1)
				break;
		}
	}
	else if(dir==DIR_RIGHT){
		for(yi=y; yi<=y+h-1; yi=Min(yi+8, y+h-1)){
			x2 = x+w-1+step;
			y2 = yi;
			if(!Ghost_CanMovePixel(x2, y2))
				return false;
			if(yi==y+h-1)
				break;
		}
	}
	
	return true;
}

void Ghost_MoveXYArray(int arrayX, int arrayY, npc n, int i, float xStep, float yStep)
{
    // If this is sideview, most enemies can't move upward
    if(yStep<0 && IsSideview() && !Ghost_FlagIsSet(GHF_NO_FALL))
        yStep=0;

    // If moving more than 8 pixels along either axis, go 8 at a time
    while(Abs(xStep)>8 || Abs(yStep)>8)
    {
        if(Abs(xStep)>=Abs(yStep))
        {
            if(xStep>0)
            {
                Ghost_MoveXYArray(arrayX, arrayY, n, i, 8, 0);
                xStep-=8;
            }
            else
            {
                Ghost_MoveXYArray(arrayX, arrayY, n, i, -8, 0);
                xStep+=8;
            }
        }
        else // yStep>=xStep
        {
            if(yStep>0)
            {
                Ghost_MoveXYArray(arrayX, arrayY, n, i, 0, 8);
                yStep-=8;
            }
            else
            {
                Ghost_MoveXYArray(arrayX, arrayY, n, i, 0, -8);
                yStep+=8;
            }
        }
    }
    
    int edge; // Position of leading edge
    int edgeDiff; // Difference between Ghost_X/Ghost_Y and edge
    int startHT; // The half-tile position where the edge starts
    int endHT; // And where it ends up
    
    if(xStep<0) // Left
    {
        edgeDiff=n->HitXOffset;
        edge=arrayX[i]+edgeDiff;
        
        startHT=Floor(edge/8);
        endHT=Floor((edge+xStep)/8);
        
        // If the edge ends up on the same half-tile line it's already on,
        // there's no need to check walkability
        if(startHT==endHT)
            edge+=xStep;
        else if(Ghost_CanMoveXL(n->X+n->HitXOffset, n->Y+n->HitYOffset, DIR_LEFT, -xStep, n->HitWidth, n->HitHeight))
            edge+=xStep;
        else // Can't move all the way; snap to the grid
            edge=(edge>>3)<<3;
        
        arrayX[i]=edge-edgeDiff;
    }
    else if(xStep>0) // Right
    {
        edgeDiff=n->HitXOffset+n->HitWidth-1; //16*Ghost_TileWidth-(__Ghost_XOffsets&0xFF)-1;
        edge=arrayX[i]+edgeDiff;
        
        startHT=Floor(edge/8);
        endHT=Floor((edge+xStep)/8);
        
        if(startHT==endHT)
            edge+=xStep;
        else if(Ghost_CanMoveXL(n->X+n->HitXOffset, n->Y+n->HitYOffset, DIR_RIGHT, xStep, n->HitWidth, n->HitHeight))
            edge+=xStep;
        else
            edge=(((edge+7)>>3)<<3)-1;
        
        arrayX[i]=edge-edgeDiff;
    }
    
    if(yStep<0) // Up
    {
        edgeDiff=n->HitYOffset;
        edge=arrayY[i]+edgeDiff;
        
        startHT=Floor(edge/8);
        endHT=Floor((edge+yStep)/8);
        
        // If the edge ends up on the same half-tile line it's already on,
        // there's no need to check walkability
        if(startHT==endHT)
            edge+=yStep;
        else if(Ghost_CanMoveXL(n->X+n->HitXOffset, n->Y+n->HitYOffset, DIR_UP, -yStep, n->HitWidth, n->HitHeight))
            edge+=yStep;
        else // Can't move all the way; snap to the grid
            edge=(edge>>3)<<3;
        
        arrayY[i]=edge-edgeDiff;
    }
    else if(yStep>0) // Down
    {
        edgeDiff=n->HitYOffset+n->HitHeight-1;//16*Ghost_TileHeight-(__Ghost_YOffsets&0xFF)-1;
        edge=arrayY[i]+edgeDiff;
        
        startHT=Floor(edge/8);
        endHT=Floor((edge+yStep)/8);
        
        if(startHT==endHT)
            edge+=yStep;
        else if(Ghost_CanMoveXL(n->X+n->HitXOffset, n->Y+n->HitYOffset, DIR_DOWN, yStep, n->HitWidth, n->HitHeight))
            edge+=yStep;
        else
            edge=(((edge+7)>>3)<<3)-1;
        
        arrayY[i]=edge-edgeDiff;
    }
}


const int NPC_ENEMYFIRE2 = 279;

const int SPR_THEDUKE_HATCH = 100;

const int SFX_THEDUKE_HATCH = 21;
const int SFX_THEDUKE_COUGH = 70;
const int SFX_THEDUKE_DASH = 59;

const int DUKELING_HP = 20;
const int DUKELING_DAMAGE = 6;

const int DUKEFLY_HP = 1;
const int DUKEFLY_DAMAGE = 6;

ffc script TheDuke{
	void run(int enemyid){
		int i; int j; int k; int m;
		int x; int y;
		int x2; int y2;
		int angle; int step;
		
		npc ghost = Ghost_InitAutoGhost(this, enemyid);
		NJFMode_IncreaseBossHP(ghost);
		this->Flags[FFCF_ETHEREAL] = true;
		
		Ghost_Transform(this, ghost, -1, -1, 2, 2);
		Ghost_SetHitOffsets(ghost, 4, 4, 4, 4);
		
		Ghost_SetFlag(GHF_IGNORE_PITS);
		Ghost_SetFlag(GHF_IGNORE_SOLIDITY);
		
		npc flies[64];
		
		int flyX[64];
		int flyY[64];
		int flyST[64];
		int flyFlash[64];
		int flyHP[64];
		int flyVx[64];
		int flyVy[64];
		int flyTx[64];
		int flyTy[64];
		int flyStep[64];
		int flyMovement[64];
		int flyMaxHP[64];
		int flyAx[64];
		int flyAy[64];
		int flyReaim[64];
		
		int fly[] = {flyX, flyY, flyST, flyFlash, flyHP, flyVx, flyVy, flyTx, flyTy, flyStep, flyMovement, flyMaxHP, flyAx, flyAy, flyReaim};
		
		int defenses[18];
		Ghost_StoreDefenses(ghost, defenses);
		Ghost_SetAllDefenses(ghost, NPCDT_BLOCK);
		int vars[16] = {ghost->HP, fly, defenses, 8, 0, Ghost_HP, 0};
		//vars[3] - Num Core Flies
		//vars[4] - Num Total Flies
		//vars[5] - Max HP
		//vars[6] - Sprite Change
		
		int flyRing[8];
		
		Ghost_X = 112;
		Ghost_Y = 72;
		
		int attackCooldown = 120;
		int eyesRotate = Rand(360);
		int walkCounter = 0;
		
		for(i=0; i<8; i++){
			x = Ghost_X+8+VectorX(32, 45*i+eyesRotate);
			y = Ghost_Y+8+VectorY(32, 45*i+eyesRotate);
			flyRing[i] = TD_AddFly(flies, vars, x, y, 1, DUKELING_DAMAGE, DUKELING_HP);
		}
		
		int diffMod[16];
		diffMod[0] = LazyDiffMod(24, 32, 32);
		
		ghost->DrawYOffset = -1000;
		while(vars[3]>0){
			eyesRotate += 4;
			eyesRotate %= 360;
			for(j=0; j<8; j++){
				x = Ghost_X+8+VectorX(diffMod[0], 45*j+eyesRotate);
				y = Ghost_Y+8+VectorY(diffMod[0], 45*j+eyesRotate);
				flyTx[flyRing[j]] = x;
				flyTy[flyRing[j]] = y;
				flyMovement[flyRing[j]] = 0;
				flyStep[flyRing[j]] = 3;
			}
			
			if(attackCooldown>0)
				attackCooldown--;
			else if(Rand(24)==0){
				int attack = Choose(0, 0, 1);
				if(!IsHardMode())
					attack = 0;
				
				if(attack==0){
					x2 = Ghost_X;
					y2 = Ghost_Y;
					angle = Angle(Ghost_X+8, Ghost_Y+8, Link->X, Link->Y);
					Game->PlaySound(SFX_THEDUKE_DASH);
					for(i=0; i<16; i++){
						Ghost_MoveAtAngle(angle+180, 1, 0);
						
						eyesRotate += 4;
						eyesRotate %= 360;
						for(j=0; j<8; j++){
							x = Ghost_X+8+VectorX(diffMod[0], 45*j+eyesRotate);
							y = Ghost_Y+8+VectorY(diffMod[0], 45*j+eyesRotate);
							flyTx[flyRing[j]] = x;
							flyTy[flyRing[j]] = y;
							flyMovement[flyRing[j]] = 0;
							flyStep[flyRing[j]] = 3;
						}
						
						TD_Waitframe(this, ghost, flies, vars);
					}
					diffMod[1] = LazyDiffMod(0.85, 0.9, 1);
					for(i=0; i<32*diffMod[1] ; i++){
						Ghost_MoveAtAngle(angle, 2, 0);
						
						eyesRotate += 2;
						eyesRotate %= 360;
						for(j=0; j<8; j++){
							x = Ghost_X+8+VectorX(diffMod[0], 45*j+eyesRotate);
							y = Ghost_Y+8+VectorY(diffMod[0], 45*j+eyesRotate);
							flyTx[flyRing[j]] = x;
							flyTy[flyRing[j]] = y;
							flyMovement[flyRing[j]] = 0;
							flyStep[flyRing[j]] = 2;
						}
						
						TD_Waitframe(this, ghost, flies, vars);
					}
					for(i=0; i<24*diffMod[1] ; i++){
						Ghost_MoveTowardLink(0.5, 0);
						
						eyesRotate += 2;
						eyesRotate %= 360;
						for(j=0; j<8; j++){
							x = Ghost_X+8+VectorX(diffMod[0], 45*j+eyesRotate);
							y = Ghost_Y+8+VectorY(diffMod[0], 45*j+eyesRotate);
							flyTx[flyRing[j]] = x;
							flyTy[flyRing[j]] = y;
							flyMovement[flyRing[j]] = 0;
							flyStep[flyRing[j]] = 2;
						}
						
						TD_Waitframe(this, ghost, flies, vars);
					}
					while(Distance(Ghost_X, Ghost_Y, x2, y2)>4){
						Ghost_MoveAtAngle(Angle(Ghost_X, Ghost_Y, x2, y2), 4, 0);
						
						eyesRotate += 4;
						eyesRotate %= 360;
						for(j=0; j<8; j++){
							x = Ghost_X+8+VectorX(diffMod[0], 45*j+eyesRotate);
							y = Ghost_Y+8+VectorY(diffMod[0], 45*j+eyesRotate);
							flyTx[flyRing[j]] = x;
							flyTy[flyRing[j]] = y;
							flyMovement[flyRing[j]] = 0;
							flyStep[flyRing[j]] = 3;
						}
						
						TD_Waitframe(this, ghost, flies, vars);
					}
					Ghost_X = x2;
					Ghost_Y = y2;
				}
				else if(attack==1){
					for(i=32; i>=0; i--){
						eyesRotate += 2;
						eyesRotate %= 360;
						for(j=0; j<8; j++){
							x = Ghost_X+8+VectorX(diffMod[0]*(i/32), 45*j+eyesRotate);
							y = Ghost_Y+8+VectorY(diffMod[0]*(i/32), 45*j+eyesRotate);
							flyTx[flyRing[j]] = x;
							flyTy[flyRing[j]] = y;
							flyMovement[flyRing[j]] = 0;
							flyStep[flyRing[j]] = 3;
						}
						
						TD_Waitframe(this, ghost, flies, vars);
					}
					eyesRotate = Rand(360);
					for(i=0; i<240; i+=0.5){
						if(i>20)
							i += 0.25;
						if(i>80)
							i += 0.5;
						eyesRotate += LazyDiffMod(4, 4, 6);
						eyesRotate %= 360;
						m = 25;
						if(i>180){
							m = 25+20*((i-180)/60);
						}
						for(j=0; j<8; j++){
							k = 128*Max(Sin(Max(-24+i+24*(j/8), 0)), 0);
							if(i>90)
								k = Max(diffMod[0], k);
							x = Ghost_X+8+VectorX(k, m*j+eyesRotate);
							y = Ghost_Y+8+VectorY(k, m*j+eyesRotate);
							flyTx[flyRing[j]] = x;
							flyTy[flyRing[j]] = y;
							flyMovement[flyRing[j]] = 0;
							flyStep[flyRing[j]] = 24;
						}
						
						ghost->Step = (8-vars[3])*11;
						if(ghost->Step>0)
							walkCounter = Ghost_ConstantWalk8(walkCounter, ghost->Step, ghost->Rate, ghost->Homing, ghost->Hunger);
			
						
						TD_Waitframe(this, ghost, flies, vars);
					}
				}
				attackCooldown = LazyDiffMod(140, 120, 90); //120;
				walkCounter = -1;
			}
			
			ghost->Step = Max(4-vars[3], 0)*11;
			if(ghost->Step>0)
				walkCounter = Ghost_ConstantWalk8(walkCounter, ghost->Step, ghost->Rate, ghost->Homing, ghost->Hunger);
			
			TD_Waitframe(this, ghost, flies, vars);
		}
		Ghost_SetDefenses(ghost, defenses);
		while(true){
			if(attackCooldown>0)
				attackCooldown--;
			else if(Rand(48)==0){
				int attack = Rand(2);
				if(attack==0){
					k = Angle(Link->X, Link->Y, Ghost_X+8, Ghost_Y+8);
					for(i=0; i<12; i++){
						Ghost_MoveAtAngle(k, 0.5, 0);
						TD_Waitframe(this, ghost, flies, vars);
					}
					for(i=0; i<4; i++){
						Ghost_MoveAtAngle(k+180, 4, 0);
						TD_Waitframe(this, ghost, flies, vars);
					}
					Game->PlaySound(SFX_THEDUKE_COUGH);
					for(i=0; i<4; i++){
						if(IsVeryHardMode()&&i==0){
							k = TD_AddFly(flies, vars, Ghost_X+8+Rand(-4, 4), Ghost_Y+8+Rand(-4, 4), 1, DUKELING_DAMAGE, DUKELING_HP);
						}
						else{
							k = TD_AddFly(flies, vars, Ghost_X+8+Rand(-4, 4), Ghost_Y+8+Rand(-4, 4), 3, DUKEFLY_DAMAGE, DUKEFLY_HP);
						}
						flyMovement[k] = 1;
						if(Rand(3)==0)
							flyMovement[k] = 2;
						flyAx[k] = Rand(1, 3)*0.01;
						flyAy[k] = Rand(1, 3)*0.01;
						flyTx[k] = Link->X;
						flyTy[k] = Link->Y;
						diffMod[1] = LazyDiffMod(20, 30, 40);
						m = Angle(Ghost_X+8, Ghost_Y+8, Link->X, Link->Y)+Rand(-diffMod[1], diffMod[1]);
						j = Rand(12, 24)*0.1;
						flyVx[k] = VectorX(j, m);
						flyVy[k] = VectorY(j, m);
						flyReaim[k] = Rand(60, 90);
					}
				}
				
				attackCooldown = LazyDiffMod(220, 180, 220); ///180;
			}
			
			ghost->Step = 88;
			walkCounter = Ghost_ConstantWalk8(walkCounter, ghost->Step, ghost->Rate, ghost->Homing, ghost->Hunger);
			
			TD_Waitframe(this, ghost, flies, vars);
		}
	}
	int TD_AddFly(npc flies, int vars, int x, int y, int st, int damage, int hp){
		
		x = Clamp(x, 32, 208);
		y = Clamp(y, 32, 128);
		int fly = vars[1];
		
		int defenses = vars[2];
		
		int flyX = fly[0];
		int flyY = fly[1];
		int flyST = fly[2];
		int flyFlash = fly[3];
		int flyHP = fly[4];
		int flyVx= fly[5];
		int flyVy= fly[6];
		int flyTx= fly[7];
		int flyTy= fly[8];
		int flyStep= fly[9];
		int flyMovement= fly[10];
		int flyMaxHP= fly[11];
		int flyAx = fly[12];
		int flyAy = fly[13];
		int flyReaim = fly[14];
		
		for(int i=0; i<64; i++){
			if(flyST[i]==0){
		
				flies[i] = CreateNPCAt(NPC_ENEMYFIRE2, x, y);
				flies[i]->DrawYOffset = -1000;
				flies[i]->HP = hp;
				flies[i]->Damage = damage;
				Ghost_SetDefenses(flies[i], defenses);
				if(!IsHardMode()){
					flies[i]->Defense[NPCD_FIRE] = NPCDT_QUARTERDAMAGE;
					flies[i]->Defense[NPCD_REFMAGIC] = NPCDT_QUARTERDAMAGE;
					flies[i]->Defense[NPCD_MAGIC] = NPCDT_QUARTERDAMAGE;
				}
				if(st==3){
					flies[i]->HitXOffset = 4;
					flies[i]->HitYOffset = 4;
					flies[i]->HitWidth = 8;
					flies[i]->HitHeight = 8;
					flies[i]->Defense[NPCD_FIRE] = NPCDT_NONE;
					flies[i]->Defense[NPCD_REFMAGIC] = NPCDT_NONE;
					flies[i]->Defense[NPCD_MAGIC] = NPCDT_NONE;
				}
				
				flyX[i] = x;
				flyY[i] = y;
				flyST[i] = st;
				flyFlash[i] = 0;
				flyHP[i] = flies[i]->HP;
				flyMaxHP[i] = flies[i]->HP;
				
				return i;
			}
		}
	}
	void TD_UpdateFlies(npc ghost, npc flies, int vars, int combo){
		int i; int j; int k; int m;
		int x; int y;
		
		int maxV;
		
		//vars[3] - Num Core Flies
		//vars[4] - Num Total Flies
		//vars[5] - Max HP
		//vars[6] - Sprite Change
		
		int fly = vars[1];
		
		int flyX = fly[0];
		int flyY = fly[1];
		int flyST = fly[2];
		int flyFlash = fly[3];
		int flyHP = fly[4];
		int flyVx= fly[5];
		int flyVy= fly[6];
		int flyTx= fly[7];
		int flyTy= fly[8];
		int flyStep= fly[9];
		int flyMovement= fly[10];
		int flyMaxHP= fly[11];
		int flyAx = fly[12];
		int flyAy = fly[13];
		int flyReaim = fly[14];
		
		vars[3] = 0;
		vars[4] = 0;
		
		for(i=0; i<64; i++){
			if(flyST[i]>0){
				if(flies[i]->isValid()){
					DamageNumbers_CalculateDamage(flies[i], false);
					vars[4]++;
					if(flyMovement[i]==0){
						if(!ghost->isValid()){
							flies[i]->HP = 0;
							flies[i]->Misc[NPCM_LASTHP] = 0;
						}
						if(Distance(flyX[i], flyY[i], flyTx[i], flyTy[i])>flyStep[i]){
							j = Angle(flyX[i], flyY[i], flyTx[i], flyTy[i]);
							flyX[i] += VectorX(flyStep[i], j);
							flyY[i] += VectorY(flyStep[i], j);
						}
						else{
							flyX[i] = flyTx[i];
							flyY[i] = flyTy[i];
						}
					}
					else if(flyMovement[i]==1){
						maxV = Max(1.2, (Abs(flyVx[i])+Abs(flyVy[i]))*0.5);
						flyVx[i] = Clamp(flyVx[i]+Sign(flyTx[i]-flyX[i])*flyAx[i], -maxV, maxV);
						flyVy[i] = Clamp(flyVy[i]+Sign(flyTy[i]-flyY[i])*flyAy[i], -maxV, maxV);
						if((flyVx[i]<0&&!Ghost_CanMoveXL(flies[i]->X+flies[i]->HitXOffset, flies[i]->Y+flies[i]->HitYOffset, DIR_LEFT, 1, flies[i]->HitWidth, flies[i]->HitHeight)) || 
						(flyVx[i]>0&&!Ghost_CanMoveXL(flies[i]->X+flies[i]->HitXOffset, flies[i]->Y+flies[i]->HitYOffset, DIR_RIGHT, 1, flies[i]->HitWidth, flies[i]->HitHeight))){
							flyVx[i] = 0;
						}
						if((flyVy[i]<0&&!Ghost_CanMoveXL(flies[i]->X+flies[i]->HitXOffset, flies[i]->Y+flies[i]->HitYOffset, DIR_UP, 1, flies[i]->HitWidth, flies[i]->HitHeight)) || 
						(flyVy[i]>0&&!Ghost_CanMoveXL(flies[i]->X+flies[i]->HitXOffset, flies[i]->Y+flies[i]->HitYOffset, DIR_DOWN, 1, flies[i]->HitWidth, flies[i]->HitHeight))){
							flyVy[i] = 0;
						}
						
						if(flyReaim[i]>0)
							flyReaim[i]--;
						else{
							flyTx[i] = Rand(32, 208);
							flyTy[i] = Rand(32, 128);
							flyReaim[k] = Rand(60, 90);
						}
						
						Ghost_MoveXYArray(flyX, flyY, flies[i], i, flyVx[i], flyVy[i]);
					}
					else if(flyMovement[i]==2){
						flyVx[i] = Clamp(flyVx[i]+Sign(flyTx[i]-flyX[i])*flyAx[i], -1.2, 1.2);
						flyVy[i] = Clamp(flyVy[i]+Sign(flyTy[i]-flyY[i])*flyAy[i], -1.2, 1.2);
						if((flyVx[i]<0&&!Ghost_CanMoveXL(flies[i]->X+flies[i]->HitXOffset, flies[i]->Y+flies[i]->HitYOffset, DIR_LEFT, 1, flies[i]->HitWidth, flies[i]->HitHeight)) || 
						(flyVx[i]>0&&!Ghost_CanMoveXL(flies[i]->X+flies[i]->HitXOffset, flies[i]->Y+flies[i]->HitYOffset, DIR_RIGHT, 1, flies[i]->HitWidth, flies[i]->HitHeight))){
							flyVx[i] = 0;
						}
						if((flyVy[i]<0&&!Ghost_CanMoveXL(flies[i]->X+flies[i]->HitXOffset, flies[i]->Y+flies[i]->HitYOffset, DIR_UP, 1, flies[i]->HitWidth, flies[i]->HitHeight)) || 
						(flyVy[i]>0&&!Ghost_CanMoveXL(flies[i]->X+flies[i]->HitXOffset, flies[i]->Y+flies[i]->HitYOffset, DIR_DOWN, 1, flies[i]->HitWidth, flies[i]->HitHeight))){
							flyVy[i] = 0;
						}
						flyTx[i] = Link->X;
						flyTy[i] = Link->Y;
						
						Ghost_MoveXYArray(flyX, flyY, flies[i], i, flyVx[i], flyVy[i]);
					}
					
					flies[i]->X = Clamp(flyX[i], -32, 256+16);
					flies[i]->Y = Clamp(flyY[i], -32, 176+16);
					if(flies[i]->HP<flyHP[i]){
						if(flies[i]->HP<=0)
							flies[i]->DrawYOffset = -2;
						
						if(flyST[i]==1&&flies[i]->HP<flyMaxHP[i]*0.5){
							flyST[i] = 2;
							Game->PlaySound(SFX_THEDUKE_HATCH);
							for(j=0; j<LazyDiffMod(1, 2, 3); j++){
								x = flyX[i]+Rand(-4, 4);
								y = flyY[i]+Rand(-4, 4);
								SpriteAnimRand(x, y, SPR_THEDUKE_HATCH, 1, 1, -4, 1);
							
								k = TD_AddFly(flies, vars, x, y, 3, DUKEFLY_DAMAGE, DUKEFLY_HP);
								flyMovement[k] = 1;
								if(Rand(3)==0)
									flyMovement[k] = 2;
								flyAx[k] = Rand(1, 3)*0.01;
								flyAy[k] = Rand(1, 3)*0.01;
								flyTx[k] = flyX[k];
								flyTy[k] = flyY[k];
								m = Angle(Link->X, Link->Y, flyX[i], flyY[i])+Rand(-45, 45);
								flyVx[k] = VectorX(1.2, m);
								flyVy[k] = VectorY(1.2, m);
								flyReaim[k] = Rand(60, 90);
							}
						}
						else if(flyST[i]==2&&flies[i]->HP<=0&&flyMaxHP[i]>0){
							flyMaxHP[i] = 0;
							if(IsHardMode()){
								Game->PlaySound(SFX_THEDUKE_HATCH);
								for(j=0; j<LazyDiffMod(1, 1, 2); j++){
									x = flyX[i]+Rand(-4, 4);
									y = flyY[i]+Rand(-4, 4);
									SpriteAnimRand(x, y, SPR_THEDUKE_HATCH, 1, 1, -4, 1);
								
									k = TD_AddFly(flies, vars, x, y, 3, DUKEFLY_DAMAGE, DUKEFLY_HP);
									flyMovement[k] = 1;
									if(Rand(3)==0)
										flyMovement[k] = 2;
									flyAx[k] = Rand(1, 3)*0.01;
									flyAy[k] = Rand(1, 3)*0.01;
									flyTx[k] = flyX[k];
									flyTy[k] = flyY[k];
									m = Angle(Link->X, Link->Y, flyX[i], flyY[i])+Rand(-45, 45);
									flyVx[k] = VectorX(1.2, m);
									flyVy[k] = VectorY(1.2, m);
									flyReaim[k] = Rand(60, 90);
								}
							}
						}
						flyFlash[i] = 32;
					}
					flyHP[i] = flies[i]->HP;
					
					int cs = Ghost_CSet;
					if(flyFlash[i]>0){
						flyFlash[i]--;
						cs = FlashCSet(flyFlash[i]);
					}
					
					if(flies[i]->HP>0){
						if(flyST[i]==1){
							vars[3]++;
							Screen->DrawCombo(2, flyX[i]-8, flyY[i], combo+3, 2, 1, cs, -1, -1, 0, 0, 0, 0, 0, true, 128);
						}
						else if(flyST[i]==2){
							vars[3]++;
							Screen->DrawCombo(2, flyX[i]-8, flyY[i], combo+4, 2, 1, cs, -1, -1, 0, 0, 0, 0, 0, true, 128);
						}
						else if(flyST[i]==3){
							Screen->FastCombo(2, flyX[i], flyY[i], combo+5, cs, 128);
						}
					}
				}
				else{
					if(flyST[i]==3)
						flyST[i] = 0;
				}
			}
		}
	}
	void TD_Draw(ffc this, npc ghost, npc flies, int vars){
		int i; int j; int k;
		
		//vars[3] - Num Core Flies
		//vars[4] - Num Total Flies
		//vars[5] - Max HP
		//vars[6] - Sprite Change
		
		int combo = ghost->Attributes[10];
		
		if(Link->HP>0){
			Screen->DrawCombo(2, Ghost_X-10, Ghost_Y+1, combo+2, 1, 2, this->CSet, -1, -1, 0, 0, 0, 0, 0, true, 128);
			Screen->DrawCombo(2, Ghost_X+16+10, Ghost_Y+1, combo+2, 1, 2, this->CSet, -1, -1, 0, 0, 0, 0, 1, true, 128);
			if(vars[6]==0)
				Screen->DrawCombo(2, Ghost_X, Ghost_Y, combo, 2, 2, this->CSet, -1, -1, 0, 0, 0, 0, 0, true, 128);
			else
				Screen->DrawCombo(2, Ghost_X, Ghost_Y, combo+1, 2, 2, this->CSet, -1, -1, 0, 0, 0, 0, 0, true, 128);
		
			TD_UpdateFlies(ghost, flies, vars, combo);
		}
	}
	void TD_Waitframe(ffc this, npc ghost, npc flies, int vars){
		int i; int j; int k; int m;
		
		//vars[3] - Num Core Flies
		//vars[4] - Num Total Flies
		//vars[5] - Max HP
		//vars[6] - Sprite Change
		
		int combo = ghost->Attributes[10];
		
		int fly = vars[1];
		
		int flyX = fly[0];
		int flyY = fly[1];
		int flyST = fly[2];
		int flyFlash = fly[3];
		int flyHP = fly[4];
		int flyVx= fly[5];
		int flyVy= fly[6];
		int flyTx= fly[7];
		int flyTy= fly[8];
		int flyStep= fly[9];
		int flyMovement= fly[10];
		int flyMaxHP= fly[11];
		int flyAx = fly[12];
		int flyAy = fly[13];
		int flyReaim = fly[14];
		
		if(Ghost_HP<vars[5]*0.5){
			int pos[8] = {0,0, 16,0, 16,12, 0,12};
			for(i=0; i<4; i++){
				Game->PlaySound(SFX_THEDUKE_HATCH);
				
				pos[i*2] += Ghost_X+Rand(-4, 4);
				pos[i*2+1] += Ghost_Y+Rand(-4, 4);
				
				for(j=0; j<3; j++){
					SpriteAnimRand(pos[i*2]+Rand(-4, 4), pos[i*2+1]+Rand(-4, 4), SPR_THEDUKE_HATCH, 1, 1, -4, 1);
				}
				
				k = TD_AddFly(flies, vars, pos[i*2], pos[i*2+1], 1, DUKELING_DAMAGE, DUKELING_HP);
				flyMovement[k] = 1;
				
				flyAx[k] = Rand(3, 5)*0.01;
				flyAy[k] = Rand(3, 5)*0.01;
				flyTx[k] = flyX[k]+VectorX(64, -135+45*i);
				flyTy[k] = flyY[k]+VectorY(64, -135+45*i);
				m = -135+45*i;
				flyVx[k] = VectorX(1.2, m);
				flyVy[k] = VectorY(1.2, m);
				flyReaim[k] = Rand(60, 90);
			}
			vars[5] = 0;
			vars[6] = 1;
		}
		
		lweapon whistle = LoadLWeaponOf(LW_WHISTLE);
		if(whistle->isValid()){
			this->Data = GH_INVISIBLE_COMBO;
			for(i=0; i<64; i++){
				if(flies[i]->isValid()){
					flies[i]->HP = -1000;
					flyHP[i] = -1000;
					flyMaxHP[i] = -1000;
				}
			}
			ghost->CollDetection = false;
			for(i=0; i<40; i++){
				TD_Draw(this, ghost, flies, vars);
				Q7_Ghost_Waitframe(this, ghost, true, true);
			}
			vars[6] = 1;
			for(i=0; i<60; i++){
				if(i%2==0){
					Game->PlaySound(SFX_THEDUKE_HATCH);
					SpriteAnimRand(Ghost_X+Rand(-8, 24), Ghost_Y+Rand(-8, 24), SPR_THEDUKE_HATCH, 1, 1, -4, 1);
				}
				TD_Draw(this, ghost, flies, vars);
				Q7_Ghost_Waitframe(this, ghost, true, true);
			}
			for(i=0; i<40; i++){
				TD_Draw(this, ghost, flies, vars);
				Q7_Ghost_Waitframe(this, ghost, true, true);
			}
			for(i=0; i<16; i++){
				SpriteAnimRand(Ghost_X+Rand(-8, 24), Ghost_Y+Rand(-8, 24), SPR_THEDUKE_HATCH, 1, 1, -4, 1);
			}
			Game->PlaySound(SFX_THEDUKE_HATCH);
			for(i=0; i<16; i++){
				TD_Draw(this, ghost, flies, vars);
				Q7_Ghost_Waitframe(this, ghost, true, true);
			}
			for(i=0; i<200; i++){
				npc n = CreateNPCAt(NPC_PEAHAT, Ghost_X+8+Rand(-12, 12), Ghost_Y+8+Rand(-12, 12));
				n->Step += Rand(200);
				n->CSet = Choose(1, 5, 7, 8, 10, 11);
				n->Dir = Rand(8);
			}
			ghost->Y = -48;
			ghost->DrawYOffset = -1000;
			this->Data = GH_INVISIBLE_COMBO;
			Ghost_Data = GH_INVISIBLE_COMBO;
			ghost->Tile = GH_BLANK_TILE;
			ghost->OriginalTile = GH_BLANK_TILE;
			while(true){
				if(NumNPCsOf(NPC_PEAHAT)==0){
					break;
				}
				Waitframe();
			}
			ghost->HP = 0;
			ghost->Misc[NPCM_LASTHP] = 0;
			this->Data = 0;
			
			Quit();
		}
		
		TD_Draw(this, ghost, flies, vars);
		if(!Q7_Ghost_Waitframe(this, ghost, true, false)){
			ghost->DrawYOffset = -2;
			this->Data = GH_INVISIBLE_COMBO;
			while(vars[4]>0){
				TD_UpdateFlies(ghost, flies, vars, combo);
				Waitframe();
			}
			Quit();
		}
	}
}

const int STR_NIGHTMARE = 77;
const int STR_NIGHTMARE_END = 81;
const int STR_NIGHTMARE_CHEAT = 82;

const int SFX_THEMARIO = 71;

const int NPC_NIGHTMARE_SLIME = 289;
const int NPC_NIGHTMARE_AQUAMENTUS_LEFT = 281;
const int NPC_NIGHTMARE_AQUAMENTUS_RIGHT = 282;
const int NPC_NIGHTMARE_DODONGO = 283;
const int NPC_NIGHTMARE_MANHANDLA = 284;
const int NPC_NIGHTMARE_GLEEOK = 285;
const int NPC_NIGHTMARE_DIGDOGGER = 286;
const int NPC_NIGHTMARE_DIGDOGGER_KID = 287;
const int NPC_NIGHTMARE_GOHMA = 288;

const int NPC_NIGHTMARE_FROG = 291;
const int NPC_NIGHTMARE_BOY = 292;
const int NPC_NIGHTMARE_CLOWN = 293;

const int NPC_NIGHTMARE_SFX = 294;

ffc script TheNightmare{
	void run(int enemyid){
		int i; int j; int k; int m;
		int x; int y;
		
		npc ghost = Ghost_InitAutoGhost(this, enemyid);
		this->Flags[FFCF_ETHEREAL] = true;
		
		Ghost_Transform(this, ghost, -1, -1, 2, 2);
		Ghost_SetHitOffsets(ghost, 8, 4, 6, 6);
		int defenses[18];
		Ghost_StoreDefenses(ghost, defenses);
		Ghost_SetAllDefenses(ghost, NPCDT_BLOCK);
		
		Ghost_X = 112;
		Ghost_Y = 32;
		ghost->CollDetection = false;
		ghost->DrawYOffset = -1000;
		
		Q7_Ghost_Waitframe(this, ghost);
		
		if(Screen->D[1]==0){
			Game->PlayMIDI(0);
			Screen->Message(STR_NIGHTMARE);
			WaitNoAction();
			Screen->D[1] = 1;
		}
		int bossMusic[] = "Nightmare.nsf";
		Game->PlayEnhancedMusic(bossMusic, 0);
		
		npc forms[16];
		int xy[16];
		int xyDat[16];
		N_SetTeleportDest(xy, xyDat, 1, 0, 128, 48, 136, 88);
		
		N_DrawTeleportStartPoint(this, ghost, xy, xyDat, 30, 0, 4);
		N_DrawTeleportStartPoint(this, ghost, xy, xyDat, 30, 4, 4);
		N_DrawTeleportGlide(this, ghost, xy, xyDat, 30, 4, 4);
		N_DrawTeleportEndPoint(this, ghost, xy, xyDat, 30, 4, 4);
		N_DrawTeleportEndPoint(this, ghost, xy, xyDat, 30, 4, 8);
		
		forms[0] = CreateNPCAt(NPC_NIGHTMARE_SLIME, xy[2+0]-8, xy[2+1]-8);
		forms[0]->ItemSet = 0;
		
		while(true){
			if(forms[0]->isValid()){
				DamageNumbers_CalculateDamage(forms[0], false);
				if(forms[0]->HP<=0){
					forms[0]->DrawYOffset = -1000;
					
					N_SetTeleportDest(xy, xyDat, 2, 0, CenterX(forms[0]), CenterY(forms[0]), 64, 80);
					N_SetTeleportDest(xy, xyDat, 2, 1, CenterX(forms[0]), CenterY(forms[0]), 192, 80);
					
					break;
				}
			}
			Q7_Ghost_Waitframe(this, ghost);
		}
		
		if(true){
			N_DrawTeleportStartPoint(this, ghost, xy, xyDat, 30, 8, 4);
			N_DrawTeleportStartPoint(this, ghost, xy, xyDat, 30, 4, 4);
			N_DrawTeleportGlide(this, ghost, xy, xyDat, 30, 4, 4);
			N_DrawTeleportEndPoint(this, ghost, xy, xyDat, 30, 4, 4);
			N_DrawTeleportEndPoint(this, ghost, xy, xyDat, 30, 4, 16);
			
			forms[0] = CreateNPCAt(NPC_NIGHTMARE_AQUAMENTUS_RIGHT, xy[4+0+0]-8, xy[4+0+1]-16);
			forms[0]->ItemSet = 0;
			forms[1] = CreateNPCAt(NPC_NIGHTMARE_AQUAMENTUS_LEFT, xy[4+2+0]-8, xy[4+2+1]-16);
			forms[1]->ItemSet = 0;
			
			while(true){
				j = 0;
				for(i=0; i<2; i++){
					if(forms[i]->isValid()){
						DamageNumbers_CalculateDamage(forms[i], false);
						if(forms[i]->HP<=0){
							forms[i]->DrawYOffset = -1000;
							
							if(i==0){
								x = forms[i]->X;
								y = forms[i]->Y+16;
							}
							else{
								x = forms[i]->X+16;
								y = forms[i]->Y+16;
							}
							
							N_SetTeleportDest(xy, xyDat, 3, 0, x, y, 136, 56);
							N_SetTeleportDest(xy, xyDat, 3, 1, x, y, 72, 88);
							N_SetTeleportDest(xy, xyDat, 3, 2, x, y, 184, 88);
						}
						else
							j++;
					}
				}
				if(j==0)
					break;
				Q7_Ghost_Waitframe(this, ghost);
			}
			
			N_DrawTeleportStartPoint(this, ghost, xy, xyDat, 30, 16, 4);
			N_DrawTeleportStartPoint(this, ghost, xy, xyDat, 30, 4, 4);
			N_DrawTeleportGlide(this, ghost, xy, xyDat, 30, 4, 4);
			N_DrawTeleportEndPoint(this, ghost, xy, xyDat, 30, 4, 4);
			N_DrawTeleportEndPoint(this, ghost, xy, xyDat, 30, 4, 8);
			
			forms[0] = CreateNPCAt(NPC_NIGHTMARE_DODONGO, xy[6+0+0]-8, xy[6+0+1]-8);
			forms[0]->ItemSet = 0;
			forms[1] = CreateNPCAt(NPC_NIGHTMARE_DODONGO, xy[6+2+0]-8, xy[6+2+1]-8);
			forms[1]->ItemSet = 0;
			forms[2] = CreateNPCAt(NPC_NIGHTMARE_DODONGO, xy[6+4+0]-8, xy[6+4+1]-8);
			forms[2]->ItemSet = 0;
			
			while(true){
				j = 0;
				for(i=0; i<3; i++){
					if(forms[i]->isValid()){
						DamageNumbers_CalculateDamage(forms[i], false);
						if(forms[i]->HP<=0){
							forms[i]->DrawYOffset = -1000;
							
							N_SetTeleportDest(xy, xyDat, 1, 0, CenterX(forms[i]), CenterY(forms[i]), 128, 104);
						}
						else
							j++;
					}
				}
				if(j==0)
					break;
				Q7_Ghost_Waitframe(this, ghost);
			}
			
			N_DrawTeleportStartPoint(this, ghost, xy, xyDat, 30, 8, 4);
			N_DrawTeleportStartPoint(this, ghost, xy, xyDat, 30, 4, 4);
			N_DrawTeleportGlide(this, ghost, xy, xyDat, 30, 4, 4);
			N_DrawTeleportEndPoint(this, ghost, xy, xyDat, 30, 4, 4);
			N_DrawTeleportEndPoint(this, ghost, xy, xyDat, 30, 4, 8);
			
			forms[0] = CreateNPCAt(NPC_NIGHTMARE_MANHANDLA, xy[2+0]-8, xy[2+1]-8);
			forms[0]->ItemSet = 0;
			
			while(true){
				if(forms[0]->isValid()){
					DamageNumbers_CalculateDamage(forms[0], false);
					if(forms[0]->HP<=0){
						forms[0]->DrawYOffset = -1000;
						
						N_SetTeleportDest(xy, xyDat, 1, 0, CenterX(forms[0]), CenterY(forms[0]), 128, 48);
						
						break;
					}
				}
				Q7_Ghost_Waitframe(this, ghost);
			}
			
			N_DrawTeleportStartPoint(this, ghost, xy, xyDat, 30, 8, 4);
			N_DrawTeleportStartPoint(this, ghost, xy, xyDat, 30, 4, 4);
			N_DrawTeleportGlide(this, ghost, xy, xyDat, 30, 4, 4);
			N_DrawTeleportEndPoint(this, ghost, xy, xyDat, 30, 4, 4);
			N_DrawTeleportEndPoint(this, ghost, xy, xyDat, 30, 4, 16);
			
			forms[0] = CreateNPCAt(NPC_NIGHTMARE_GLEEOK, xy[2+0]-8, xy[2+1]+8);
			forms[0]->ItemSet = 0;
			
			while(true){
				if(forms[0]->isValid()){
					DamageNumbers_CalculateDamage(forms[0], false);
					if(forms[0]->HP<=0){
						forms[0]->DrawYOffset = -1000;
						
						N_SetTeleportDest(xy, xyDat, 1, 0, CenterX(forms[0]), CenterY(forms[0]), 128, 88);
						
						break;
					}
				}
				Q7_Ghost_Waitframe(this, ghost);
			}
			
			N_DrawTeleportStartPoint(this, ghost, xy, xyDat, 30, 16, 4);
			N_DrawTeleportStartPoint(this, ghost, xy, xyDat, 30, 4, 4);
			N_DrawTeleportGlide(this, ghost, xy, xyDat, 30, 4, 4);
			N_DrawTeleportEndPoint(this, ghost, xy, xyDat, 30, 4, 4);
			N_DrawTeleportEndPoint(this, ghost, xy, xyDat, 30, 4, 16);
			
			forms[0] = CreateNPCAt(NPC_NIGHTMARE_DIGDOGGER, xy[2+0]-8, xy[2+1]-8);
			forms[0]->ItemSet = 0;
			
			while(NumNPCsOf(NPC_NIGHTMARE_DIGDOGGER_KID)==0){
				Q7_Ghost_Waitframe(this, ghost);
			}
			j = 0;
			for(i=Screen->NumNPCs(); i>0; i--){
				npc n = Screen->LoadNPC(i);
				if(n->ID==NPC_NIGHTMARE_DIGDOGGER_KID){
					forms[j] = n;
					j++;
				}
			}
			while(true){
				j = 0;
				for(i=0; i<3; i++){
					if(forms[i]->isValid()){
						DamageNumbers_CalculateDamage(forms[i], false);
						if(forms[i]->HP<=0){
							forms[i]->DrawYOffset = -1000;
							
							N_SetTeleportDest(xy, xyDat, 1, 0, CenterX(forms[i]), CenterY(forms[i]), 136, 56);
						}
						else
							j++;
					}
				}
				if(j==0)
					break;
				Q7_Ghost_Waitframe(this, ghost);
			}
			
			N_DrawTeleportStartPoint(this, ghost, xy, xyDat, 30, 8, 4);
			N_DrawTeleportStartPoint(this, ghost, xy, xyDat, 30, 4, 4);
			N_DrawTeleportGlide(this, ghost, xy, xyDat, 30, 4, 4);
			N_DrawTeleportEndPoint(this, ghost, xy, xyDat, 30, 4, 4);
			N_DrawTeleportEndPoint(this, ghost, xy, xyDat, 30, 4, 8);
			
			forms[0] = CreateNPCAt(NPC_NIGHTMARE_GOHMA, xy[2+0]-8, xy[2+1]-8);
			forms[0]->ItemSet = 0;
			
			while(true){
				if(forms[0]->isValid()){
					DamageNumbers_CalculateDamage(forms[0], false);
					if(forms[0]->HP<=0){
						forms[0]->DrawYOffset = -1000;
						
						N_SetTeleportDest(xy, xyDat, 3, 0, CenterX(forms[0]), CenterY(forms[0]), 128, 40);
						N_SetTeleportDest(xy, xyDat, 3, 1, CenterX(forms[0]), CenterY(forms[0]), 40, 136);
						N_SetTeleportDest(xy, xyDat, 3, 2, CenterX(forms[0]), CenterY(forms[0]), 216, 136);
						
						break;
					}
				}
				Q7_Ghost_Waitframe(this, ghost);
			}
			
			N_DrawTeleportStartPoint(this, ghost, xy, xyDat, 30, 8, 4);
			N_DrawTeleportStartPoint(this, ghost, xy, xyDat, 30, 4, 4);
			N_DrawTeleportGlide(this, ghost, xy, xyDat, 30, 4, 4);
			N_DrawTeleportEndPoint(this, ghost, xy, xyDat, 30, 4, 4);
			N_DrawTeleportEndPoint(this, ghost, xy, xyDat, 30, 4, 8);
			
			forms[0] = CreateNPCAt(NPC_NIGHTMARE_FROG, xy[6+0+0]-8, xy[6+0+1]-8);
			forms[0]->ItemSet = 0;
			forms[1] = CreateNPCAt(NPC_NIGHTMARE_BOY, xy[6+2+0]-8, xy[6+2+1]-8);
			forms[1]->ItemSet = 0;
			forms[2] = CreateNPCAt(NPC_NIGHTMARE_CLOWN, xy[6+4+0]-8, xy[6+4+1]-8);
			forms[2]->ItemSet = 0;
			
			int formX;
			int formY;
			while(true){
				j = 0;
				for(i=0; i<3; i++){
					if(forms[i]->isValid()){
						++j;
						if(forms[i]->HP<=0){
							formX = CenterX(forms[i]);
							formY = CenterY(forms[i]);
						}
					}
				}
				if(j==0)
					break;
				Q7_Ghost_Waitframe(this, ghost);
			}
			N_SetTeleportDest(xy, xyDat, 1, 0, formX, formY, 128, 48);
		}
		
		N_DrawTeleportStartPoint(this, ghost, xy, xyDat, 30, 8, 4);
		N_DrawTeleportStartPoint(this, ghost, xy, xyDat, 30, 4, 4);
		N_DrawTeleportGlide(this, ghost, xy, xyDat, 30, 4, 4);
		N_DrawTeleportEndPoint(this, ghost, xy, xyDat, 30, 4, 4);
		N_DrawTeleportEndPoint(this, ghost, xy, xyDat, 30, 4, 16);
		
		Ghost_X = 112;
		Ghost_Y + 32;
		
		int arms[12] = {Ghost_X+8, Ghost_Y+8, Ghost_X+8, Ghost_Y+8, Ghost_X+8, Ghost_Y+8, Ghost_X+8, Ghost_Y+8, Ghost_X+8, Ghost_Y+8, Ghost_X+8, Ghost_Y+8};
		int armsTarget[12];
		int vars[16] = {0, arms, 0, 0, defenses, 0, 0, 0, 0};
		
		//vars[0] - The Mario Timer
		//vars[1] - Arms Array
		//vars[2] - Eye State
		//vars[3] - Eye Cooldown
		//vars[4] - Defenses
		//vars[5] - You cheated
		//vars[6] - Blinker Left
		//vars[7] - Blinker Right
		//vars[8] - HideSegments
		
		ghost->CollDetection = true;
		Ghost_Dir = DIR_DOWN;
		Game->PlayMIDI(0);
		for(i=0; i<48; i++){
			FN_ExtendArms(this, ghost, arms, 180, 0, 64*(i/48), 64*(i/48), 0, 0);
			Ghost_Y += 0.3333;
			FN_Waitframe(this, ghost, vars);
		}
		
		int arm1a = 180;
		int arm2a = 0;
		
		int armRotOffset[3];
		
		eweapon e;
		
		int initHP = Ghost_HP;
		
		int hitcheck = 0;
		int attackCooldown = 300;
		int counter = -1;
		
		npc theMario;
		if(!AllowAllJokes()){
			int bossMusic[] = "Sonic 2.nsf";
			Game->PlayEnhancedMusic(bossMusic, 2);
		}
		else{
			theMario = CreateNPCAt(NPC_NIGHTMARE_SFX, 120, 0);
		}
		
		int diffMod[16];
		
		diffMod[0] = LazyDiffMod(0.5, 0.8, 1);
		
		while(true){
			if(armRotOffset[2]==0){
				if(Ghost_HP<initHP*0.70){
					armRotOffset[0] = 180/diffMod[0];
					armRotOffset[2] = 1;
				}
			}
			else if(armRotOffset[2]==1){
				if(Ghost_HP<initHP*0.40){
					armRotOffset[1] = 180/diffMod[0];
					armRotOffset[2] = 2;
				}
			}
			arm1a = WrapDegrees(arm1a+1*diffMod[0]);
			if(armRotOffset[1]>0){
				armRotOffset[1]--;
				arm1a = WrapDegrees(arm1a+0.5*diffMod[0]);
			}
			arm2a = WrapDegrees(arm2a-1*diffMod[0]);
			if(armRotOffset[0]>0){
				armRotOffset[0]--;
				arm1a = WrapDegrees(arm1a+0.5*diffMod[0]);
			}
			FN_ExtendArms(this, ghost, arms, arm1a, arm2a, 64, 64, 0, 0);
			
			counter = Ghost_ConstantWalk8(counter, ghost->Step, ghost->Rate, ghost->Homing, ghost->Hunger);
			if(Ghost_X<48||Ghost_X>176){
				Ghost_X += Sign(112-Ghost_X);
			}
			if(Ghost_Y<48||Ghost_Y>96){
				Ghost_Y += Sign(72-Ghost_Y);
			}
			
			if(Ghost_GotHit())
				hitcheck = 1;
			if(attackCooldown>0)
				attackCooldown--;
			else if(Rand(56)==0&&hitcheck){
				if(IsHardMode()){
					FN_ExtendArms(this, ghost, armsTarget, 130, 40, 32, 32, 12, 12);
					while(FN_TrackArms(arms, armsTarget, 4)){
						x = Ghost_X;
						y = Ghost_Y;
						Ghost_MoveXY(0, -2, 0);
						FN_ArmsMoveXY(arms, Ghost_X-x, Ghost_Y-y);
						FN_ArmsMoveXY(armsTarget, Ghost_X-x, Ghost_Y-y);
						FN_Waitframe(this, ghost, vars);
					}
					for(i=0; i<60; i++){
						x = Ghost_X;
						y = Ghost_Y;
						Ghost_MoveXY(0, -2, 0);
						FN_ArmsMoveXY(arms, Ghost_X-x, Ghost_Y-y);
						FN_ArmsMoveXY(armsTarget, Ghost_X-x, Ghost_Y-y);
						FN_Waitframe(this, ghost, vars);
					}
					for(i=0; i<3; i++){
						k = Rand(3);
						if(k==2&&i<2)
							k = Rand(2);
						
						diffMod[1] = LazyDiffMod(1.4, 1.4, 1);
						diffMod[2] = LazyDiffMod(0.5, 0.5, 1);
						if(k==0){
							FN_ExtendArms(this, ghost, armsTarget, 130+40, 50, 16, 32, 40, 12);
							vars[6] = 1;
							vars[7] = 0;
							while(FN_TrackArms(arms, armsTarget, 1*diffMod[1])){
								FN_Waitframe(this, ghost, vars);
							}
							FN_ExtendArms(this, ghost, armsTarget, 130-30, 50, 40, 32, 8, 12);
							while(FN_TrackArms(arms, armsTarget, 3)){
								x = Ghost_X;
								y = Ghost_Y;
								Ghost_MoveXY(1.5*diffMod[2], -1, 0);
								FN_ArmsMoveXY(arms, Ghost_X-x, Ghost_Y-y);
								FN_ArmsMoveXY(armsTarget, Ghost_X-x, Ghost_Y-y);
								FN_Waitframe(this, ghost, vars);
							}
							for(m=0; m<16; m++){
								x = arms[2*2+0];
								y = arms[2*2+1];
								e = FireEWeapon(EW_FIREBALL, x, y, DegtoRad(90+60+60*Sin(m*20)), 300+50*Sin(m*20), ghost->WeaponDamage, SPR_FIREBALL_UNBLOCKABLE, -1, EWF_UNBLOCKABLE);
								e = FireEWeapon(EW_FIREBALL, x, y, DegtoRad(90+60-60*Sin(m*20)), 300+50*Sin(m*20), ghost->WeaponDamage, SPR_FIREBALL_UNBLOCKABLE, -1, EWF_UNBLOCKABLE);
								for(j=0; j<2; j++){
									FN_Waitframe(this, ghost, vars);
								}
							}
						}
						else if(k==1){
							FN_ExtendArms(this, ghost, armsTarget, 130, 50-40, 32, 16, 12, 40);
							vars[6] = 0;
							vars[7] = 1;
							while(FN_TrackArms(arms, armsTarget, 1*diffMod[1])){
								FN_Waitframe(this, ghost, vars);
							}
							FN_ExtendArms(this, ghost, armsTarget, 130, 50+30, 16, 32, 12, 8);
							while(FN_TrackArms(arms, armsTarget, 3)){
								x = Ghost_X;
								y = Ghost_Y;
								Ghost_MoveXY(-1.5*diffMod[2], -1, 0);
								FN_ArmsMoveXY(arms, Ghost_X-x, Ghost_Y-y);
								FN_ArmsMoveXY(armsTarget, Ghost_X-x, Ghost_Y-y);
								FN_Waitframe(this, ghost, vars);
							}
							for(m=0; m<16; m++){
								x = arms[2*5+0];
								y = arms[2*5+1];
								e = FireEWeapon(EW_FIREBALL, x, y, DegtoRad(90-60+60*Sin(m*20)), 300+50*Sin(m*20), ghost->WeaponDamage, SPR_FIREBALL_UNBLOCKABLE, -1, EWF_UNBLOCKABLE);
								e = FireEWeapon(EW_FIREBALL, x, y, DegtoRad(90-60-60*Sin(m*20)), 300+50*Sin(m*20), ghost->WeaponDamage, SPR_FIREBALL_UNBLOCKABLE, -1, EWF_UNBLOCKABLE);
								for(j=0; j<2; j++){
									FN_Waitframe(this, ghost, vars);
								}
							}
						}
						else{
							FN_ExtendArms(this, ghost, armsTarget, 130, 50, 32, 32, 12, 12);
							while(FN_TrackArms(arms, armsTarget, 1*diffMod[1])){
								x = Ghost_X;
								y = Ghost_Y;
								Ghost_MoveXY(0, -2, 0);
								FN_ArmsMoveXY(arms, Ghost_X-x, Ghost_Y-y);
								FN_ArmsMoveXY(armsTarget, Ghost_X-x, Ghost_Y-y);
								FN_Waitframe(this, ghost, vars);
							}
							FN_ExtendArms(this, ghost, armsTarget, 130+50, 50-50, 24, 24, 64, 64);
							vars[6] = 1;
							vars[7] = 1;
							while(FN_TrackArms(arms, armsTarget, 1*diffMod[1])){
								FN_Waitframe(this, ghost, vars);
							}
							FN_ExtendArms(this, ghost, armsTarget, 130-30, 50+30, 40, 40, 4, 4);
							while(FN_TrackArms(arms, armsTarget, 4)){
								x = Ghost_X;
								y = Ghost_Y;
								Ghost_MoveXY(0, -1, 0);
								FN_ArmsMoveXY(arms, Ghost_X-x, Ghost_Y-y);
								FN_ArmsMoveXY(armsTarget, Ghost_X-x, Ghost_Y-y);
								FN_Waitframe(this, ghost, vars);
							}
							for(m=0; m<16; m++){
								x = arms[2*2+0];
								y = arms[2*2+1];
								e = FireEWeapon(EW_FIREBALL, x, y, DegtoRad(90-30+40*Sin(m*20)), 300+50*Sin(m*20), ghost->WeaponDamage, SPR_FIREBALL_UNBLOCKABLE, -1, EWF_UNBLOCKABLE);
								e = FireEWeapon(EW_FIREBALL, x, y, DegtoRad(90-30-40*Sin(m*20)), 300+50*Sin(m*20), ghost->WeaponDamage, SPR_FIREBALL_UNBLOCKABLE, -1, EWF_UNBLOCKABLE);
								
								x = arms[2*5+0];
								y = arms[2*5+1];
								e = FireEWeapon(EW_FIREBALL, x, y, DegtoRad(90+30+40*Sin(m*20)), 300+50*Sin(m*20), ghost->WeaponDamage, SPR_FIREBALL_UNBLOCKABLE, -1, EWF_UNBLOCKABLE);
								e = FireEWeapon(EW_FIREBALL, x, y, DegtoRad(90+30-40*Sin(m*20)), 300+50*Sin(m*20), ghost->WeaponDamage, SPR_FIREBALL_UNBLOCKABLE, -1, EWF_UNBLOCKABLE);
								
								for(j=0; j<2; j++){
									FN_Waitframe(this, ghost, vars);
								}
							}
						}
						vars[6] = 0;
						vars[7] = 0;
						if(Link->Y<Ghost_Y+48)
							break;
					}
					FN_ExtendArms(this, ghost, armsTarget, arm1a, arm2a, 64, 64, 0, 0);
					while(FN_TrackArms(arms, armsTarget, 1.5)){
						FN_Waitframe(this, ghost, vars);
					}
				}
				hitcheck = 0;
				attackCooldown = 600;
			}
			
			FN_Waitframe(this, ghost, vars);
		}
	}
	void N_SetTeleportDest(int xy, int xyDat, int count, int i, int startX, int startY, int endX, int endY){
		xy[2*i+0] = startX;
		xy[2*i+1] = startY;
		xy[2*count+2*i+0] = endX;
		xy[2*count+2*i+1] = endY;
		
		xyDat[0] = 0;
		xyDat[1] = count;
	}
	void N_DrawTeleportPos(int xy, int xyDat, int count, int numFrames, int curFrame, int r){
		xyDat[0] += 4;
		xyDat[0] %= 360;
		
		for(int i=0; i<count; i++){
			int startX = xy[2*i+0];
			int startY = xy[2*i+1];
			int endX = xy[2*count+2*i+0];
			int endY = xy[2*count+2*i+1];
			int ang = Angle(startX, startY, endX, endY);
			int dist = Distance(startX, startY, endX, endY);
			int x = startX+VectorX(dist*(curFrame/numFrames), ang);
			int y = startY+VectorY(dist*(curFrame/numFrames), ang);
			Screen->Circle(0, x, y, r+0.1*r+0.1*r*Sin(xyDat[0]), 0x0F, 1, 0, 0, 0, true, 128);
		}
	}
	void N_DrawTeleportStartPoint(ffc this, npc ghost, int xy, int xyDat, int time, int startScale, int endScale){
		for(int i=0; i<time; i++){
			int r = startScale + (endScale-startScale)*(i/time);
			N_DrawTeleportPos(xy, xyDat, xyDat[1], 1, 0, r);
			Q7_Ghost_Waitframe(this, ghost);
		}
	}
	void N_DrawTeleportEndPoint(ffc this, npc ghost, int xy, int xyDat, int time, int startScale, int endScale){
		for(int i=0; i<time; i++){
			int r = startScale + (endScale-startScale)*(i/time);
			N_DrawTeleportPos(xy, xyDat, xyDat[1], 1, 1, r);
			Q7_Ghost_Waitframe(this, ghost);
		}
	}
	void N_DrawTeleportGlide(ffc this, npc ghost, int xy, int xyDat, int time, int startScale, int endScale){
		for(int i=0; i<time; i++){
			int r = startScale + (endScale-startScale)*(i/time);
			N_DrawTeleportPos(xy, xyDat, xyDat[1], time, i, r);
			Q7_Ghost_Waitframe(this, ghost);
		}
	}
	bool FN_TrackArms(int arms, int armsTarget, int step){
		bool stillGoing = false;
		for(int i=0; i<6; i++){
			if(Distance(arms[2*i+0], arms[2*i+1], armsTarget[2*i+0], armsTarget[2*i+1])>step){
				int angle = Angle(arms[2*i+0], arms[2*i+1], armsTarget[2*i+0], armsTarget[2*i+1]);
				arms[2*i+0] += VectorX(step, angle);
				arms[2*i+1] += VectorY(step, angle);
				stillGoing = true;
			}
			else{
				arms[2*i+0] = armsTarget[2*i+0];
				arms[2*i+1] = armsTarget[2*i+1];
			}
		}
		return stillGoing;
	}
	void FN_ExtendArms(ffc this, npc ghost, int arms, int arm1a, int arm2a, int arm1d, int arm2d, int arm1arc, int arm2arc){
		arms[0] = Ghost_X+8;
		arms[1] = 4+Ghost_Y+8;
		
		arms[2] = arms[0]+VectorX(arm1d*0.5, arm1a)+VectorX(arm1arc, arm1a+90);
		arms[3] = 4+arms[1]+VectorY(arm1d*0.5, arm1a)+VectorY(arm1arc, arm1a+90);
		
		arms[4] = arms[0]+VectorX(arm1d, arm1a);
		arms[5] = 4+arms[1]+VectorY(arm1d, arm1a);
		
		arms[6] = Ghost_X+8;
		arms[7] = 4+Ghost_Y+8;
		
		arms[8] = arms[6]+VectorX(arm2d*0.5, arm2a)+VectorX(arm2arc, arm2a-90);
		arms[9] = 4+arms[7]+VectorY(arm2d*0.5, arm2a)+VectorY(arm2arc, arm2a-90);
		
		arms[10] = arms[6]+VectorX(arm2d, arm2a);
		arms[11] = 4+arms[7]+VectorY(arm2d, arm2a);
		
	}
	void FN_ArmsMoveXY(int arms, int vX, int vY){
		for(int i=0; i<6; i++){
			arms[i*2+0] += vX;
			arms[i*2+1] += vY;
		}
	}
	void FN_Draw(ffc this, npc ghost, int combo, int vars){
		int i; int j; int k;
		int x; int y;
		int cs;
		int xy[2];
		
		//vars[0] - The Mario Timer
		//vars[1] - Arms Array
		//vars[2] - Eye State
		//vars[3] - Eye Cooldown
		//vars[4] - Defenses
		//vars[5] - You cheated
		//vars[6] - Blinker Left
		//vars[7] - Blinker Right
		//vars[8] - HideSegments
		
		int arms = vars[1];
		int defenses = vars[4];
		
		int eyeCMB;
		if(vars[2]==0){
			eyeCMB = -1;
			if(vars[3]>0)
				vars[3]--;
			else if(Rand(96)==0){
				vars[2] = 1;
				vars[3] = 0;
			}
		}
		else if(vars[2]==1){
			vars[3]++;
			eyeCMB = Clamp(Floor(vars[3]/40), 0, 3);
			// if(eyeCMB>1&&ghost->Defense[NPCD_ARROW]==NPCDT_BLOCK)
				// Ghost_SetDefenses(ghost, defenses);
			if(vars[3]>=3*40){
				vars[2] = 2;
				vars[3] = 80;
			}
		}
		else if(vars[2]==2){
			eyeCMB = 3;
			if(vars[3]>0)
				vars[3]--;
			else if(Rand(48)==0){
				vars[2] = 3;
				vars[3] = 3*40;
			}
		}
		else if(vars[2]==3){
			vars[3]--;
			eyeCMB = Clamp(Floor(vars[3]/40), 0, 3);
			// if(eyeCMB<=1&&ghost->Defense[NPCD_ARROW]!=NPCDT_BLOCK)
				// Ghost_SetAllDefenses(ghost, NPCDT_BLOCK);
			if(vars[3]<=0){
				vars[2] = 0;
				vars[3] = 120;
			}
		}
		
		lweapon arrow = LoadLWeaponOf(LW_ARROW);
		lweapon brang = LoadLWeaponOf(LW_BRANG);
		
		if(Link->HP>0){
			for(i=0; i<8; i++){
				BezierQuadFrame(xy, i, 7, arms[0], arms[1], arms[2], arms[3], arms[4], arms[5]);
				
				if(i<8-vars[8]){
					if(i==7){
						if(vars[6])
							Screen->FastCombo(4, xy[0], xy[1], combo+8, this->CSet, 128);
						else
							Screen->FastCombo(4, xy[0], xy[1], combo+7, this->CSet, 128);
					}
					else if(i==6){
						Screen->FastCombo(4, xy[0], xy[1], combo+6, this->CSet, 128);
					}
					else{
						Screen->FastCombo(4, xy[0], xy[1], combo+5, this->CSet, 128);
					}
				}
				if(vars[8]==0){
					if(__Ghost_FlashCounter<=0)
						MakeHitbox(xy[0], xy[1], 16, 16, ghost->Damage);
					if(arrow->isValid()&&i>2){
						if(CollisionMod(arrow, xy[0]+4, xy[1]+4, 8, 8)&&arrow->DeadState==WDS_ALIVE){
							Game->PlaySound(SFX_CLINK);
							arrow->DeadState = WDS_ARROW;
						}
					}
				}
				
				BezierQuadFrame(xy, i, 7, arms[6], arms[7], arms[8], arms[9], arms[10], arms[11]);
			
				if(i<8-vars[8]){
					if(i==7){
						if(vars[7])
							Screen->FastCombo(4, xy[0], xy[1], combo+8, this->CSet, 128);
						else
							Screen->FastCombo(4, xy[0], xy[1], combo+7, this->CSet, 128);
					}
					else if(i==6){
						Screen->FastCombo(4, xy[0], xy[1], combo+6, this->CSet, 128);
					}
					else{
						Screen->FastCombo(4, xy[0], xy[1], combo+5, this->CSet, 128);
					}
				}
				if(vars[8]==0){
					if(__Ghost_FlashCounter<=0)
						MakeHitbox(xy[0], xy[1], 16, 16, ghost->Damage);
					if(arrow->isValid()&&i>2){
						if(CollisionMod(arrow, xy[0]+4, xy[1]+4, 8, 8)&&arrow->DeadState==WDS_ALIVE){
							Game->PlaySound(SFX_CLINK);
							arrow->DeadState = WDS_ARROW;
						}
					}
				}
			}
			
			cs = 9;
			if(__Ghost_FlashCounter>0){
				cs = this->CSet;
			}
			Screen->DrawCombo(4, Ghost_X, Ghost_Y, combo, 2, 2, cs, -1, -1, 0, 0, 0, 0, 0, true, 128);
			cs = 8;
			if(!AllowAllJokes())
				cs = 7;
			if(__Ghost_FlashCounter>0){
				cs = this->CSet;
			}
			if(eyeCMB>-1)
				Screen->DrawCombo(4, Ghost_X, Ghost_Y, combo+1+eyeCMB, 2, 2, cs, -1, -1, 0, 0, 0, 0, 0, true, 128);
			
			if(eyeCMB>0){
				if(brang->isValid()&&vars[5]==0){
					if(brang->Dir==DIR_UP&&AngleDir4(Angle(brang->X, brang->Y, Ghost_X+8, Ghost_Y+8))==DIR_UP&&CollisionMod(brang, ghost->X+ghost->HitXOffset, ghost->Y+ghost->HitYOffset, ghost->HitWidth, ghost->HitHeight)){
						if(AllowSomeJokes())
							Screen->Message(STR_NIGHTMARE_CHEAT);
						vars[5] = 1;
					}
				}
				
				if(Abs(Link->X-(Ghost_X+8))<16&&Link->Y>Ghost_Y+16&&Link->Y<Ghost_Y+40){
					ghost->Defense[NPCD_ARROW] = NPCDT_NONE;
				}
				else if(arrow->isValid()){
					if(CollisionMod(arrow, ghost->X+ghost->HitXOffset, ghost->Y+ghost->HitYOffset, ghost->HitWidth, ghost->HitHeight)&&arrow->Dir==DIR_UP){
						ghost->Defense[NPCD_ARROW] = NPCDT_NONE;
					}
					else{
						ghost->Defense[NPCD_ARROW] = NPCDT_BLOCK;
					}
				}
				else{
					ghost->Defense[NPCD_ARROW] = NPCDT_BLOCK;
				}
			}
			else{
				ghost->Defense[NPCD_ARROW] = NPCDT_BLOCK;
			}
		}
	}
	void FN_DeathEffect(ffc this, npc ghost, int vars){
		int i; int j; int k;
		
		int xy[2];
		int arms = vars[1];
		
		int combo = ghost->Attributes[10];
		
		Ghost_HP = 1;
		ghost->HP = 1;
		ghost->CollDetection = false;
		
		npc theMario = LoadNPCOf(NPC_NIGHTMARE_SFX);
		if(theMario->isValid()){
			theMario->HP = -1000;
			theMario->DrawYOffset = -1000;
		}
		
		for(i=0; i<2; i++){
			if(i==1){
				Screen->Message(STR_NIGHTMARE_END);
			}
			FN_Draw(this, ghost, combo, vars);
			Ghost_WaitframeLight(this, ghost);
		}
		
		for(i=0; i<8; i++){
			vars[8]++;
			BezierQuadFrame(xy, 7-i, 7, arms[0], arms[1], arms[2], arms[3], arms[4], arms[5]);
				
			npc poof = CreateNPCAt(NPC_ENEMYFIRE, xy[0], xy[1]);
			poof->HP = 0;
			poof->Misc[NPCM_LASTHP] = 0;
			poof->CollDetection = false;
			
			BezierQuadFrame(xy, 7-i, 7, arms[6], arms[7], arms[8], arms[9], arms[10], arms[11]);
			
			poof = CreateNPCAt(NPC_ENEMYFIRE, xy[0], xy[1]);
			poof->HP = 0;
			poof->Misc[NPCM_LASTHP] = 0;
			poof->CollDetection = false;

			for(j=0; j<8; j++){
				FN_Draw(this, ghost, combo, vars);
				Ghost_WaitframeLight(this, ghost);
			}
		}
		
		ghost->HP = 0;
		ghost->Misc[NPCM_LASTHP] = 0;
	}
	void FN_Waitframe(ffc this, npc ghost, int vars){
		// if(vars[0]==0)
			// Game->PlaySound(SFX_THEMARIO);
		// vars[0]++;
		// if(vars[0]>40*60){
			// vars[0] = 0;
		// }
		int combo = ghost->Attributes[10];
		FN_Draw(this, ghost, combo, vars);
		if(!Q7_Ghost_Waitframe(this, ghost, true, false)){
			FN_DeathEffect(this, ghost, vars);
			Quit();
		}
	}
}

ffc script DudeFuckManhandlasManLikeSeriously{
	void run(int dest, int src, int w, int h){
		CopyTileBlock(src, src+(w-1)+(h-1)*20, dest);
	}
}

int FindJumpLength(int jumpInput, bool inputFrames){
	//Big ol table of rough jump values and their durations
	int jumpTBL[] = 
	{
		0.0, 0,
		0.1, 3,
		0.2, 4,
		0.3, 5,
		0.4, 6,
		0.5, 8,
		0.6, 9,
		0.7, 10,
		0.8, 11,
		0.9, 13,
		1.0, 14,
		1.1, 15,
		1.2, 16,
		1.3, 18,
		1.4, 19,
		1.5, 20,
		1.6, 21,
		1.7, 23,
		1.8, 24,
		1.9, 25,
		2.0, 26,
		2.1, 28,
		2.2, 29,
		2.3, 30,
		2.4, 31,
		2.5, 33,
		2.6, 34,
		2.7, 35,
		2.8, 36,
		2.9, 38,
		3.0, 39,
		3.1, 40,
		3.2, 41,
		3.3, 43,
		3.4, 44,
		3.5, 45,
		3.6, 47,
		3.7, 48,
		3.8, 49,
		3.9, 51,
		4.0, 52,
		4.1, 54,
		4.2, 55,
		4.3, 57,
		4.4, 58,
		4.5, 60,
		4.6, 61,
		4.7, 63,
		4.8, 64,
		4.9, 66,
		5.0, 67,
		5.1, 69,
		5.2, 71,
		5.3, 72,
		5.4, 74,
		5.5, 76,
		5.6, 77,
		5.7, 79,
		5.8, 81,
		5.9, 83,
		6.0, 85,
		6.1, 86,
		6.2, 88,
		6.3, 90,
		6.4, 92,
		6.5, 94,
		6.6, 96,
		6.7, 98,
		6.8, 100,
		6.9, 102,
		7.0, 104,
		7.1, 106,
		7.2, 108,
		7.3, 110,
		7.4, 112,
		7.5, 114,
		7.6, 116,
		7.7, 118,
		7.8, 120,
		7.9, 123,
		8.0, 125,
		8.1, 127,
		8.2, 129,
		8.3, 131,
		8.4, 134,
		8.5, 136,
		8.6, 138,
		8.7, 141,
		8.8, 143,
		8.9, 145,
		9.0, 148,
		9.1, 150,
		9.2, 153,
		9.3, 155,
		9.4, 158,
		9.5, 160,
		9.6, 162,
		9.7, 165,
		9.8, 168,
		9.9, 170,
		10.0, 173
	};

	//When getting a duration from a jump
	if(!inputFrames){
		//Keep values between 0 and 10, nothing beyond that would be sensible in most cases
		jumpInput = Clamp(jumpInput, 0, 10);
		//Round to the nearest 0.1
		jumpInput *= 10;
		jumpInput = Round(jumpInput);
		//jumpInput *= 0.1;
		
		return jumpTBL[jumpInput*2+1];
	}
	//When getting a jump from a duration
	else{
		int closestIndex = 0;
		int closest = 0;
		//Cycle through the table to find the closest duration to the desired one
		for(int i=1; i<100; i++){
			if(Abs(jumpTBL[i*2+1]-jumpInput)<Abs(closest-jumpInput)){
				closestIndex = i;
				closest = jumpTBL[i*2+1];
			}
		}
		
		return jumpTBL[closestIndex*2+0];
	}
}

const int SFX_FROGGER_GOOSH = 72;
const int TIL_LINKPRONE = 1384;

ffc script FrogWithoutZAxisOhFack{
	void run(int enemyid){
		Screen->D[2] = 0;
		Screen->D[3] = 0;
		int i; int j; int k;
		int step; int angle;
		int vx; int vy;
		npc ghost = Ghost_InitAutoGhost(this, enemyid);
		this->Flags[FFCF_ETHEREAL] = true;
		
		Ghost_SetFlag(GHF_FAKE_Z);
		Ghost_SetFlag(GHF_4WAY);
		
		int bombX[16];
		int bombY[16];
		int bombA[16];
		int bombT[16];
		int bombST[16];
		
		int vars[] = {bombX, bombY, bombA, bombT, bombST};
		
		int combo = ghost->Attributes[10];
		
		int bombCooldown = 0;
		
		int diffMod[16];
		
		while(true){
			int attack = Choose(0, 0, 1, 2);
			if(Screen->D[3])
				attack = 0;
			if(bombCooldown>0){
				if(attack==1)
					attack = 0;
				bombCooldown--;
			}
			int jump = 0;
			if(attack==0){
				angle = Q7_DirAngle(AngleDir8(Angle(Ghost_X, Ghost_Y, Link->X, Link->Y)))+Choose(-45, 45);
				Ghost_Dir = AngleDir4(angle);
				Game->PlaySound(SFX_JUMP);
				Ghost_Jump = FindJumpLength(24, true);
				while(Ghost_Jump>0||Ghost_Z>0){
					Ghost_MoveAtAngle(angle, 1.5, 0);
					FWAZ_Waitframe(this, ghost, vars);
				}
				Ghost_Data = combo+4;
				for(j=0; j<20; j++){
					angle = Angle(Ghost_X, Ghost_Y, Link->X, Link->Y);
					Ghost_Dir = AngleDir4(angle);
					FWAZ_Waitframe(this, ghost, vars);
				}
				Ghost_Data = combo;
			}
			if(attack==1){
				Screen->D[3] = 1;
				bombCooldown = LazyDiffMod(5, 4, 3);
				Ghost_Data = combo+4;
				for(j=0; j<40; j++){
					FWAZ_Waitframe(this, ghost, vars);
				}
				Ghost_Data = combo;
				
				angle = Angle(Ghost_X, Ghost_Y, Link->X, Link->Y);
				Ghost_Dir = AngleDir4(angle);
				
				for(i=0; i<3; i++){
					angle = Angle(Ghost_X, Ghost_Y, Link->X, Link->Y);
					Ghost_Dir = AngleDir4(angle);
					
					for(j=0; j<20; j++){
						FWAZ_Waitframe(this, ghost, vars);
					}
					
					vx = 0;
					vy = 0;
					if(Ghost_Dir==DIR_UP||Ghost_Dir==DIR_DOWN){
						vx = Sign(Link->X-Ghost_X);
					}
					else{
						vy = Sign(Link->Y-Ghost_Y);
					}
					
					Game->PlaySound(SFX_JUMP);
					Ghost_Jump = FindJumpLength(32, true);
					while(Ghost_Jump>0||Ghost_Z>0){
						Ghost_MoveXY(vx*2, vy*2, 0);
						FWAZ_Waitframe(this, ghost, vars);
					}
					diffMod[0] = LazyDiffMod(32, 16, 8);
					for(j=0; j<diffMod[0]; j++){
						FWAZ_Waitframe(this, ghost, vars);
					}
					j = Q7_DirAngle(Ghost_Dir);
					FWAZ_AddExplosion(vars, Ghost_X, Ghost_Y, j, 2);
				}
				Screen->D[3] = 0;
			}
			else if(attack==2){
				Game->PlaySound(36);
				Ghost_Data = combo+4;
				
				diffMod[0] = LazyDiffMod(80, 60, 40);
				for(i=0; i<diffMod[0]; i++){
					j = 40*(i/diffMod[0]);
					Ghost_Dir = AngleDir4(Angle(Ghost_X, Ghost_Y+16, Link->X, Link->Y));
					Screen->Circle(3, Ghost_X+8+VectorX(50-j, Rand(360)), Ghost_Y+18-ghost->Z+VectorY(50-j, Rand(360)), Rand(2,4)+1, 0x01, 1, 0, 0, 0, true, OP_OPAQUE);
					Ghost_MoveAtAngle(Angle(Ghost_X, Ghost_Y, Link->X, Link->Y)+180, .3, 1);
					FWAZ_Waitframe(this, ghost, vars);
				}
				angle = Angle(Ghost_X, Ghost_Y, Link->X, Link->Y);
				Ghost_Dir = AngleDir4(angle);
				bool grabbed = false;
				Ghost_Data = combo;
				bool bounced;
				j = 0;
				for(i=0; i<60; i++){
					if(j>0)
						j--;
					else
						Ghost_MoveAtAngle(angle, 4, 1);
					if(!bounced&&IsVeryHardMode()){
						int vX = VectorX(4, angle);
						int vY = VectorY(4, angle);
						if((vX<-1&&!Ghost_CanMove(DIR_LEFT, 1, 0)) || (vX>1&&!Ghost_CanMove(DIR_RIGHT, 1, 0))){
							vX = -vX;
							angle = Angle(0, 0, vX, vY);
							Ghost_Dir = AngleDir4(angle);
							j = 8;
							bounced = true;
						}
						else if((vY<-1&&!Ghost_CanMove(DIR_UP, 1, 0)) || (vY>1&&!Ghost_CanMove(DIR_DOWN, 1, 0))){
							vY = -vY;
							angle = Angle(0, 0, vX, vY);
							Ghost_Dir = AngleDir4(angle);
							j = 8;
							bounced = true;
						}
					}
					if(Link->Action == LA_GOTHURTLAND && LinkCollision(ghost)){
						grabbed=true;
						break;
					}
					FWAZ_Waitframe(this, ghost, vars);
				}
				if(grabbed){
					Link->CollDetection = false;
					ghost->CollDetection = false;
					Link->Invisible = true;
					angle = Angle(Link->X, Link->Y, Ghost_X, Ghost_Y);
					Ghost_Dir = AngleDir4(WrapDegrees(angle+180));
					Screen->D[2] = 1;
					for(i=0; i<256; i++){
						Ghost_X = Link->X+VectorX(8+8*Sin(i*32), angle);
						Ghost_Y = Link->Y+VectorY(8+8*Sin(i*32), angle);
						if(i%40==0){
							if(!AllowAllJokes())
								Game->PlaySound(SFX_EHIT);
							else
								Game->PlaySound(SFX_FROGGER_GOOSH);
						}
						diffMod[0] = LazyDiffMod(32, 24, 16);
						if(i%diffMod[0]==0){
							k = Min(4, Link->HP-1);
							DealDirectDamage(k);
							Game->PlaySound(SFX_OUCH);
						}
						bool doExplode = false;
						if(i>192&&i%8==0)
							doExplode = true;
						else if(i>128&&i%12==0)
							doExplode = true;
						else if(i>64&&i%16==0)
							doExplode = true;
						if(doExplode){
							eweapon boom = CreateEWeaponAt(EW_BOMBBLAST, Link->X+Rand(-16, 16), Link->Y+Rand(-16, 16));
							boom->CollDetection = false;
						}
						Screen->FastTile(0, Link->X, Link->Y, TIL_LINKPRONE, 6, 128);
						NoAction();
						FWAZ_Waitframe(this, ghost, vars);
					}
					Screen->D[2] = 0;
					for(i=0; i<24; i++){
						Ghost_MoveAtAngle(angle, 4, 0);
						Screen->FastTile(0, Link->X, Link->Y, TIL_LINKPRONE, 6, 128);
						NoAction();
						FWAZ_Waitframe(this, ghost, vars);
					}
					Link->CollDetection = true;
					ghost->CollDetection = true;
					Link->Invisible = false;
				}
			}
			FWAZ_Waitframe(this, ghost, vars);
		}
	}
	void FWAZ_AddExplosion(int vars, int x, int y, int ang, int st){
		int bombX = vars[0];
		int bombY = vars[1];
		int bombA = vars[2];
		int bombT = vars[3];
		int bombST = vars[4];
		
		for(int i=0; i<16; i++){
			if(bombST[i]==0){
				bombX[i] = x;
				bombY[i] = y;
				bombA[i] = ang;
				bombT[i] = 0;
				bombST[i] = st;
				
				return;
			}
		}
	}
	void FWAZ_UpdateExplosion(npc ghost, int vars){
		int i; int j; int k;
		int x; int y;
		
		int bombX = vars[0];
		int bombY = vars[1];
		int bombA = vars[2];
		int bombT = vars[3];
		int bombST = vars[4];
		
		for(i=0; i<16; i++){
			if(bombST[i]>0){
				if(bombST[i]==1){
					if(bombT[i]%6==0){
						for(j=0; j<4; j++){
							x = bombX[i]+VectorX(bombT[i]/6*12, bombA[i]+90*j+30*bombT[i]/6);
							y = bombY[i]+VectorY(bombT[i]/6*12, bombA[i]+90*j+30*bombT[i]/6);
							eweapon boom = CreateEWeaponAt(EW_BOMBBLAST, x, y);
							boom->Damage = ghost->WeaponDamage;
						}
					}
					bombT[i]++;
					if(bombT[i]>=18)
						bombST[i] = 0;
				}
				else if(bombST[i]==2){
					x = bombX[i]+VectorX(4*bombT[i], bombA[i])+VectorX(16*Sin(bombT[i]*8), bombA[i]-90);
					y = bombY[i]+VectorY(4*bombT[i], bombA[i])+VectorY(16*Sin(bombT[i]*8), bombA[i]-90);
							
					if(bombT[i]%8==0){
						eweapon boom = CreateEWeaponAt(EW_BOMBBLAST, x, y);
						boom->Damage = ghost->WeaponDamage;
					}
					
					bombT[i]++;
					
					if(x<32-16||x>208+16||y<32-16||y>128+16){
						bombST[i] = 0;
					}
				}
			}
		}
	}
	void FWAZ_Waitframe(ffc this, npc ghost, int vars){
		FWAZ_UpdateExplosion(ghost, vars);
		if(!Q7_Ghost_Waitframe(this, ghost, true, false)){
			Link->CollDetection = true;
			Link->Invisible = false;
			if(Screen->D[3]==1)
				Screen->D[3] = 0;
			Quit();
		}
	}
}

ffc script PatraInHumanForm{
	void run(int enemyid){
		int i; int j; int k;
		int dist; int ang;
		int x; int y;
		
		npc ghost = Ghost_InitAutoGhost(this, enemyid);
		this->Flags[FFCF_ETHEREAL] = true;
		
		Ghost_SetFlag(GHF_4WAY);
		
		int vars[16] = {Ghost_X, Ghost_Y, 0, 0, 0, 0, ghost->WeaponDamage};
		
		//vars[0] - Shield X Position
		//vars[1] - Shield Y Position
		//vars[2] - Shield State
		//vars[3] - Shield Rotation
		//vars[4] - Shield Dist
		//vars[5] - Shield Rot Speed
		//vars[6] - Shield Damage
		
		int combo = ghost->Attributes[10];
		
		eweapon shield[4];
		
		int attackCooldown = 60;
		int rotDir = Choose(-1, 1);
		
		int diffMod[16];
		
		while(true){
			dist = Distance(Ghost_X, Ghost_Y, Link->X, Link->Y);
			ang = Angle(Ghost_X, Ghost_Y, Link->X, Link->Y);
			Ghost_Dir = AngleDir4(ang);
			if(dist<64){
				Ghost_MoveAtAngle(ang+180+Rand(-15, 15), 0.8, 0);
			}
			else if(dist>80){
				Ghost_MoveAtAngle(ang+Rand(-15, 15), 0.8, 0);
			}
			else{
				Ghost_MoveAtAngle(ang+90*rotDir+Rand(-5, 5), 0.8, 0);
			}
			if(!Ghost_CanMove8(Ghost_Dir, 1, 0))
				rotDir = -rotDir;
			
			if(attackCooldown>0)
				attackCooldown--;
			else if(Rand(24)==0){
				if(vars[2]==0){
					vars[0] = Ghost_X;
					vars[1] = Ghost_Y;
					vars[2] = 1;
					vars[3] = Rand(360);
					vars[4] = 0;
					vars[5] = 8;
					
					Ghost_Data = combo+4;
					diffMod[0] = LazyDiffMod(48, 32, 24);
					for(i=0; i<diffMod[0]; i+=2){
						vars[4] = 24*(i/diffMod[0]);
						WPBC_Waitframe(this, ghost, shield, vars);
					}
					Ghost_Data = combo;
					
					vars[2] = 2;
					vars[5] = 4;
					
					attackCooldown = 160;
				}
				else if(vars[2]==2){
					vars[5] = 8;
					Ghost_Data = combo+4;
					ang = Angle(Ghost_X, Ghost_Y, Link->X, Link->Y);
					diffMod[0] = LazyDiffMod(64, 48, 48);
					for(i=0; i<diffMod[0]; i++){
						WPBC_Waitframe(this, ghost, shield, vars);
					}
					vars[2] = 3;
					diffMod[0] = LazyDiffMod(2, 2.5, 3);
					while(vars[0]>16&&vars[0]<224&&vars[1]>16&&vars[1]<144){
						vars[0] += VectorX(diffMod[0], ang);
						vars[1] += VectorY(diffMod[0], ang);
						WPBC_Waitframe(this, ghost, shield, vars);
					}
					vars[2] = 0;
					Ghost_Data = combo;
					
					attackCooldown = 50;
				}
			}
			
			if(Screen->D[2]){
				bool grabbed = false;
				Ghost_Data = combo;
				while(Screen->D[2]){
					ang = Angle(Ghost_X, Ghost_Y, Link->X, Link->Y);
					Ghost_MoveAtAngle(ang, 4, 1);
					if(LinkCollision(ghost)){
						grabbed=true;
						break;
					}
					WPBC_Waitframe(this, ghost, shield, vars);
				}
				if(grabbed){
					ang = Angle(Link->X, Link->Y, Ghost_X, Ghost_Y);
					Ghost_Dir = AngleDir4(WrapDegrees(ang+180));
					i = 0;
					while(Screen->D[2]){
						i++;
						Ghost_X = Link->X+VectorX(8+8*Sin(i*32), ang);
						Ghost_Y = Link->Y+VectorY(8+8*Sin(i*32), ang);
						
						WPBC_Waitframe(this, ghost, shield, vars);
					}
					for(i=0; i<24; i++){
						Ghost_MoveAtAngle(ang, 4, 0);
						Screen->FastTile(0, Link->X, Link->Y, TIL_LINKPRONE, 6, 128);
						
						WPBC_Waitframe(this, ghost, shield, vars);
					}
				}
			}
			
			WPBC_Waitframe(this, ghost, shield, vars);
		}
	}
	void WPBC_UpdateShield(ffc this, npc ghost, eweapon shield, int vars){
		int i; int j; int k;
		int x; int y;
		
		//vars[0] - Shield X Position
		//vars[1] - Shield Y Position
		//vars[2] - Shield State
		//vars[3] - Shield Rotation
		//vars[4] - Shield Dist
		//vars[5] - Shield Rot Speed
		//vars[6] - Shield Damage
		
		if(vars[2]>0){
			vars[3] += vars[5];
			vars[3] %= 360;
			for(i=0; i<4; i++){
				x = vars[0]+VectorX(vars[4], vars[3]+90*i);
				y = vars[1]+VectorY(vars[4], vars[3]+90*i);
				if(shield[i]->isValid()){
					shield[i]->X = x;
					shield[i]->Y = y;
				}
				else{
					shield[i] = FireEWeapon(EW_FIREBALL, x, y, 0, 0, vars[6], SPR_FIREBALL_UNBLOCKABLE, 0, EWF_UNBLOCKABLE);
					shield[i]->CSet = 11;
				}
			}
		}
		else{
			for(i=0; i<4; i++){
				if(shield[i]->isValid())
					shield[i]->DeadState = 0;
			}
		}
	}
	void WPBC_Waitframe(ffc this, npc ghost, eweapon shield, int vars){
		
		if(vars[2]==2){
			vars[0] = Ghost_X;
			vars[1] = Ghost_Y;
		}
		
		WPBC_UpdateShield(this, ghost, shield, vars);
		if(!Q7_Ghost_Waitframe(this, ghost, true, false)){
			for(int i=0; i<4; i++){
				if(shield[i]->isValid())
					shield[i]->DeadState = 0;
			}
			Quit();
		}
	}
}

const int SPR_DIMENTIO_FIREBALL = 101;

ffc script TheClownTheWorldDeserves{
	void run(int enemyid){
		int i; int j; int k;
		int x; int y;
		int dist; int ang;
		
		npc ghost = Ghost_InitAutoGhost(this, enemyid);
		this->Flags[FFCF_ETHEREAL] = true;
		
		Ghost_SetFlag(GHF_4WAY);
		
		int combo = ghost->Attributes[10];
		
		int vars[16] = {0};
		
		//vars[0] - Anim Counter
		
		eweapon e;
		
		int xy[2];
		
		int attackCooldown = 120;
		int teleCooldown = 32;
		
		int diffMod[16];
		while(true){
			if(Distance(Ghost_X, Ghost_Y, Link->X, Link->Y)<48){
				for(i=-1; i<=1; i+=2){
					e = FireAimedEWeapon(EW_SCRIPT10, Ghost_X, Ghost_Y, DegtoRad(Rand(-30, 30)), 0, ghost->WeaponDamage, SPR_DIMENTIO_FIREBALL, SFX_FIREBALL, EWF_UNBLOCKABLE);
					SetEWeaponLifespan(e, EWL_SLOW_TO_HALT, -5);
				}
				Ghost_Data = combo+4;
				for(i=0; i<24; i++){
					TCTWD_Waitframe(this, ghost, vars);
				}
				Ghost_Data = combo;
				TCTWD_FindTeleport(ghost, xy);
				TCTWD_Teleport(this, ghost, vars, xy[0], xy[1]);
				teleCooldown = 64;
			}
			
			if(teleCooldown>0)
				teleCooldown--;
			else if(Rand(24)==0){
				TCTWD_FindTeleport(ghost, xy);
				TCTWD_Teleport(this, ghost, vars, xy[0], xy[1]);
				teleCooldown = 32;
			}
			
			if(attackCooldown>0)
				attackCooldown--;
			else if(attackCooldown==0){
				int attack = 0;
				if(NumNPCsOf(NPC_NIGHTMARE_FROG)==0&&NumNPCsOf(NPC_NIGHTMARE_BOY)==0)
					attack = 1;
				if(Screen->D[3])
					attack = -1;
				if(attack==0){
					Screen->D[3] = 2;
					for(i=0; i<2; i++){
						TCTWD_FindTeleport(ghost, xy);
						TCTWD_Teleport(this, ghost, vars, xy[0], xy[1]);
						for(j=0; j<8; j++){
							Ghost_Dir = AngleDir4(Angle(Ghost_X, Ghost_Y, Link->X, Link->Y));
							TCTWD_Waitframe(this, ghost, vars);
						}
					}
					for(j=0; j<16; j++){
						Ghost_Dir = AngleDir4(Angle(Ghost_X, Ghost_Y, Link->X, Link->Y));
						TCTWD_Waitframe(this, ghost, vars);
					}
					ang = Angle(Ghost_X, Ghost_Y, Link->X, Link->Y);
					Ghost_Data = combo+4;
					for(i=-60; i<=60; i+=40){
						e = FireEWeapon(EW_SCRIPT10, Ghost_X, Ghost_Y, DegtoRad(ang+i), 0, ghost->WeaponDamage, SPR_DIMENTIO_FIREBALL, SFX_FIREBALL, EWF_UNBLOCKABLE);
						SetEWeaponLifespan(e, EWL_SLOW_TO_HALT, -3);
						// e = FireEWeapon(EW_SCRIPT10, Ghost_X, Ghost_Y, DegtoRad(ang-i), 0, ghost->WeaponDamage, SPR_DIMENTIO_FIREBALL, SFX_FIREBALL, EWF_UNBLOCKABLE);
						// SetEWeaponLifespan(e, EWL_SLOW_TO_HALT, -5);
						diffMod[0] = LazyDiffMod(12, 10, 8);
						for(j=0; j<diffMod[0]; j++){
							Ghost_Dir = AngleDir4(Angle(Ghost_X, Ghost_Y, Link->X, Link->Y));
							TCTWD_Waitframe(this, ghost, vars);
						}
					}
					for(i=-30; i<=30; i+=30){
						// e = FireEWeapon(EW_SCRIPT10, Ghost_X, Ghost_Y, DegtoRad(ang+i), 0, ghost->WeaponDamage, SPR_DIMENTIO_FIREBALL, SFX_FIREBALL, EWF_UNBLOCKABLE);
						// SetEWeaponLifespan(e, EWL_SLOW_TO_HALT, -10);
						e = FireEWeapon(EW_SCRIPT10, Ghost_X, Ghost_Y, DegtoRad(ang-i), 0, ghost->WeaponDamage, SPR_DIMENTIO_FIREBALL, SFX_FIREBALL, EWF_UNBLOCKABLE);
						SetEWeaponLifespan(e, EWL_SLOW_TO_HALT, -6);
						diffMod[0] = LazyDiffMod(12, 10, 8);
						for(j=0; j<diffMod[0]; j++){
							Ghost_Dir = AngleDir4(Angle(Ghost_X, Ghost_Y, Link->X, Link->Y));
							TCTWD_Waitframe(this, ghost, vars);
						}
					}
					Ghost_Data = combo;
					attackCooldown = 160;
					Screen->D[3] = 0;
				}
				else if(attack==1){
					Screen->D[3] = 2;
					for(i=0; i<3; i++){
						TCTWD_FindTeleport(ghost, xy);
						TCTWD_Teleport(this, ghost, vars, xy[0], xy[1]);
						for(j=0; j<8; j++){
							Ghost_Dir = AngleDir4(Angle(Ghost_X, Ghost_Y, Link->X, Link->Y));
							TCTWD_Waitframe(this, ghost, vars);
						}
					}
					for(j=0; j<16; j++){
						Ghost_Dir = AngleDir4(Angle(Ghost_X, Ghost_Y, Link->X, Link->Y));
						TCTWD_Waitframe(this, ghost, vars);
					}
					ang = Angle(Ghost_X, Ghost_Y, Link->X, Link->Y);
					Ghost_Data = combo+4;
					for(i=-60; i<=60; i+=30){
						e = FireEWeapon(EW_SCRIPT10, Ghost_X, Ghost_Y, DegtoRad(ang+i), 0, ghost->WeaponDamage, SPR_DIMENTIO_FIREBALL, SFX_FIREBALL, EWF_UNBLOCKABLE);
						SetEWeaponLifespan(e, EWL_SLOW_TO_HALT, -3);
						e = FireEWeapon(EW_SCRIPT10, Ghost_X, Ghost_Y, DegtoRad(ang-i), 0, ghost->WeaponDamage, SPR_DIMENTIO_FIREBALL, SFX_FIREBALL, EWF_UNBLOCKABLE);
						SetEWeaponLifespan(e, EWL_SLOW_TO_HALT, -3);
						diffMod[0] = LazyDiffMod(12, 10, 8);
						for(j=0; j<diffMod[0]; j++){
							Ghost_Dir = AngleDir4(Angle(Ghost_X, Ghost_Y, Link->X, Link->Y));
							TCTWD_Waitframe(this, ghost, vars);
						}
					}
					for(i=-45; i<=45; i+=15){
						e = FireEWeapon(EW_SCRIPT10, Ghost_X, Ghost_Y, DegtoRad(ang+i), 0, ghost->WeaponDamage, SPR_DIMENTIO_FIREBALL, SFX_FIREBALL, EWF_UNBLOCKABLE);
						SetEWeaponLifespan(e, EWL_SLOW_TO_HALT, -6);
						e = FireEWeapon(EW_SCRIPT10, Ghost_X, Ghost_Y, DegtoRad(ang-i), 0, ghost->WeaponDamage, SPR_DIMENTIO_FIREBALL, SFX_FIREBALL, EWF_UNBLOCKABLE);
						SetEWeaponLifespan(e, EWL_SLOW_TO_HALT, -6);
						diffMod[0] = LazyDiffMod(12, 10, 8);
						for(j=0; j<diffMod[0]; j++){
							Ghost_Dir = AngleDir4(Angle(Ghost_X, Ghost_Y, Link->X, Link->Y));
							TCTWD_Waitframe(this, ghost, vars);
						}
					}
					Ghost_Data = combo;
					attackCooldown = 160;
					Screen->D[3] = 0;
				}
			}
			
			Ghost_Dir = AngleDir4(Angle(Ghost_X, Ghost_Y, Link->X, Link->Y));
			
			if(Screen->D[2]){
				bool grabbed = false;
				Ghost_Data = combo;
				while(Screen->D[2]){
					ang = Angle(Ghost_X, Ghost_Y, Link->X, Link->Y);
					Ghost_MoveAtAngle(ang, 4, 1);
					if(LinkCollision(ghost)){
						grabbed=true;
						break;
					}
					TCTWD_Waitframe(this, ghost, vars);
				}
				if(grabbed){
					ang = Angle(Link->X, Link->Y, Ghost_X, Ghost_Y);
					Ghost_Dir = AngleDir4(WrapDegrees(ang+180));
					i = 0;
					while(Screen->D[2]){
						i++;
						Ghost_X = Link->X+VectorX(8+8*Sin(i*32), ang);
						Ghost_Y = Link->Y+VectorY(8+8*Sin(i*32), ang);
						
						TCTWD_Waitframe(this, ghost, vars);
					}
					for(i=0; i<24; i++){
						Ghost_MoveAtAngle(ang, 4, 0);
						Screen->FastTile(0, Link->X, Link->Y, TIL_LINKPRONE, 6, 128);
						
						TCTWD_Waitframe(this, ghost, vars);
					}
				}
			}
			
			
			TCTWD_Waitframe(this, ghost, vars);
		}
	}
	void TCTWD_FindTeleport(npc ghost, int xy){
		for(int i=0; i<176*2; i++){
			if(i<176){
				xy[0] = Rand(32, 208);
				xy[1] = Rand(32, 128);
			}
			else{
				xy[0] = ComboX(i-176);
				xy[1] = ComboY(i-176);
			}
			if(Ghost_CanPlace(xy[0], xy[1], ghost->HitWidth, ghost->HitHeight)&&Distance(xy[0], xy[1], Link->X, Link->Y)>80)
				return;
		}
	}
	void TCTWD_Teleport(ffc this, npc ghost, int vars, int x, int y){
		int i;
		
		int startX = Ghost_X;
		int startY = Ghost_Y;
		int dist = Distance(startX, startY, x, y);
		int ang = Angle(startX, startY, x, y);
		int x2; int y2;
		int r = 0;
		ghost->CollDetection = false;
		ghost->DrawYOffset = -1000;
		for(i=8; i>0; i--){
			r = 4+i/2;
			Screen->Circle(0, startX+8, startY+8, r+0.1*r+0.1*r*Sin(vars[0]), 0x0F, 1, 0, 0, 0, true, 128);
			TCTWD_Waitframe(this, ghost, vars);
		}
		for(i=0; i<8; i++){
			r = 8;
			x2 = startX + VectorX(dist*(i/8), ang);
			y2 = startY + VectorY(dist*(i/8), ang);
			Screen->Circle(0, x2+8, y2+8, r+0.1*r+0.1*r*Sin(vars[0]), 0x0F, 1, 0, 0, 0, true, 128);
			TCTWD_Waitframe(this, ghost, vars);
		}
		for(i=0; i<8; i++){
			r = 4+i/2;
			Screen->Circle(0, x+8, y+8, r+0.1*r+0.1*r*Sin(vars[0]), 0x0F, 1, 0, 0, 0, true, 128);
			TCTWD_Waitframe(this, ghost, vars);
		}
		Ghost_X = x;
		Ghost_Y = y;
		ghost->CollDetection = true;
		ghost->DrawYOffset = -2;
	}
	void TCTWD_Waitframe(ffc this, npc ghost, int vars){
		vars[0] += 1;
		vars[0] %= 360;
		
		if(!Q7_Ghost_Waitframe(this, ghost, true, false)){
			if(Screen->D[3]==2)
				Screen->D[3] = 0;
			Quit();
		}
	}
}

item script SuperBombPickup{
	void run(int msg, int id){
		if(id>0){
			if(!ItemStringsPlayed[id]){
				ItemStringsPlayed[id] = true;
				if(!Link->Item[I_SETTING_NOITEMTEXT])
					QueueMessage(msg);
			}
		}
		else{
			if(!Link->Item[I_SETTING_NOITEMTEXT])
				QueueMessage(msg);
		}
		
		G[G_HASSBOMB] = 1;
		G[G_SBOMBTIMER] = 300;
	}
}

const int CMB_SUPERBOMB = 5542;

ffc script SuperBomb{
	void run(){
		int bombX = Link->X;
		int bombY = Link->Y;
		int bombJump = 1.2;
		int bombZ = 0;
		int bombPickupCooldown;
		while(true){
			bombJump = Clamp(bombJump-0.16, -3.2, 3.2);
			bombZ = Max(0, bombZ+bombJump);
			
			if(G[G_HASSBOMB]){
				if(bombZ==0)
					bombJump = 1.5;
			
				if(Distance(bombX, bombY, Link->X, Link->Y)>12){
					int angle = Angle(bombX, bombY, Link->X, Link->Y);
					bombX += VectorX(1.5, angle);
					bombY += VectorY(1.5, angle);
				}
				
				
				bool attacking = false;
				lweapon sword = LoadLWeaponOf(LW_SWORD);
				if(sword->isValid())
					attacking = true;
				if(Link->PressA)//(!Link->Item[I_SWORD1]&&Link->PressA)
					attacking = true;
				lweapon wand = LoadLWeaponOf(LW_WAND);
				if(wand->isValid())
					attacking = true;
				if(attacking||Link->Action==LA_GOTHURTLAND||Link->Action==LA_GOTHURTWATER){
					if(attacking){
						bombX = Link->X;
						bombY = Link->Y;
					}
					G[G_HASSBOMB] = 0;
					G[G_SBOMBTIMER] = Max(G[G_SBOMBTIMER], 90);
					bombPickupCooldown = 60;
					Game->PlaySound(SFX_PLACE);
				}
				
				Screen->FastCombo(2, bombX, bombY-bombZ, CMB_SUPERBOMB, 8, 128);
			}
			else{
				if(G[G_SBOMBTIMER]>0){
					G[G_SBOMBTIMER]--;
					if(bombPickupCooldown>0)
						bombPickupCooldown--;
					else if(Distance(Link->X, Link->Y, bombX, bombY)<16){
						Game->PlaySound(SFX_PLINK);
						G[G_HASSBOMB] = 1;
					}
				}
				else{
					for(int i=0; i<8; i++){
						lweapon l = CreateLWeaponAt(LW_SBOMBBLAST, bombX+Rand(-24, 24), bombY+Rand(-24, 24));
						l->Damage = 32;
						l->Dir = Link->Dir + 8;
						Waitframes(2);
					}
					G[G_HASSBOMB] = 0;
					Quit();
				}
				
				Screen->FastCombo(2, bombX, bombY-bombZ, CMB_SUPERBOMB+1, 8, 128);
			}
			Waitframe();
		}
	}
}

const int NPC_REPRODUCTIONROCK = 296;

ffc script RockLynel{
	void run(int enemyid){
		npc ghost = Ghost_InitAutoGhost(this, enemyid);
		this->Flags[FFCF_ETHEREAL] = true;
		
		Ghost_SetFlag(GHF_4WAY);
		Ghost_SetFlag(GHF_KNOCKBACK);
		
		int combo = ghost->Attributes[10];
		int counter = -1;
		//int enemyid, int repetitions, int delay, int sp, int x, int y){
		while(true){
			if(!ghost->Stun)
				counter = Ghost_HaltingWalk4(counter, ghost->Step, ghost->Rate, ghost->Homing, ghost->Haltrate, ghost->Hunger, 48);
			if(counter==16){
				Ghost_Data = combo+4;
				Ghost_UnsetFlag(GHF_KNOCKBACK);
				for(int i=0; i<16; i++){
					if(Link->HP>0)
						Screen->FastCombo(4, Ghost_X, Ghost_Y-12, combo+8, 8, 128);
					Q7_Ghost_Waitframe(this, ghost);
				}
				Ghost_Dir = DIR_DOWN;
				for(int i=0; i<16; i++){
					if(Link->HP>0)
						Screen->FastCombo(4, Ghost_X, Ghost_Y-12, combo+8, 8, 128);
					Q7_Ghost_Waitframe(this, ghost);
				}
				npc n = CreateNPCAt(NPC_REPRODUCTIONROCK, Ghost_X, Ghost_Y-12);
				for(int i=0; i<16; i++){
					Q7_Ghost_Waitframe(this, ghost);
				}
				Ghost_SetFlag(GHF_KNOCKBACK);
				Ghost_Data = combo;
				counter = -1;
			}
			Q7_Ghost_Waitframe(this, ghost);
		}
	}
}

ffc script ReproductionRock{
	void run(int enemyid){
		npc ghost = Ghost_InitAutoGhost(this, enemyid);
		this->Flags[FFCF_ETHEREAL] = true;
		
		int vars[16] = {-1, 0, 0, 0, 0, -1, 1};
		vars[5] = ghost->Attributes[0];
		
		while(true){
			RR_Update(this, ghost, vars);
			Q7_Ghost_Waitframe(this, ghost);
		}
	}
	void RR_Update(ffc this, npc ghost, int vars){
		//nightmares ahead
		
		//vars[0] = clk2 (Respawn clock)
		//vars[1] = clk3 (Bounce time)
		//vars[2] = dummy_int[1] (Last Direction)
		//vars[3] = dummy_int[2] (Diagonal direction)
		//vars[4] = dir
		//vars[5] = Remaining loops
		//vars[6] = Skip Start
    
		
		++vars[0];
		if(vars[0]==0) // start it
		{
			if(!vars[6]){
				Ghost_X = Rand(240);
				Ghost_Y = 0;
			}
			vars[6] = 0;
			vars[1]=0;
			vars[0]=Rand(16);
		}
    
		if(vars[0]>16) // move it
		{
			if(vars[1]<=0) // start bounce
			{
				vars[4] = Rand(DIR_LEFT, DIR_RIGHT);
				
				if(Ghost_X<32)  
					vars[4] = DIR_RIGHT;
				
				if(Ghost_X>208) 
					vars[4] = DIR_LEFT;
			}
			
			if(vars[1]<13+16)
			{
				Ghost_X += Cond(vars[4]==DIR_LEFT, -1, 1)*ghost->Step*0.01; //right, left
				vars[2]=vars[4];
				
				if(vars[1]<2)
				{
					Ghost_Y -= 2*ghost->Step*0.01;    //up
					vars[3] = Cond(vars[2]==DIR_RIGHT, DIR_RIGHTUP, DIR_LEFTUP); //vars[3]=(dummy_int[1]==1)?r_up:l_up;
				}
				else if(vars[1]<5)
				{
					Ghost_Y -= 1*ghost->Step*0.01;    //up
					vars[3] = Cond(vars[2]==DIR_RIGHT, DIR_RIGHTUP, DIR_LEFTUP); //(dummy_int[1]==1)?r_up:l_up;
				}
				else if(vars[1]<8)
				{
					vars[3] = Cond(vars[2]==DIR_RIGHT, DIR_RIGHT, DIR_LEFT); //vars[3] = (dummy_int[1]==1)?right:left;
				}
				else if(vars[1]<11)
				{
					Ghost_Y += 1*ghost->Step*0.01;   //down
					vars[3] = Cond(vars[2]==DIR_RIGHT, DIR_RIGHTDOWN, DIR_LEFTDOWN); //vars[3] = (dummy_int[1]==1)?r_down:l_down;
				}
				else
				{
					Ghost_Y += 2*ghost->Step*0.01; //down
					vars[3] = Cond(vars[2]==DIR_RIGHT, DIR_RIGHTDOWN, DIR_LEFTDOWN); //vars[3] = (dummy_int[1]==1)?r_down:l_down;
				}
				
				++vars[1];
			}
			else if(Ghost_Y<176)
				vars[1] = 0; // next bounce
			else{
				if(vars[5]>0)
					vars[5]--;
				if(vars[5]!=0){
					vars[0] = -Rand(64); // back to top
				}
				else{
					ghost->DrawYOffset = -1000;
					ghost->HP = -1000;
					ghost->CollDetection = false;
					ghost->ItemSet = 0;
					this->Data = 0;
					Quit();
				}
			}
		
			Ghost_Dir = vars[4];
		}
	}
}

const int SPR_BOMBNONDIR = 102;

ffc script Zirro{
	void run(int enemyid){
		npc ghost = Ghost_InitAutoGhost(this, enemyid);
		this->Flags[FFCF_ETHEREAL] = true;
		
		Ghost_Transform(this, ghost, -1, -1, 2, 1);
		Ghost_SetHitOffsets(ghost, 0, 0, 4, 4);
		
		Ghost_SetFlag(GHF_STUN);
		Ghost_SetFlag(GHF_FLYING_ENEMY);
		Ghost_SetFlag(GHF_IGNORE_SOLIDITY);
		Ghost_SetFlag(GHF_FAKE_Z);
		Ghost_SetFlag(GHF_NO_FALL);
		
		int vars[16] = {0};
		
		int counter = -1;
		
		int attackCooldown = Choose(60, 120, 180);
		int lungeCooldown;
		
		while(true){
			counter = Ghost_ConstantWalk8(counter, ghost->Step, ghost->Rate, ghost->Homing, ghost->Hunger);
			
			if(lungeCooldown>0)
				lungeCooldown--;
			else if(Distance(Ghost_X+8, Ghost_Y, Link->X, Link->Y)<48&&IsHardMode()){
				int angle = Angle(Ghost_X+8, Ghost_Y, Link->X, Link->Y);
				for(int i=0; i<32; i++){
					Zirro_Waitframe(this, ghost, vars);
				}
				for(int i=0; i<24; i++){
					int angle2 = AngDiff(Angle(Ghost_X+8, Ghost_Y, Link->X, Link->Y), angle);
					if(i%4==0){
						eweapon e = FireEWeapon(EW_BOMB, Ghost_X+8, Ghost_Y-Ghost_Z, DegtoRad(angle+angle2/2), 250, ghost->WeaponDamage, SPR_BOMBNONDIR, SFX_ROCK, EWF_UNBLOCKABLE);
						SetEWeaponMovement(e, EWM_THROW, 2, EWMF_DIE);
						SetEWeaponDeathEffect(e, EWD_EXPLODE, e->Damage);
					}
					Ghost_MoveAtAngle(angle, 2, 4);
					Zirro_Waitframe(this, ghost, vars);
				}
				lungeCooldown = 90;
			}
			
			if(attackCooldown>0)
				attackCooldown--;
			else if(Rand(24)==0){
				eweapon e = FireAimedEWeapon(EW_BOMB, Ghost_X+8, Ghost_Y-Ghost_Z, 0, 200, ghost->WeaponDamage, SPR_BOMBNONDIR, SFX_ROCK, EWF_UNBLOCKABLE);
				SetEWeaponMovement(e, EWM_THROW, 2.4, EWMF_DIE);
				SetEWeaponDeathEffect(e, EWD_EXPLODE, e->Damage);
				
				attackCooldown = Choose(120, 180);
			}
			ghost->Tile = Game->ComboTile(Ghost_Data);
			Zirro_Waitframe(this, ghost, vars);
		}
	}
	void Zirro_Waitframe(ffc this, npc ghost, int vars){
		++vars[0];
		vars[0] %= 360;
		
		Ghost_Z = 8+4*Sin(vars[0]*2);
		
		Q7_Ghost_Waitframe(this, ghost);
	}
}

const int LW_PHASECLOAK_BOMB = 39; //Script 9

const int DAMAGE_PHASECLOAK_BOMB = 6;

const int TIL_PHASECLOAK_BOMB = 1670;

const int SFX_PHASECLOAK_BOMB = 39;

ffc script PhaseCloak_Bomb{
	void run(int x, int y){
		int i; int j;
		for(i=0; i<10; i++){
			for(j=0; j<4; j++){
				Screen->FastTile(2, x, y, TIL_PHASECLOAK_BOMB+i, 11, 128);
				Waitframe();
			}
		}
		int angle1 = Rand(360);
		int angle2 = Rand(360);
		int angle3 = Rand(360);
		int x2; int y2;
		int cs = 10;
		lweapon ring[20];
		Game->PlaySound(SFX_PHASECLOAK_BOMB);
		for(i=0; i<30; i++){
			angle1 += 6;
			angle2 -= 10;
			for(j=0; j<10; j++){
				x2 = x+VectorX(24*(1+Sin(i*6)+0.2*Sin(angle3+j*36*8+i*8))*0.5, angle1+j*36);
				y2 = y+VectorY(24*(1+Sin(i*6)+0.2*Sin(angle3+j*36*8+i*8))*0.5, angle1+j*36);
				
				if(!ring[j]->isValid()){
					ring[j] = CreateLWeaponAt(LW_PHASECLOAK_BOMB, x2, y2);
					ring[j]->Dir = -1;
					ring[j]->Damage = DAMAGE_PHASECLOAK_BOMB*G[G_HPSCALE];
					ring[j]->CSet = cs;
				}
				ring[j]->Tile = TIL_PHASECLOAK_BOMB+20+(Floor(i/2)+2*j)%8;
				ring[j]->X = x2;
				ring[j]->Y = y2;
				
				x2 = x+VectorX(32*(1+Sin(i*6)+0.2*Sin(angle3+j*36*8+i*8))*0.5, angle2+j*36);
				y2 = y+VectorY(32*(1+Sin(i*6)+0.2*Sin(angle3+j*36*8+i*8))*0.5, angle2+j*36);
				
				if(!ring[j+10]->isValid()){
					ring[j+10] = CreateLWeaponAt(LW_PHASECLOAK_BOMB, x2, y2);
					ring[j+10]->Dir = -1;
					ring[j+10]->Damage = DAMAGE_PHASECLOAK_BOMB*G[G_HPSCALE];
					ring[j+10]->CSet = cs;
				}
				ring[j+10]->Tile = TIL_PHASECLOAK_BOMB+20+(Floor(i/2)+2*j)%8;
				ring[j+10]->X = x2;
				ring[j+10]->Y = y2;
			}
			Waitframe();
		}
		for(j=0; j<20; j++){
			if(ring[j]->isValid())
				ring[j]->DeadState = 0;
		}
	}
}

const int DAMAGE_HYPERWAND_SPIN = 4;

item script HyperWand{
	void run(){
		int scr[] = "HyperWandFFC";
		if(CountFFCsRunning(Game->GetFFCScript(scr))==0){
			RunFFCScript(Game->GetFFCScript(scr), 0);
		}
	}
}

ffc script HyperWandFFC{
	void run(){
		int i; int j;
		int x; int y;
		lweapon spin[2];
		lweapon wand;
		
		for(i=0; i<16; i++){
			wand = LoadLWeaponOf(LW_WAND);
			if(wand->isValid())
				break;
			Waitframe();
		}
		
		for(i=0; i<2; i++){
			spin[i] = CreateLWeaponAt(LW_SCRIPT10, Link->X, Link->Y);
			spin[i]->UseSprite(16);
			spin[i]->Dir = Link->Dir;
			spin[i]->Step = 0;
			spin[i]->Damage = DAMAGE_HYPERWAND_SPIN*G[G_HPSCALE];
		}
		for(j=0; j<18; j++){
			for(i=0; i<2; i++){
				x = Link->X+VectorX(16, Q7_DirAngle(Link->Dir)-90+40*j+180*i);
				y = Link->Y+VectorY(16, Q7_DirAngle(Link->Dir)-90+40*j+180*i);
				spin[i]->X = x;
				spin[i]->Y = y;
				spin[i]->Dir = Link->Dir;
				spin[i]->Tile = spin[i]->OriginalTile;
				if(spin[i]->Dir>=2)
					spin[i]->Tile++;
				if(spin[i]->Dir==DIR_DOWN)
					spin[i]->Flip = 2;
				else if(spin[i]->Dir==DIR_LEFT)
					spin[i]->Flip = 1;
			}
			Waitframe();
		}
		for(i=0; i<2; i++){
			if(spin[i]->isValid()){
				x = Link->X+VectorX(16, Q7_DirAngle(Link->Dir)-90+180*i);
				y = Link->Y+VectorY(16, Q7_DirAngle(Link->Dir)-90+180*i);
				
				lweapon l = CreateLWeaponAt(LW_MAGIC, x, y);
				l->UseSprite(16);
				l->Dir = Link->Dir;
				l->Step = 400;
				l->Damage = DAMAGE_HYPERWAND_SPIN*G[G_HPSCALE];
				
				l->Tile = spin[i]->OriginalTile;
				if(l->Dir>=2)
					l->Tile++;
				if(l->Dir==DIR_DOWN)
					l->Flip = 2;
				else if(l->Dir==DIR_LEFT)
					l->Flip = 1;
				l->Step = 400;
				
				spin[i]->DeadState = 0;
			}
		}
	}
}

const int NPC_RAINSFX = 299;
const int SPR_RAINSPLASH = 108;

const int SFX_LIGHTNING_STRIKE = 78;

const int RT_RAIN = 1;

ffc script RainEffect{
	void run(){
		int rainX[128];
		int rainY[128];
		int rainAngle[128];
		int rainT[128];
		
		int rain[] = {rainX, rainY, rainAngle, rainT, 4, 0};
		
		if(Game->GetCurDMap()==24){ //Level 9 outer ring
			rain[4] = 3;
			rain[5] = 1;
		}
		else if(Game->GetCurDMap()==16){ //Level 9 F7B
			rain[4] = 6;
		}
		else if(Game->GetCurDMap()==37||Game->GetCurDMap()==68){ //Level 9 F7B
			rain[4] = 0;
			rain[5] = 1;
			Screen->SetRenderTarget(RT_RAIN);
			Screen->Rectangle(0, 0, 0, 511, 511, 0x00, 1, 0, 0, 0, true, 128);
			Screen->SetRenderTarget(RT_SCREEN);
		}
		
		int flashTime;
		
		Droplets_Init(rain, 32);
		while(true){
			if(Game->GetCurDMap()==24||Game->GetCurDMap()==16){
				if(G[G_DARMLIGHTNINGCOOLDOWN]>0)
					G[G_DARMLIGHTNINGCOOLDOWN]--;
				else if(Rand(24)==0){
					flashTime = 24;
					Game->PlaySound(SFX_LIGHTNING_STRIKE);
					G[G_DARMLIGHTNINGCOOLDOWN] = 300+Rand(120);
				}
			}
			
			if(flashTime>0){
				int flashLayer = 3;
				if(Game->GetCurDMap()==16)
					flashLayer = 6;
				flashTime--;
				int intensity = Abs(flashTime-12);
				if(intensity<3)
					Screen->Rectangle(flashLayer, 0, 0, 255, 175, 0x01, 1, 0, 0, 0, true, 128);
				if(intensity<6)
					Screen->Rectangle(flashLayer, 0, 0, 255, 175, 0x01, 1, 0, 0, 0, true, 64);
				if(intensity<9)
					Screen->Rectangle(flashLayer, 0, 0, 255, 175, 0x01, 1, 0, 0, 0, true, 64);
				if(Game->GetCurDMap()==24){
					if(intensity<9&&flashTime%5==0){
						Screen->Rectangle(6, 0, 88, 255, 175, 0x01, 1, 0, 0, 0, true, 64);
						Screen->Rectangle(6, 64, 0, 80, 87, 0x01, 1, 0, 0, 0, true, 64);
						Screen->Rectangle(6, 176, 0, 192, 87, 0x01, 1, 0, 0, 0, true, 64);
					}
				}
			}
			
			Droplets_Update(rain, 32);
			if(rain[4]==0){
				Screen->SetRenderTarget(RT_RAIN);
				for(int i=0; i<176; i++){
					if(Screen->ComboT[i]!=CT_LADDERHOOKSHOT){
						Screen->Rectangle(0, ComboX(i), ComboY(i), ComboX(i)+15, ComboY(i)+15, 0, 1, 0, 0, 0, true, 128);
					}
				}
				Screen->SetRenderTarget(RT_SCREEN);
				Screen->DrawBitmap(0, RT_RAIN, 0, 0, 256, 176, 0, 0, 256, 176, 0, true);
			}
			
			Waitframe();
		}
	}
	void Droplets_Init(int rain, int total){
		int rainX = rain[0];
		int rainY = rain[1];
		int rainAngle = rain[2];
		int rainT = rain[3];
		
		for(int i=0; i<total; i++){
			rainX[i] = Rand(-32, 256);
			rainY[i] = Rand(0, 176+32);
			rainAngle[i] = -70+Rand(-10, 10);
			rainT[i] = Rand(24);
		}
	}
	void Droplets_Update(int rain, int total){
		int rainX = rain[0];
		int rainY = rain[1];
		int rainAngle = rain[2];
		int rainT = rain[3];
		
		if(rain[4]==0){
			Screen->SetRenderTarget(RT_RAIN);
			Screen->Rectangle(0, 0, 0, 511, 511, 0x00, 1, 0, 0, 0, true, 128);
		}
		for(int i=0; i<total; i++){
			int dist1 = Max(rainT[i]*16-96, 0);
			int dist2 = Max(rainT[i]*16, 0);
			int x1 = rainX[i] + VectorX(dist1, rainAngle[i]);
			int y1 = rainY[i] + VectorY(dist1, rainAngle[i]);
			int x2 = rainX[i] + VectorX(dist2, rainAngle[i]);
			int y2 = rainY[i] + VectorY(dist2, rainAngle[i]);
			Screen->Line(rain[4], x1, y1, x2, y2, 0x01, 1, 0, 0, 0, 128);
			rainT[i]--;
			if(rainT[i]<=0){
				int ct = Screen->ComboT[ComboAt(rainX[i], rainY[i])];
				int cf = Screen->ComboF[ComboAt(rainX[i], rainY[i])];
				if(cf!=CF_NOGROUNDENEMY&&rain[5]==0)
					SpriteAnim(rainX[i]-8, rainY[i]-8, SPR_RAINSPLASH, 1, 1);
				
				bool revealGannon;
				if(G[G_GANNONX]>0&&G[G_GANNONY]>0){
					if(Rand(4)!=0)
						revealGannon = true;
				}
				
				if(revealGannon){
					rainX[i] = G[G_GANNONX] + Rand(-24, 24);
					rainY[i] = G[G_GANNONY] + Rand(-24, 24);
					G[G_GANNONX] = 0;
					G[G_GANNONY] = 0;
				}
				else{
					rainX[i] = Rand(-32, 256);
					rainY[i] = Rand(0, 176+32);
				}
				rainAngle[i] = -70+Rand(-10, 10);
				rainT[i] = Rand(24);
			}
		}
		if(rain[4]==0)
			Screen->SetRenderTarget(RT_SCREEN);
	}
}

ffc script FountainsOfTheDeep{
	void run(int flag, int cd){
		if(Game->GetCurDMap()==22){
			for(int i=0; i<176; i++){
				if(Screen->ComboF[i]==flag){
					Screen->ComboD[i] = cd;
					Screen->ComboC[i] = this->CSet;
				}
			}
		}
	}
}

ffc script GlobalScriptFrame1IsAllKindsOfJankLemmeTellYou{
	void run(){
		Waitframe();
		for(int i=0; i<4; i++){
			if(Screen->GetSideWarpType(i)==WT_NOWARP){
				Screen->SetSideWarp(i, Screen->GetSideWarpScreen(i), Screen->GetSideWarpDMap(i), WT_ENTRANCEEXIT);
			}
		}
	}
}

const int SHUTTER_INVISIBLE_COMBO = 1; //Set this to a combo that when placed on a 4x4 FFC will be invisible.

const int CMB_BOMBWALL_MARKER = 0; //Combo used for the hint marker when using the lens on a bomb wall
const int CS_BOMBWALL_MARKER = 7; //CSet of the hint marker

const int D_LTTPDOORS = 5; //Screen->D[] (0-7) index used for directional doors
const int D_LTTPDOORID = 6; //Screen->D[] (0-7) index used for ID'd doors

const int SHUTTER_USE_FFC_CSET = 0; //If 1, will set shutters to the FFC's CSet. Else keep the CSets below the FFC.

const int SHUTTER_OPEN_FRAMES = 0; //How long in frames (60ths of a second) an animated shutter takes to open
const int SHUTTER_LOCK_OPEN_FRAMES = 0; //How long in frames (60ths of a second) an animated locked door takes to open
const int SHUTTER_BOSS_LOCK_OPEN_FRAMES = 0; //How long in frames (60ths of a second) an animated boss lock door takes to open

const int SHUTTER_REPEAT_DELAY_FRAMES = 12; //Delay between a shutter closing and opening
const int SHUTTER_LOCK_ACTIVATION_FRAMES = 12; //Delay when pushing against a locked door before it opens

const int SFX_SHUTTER_OPEN = 9; //SFX of a shutter opening
const int SFX_SHUTTER_CLOSE = 9; //SFX of a shutter closing
const int SFX_LOCK_OPEN = 9; //SFX of a lock opening
const int SFX_BOSS_LOCK_OPEN = 9; //SFX of a boss lock opening
const int SFX_BOMB_WALL_OPEN = 0; //SFX of a bomb wall being blasted open

const int LENS_MP_COST = 0; //The MP cost of the lens item

//If you have different/more lens items in your quest, this function will need to be changed
bool UsingLens(){
	if(Link->MP<LENS_MP_COST)
		return false;
	if(GetEquipmentA()==I_LENS&&Link->InputA)
		return true;
	if(GetEquipmentB()==I_LENS&&Link->InputB)
		return true;
	return false;
}

bool BombWall_HoldingItemButton(int id){
		if(GetEquipmentA()==id&&Link->InputA)
			return true;
		if(GetEquipmentB()==id&&Link->InputB)
			return true;
		return false;
	}

//LttP Shutter
//D0: Direction to the wall the shutter is on - 0: Up, 1: Down, 2: Left, 3: Right
//D1: Trigger type for the shutter
//		0: One way
//		1: Kill enemies
//		2: Push block
//		3: Combo change
//		4: Perm secret
//D2: Combo position of the trigger combo for a combo change (3) shutter
//D6: If using an opening animation, this is the first of the combo groups, starting with a closed door.
//	  Opening combo groups should be arranged vertically and be made up of doors the same size as the FFC.
//D7: If using an opening animation, this is the number of frames in the animation.

ffc script LttP_Shutter{
	void run(int dir, int openTrigger, int triggerPos, int d3, int d4, int layer, int openingCmb, int openingFrames){
		int comboPos = ComboAt(this->X+8, this->Y+8);
		
		int closedCmb = this->Data;
		int openCmb = this->Data+4*this->TileHeight;
		this->Data = SHUTTER_INVISIBLE_COMBO;
		
		//Uncheck flags that make the FFC invisible during scrolling
		this->Flags[FFCF_LENSVIS] = false;
		this->Flags[FFCF_CHANGER] = false;
		
		int triggerCD = Screen->ComboD[triggerPos];
		int triggerCC = Screen->ComboC[triggerPos];
		int triggerCF = Screen->ComboF[triggerPos];
		
		bool open = false;
		bool silentOpen = false;
		if(IsEasyMode()||Q7_CheatEnabled(G_MODE_EASYNAVIGATION)){
			if(open){
				Screen->D[D_EASYMODESHUTTERS] |= (1<<dir);
			}
			else{
				if(Screen->D[D_EASYMODESHUTTERS]&(1<<dir)){
					open = true;
					silentOpen = true;
				}
			}
		}
		
		//Set opening combo relative to the open and closed states if not set
		if(openingCmb==0&&openingFrames>0){
			openingCmb = closedCmb+2*(4*this->TileHeight);
		}
		
		int linkX = Link->X;
		int linkY = Link->Y;
		//If the script is running while the screen is scrolling, Link's position will be flipped.
		if(this->Flags[FFCF_PRELOAD]){
			if(dir==DIR_UP||dir==DIR_DOWN){
				if(linkY<=0)
					linkY = 160;
				else if(linkY>=160)
					linkY = 0;
			}
			else{
				if(linkX<=0)
					linkX = 240;
				else if(linkX>=240)
					linkX = 0;
			}
		}
		
		// >using variables as labels
		// shiggydiggy
		int SHUTTER_STATE = 0; //0 = Closed, 1 = Opening, 2 = Open, 3 = Closing
		int SHUTTER_FRAMES = 1;
		int SHUTTER_OPENCMB = 2;
		int SHUTTER_CLOSEDCMB = 3;
		int SHUTTER_COMBOPOS = 4;
		int shutter[16] = {0, 0, openCmb, closedCmb, comboPos};
		
		if(openTrigger==4&&Screen->State[ST_SECRET]){ //Doors triggered by secret state don't need to run if it's already set
			Shutter_SetCombos(this, layer, comboPos, openCmb);
			Quit();
		}
			
		int shutterCooldown;
		
		//If Link entered from this shutter, push him out and close it
		if(!open&&Shutter_LinkCollide(this, dir, linkX, linkY, false)){
			shutterCooldown = SHUTTER_REPEAT_DELAY_FRAMES;
			shutter[SHUTTER_STATE] = 2; //Open
			Shutter_SetCombos(this, layer, comboPos, openCmb);
			Waitframe();
			while(Link->Action==LA_SCROLLING||Shutter_LinkCollide(this, dir, Link->X, Link->Y, true)){
				if(Link->Action!=LA_SCROLLING)
					Shutter_MoveLink(dir);
				Waitframe();
			}
			Shutter_EjectLink(this, dir);
			Shutter_Close(this, layer, shutter, openingFrames, false);
		}
		else{
			if(this->Flags[FFCF_PRELOAD]){
				if(open)
					Shutter_SetCombos(this, layer, comboPos, openCmb);
				else
					Shutter_SetCombos(this, layer, comboPos, closedCmb);
				//Wait for screen to finish scrolling so Link doesn't get teleported during the animation
				Waitframe();
				while(Link->Action==LA_SCROLLING){
					Waitframe();
				}
			}
			else{
				if(open)
					Shutter_Open(this, layer, shutter, openingFrames, silentOpen);
				else
					Shutter_Close(this, layer, shutter, openingFrames, silentOpen);
			}
		}
		
		bool wasBlock = false;
		bool blockPuzzle = false;
		if(Shutter_CountBlockTriggers()>0)
			blockPuzzle = true;
			
		int enemyCooldown = 12;
		
		while(true){
			silentOpen = false;
			if(IsEasyMode()||Q7_CheatEnabled(G_MODE_EASYNAVIGATION)){
				if(open){
					Screen->D[D_EASYMODESHUTTERS] |= (1<<dir);
				}
				else{
					if(Screen->D[D_EASYMODESHUTTERS]&(1<<dir)){
						open = true;
						silentOpen = true;
					}
				}
			}
			
			if(openTrigger==1){ //Enemies
				if(enemyCooldown>0)
					enemyCooldown--;
				else{
					if(Shutter_CountNPCs()==0)
						open = true;
				}
			}
			else if(openTrigger==2){ //Block
				if(blockPuzzle){ //Block puzzle secrets should override screens that just have blocks
					if(Shutter_CountBlockTriggers()==0)
						open = true;
				}
				else{
					if(Screen->MovingBlockX>-1||Screen->MovingBlockY>-1)
						wasBlock = true;
					else if(wasBlock)
						open = true;
				}
			}
			else if(openTrigger==3){ //Combo change
				if(triggerCD!=Screen->ComboD[triggerPos]||triggerCC!=Screen->ComboC[triggerPos]||triggerCF!=Screen->ComboF[triggerPos]){
					open = true;
				}
				else{
					//if(!Shutter_LinkCollide(this, dir, Link->X, Link->Y, true))
						open = false;
				}
			}
			else if(openTrigger==4){ //Perm secret
				if(Screen->State[ST_SECRET])
					open = true;
			}
			
			if(shutter[SHUTTER_STATE]==0&&Shutter_LinkCollide(this, dir, Link->X, Link->Y, false))
				Shutter_EjectLink(this, dir);
			
			//Open and close the shutter if it should be closed/open but isn't
			if(open&&shutter[SHUTTER_STATE]==0){
				if(shutterCooldown>0)
					shutterCooldown--;
				else
					Shutter_Open(this, layer, shutter, openingFrames, silentOpen);
			}
			else if(!open&&shutter[SHUTTER_STATE]==2){
				Shutter_Close(this, layer, shutter, openingFrames, silentOpen);
				shutterCooldown = SHUTTER_REPEAT_DELAY_FRAMES;
			}
				
			Shutter_Update(this, layer, shutter, openingCmb, openingFrames);
			Waitframe();
		}
	}
	bool Shutter_Update(ffc this, int layer, int shutter, int openingCmb, int openingFrames){
		int SHUTTER_STATE = 0;
		int SHUTTER_FRAMES = 1;
		int SHUTTER_OPENCMB = 2;
		int SHUTTER_CLOSEDCMB = 3;
		int SHUTTER_COMBOPOS = 4;
		int curFrame;
		if(shutter[SHUTTER_STATE]==1){ //Opening
			if(shutter[SHUTTER_FRAMES]>0){
				shutter[SHUTTER_FRAMES]--;
				curFrame = Clamp(Floor((SHUTTER_OPEN_FRAMES-shutter[SHUTTER_FRAMES])/(SHUTTER_OPEN_FRAMES/openingFrames)), 0, openingFrames-1);
				Shutter_SetCombos(this, layer, shutter[SHUTTER_COMBOPOS], openingCmb+curFrame*(4*this->TileHeight));
			}
			else{
				Shutter_SetCombos(this, layer, shutter[SHUTTER_COMBOPOS], shutter[SHUTTER_OPENCMB]);
				shutter[SHUTTER_STATE] = 2; //Open
			}
		}
		else if(shutter[SHUTTER_STATE]==3){ //Closing
			if(shutter[SHUTTER_FRAMES]>0){
				shutter[SHUTTER_FRAMES]--;
				curFrame = Clamp(Floor(shutter[SHUTTER_FRAMES]/(SHUTTER_OPEN_FRAMES/openingFrames)), 0, openingFrames-1);
				Shutter_SetCombos(this, layer, shutter[SHUTTER_COMBOPOS], openingCmb+curFrame*(4*this->TileHeight));
			}
			else{
				Shutter_SetCombos(this, layer, shutter[SHUTTER_COMBOPOS], shutter[SHUTTER_CLOSEDCMB]);
				shutter[SHUTTER_STATE] = 0; //Closed
			}
		}
	}
	void Shutter_Open(ffc this, int layer, int shutter, int openingFrames, bool silent){
		int SHUTTER_STATE = 0;
		int SHUTTER_FRAMES = 1;
		int SHUTTER_OPENCMB = 2;
		int SHUTTER_CLOSEDCMB = 3;
		int SHUTTER_COMBOPOS = 4;
		if(!silent)
			Game->PlaySound(SFX_SHUTTER_OPEN);
		if(openingFrames==0){
			Shutter_SetCombos(this, layer, shutter[SHUTTER_COMBOPOS], shutter[SHUTTER_OPENCMB]);
			shutter[SHUTTER_STATE] = 2; //Open
		}
		else{
			shutter[SHUTTER_STATE] = 1; //Opening
			shutter[SHUTTER_FRAMES] = SHUTTER_OPEN_FRAMES;
		}
	}
	void Shutter_Close(ffc this, int layer, int shutter, int openingFrames, bool silent){
		int SHUTTER_STATE = 0;
		int SHUTTER_FRAMES = 1;
		int SHUTTER_OPENCMB = 2;
		int SHUTTER_CLOSEDCMB = 3;
		int SHUTTER_COMBOPOS = 4;
		if(!silent)
			Game->PlaySound(SFX_SHUTTER_CLOSE);
		if(openingFrames==0){
			Shutter_SetCombos(this, layer, shutter[SHUTTER_COMBOPOS], shutter[SHUTTER_CLOSEDCMB]);
			shutter[SHUTTER_STATE] = 0; //Closed
		}
		else{
			shutter[SHUTTER_STATE] = 3; //Closing
			shutter[SHUTTER_FRAMES] = SHUTTER_OPEN_FRAMES;
		}
	}
	bool Shutter_SetCombos(ffc this, int layer, int comboPos, int cmb){
		int w = this->TileWidth;
		int h = this->TileHeight;
		for(int x=0; x<w; x++){
			for(int y=0; y<h; y++){
				SetLayerComboD(layer, comboPos+x+y*16, cmb+x+y*4);
				if(SHUTTER_USE_FFC_CSET)
					__SetLayerComboC(layer, comboPos+x+y*16, this->CSet);
				//Screen->ComboD[comboPos+x+y*16] = cmb+x+y*4;
			}
		}
	}
	bool Shutter_LinkCollide(ffc this, int dir, int linkX, int linkY, bool fullTile){
		if(Link->Action==LA_SCROLLING||Link->X<0||Link->X>240||Link->Y<0||Link->Y>160)
			return false;
		int w = this->TileWidth;
		int h = this->TileHeight;
		int offset = 0;
		if(fullTile) 
			offset = 16;
		if(dir==DIR_UP){
			return (linkX>=this->X-16 && linkX<=this->X+w*16 && linkY <= Max(this->Y+h*16-16+offset-8, 0));
		}
		else if(dir==DIR_DOWN){
			return (linkX>=this->X-16 && linkX<=this->X+w*16 && linkY >= this->Y-offset);
		}
		else if(dir==DIR_LEFT){
			return (linkY>=this->Y-16 && linkY<=this->Y+h*16 && linkX <= this->X+w*16-16+offset);
		}
		else if(dir==DIR_RIGHT){
			return (linkY>=this->Y-16 && linkY<=this->Y+h*16 && linkX >= this->X-offset);
		}
	}
	bool Shutter_MoveLink(int dir){
		NoAction();
		if(dir==DIR_UP){
			Link->InputDown = true;
			if(!CanWalk(Link->X, Link->Y, DIR_DOWN, 1, false))
				Link->Y++;
		}
		else if(dir==DIR_DOWN){
			Link->InputUp = true;
			if(!CanWalk(Link->X, Link->Y, DIR_UP, 1, false))
				Link->Y--;
		}
		else if(dir==DIR_LEFT){
			Link->InputRight = true;
			if(!CanWalk(Link->X, Link->Y, DIR_RIGHT, 1, false))
				Link->X++;
		}
		else if(dir==DIR_RIGHT){
			Link->InputLeft = true;
			if(!CanWalk(Link->X, Link->Y, DIR_LEFT, 1, false))
				Link->X--;
		}
	}
	bool Shutter_EjectLink(ffc this, int dir){
		if(dir==DIR_UP)
			Link->Y = this->Y+this->TileHeight*16-8;
		else if(dir==DIR_DOWN)
			Link->Y = this->Y-16;
		else if(dir==DIR_LEFT)
			Link->X = this->X+this->TileWidth*16;
		else if(dir==DIR_RIGHT)
			Link->X = this->X-16;
	}
	int Shutter_CountNPCs(){
		int count;
		for(int i=Screen->NumNPCs(); i>=1; i--){
			npc n = Screen->LoadNPC(i);
			if(n->MiscFlags&(1<<3)) //Doesn't count as a beatable enemy flag
				continue;
			if(n->ID==NPC_FIRE)
				continue;
			if(n->Type==NPCT_FAIRY||n->Type==NPCT_TRAP||n->Type==NPCT_PROJECTILE||n->Type==NPCT_NONE)
				continue;
			if(n->Type==NPCT_ZORA) //Borderline if this should be a skippable enemy. I believe most ZC behaviors skip it, so I've put it here
				continue;
			count++;
		}
		return count;
	}
	int Shutter_CountBlockTriggers(){
		int count;
		for(int i=0; i<176; i++){
			if(ComboFI(i, CF_BLOCKTRIGGER))
				count++;
		}
		return count;
	}
	//A shorthand way to set a combo on the current layer.
	//Layer 0 is the screen itself.
	void __SetLayerComboC(int layer, int pos, int cset) {
	  if (layer == 0)
		Screen->ComboC[pos] = cset;
	  else
		Game->SetComboCSet(Screen->LayerMap(layer), Screen->LayerScreen(layer), pos, cset);
	}
}

//LttP Locked Door
//D0: Direction to the wall the door is on - 0: Up, 1: Down, 2: Left, 3: Right
//D1: Special ID of the door (0 for none, 1-16). Be sure to match it with the door on the other side so both open properly.
//D4: Prevents linking to the door on the adjacent screen
//D6: If using an opening animation, this is the first of the combo groups, starting with a closed door.
//	  Opening combo groups should be arranged vertically and be made up of doors the same size as the FFC.
//D7: If using an opening animation, this is the number of frames in the animation.
ffc script LttP_LockedDoor{
	void run(int dir, int id, int d2, int d3, int noLink, int layer, int openingCmb, int openingFrames){
		int comboPos = ComboAt(this->X+8, this->Y+8);
		
		int closedCmb = this->Data;
		int openCmb = this->Data+4*this->TileHeight;
		this->Data = SHUTTER_INVISIBLE_COMBO;
		
		//Uncheck flags that make the FFC invisible during scrolling
		this->Flags[FFCF_LENSVIS] = false;
		this->Flags[FFCF_CHANGER] = false;
		
		//Set opening combo relative to the open and closed states if not set
		if(openingCmb==0&&openingFrames>0){
			openingCmb = closedCmb+2*(4*this->TileHeight);
		}
		
		// >using variables as labels
		// shiggydiggy
		int SHUTTER_STATE = 0; //0 = Closed, 1 = Opening, 2 = Open, 3 = Closing
		int SHUTTER_FRAMES = 1;
		int SHUTTER_OPENCMB = 2;
		int SHUTTER_CLOSEDCMB = 3;
		int SHUTTER_COMBOPOS = 4;
		int shutter[16] = {0, 0, openCmb, closedCmb, comboPos};
		
		//If screen D bit is set, open the door
		if(LockedDoor_CheckD(dir, id)){
			if(this->Flags[FFCF_PRELOAD]){
				LockedDoor_SetCombos(this, layer, comboPos, openCmb);
				Quit();
			}
			else{
				LockedDoor_Open(this, layer, shutter, openingFrames);
			}
		}
		else{
			LockedDoor_SetCombos(this, layer, comboPos, closedCmb);
		}
		
		int lockCount = SHUTTER_LOCK_ACTIVATION_FRAMES;
		while(true){
			if(shutter[SHUTTER_STATE]==0){ //Closed
				if(LockedDoor_DetectOpen(this, dir)){
					if(lockCount>0)
						lockCount--;
					else if(LockedDoor_HasKey()){
						LockedDoor_Open(this, layer, shutter, openingFrames);
						LockedDoor_SetD(dir, id, noLink);
						LockedDoor_TakeKey();
					}
				}
				else
					lockCount = SHUTTER_LOCK_ACTIVATION_FRAMES;
			}
			LockedDoor_Update(this, layer, shutter, openingCmb, openingFrames);
			Waitframe();
		}
	}
	bool LockedDoor_Update(ffc this, int layer, int shutter, int openingCmb, int openingFrames){
		int SHUTTER_STATE = 0;
		int SHUTTER_FRAMES = 1;
		int SHUTTER_OPENCMB = 2;
		int SHUTTER_CLOSEDCMB = 3;
		int SHUTTER_COMBOPOS = 4;
		int curFrame;
		if(shutter[SHUTTER_STATE]==1){ //Opening
			if(shutter[SHUTTER_FRAMES]>0){
				shutter[SHUTTER_FRAMES]--;
				curFrame = Clamp(Floor((SHUTTER_LOCK_OPEN_FRAMES-shutter[SHUTTER_FRAMES])/(SHUTTER_LOCK_OPEN_FRAMES/openingFrames)), 0, openingFrames-1);
				LockedDoor_SetCombos(this, layer, shutter[SHUTTER_COMBOPOS], openingCmb+curFrame*(4*this->TileHeight));
			}
			else{
				LockedDoor_SetCombos(this, layer, shutter[SHUTTER_COMBOPOS], shutter[SHUTTER_OPENCMB]);
				shutter[SHUTTER_STATE] = 2; //Open
			}
		}
	}
	void LockedDoor_Open(ffc this, int layer, int shutter, int openingFrames){
		int SHUTTER_STATE = 0;
		int SHUTTER_FRAMES = 1;
		int SHUTTER_OPENCMB = 2;
		int SHUTTER_CLOSEDCMB = 3;
		int SHUTTER_COMBOPOS = 4;
		Game->PlaySound(SFX_LOCK_OPEN);
		if(openingFrames==0){
			LockedDoor_SetCombos(this, layer, shutter[SHUTTER_COMBOPOS], shutter[SHUTTER_OPENCMB]);
			shutter[SHUTTER_STATE] = 2; //Open
		}
		else{
			shutter[SHUTTER_STATE] = 1; //Opening
			shutter[SHUTTER_FRAMES] = SHUTTER_OPEN_FRAMES;
		}
	}
	bool LockedDoor_SetCombos(ffc this, int layer, int comboPos, int cmb){
		int w = this->TileWidth;
		int h = this->TileHeight;
		for(int x=0; x<w; x++){
			for(int y=0; y<h; y++){
				SetLayerComboD(layer, comboPos+x+y*16, cmb+x+y*4);
				if(SHUTTER_USE_FFC_CSET)
					__SetLayerComboC(layer, comboPos+x+y*16, this->CSet);
				//Screen->ComboD[comboPos+x+y*16] = cmb+x+y*4;
			}
		}
	}
	bool LockedDoor_DetectOpen(ffc this, int dir){
		int hitboxX;
		int hitboxY;
		if(dir==DIR_UP){
			hitboxX = this->X+this->TileWidth*8-8;
			hitboxY = this->Y+this->TileHeight*16-16;
		}
		else if(dir==DIR_DOWN){
			hitboxX = this->X+this->TileWidth*8-8;
			hitboxY = this->Y;
		}
		else if(dir==DIR_LEFT){
			hitboxX = this->X+this->TileWidth*16-16;
			hitboxY = this->Y+this->TileHeight*8-8;
		}
		else if(dir==DIR_RIGHT){
			hitboxX = this->X;
			hitboxY = this->Y+this->TileHeight*8-8;
		}
		
		if(Link->X>=hitboxX-8&&Link->X<=hitboxX+8&&Link->Y>=hitboxY-16&&Link->Y<=hitboxY&&Link->InputDown&&Link->Dir==DIR_DOWN&&dir<2)
			return true;
		if(Link->X>=hitboxX-8&&Link->X<=hitboxX+8&&Link->Y>=hitboxY&&Link->Y<=hitboxY+8&&Link->InputUp&&Link->Dir==DIR_UP&&dir<2)
			return true;
		if(Link->X>=hitboxX-16&&Link->X<=hitboxX&&Link->Y>=hitboxY-8&&Link->Y<=hitboxY+8&&Link->InputRight&&Link->Dir==DIR_RIGHT&&dir>=2)
			return true;
		if(Link->X>=hitboxX&&Link->X<=hitboxX+16&&Link->Y>=hitboxY-8&&Link->Y<=hitboxY+8&&Link->InputLeft&&Link->Dir==DIR_LEFT&&dir>=2)
			return true;
		return false;
	}
	bool LockedDoor_CheckD(int dir, int id){
		if(id>0)
			return Screen->D[D_LTTPDOORID]&(1<<(Clamp(id-1, 0, 15)));
		else
			return Screen->D[D_LTTPDOORS]&(1<<Clamp(dir, 0, 3));
	}
	void LockedDoor_SetD(int dir, int id, int noLink){
		int offset;
		if(dir==DIR_UP)
			offset = -16;
		else if(dir==DIR_DOWN)
			offset = 16;
		else if(dir==DIR_LEFT)
			offset = -1;
		else
			offset = 1;
		int nextD;
		if(id>0){
			Screen->D[D_LTTPDOORID] |= (1<<(Clamp(id-1, 0, 15)));
			nextD = Game->GetDMapScreenD(Game->GetCurDMap(), Game->GetCurDMapScreen()+offset, D_LTTPDOORID);
			if(!noLink)
				Game->SetDMapScreenD(Game->GetCurDMap(), Game->GetCurDMapScreen()+offset, D_LTTPDOORID, nextD|(1<<(Clamp(id-1, 0, 15))));
		}
		else{
			Screen->D[D_LTTPDOORS] |= (1<<Clamp(dir, 0, 3));
			nextD = Game->GetDMapScreenD(Game->GetCurDMap(), Game->GetCurDMapScreen()+offset, D_LTTPDOORS);
			if(!noLink)
				Game->SetDMapScreenD(Game->GetCurDMap(), Game->GetCurDMapScreen()+offset, D_LTTPDOORS, nextD|(1<<Clamp(OppositeDir(dir), 0, 3)));
		}
	}
	bool LockedDoor_HasKey(){
		if(Link->Item[I_MAGICKEY])
			return true;
		if(Game->Counter[CR_KEYS]>0)
			return true;
		if(Game->LKeys[Game->GetCurLevel()]>0)
			return true;
		return false;
	}
	void LockedDoor_TakeKey(){
		if(Link->Item[I_MAGICKEY])
			return;
		if(Game->LKeys[Game->GetCurLevel()]>0)
			Game->LKeys[Game->GetCurLevel()]--;
		else if(Game->Counter[CR_KEYS]>0)
			Game->Counter[CR_KEYS]--;
	}
	//A shorthand way to set a combo on the current layer.
	//Layer 0 is the screen itself.
	void __SetLayerComboC(int layer, int pos, int cset) {
	  if (layer == 0)
		Screen->ComboC[pos] = cset;
	  else
		Game->SetComboCSet(Screen->LayerMap(layer), Screen->LayerScreen(layer), pos, cset);
	}
}

//LttP Boss Locked Door
//D0: Direction to the wall the door is on - 0: Up, 1: Down, 2: Left, 3: Right
//D1: Special ID of the door (0 for none, 1-16). Be sure to match it with the door on the other side so both open properly.
//D6: If using an opening animation, this is the first of the combo groups, starting with a closed door.
//	  Opening combo groups should be arranged vertically and be made up of doors the same size as the FFC.
//D7: If using an opening animation, this is the number of frames in the animation.
ffc script LttP_BossLockedDoor{
	void run(int dir, int id, int d2, int d3, int d4, int layer, int openingCmb, int openingFrames){
		int comboPos = ComboAt(this->X+8, this->Y+8);
		
		int closedCmb = this->Data;
		int openCmb = this->Data+4*this->TileHeight;
		this->Data = SHUTTER_INVISIBLE_COMBO;
		
		//Uncheck flags that make the FFC invisible during scrolling
		this->Flags[FFCF_LENSVIS] = false;
		this->Flags[FFCF_CHANGER] = false;
		
		//Set opening combo relative to the open and closed states if not set
		if(openingCmb==0&&openingFrames>0){
			openingCmb = closedCmb+2*(4*this->TileHeight);
		}
		
		// >using variables as labels
		// shiggydiggy
		int SHUTTER_STATE = 0; //0 = Closed, 1 = Opening, 2 = Open, 3 = Closing
		int SHUTTER_FRAMES = 1;
		int SHUTTER_OPENCMB = 2;
		int SHUTTER_CLOSEDCMB = 3;
		int SHUTTER_COMBOPOS = 4;
		int shutter[16] = {0, 0, openCmb, closedCmb, comboPos};
		
		//If screen D bit is set, open the door
		if(BossLockedDoor_CheckD(dir, id)){
			if(this->Flags[FFCF_PRELOAD]){
				BossLockedDoor_SetCombos(this, layer, comboPos, openCmb);
				Quit();
			}
			else{
				BossLockedDoor_Open(this, layer, shutter, openingFrames);
			}
		}
		else{
			BossLockedDoor_SetCombos(this, layer, comboPos, closedCmb);
		}
		
		int lockCount = SHUTTER_LOCK_ACTIVATION_FRAMES;
		while(true){
			if(shutter[SHUTTER_STATE]==0){ //Closed
				if(BossLockedDoor_DetectOpen(this, dir)){
					if(lockCount>0)
						lockCount--;
					else if(BossLockedDoor_HasKey()){
						BossLockedDoor_Open(this, layer, shutter, openingFrames);
						BossLockedDoor_SetD(dir, id);
					}
				}
				else
					lockCount = SHUTTER_LOCK_ACTIVATION_FRAMES;
			}
			BossLockedDoor_Update(this, layer, shutter, openingCmb, openingFrames);
			Waitframe();
		}
	}
	bool BossLockedDoor_Update(ffc this, int layer, int shutter, int openingCmb, int openingFrames){
		int SHUTTER_STATE = 0;
		int SHUTTER_FRAMES = 1;
		int SHUTTER_OPENCMB = 2;
		int SHUTTER_CLOSEDCMB = 3;
		int SHUTTER_COMBOPOS = 4;
		int curFrame;
		if(shutter[SHUTTER_STATE]==1){ //Opening
			if(shutter[SHUTTER_FRAMES]>0){
				shutter[SHUTTER_FRAMES]--;
				curFrame = Clamp(Floor((SHUTTER_LOCK_OPEN_FRAMES-shutter[SHUTTER_FRAMES])/(SHUTTER_LOCK_OPEN_FRAMES/openingFrames)), 0, openingFrames-1);
				BossLockedDoor_SetCombos(this, layer, shutter[SHUTTER_COMBOPOS], openingCmb+curFrame*(4*this->TileHeight));
			}
			else{
				BossLockedDoor_SetCombos(this, layer, shutter[SHUTTER_COMBOPOS], shutter[SHUTTER_OPENCMB]);
				shutter[SHUTTER_STATE] = 2; //Open
			}
		}
	}
	void BossLockedDoor_Open(ffc this, int layer, int shutter, int openingFrames){
		int SHUTTER_STATE = 0;
		int SHUTTER_FRAMES = 1;
		int SHUTTER_OPENCMB = 2;
		int SHUTTER_CLOSEDCMB = 3;
		int SHUTTER_COMBOPOS = 4;
		Game->PlaySound(SFX_BOSS_LOCK_OPEN);
		if(openingFrames==0){
			BossLockedDoor_SetCombos(this, layer, shutter[SHUTTER_COMBOPOS], shutter[SHUTTER_OPENCMB]);
			shutter[SHUTTER_STATE] = 2; //Open
		}
		else{
			shutter[SHUTTER_STATE] = 1; //Opening
			shutter[SHUTTER_FRAMES] = SHUTTER_OPEN_FRAMES;
		}
	}
	bool BossLockedDoor_SetCombos(ffc this, int layer, int comboPos, int cmb){
		int w = this->TileWidth;
		int h = this->TileHeight;
		for(int x=0; x<w; x++){
			for(int y=0; y<h; y++){
				SetLayerComboD(layer, comboPos+x+y*16, cmb+x+y*4);
				if(SHUTTER_USE_FFC_CSET)
					__SetLayerComboC(layer, comboPos+x+y*16, this->CSet);
				//Screen->ComboD[comboPos+x+y*16] = cmb+x+y*4;
			}
		}
	}
	bool BossLockedDoor_DetectOpen(ffc this, int dir){
		int hitboxX;
		int hitboxY;
		if(dir==DIR_UP){
			hitboxX = this->X+this->TileWidth*8-8;
			hitboxY = this->Y+this->TileHeight*16-16;
		}
		else if(dir==DIR_DOWN){
			hitboxX = this->X+this->TileWidth*8-8;
			hitboxY = this->Y;
		}
		else if(dir==DIR_LEFT){
			hitboxX = this->X+this->TileWidth*16-16;
			hitboxY = this->Y+this->TileHeight*8-8;
		}
		else if(dir==DIR_RIGHT){
			hitboxX = this->X;
			hitboxY = this->Y+this->TileHeight*8-8;
		}
		
		if(Link->X>=hitboxX-8&&Link->X<=hitboxX+8&&Link->Y>=hitboxY-16&&Link->Y<=hitboxY&&Link->InputDown&&Link->Dir==DIR_DOWN&&dir<2)
			return true;
		if(Link->X>=hitboxX-8&&Link->X<=hitboxX+8&&Link->Y>=hitboxY&&Link->Y<=hitboxY+8&&Link->InputUp&&Link->Dir==DIR_UP&&dir<2)
			return true;
		if(Link->X>=hitboxX-16&&Link->X<=hitboxX&&Link->Y>=hitboxY-8&&Link->Y<=hitboxY+8&&Link->InputRight&&Link->Dir==DIR_RIGHT&&dir>=2)
			return true;
		if(Link->X>=hitboxX&&Link->X<=hitboxX+16&&Link->Y>=hitboxY-8&&Link->Y<=hitboxY+8&&Link->InputLeft&&Link->Dir==DIR_LEFT&&dir>=2)
			return true;
		return false;
	}
	bool BossLockedDoor_CheckD(int dir, int id){
		if(id>0)
			return Screen->D[D_LTTPDOORID]&(1<<(Clamp(id-1, 0, 15)));
		else
			return Screen->D[D_LTTPDOORS]&(1<<(4+Clamp(dir, 0, 3)));
	}
	void BossLockedDoor_SetD(int dir, int id){
		int offset;
		if(dir==DIR_UP)
			offset = -16;
		else if(dir==DIR_DOWN)
			offset = 16;
		else if(dir==DIR_LEFT)
			offset = -1;
		else
			offset = 1;
		int nextD;
		if(id>0){
			Screen->D[D_LTTPDOORID] |= (1<<(Clamp(id-1, 0, 15)));
			nextD = Game->GetDMapScreenD(Game->GetCurDMap(), Game->GetCurDMapScreen()+offset, D_LTTPDOORID);
			Game->SetDMapScreenD(Game->GetCurDMap(), Game->GetCurDMapScreen()+offset, D_LTTPDOORID, nextD|(1<<(Clamp(id-1, 0, 15))));
		}
		else{
			Screen->D[D_LTTPDOORS] |= (1<<(4+Clamp(dir, 0, 3)));
			nextD = Game->GetDMapScreenD(Game->GetCurDMap(), Game->GetCurDMapScreen()+offset, D_LTTPDOORS);
			Game->SetDMapScreenD(Game->GetCurDMap(), Game->GetCurDMapScreen()+offset, D_LTTPDOORS, nextD|(1<<(4+Clamp(OppositeDir(dir), 0, 3))));
		}
	}
	bool BossLockedDoor_HasKey(){
		if(Game->LItems[Game->GetCurLevel()]&LI_BOSSKEY)
			return true;
		return false;
	}
	//A shorthand way to set a combo on the current layer.
	//Layer 0 is the screen itself.
	void __SetLayerComboC(int layer, int pos, int cset) {
	  if (layer == 0)
		Screen->ComboC[pos] = cset;
	  else
		Game->SetComboCSet(Screen->LayerMap(layer), Screen->LayerScreen(layer), pos, cset);
	}
}

//LttP Bomb Wall
//D0: Direction to the wall the door is on - 0: Up, 1: Down, 2: Left, 3: Right
//D1: Special ID of the door (0 for none, 1-16). Be sure to match it with the door on the other side so both open properly.
ffc script LttP_BombWall{
	void run(int dir, int id, int d2, int d3, int d4, int layer, int d6, int d7){
		int comboPos = ComboAt(this->X+8, this->Y+8);
		
		int openCmb = this->Data;
		int rubbleCmb = this->Data+4*this->TileHeight;
		this->Data = SHUTTER_INVISIBLE_COMBO;
		
		//Uncheck flags that make the FFC invisible during scrolling
		this->Flags[FFCF_LENSVIS] = false;
		this->Flags[FFCF_CHANGER] = false;
		
		if(IsEasyMode()||Q7_CheatEnabled(G_MODE_EASYNAVIGATION)){
			if(dir==DIR_UP){
				BombWall_SetCombos(this, layer, comboPos, 8192);
			}
			else if(dir==DIR_DOWN){
				BombWall_SetCombos(this, layer, comboPos, 8194);
			}
			else if(dir==DIR_LEFT){
				BombWall_SetCombos(this, layer, comboPos, 8208);
			}
			else if(dir==DIR_RIGHT){
				BombWall_SetCombos(this, layer, comboPos, 8210);
			}
		}
		
		//If screen D bit is set, open the door
		if(BombWall_CheckD(dir, id)){
			BombWall_SetCombos(this, layer, comboPos, openCmb);
			BombWall_SetRubble(this, dir, rubbleCmb);
			Quit();
		}
		
		while(true){
			//Draw a hint graphic when using the lens
			if(UsingLens()){
				int x;
				int y;
				if(dir==DIR_UP){
					x = this->X+this->TileWidth*8-8;
					y = this->Y+this->TileHeight*16-16;
				}
				else if(dir==DIR_DOWN){
					x = this->X+this->TileWidth*8-8;
					y = this->Y;
				}
				else if(dir==DIR_LEFT){
					x = this->X+this->TileWidth*16-16;
					y = this->Y+this->TileHeight*8-8;
				}
				else if(dir==DIR_RIGHT){
					x = this->X;
					y = this->Y+this->TileHeight*8-8;
				}
				
				if(CMB_BOMBWALL_MARKER>0)
					Screen->FastCombo(6, x, y, CMB_BOMBWALL_MARKER, CS_BOMBWALL_MARKER, 128);
			}
			
			if(BombWall_DetectOpen(this, dir)){
				BombWall_SetCombos(this, layer, comboPos, openCmb);
				BombWall_SetRubble(this, dir, rubbleCmb);
				BombWall_SetD(dir, id);
				Game->PlaySound(SFX_BOMB_WALL_OPEN);
				Quit();
			}
			
			Waitframe();
		}
	}
	bool BombWall_SetCombos(ffc this, int layer, int comboPos, int cmb){
		int w = this->TileWidth;
		int h = this->TileHeight;
		for(int x=0; x<w; x++){
			for(int y=0; y<h; y++){
				SetLayerComboD(layer, comboPos+x+y*16, cmb+x+y*4);
				if(SHUTTER_USE_FFC_CSET)
					__SetLayerComboC(layer, comboPos+x+y*16, this->CSet);
				//Screen->ComboD[comboPos+x+y*16] = cmb+x+y*4;
			}
		}
	}
	void BombWall_SetRubble(ffc this, int dir, int cmb){
		int rubbleX;
		int rubbleY;
		
		if(dir==DIR_UP){
			rubbleX = this->X+this->TileWidth*8-8;
			rubbleY = this->Y+this->TileHeight*16;
		}
		else if(dir==DIR_DOWN){
			rubbleX = this->X+this->TileWidth*8-8;
			rubbleY = this->Y-16;
		}
		else if(dir==DIR_LEFT){
			rubbleX = this->X+this->TileWidth*16;
			rubbleY = this->Y+this->TileHeight*8-8;
		}
		else if(dir==DIR_RIGHT){
			rubbleX = this->X-16;
			rubbleY = this->Y+this->TileHeight*8-8;
		}
		
		this->Data = cmb;
		this->X = rubbleX;
		this->Y = rubbleY;
		this->TileWidth = 1;
		this->TileHeight = 1;
	}
	bool BombWall_DetectOpen(ffc this, int dir){
		int hitboxX;
		int hitboxY;
		if(dir==DIR_UP){
			hitboxX = this->X+this->TileWidth*8-8;
			hitboxY = this->Y+this->TileHeight*16-16;
		}
		else if(dir==DIR_DOWN){
			hitboxX = this->X+this->TileWidth*8-8;
			hitboxY = this->Y;
		}
		else if(dir==DIR_LEFT){
			hitboxX = this->X+this->TileWidth*16-16;
			hitboxY = this->Y+this->TileHeight*8-8;
		}
		else if(dir==DIR_RIGHT){
			hitboxX = this->X;
			hitboxY = this->Y+this->TileHeight*8-8;
		}
		
		if(Link->Item[I_SECRETRING]||G[G_MODE_FREESIGHT]){
			if(G[G_ANIM]%FREQ_SECRETSPARKLE==0){
				int range = 40;
				if(Q7_HasRing(I_SPRING11_MIRR))
					range += 64;
				if(Distance(hitboxX, hitboxY, Link->X, Link->Y)<40){
					SecretSparkles_MakeParticles(hitboxX, hitboxY);
				}
			}
		}
		
		for(int i=Screen->NumLWeapons(); i>=1; i--){
			lweapon l = Screen->LoadLWeapon(i);
			if(l->CollDetection&&l->DeadState==WDS_ALIVE){
				if(l->ID==LW_BOMBBLAST||l->ID==LW_SBOMBBLAST){
					if(RectCollision(l->X+l->HitXOffset, l->Y+l->HitYOffset, l->X+l->HitXOffset+l->HitWidth-1, l->Y+l->HitYOffset+l->HitHeight-1, hitboxX, hitboxY, hitboxX+15, hitboxY+15)){
						return true;
					}
				}
			}
		}
		return false;
	}
	bool BombWall_CheckD(int dir, int id){
		if(id>0)
			return Screen->D[D_LTTPDOORID]&(1<<(Clamp(id-1, 0, 15)));
		else
			return Screen->D[D_LTTPDOORS]&(1<<(8+Clamp(dir, 0, 3)));
	}
	void BombWall_SetD(int dir, int id){
		int offset;
		if(dir==DIR_UP)
			offset = -16;
		else if(dir==DIR_DOWN)
			offset = 16;
		else if(dir==DIR_LEFT)
			offset = -1;
		else
			offset = 1;
		int nextD;
		if(id>0){
			Screen->D[D_LTTPDOORID] |= (1<<(Clamp(id-1, 0, 15)));
			nextD = Game->GetDMapScreenD(Game->GetCurDMap(), Game->GetCurDMapScreen()+offset, D_LTTPDOORID);
			Game->SetDMapScreenD(Game->GetCurDMap(), Game->GetCurDMapScreen()+offset, D_LTTPDOORID, nextD|(1<<(Clamp(id-1, 0, 15))));
		}
		else{
			Screen->D[D_LTTPDOORS] |= (1<<(8+Clamp(dir, 0, 3)));
			nextD = Game->GetDMapScreenD(Game->GetCurDMap(), Game->GetCurDMapScreen()+offset, D_LTTPDOORS);
			Game->SetDMapScreenD(Game->GetCurDMap(), Game->GetCurDMapScreen()+offset, D_LTTPDOORS, nextD|(1<<(8+Clamp(OppositeDir(dir), 0, 3))));
		}
	}
	//A shorthand way to set a combo on the current layer.
	//Layer 0 is the screen itself.
	void __SetLayerComboC(int layer, int pos, int cset) {
	  if (layer == 0)
		Screen->ComboC[pos] = cset;
	  else
		Game->SetComboCSet(Screen->LayerMap(layer), Screen->LayerScreen(layer), pos, cset);
	}
}

const int CMB_TRACKTILE = 7972;

const int SFX_TRACKTILE_RESET = 75;
const int SFX_TRACKTILE_RESET2 = 76;

ffc script TrackTile{
	void run(int d, int dHalf, int step){
		int i; int j;
		
		int dbr = 1<<16; //Resetting bit. When unset, platforms reset to their starting positions
		
		int x; int y;
		int pos;
		
		if(step==0)
			step = 1.2;
		
		//If moving on a track tile when entering the screen, set the position to invalid
		if(G[G_TRACKTILEDIR]>-1&&(G[G_TRACKTILED]&1)==dHalf){
			x = 0;
			y = 0;
		}
		//If the bit flagging a reset is unset, set the Screen->D for the first time
		else if(!(Screen->D[d]&dbr)){
			x = this->X;
			y = this->Y;
			
			pos = ComboAt(x+8, y+8);
			
			if(dHalf){
				Screen->D[d] &= 0x00FF;
				Screen->D[d] |= pos<<8;
			}
			else{
				Screen->D[d] &= 0xFF00;
				Screen->D[d] |= pos;
			}
			
			if(IsLastInstanceOfTrackTile(this, d))
				Screen->D[d] |= dbr;
		}
		//Otherwise get positions from Screen->D
		else{
			if(dHalf){
				pos = (Screen->D[d] & (0xFF<<8))>>8;
				if(pos>0){
					x = ComboX(pos);
					y = ComboY(pos);
				}
			}
			else{
				pos = Screen->D[d] & 0xFF;
				
				if(pos>0){
					x = ComboX(pos);
					y = ComboY(pos);
				}
			}
		}
		
		pos = ComboAt(x+8, y+8);
		
		//Set up undercombos on first load
		int cmb = CMB_TRACKTILE;
		int underCmb = Screen->ComboD[pos];
		int underCSet = Screen->ComboC[pos];
		if(x!=0&&y!=0){
			Screen->ComboD[pos] = cmb;
			Screen->ComboC[pos] = this->CSet;
		}
		
		int canMoveDirections[4];
		//Which directions the platform is able to move
		for(i=0; i<4; i++){
			canMoveDirections[i] = 0;
			if(TrackTile_CanMoveDir(pos, i))
				canMoveDirections[i] = 1;
		}
		
		//Change the under combo to be walkable on the top if you can exit that way
		if(x!=0&&y!=0){
			if(Screen->ComboS[pos-16]==0000b){
				Screen->ComboD[pos]++;
			}
		}
		
		int pushTrackCooldown = 16;
		
		this->Flags[FFCF_LENSVIS] = false;
		
		//Set the FFC's combo
		if(x!=0&&y!=0){
			this->X = x;
			this->Y = y;
			this->Data = cmb;
		}
		else{
			this->Data = FFCS_INVISIBLE_COMBO;
		}
		//Wait for screen scrolling
		Waitframe();
		while(true){
			bool pushTrack = false;
			
			//If the position of the platform is valid
			if(x!=0&&y!=0){
				//Make it visible
				this->X = x;
				this->Y = y;
				this->Data = cmb;
				
				//If Link is reasonably aligned, do input checking tho start the platform's movement
				if(Abs(Link->X-x)<2&&Abs(Link->Y-y)<2){
					//Which directions the platform is able to move
					for(i=0; i<4; i++){
						canMoveDirections[i] = 0;
						if(TrackTile_CanMoveDir(pos, i))
							canMoveDirections[i] = 1;
					}
					
					if(LinkMovement_StickX()<0&&canMoveDirections[DIR_LEFT]){
						pushTrack = true;
						if(pushTrackCooldown<=0){
							G[G_TRACKTILEDIR] = DIR_LEFT;
							G[G_TRACKTILEX] = x;
							G[G_TRACKTILEY] = y;
							G[G_TRACKTILED] = (d<<1) | dHalf;
							G[G_TRACKTILECMB] = cmb;
							G[G_TRACKTILECS] = this->CSet;
							G[G_TRACKTILESTEP] = step;
							
							Screen->ComboD[pos] = underCmb;
							Screen->ComboC[pos] = underCSet;
							
							//Set Screen->D stuff to to mark the platform as in motion or offscreen
							if(dHalf){
								Screen->D[d] &= 0x00FF;
								//Screen->D[d] |= 0<<8;
							}
							else{
								Screen->D[d] &= 0xFF00;
								//Screen->D[d] |= 0;
							}
							Screen->D[d] |= dbr;
							
							x = 0; y = 0;
						}
					}
					else if(LinkMovement_StickX()>0&&canMoveDirections[DIR_RIGHT]){
						pushTrack = true;
						if(pushTrackCooldown<=0){
							G[G_TRACKTILEDIR] = DIR_RIGHT;
							G[G_TRACKTILEX] = x;
							G[G_TRACKTILEY] = y;
							G[G_TRACKTILED] = (d<<1) | dHalf;
							G[G_TRACKTILECMB] = cmb;
							G[G_TRACKTILECS] = this->CSet;
							G[G_TRACKTILESTEP] = step;
							
							Screen->ComboD[pos] = underCmb;
							Screen->ComboC[pos] = underCSet;
							
							//Set Screen->D stuff to to mark the platform as in motion or offscreen
							if(dHalf){
								Screen->D[d] &= 0x00FF;
								//Screen->D[d] |= 0<<8;
							}
							else{
								Screen->D[d] &= 0xFF00;
								//Screen->D[d] |= 0;
							}
							Screen->D[d] |= dbr;
							
							x = 0; y = 0;
						}
					}
					else if(LinkMovement_StickY()<0&&canMoveDirections[DIR_UP]){
						pushTrack = true;
						if(pushTrackCooldown<=0){
							G[G_TRACKTILEDIR] = DIR_UP;
							G[G_TRACKTILEX] = x;
							G[G_TRACKTILEY] = y;
							G[G_TRACKTILED] = (d<<1) | dHalf;
							G[G_TRACKTILECMB] = cmb;
							G[G_TRACKTILECS] = this->CSet;
							G[G_TRACKTILESTEP] = step;
							
							Screen->ComboD[pos] = underCmb;
							Screen->ComboC[pos] = underCSet;
							
							//Set Screen->D stuff to to mark the platform as in motion or offscreen
							if(dHalf){
								Screen->D[d] &= 0x00FF;
								//Screen->D[d] |= 0<<8;
							}
							else{
								Screen->D[d] &= 0xFF00;
								//Screen->D[d] |= 0;
							}
							Screen->D[d] |= dbr;
							
							x = 0; y = 0;
						}
					}
					else if(LinkMovement_StickY()>0&&canMoveDirections[DIR_DOWN]){
						pushTrack = true;
						if(pushTrackCooldown<=0){
							G[G_TRACKTILEDIR] = DIR_DOWN;
							G[G_TRACKTILEX] = x;
							G[G_TRACKTILEY] = y;
							G[G_TRACKTILED] = (d<<1) | (dHalf&1);
							G[G_TRACKTILECMB] = cmb;
							G[G_TRACKTILECS] = this->CSet;
							G[G_TRACKTILESTEP] = step;
							
							Screen->ComboD[pos] = underCmb;
							Screen->ComboC[pos] = underCSet;
							
							//Set Screen->D stuff to to mark the platform as in motion or offscreen
							if(dHalf){
								Screen->D[d] &= 0x00FF;
								//Screen->D[d] |= 0<<8;
							}
							else{
								Screen->D[d] &= 0xFF00;
								//Screen->D[d] |= 0;
							}
							Screen->D[d] |= dbr;
						
							x = 0; y = 0;
						}
					}
				}
			}
			//Else make it invisible
			else{
				this->Data = FFCS_INVISIBLE_COMBO;
			}
			
			//If there's a valid track tile being handled by the global currently
			if(G[G_TRACKTILED]>-1){
				//If the current moving platform is this one
				if((G[G_TRACKTILED]&1)==dHalf&&(G[G_TRACKTILED]>>1)==d){
					//If it's not moving, update variables
					if(G[G_TRACKTILEDIR]==-1){
						x = G[G_TRACKTILEX];
						y = G[G_TRACKTILEY];
						Link->X = x;
						Link->Y = y;
						pos = ComboAt(x+8, y+8);
						
						//Set up undercombos
						underCmb = Screen->ComboD[pos];
						underCSet = Screen->ComboC[pos];
						if(x!=0&&y!=0){
							Screen->ComboD[pos] = cmb;
							Screen->ComboC[pos] = this->CSet;
						}
						
						//Which directions the platform is able to move
						for(i=0; i<4; i++){
							canMoveDirections[i] = 0;
							if(TrackTile_CanMoveDir(pos, i))
								canMoveDirections[i] = 1;
						}
						
						//Change the under combo to be walkable on the top if you can exit that way
						if(x!=0&&y!=0){
							if(Screen->ComboS[pos-16]==0000b){
								Screen->ComboD[pos]++;
							}
						}
			
						//Set Screen->D stuff to the new position
						if(dHalf){
							Screen->D[d] &= 0xFF;
							Screen->D[d] |= pos<<8;
						}
						else{
							Screen->D[d] &= 0xFF<<8;
							Screen->D[d] |= pos;
						}
						Screen->D[d] |= dbr;
				
						//Flag that the tile is no longer being handled by the global
						G[G_TRACKTILED] = -1;
					}
				}
			}
			
			if(G[G_TRACKTILERESET]>-1){
				if(G[G_TRACKTILERESETD]==d&&G[G_TRACKTILERESETDHALF]==dHalf){
					this->Data = FFCS_INVISIBLE_COMBO;
					//If the tile is onscreen, animate it fading out
					if(x!=0&&y!=0){
						Screen->ComboD[pos] = underCmb;
						Screen->ComboC[pos] = underCSet;
						
						Game->PlaySound(SFX_TRACKTILE_RESET);
						
						for(i=0; i<3; i++){
							for(j=0; j<4; j++){
								Screen->FastCombo(2, x, y, CMB_TRACKTILE+2+i, this->CSet, 128);
								Waitframe();
							}
						}
						Waitframes(16);
					}
					
					x = ComboX(G[G_TRACKTILERESET]);
					y = ComboY(G[G_TRACKTILERESET]);
					
					//Animate the tile appearing at the new position
					Game->PlaySound(SFX_TRACKTILE_RESET2);
					for(i=2; i>=0; i--){
						for(j=0; j<4; j++){
							Screen->FastCombo(2, x, y, CMB_TRACKTILE+2+i, this->CSet, 128);
							Waitframe();
						}
					}
					
					pos = ComboAt(x+8, y+8);
						
					//Set up undercombos
					underCmb = Screen->ComboD[pos];
					underCSet = Screen->ComboC[pos];
					if(x!=0&&y!=0){
						Screen->ComboD[pos] = cmb;
						Screen->ComboC[pos] = this->CSet;
					}
					
					//Which directions the platform is able to move
					for(i=0; i<4; i++){
						canMoveDirections[i] = 0;
						if(TrackTile_CanMoveDir(pos, i))
							canMoveDirections[i] = 1;
					}
					
					//Change the under combo to be walkable on the top if you can exit that way
					if(x!=0&&y!=0){
						if(Screen->ComboS[pos-16]==0000b){
							Screen->ComboD[pos]++;
						}
					}
		
					//Set Screen->D stuff to the new position
					if(dHalf){
						Screen->D[d] &= 0xFF;
						Screen->D[d] |= pos<<8;
					}
					else{
						Screen->D[d] &= 0xFF<<8;
						Screen->D[d] |= pos;
					}
					Screen->D[d] |= dbr;
					
					this->Data = cmb;
					this->X = x;
					this->Y = y;
					
					G[G_TRACKTILERESET] = -1;
					G[G_TRACKTILERESETD] = -1;
					G[G_TRACKTILERESETDHALF] = -1;
				}
			}
			
			if(pushTrack){
				pushTrackCooldown--;
			}
			else{
				pushTrackCooldown = 16;
			}
			
			Waitframe();
		}
	}
	bool IsLastInstanceOfTrackTile(ffc this, int d){
		ffc last;
		for(int i=1; i<=32; ++i){
			ffc f = Screen->LoadFFC(i);
			if(f->Script==this->Script&&f->InitD[0]==d){
				last = f;
			}
		}
		if(last==this)
			return true;
		return false;
	}
}

const int CMB_TRACKTILETRACK = 7936;

//Returns 1 if the track tile can move in a direction based on flags 8 and 12 on layer 1
//Returns 0 otherwise
int TrackTile_CanMoveDir(int pos, int dir){
	int tileDirMap[] = {1010b, 1100b, 0110b, 1111b, 
						0011b, 1111b, 0011b, 0000b, 
						1001b, 1100b, 0101b, 0000b, 
						1011b, 1110b, 1011b, 1110b, 
						1101b, 0111b, 1101b, 0111b, 
						1010b, 0110b, 0001b, 1000b, 
						1001b, 0101b, 0100b, 0010b,
						1011b, 1110b, 0000b, 0000b, 
						1101b, 0111b, 0000b, 0000b};
	
	int cd = Clamp(GetLayerComboD(1, pos)-CMB_TRACKTILETRACK, 0, 35);
	if(!(tileDirMap[cd]&(1<<dir))){
		return 0;
	}
	
	if(dir==DIR_UP){
		if(pos<16)
			return 1;
		if(GetLayerComboI(1, pos-16)==CF_RAFTBRANCH)
			return 1;
		else if(GetLayerComboI(1, pos-16)==CF_RAFT)
			return 1;
	}
	else if(dir==DIR_DOWN){
		if(pos>=160)
			return 1;
		if(GetLayerComboI(1, pos+16)==CF_RAFTBRANCH)
			return 1;
		else if(GetLayerComboI(1, pos+16)==CF_RAFT)
			return 1;
	}
	else if(dir==DIR_LEFT){
		if(pos%16==0)
			return 1;
		if(GetLayerComboI(1, pos-1)==CF_RAFTBRANCH)
			return 1;
		else if(GetLayerComboI(1, pos-1)==CF_RAFT)
			return 1;
	}
	else if(dir==DIR_RIGHT){
		if(pos%16==15)
			return 1;
		if(GetLayerComboI(1, pos+1)==CF_RAFTBRANCH)
			return 1;
		else if(GetLayerComboI(1, pos+1)==CF_RAFT)
			return 1;
	}
	return 0;
}

void TrackTile_Init(){
	//Reset TrackTile global variables
	G[G_TRACKTILEDIR] = -1;
	G[G_TRACKTILEX] = 0;
	G[G_TRACKTILEY] = 0;
	G[G_TRACKTILED] = -1;
	G[G_TRACKTILESUBPIXELS] = 0;
	
	G[G_TRACKTILERESET] = -1;
	G[G_TRACKTILERESETD] = -1;
	G[G_TRACKTILERESETDHALF] = -1;
}

void TrackTile_Update1(){
	//If the track tile is currently in motion
	if(G[G_TRACKTILEDIR]>-1){
		//While scrolling add an offset to the direction to track which way it was going
		if(Link->Action==LA_SCROLLING){
			if(G[G_TRACKTILEDIR]<4)
				G[G_TRACKTILEDIR] += 4;
		}
		else{
			//Prevent Link from wandering off the edge of the screen after scrolling
			if(Link->X<=2||Link->X>=238||Link->Y<=2||Link->Y>=158)
				NoAction();
			
			//Revert the direction and update position when scrolling ends
			if(G[G_TRACKTILEDIR]>=4){
				G[G_TRACKTILEDIR] -= 4;
				G[G_TRACKTILEX] = GridX(Link->X+8);
				G[G_TRACKTILEY] = GridY(Link->Y+8);
			}
			
			int step = G[G_TRACKTILESTEP];
			if(G[G_ACCELERATOR_TIME]>0)
				step *= 1.5;
			if(G[G_TRACKTILEDIR]==DIR_UP){
				if(Link->InputDown)
					step *= 0.25;
			}
			else if(G[G_TRACKTILEDIR]==DIR_DOWN){
				if(Link->InputUp)
					step *= 0.25;
			}
			else if(G[G_TRACKTILEDIR]==DIR_LEFT){
				if(Link->InputRight)
					step *= 0.25;
			}
			else if(G[G_TRACKTILEDIR]==DIR_RIGHT){
				if(Link->InputLeft)
					step *= 0.25;
			}
			
			//Subpixel counter is used so the tile doesn't get misaligned from the grid
			G[G_TRACKTILESUBPIXELS] += step;
			int fullPixelStep = Floor(G[G_TRACKTILESUBPIXELS]);
			G[G_TRACKTILESUBPIXELS] -= fullPixelStep;
			
			int ccw[] = {0, 0, 0, 0,
						0, 0, 0, 0,
						0, 0, 0, 0,
						0, 0, 0, 0,
						0, 0, 0, 0,
						0, 0, 0, 0,
						0, 0, 0, 0,
						1, 1, 0, 0,
						1, 1, 0, 0};
			
			for(int i=0; i<fullPixelStep; i++){
				//Move the tile until it becomes grid aligned
				G[G_TRACKTILEX] += DirX(G[G_TRACKTILEDIR], 1);
				G[G_TRACKTILEY] += DirY(G[G_TRACKTILEDIR], 1);
				
				if(G[G_TRACKTILEX]%16==0&&G[G_TRACKTILEY]%16==0){
					int pos = ComboAt(G[G_TRACKTILEX]+8, G[G_TRACKTILEY]+8);
					int canMoveDir[4];
					//Record the state of the adjacent flags on layer 1
					for(int j=0; j<4; j++){
						//The tile cannot ever go back the way it came
						if(j!=OppositeDir(G[G_TRACKTILEDIR]))
							canMoveDir[j] = TrackTile_CanMoveDir(pos, j);
					}
					
					bool turned;
					//If it's on a branch, allow manual turning
					if(GetLayerComboI(1, pos)==CF_RAFTBRANCH){
						if(LinkMovement_StickX()<0&&canMoveDir[DIR_LEFT]){
							G[G_TRACKTILEDIR] = DIR_LEFT;
							turned = true;
							break;
						}
						else if(LinkMovement_StickX()>0&&canMoveDir[DIR_RIGHT]){
							G[G_TRACKTILEDIR] = DIR_RIGHT;
							turned = true;
							break;
						}
						else if(LinkMovement_StickY()<0&&canMoveDir[DIR_UP]){
							G[G_TRACKTILEDIR] = DIR_UP;
							turned = true;
							break;
						}
						else if(LinkMovement_StickY()>0&&canMoveDir[DIR_DOWN]){
							G[G_TRACKTILEDIR] = DIR_DOWN;
							turned = true;
							break;
						}
					}
					
					//If a manual turn didn't happen, perform an automatic one
					if(!turned){
						int j = Clamp(GetLayerComboD(1, pos)-CMB_TRACKTILETRACK, 0, 35);
						if(ccw[j]==0){
							//Try going straight first
							if(canMoveDir[G[G_TRACKTILEDIR]]){
								G[G_TRACKTILEDIR] = G[G_TRACKTILEDIR];
								//Straight movement doesn't need to reset the subpixel counter and so there is no break
							}
							//Then try a clockwise turn
							else if(canMoveDir[RotDirCW4(G[G_TRACKTILEDIR])]){
								G[G_TRACKTILEDIR] = RotDirCW4(G[G_TRACKTILEDIR]);
								break;
							}
							//Then try counter clockwise
							else if(canMoveDir[RotDirCCW4(G[G_TRACKTILEDIR])]){
								G[G_TRACKTILEDIR] = RotDirCCW4(G[G_TRACKTILEDIR]);
								break;
							}
							//If there's nowhere left to turn the tile stops
							else{
								G[G_TRACKTILEDIR] = -1;
								break;
							}
						}
						else{
							//Try going straight first
							if(canMoveDir[G[G_TRACKTILEDIR]]){
								G[G_TRACKTILEDIR] = G[G_TRACKTILEDIR];
								//Straight movement doesn't need to reset the subpixel counter and so there is no break
							}
							//Then try a counter clockwise turn
							else if(canMoveDir[RotDirCCW4(G[G_TRACKTILEDIR])]){
								G[G_TRACKTILEDIR] = RotDirCCW4(G[G_TRACKTILEDIR]);
								break;
							}
							//Then try clockwise
							else if(canMoveDir[RotDirCW4(G[G_TRACKTILEDIR])]){
								G[G_TRACKTILEDIR] = RotDirCW4(G[G_TRACKTILEDIR]);
								break;
							}
							//If there's nowhere left to turn the tile stops
							else{
								G[G_TRACKTILEDIR] = -1;
								break;
							}
						}
					}
				}
			}
		
			Screen->FastCombo(2, G[G_TRACKTILEX], G[G_TRACKTILEY], G[G_TRACKTILECMB], G[G_TRACKTILECS], 128);
		}
	}
}

void TrackTile_Update2(){
	//Update Link's position to the tile's after Waitdraw()
	if(G[G_TRACKTILEDIR]>-1){
		if(Link->Action!=LA_SCROLLING){
			if(G[G_TRACKTILEX]||G[G_TRACKTILEY]){
				Link->X = G[G_TRACKTILEX];
				Link->Y = G[G_TRACKTILEY];
			}
		}
	}
}

int RotDirCW4(int dir){
	dir = Clamp(dir, 0, 3);
	int ret[4] = {DIR_RIGHT, DIR_LEFT, DIR_UP, DIR_DOWN};
	return ret[dir];
}

int RotDirCCW4(int dir){
	dir = Clamp(dir, 0, 3);
	int ret[4] = {DIR_LEFT, DIR_RIGHT, DIR_DOWN, DIR_UP};
	return ret[dir];
}

const int CMB_DARMCONVEYOR = 404;

bool IsFirstInstanceOfFFCScript(ffc this){
	for(int i=1; i<=32; ++i){
		ffc f = Screen->LoadFFC(i);
		if(f->Script==this->Script){
			if(f==this)
				return true;
			return false;
		}
	}
}

bool IsLastInstanceOfFFCScript(ffc this){
	ffc last;
	for(int i=1; i<=32; ++i){
		ffc f = Screen->LoadFFC(i);
		if(f->Script==this->Script){
			last = f;
		}
	}
	if(last==this)
		return true;
	return false;
}

void ClearFFCScript(int slot){
	for(int i=1; i<=32; ++i){
		ffc f = Screen->LoadFFC(i);
		if(f->Script==slot){
			f->Script = 0;
			f->Data = 0;
			f->X = 0;
			f->Y = 0;
		}
	}
}

int GetFFCNumber(ffc this){
	for(int i=1; i<=32; i++){
		ffc f = Screen->LoadFFC(i);
		if(f==this){
			return i;
		}
	}
}

ffc script Switch_DarmConveyors{
	void run(int quitAfterChange){
		
		int data = this->Data;
		int i; int j; int k;
		int d;
		int db;
		
		if(G[G_DARMCONVEYORDIR]){
			if(IsFirstInstanceOfFFCScript(this)){
				for(i=0; i<176; i++){
					if(Screen->ComboD[i]==CMB_DARMCONVEYOR){
						Screen->ComboD[i] = CMB_DARMCONVEYOR+1;
					}
					else if(Screen->ComboD[i]==CMB_DARMCONVEYOR+1){
						Screen->ComboD[i] = CMB_DARMCONVEYOR;
					}
					else if(Screen->ComboD[i]==CMB_DARMCONVEYOR+2){
						Screen->ComboD[i] = CMB_DARMCONVEYOR+3;
					}
					else if(Screen->ComboD[i]==CMB_DARMCONVEYOR+3){
						Screen->ComboD[i] = CMB_DARMCONVEYOR+2;
					}
				}
			}
		}
		if(quitAfterChange){
			Quit();
		}
		
		Waitframe();
		
		while(true){
			while(!Switch_Pressed(this->X, this->Y, false)){
				Waitframe();
			}
			this->Data = data+1;
			Game->PlaySound(SFX_SWITCH_PRESS);
			G[G_DARMCONVEYORDIR] = Cond(G[G_DARMCONVEYORDIR], 0, 1);;
			for(i=0; i<176; i++){
				if(Screen->ComboD[i]==CMB_DARMCONVEYOR){
					Screen->ComboD[i] = CMB_DARMCONVEYOR+1;
				}
				else if(Screen->ComboD[i]==CMB_DARMCONVEYOR+1){
					Screen->ComboD[i] = CMB_DARMCONVEYOR;
				}
				else if(Screen->ComboD[i]==CMB_DARMCONVEYOR+2){
					Screen->ComboD[i] = CMB_DARMCONVEYOR+3;
				}
				else if(Screen->ComboD[i]==CMB_DARMCONVEYOR+3){
					Screen->ComboD[i] = CMB_DARMCONVEYOR+2;
				}
			}
			while(Switch_Pressed(this->X, this->Y, false)){
				Waitframe();
			}
			this->Data = data;
			Waitframe();
		}
	}
}

ffc script Switch_TrackTileReset{
	void run(int pos, int d, int dHalf, int triggerSecret){
		
		int data = this->Data;
		int i; int j; int k;
		
		
		
		Waitframe();
		
		while(true){
			while(!Switch_Pressed(this->X, this->Y, false)){
				Waitframe();
			}
			this->Data = data+1;
			Game->PlaySound(SFX_SWITCH_PRESS);
			if(triggerSecret){
				if(!Screen->State[ST_SECRET]){
					Game->PlaySound(SFX_SECRET);
					Screen->State[ST_SECRET] = true;
					Screen->TriggerSecrets();
				}
			}
			G[G_TRACKTILERESET] = pos;
			G[G_TRACKTILERESETD] = d;
			G[G_TRACKTILERESETDHALF] = dHalf;
			while(Switch_Pressed(this->X, this->Y, false)){
				Waitframe();
			}
			while(G[G_TRACKTILERESET]>-1){
				Waitframe();
			}
			this->Data = data;
			Waitframe();
		}
	}
}

ffc script Firebar{
	void run(int links, int angle, int rot, int damage){
		if(damage==0)
			damage = 4;
		
		damage = PiercingDamage(damage);
		
		int data = this->Data;
		this->Data = FFCS_INVISIBLE_COMBO;
		while(true){
			if(Link->HP>0){
				for(int i=0; i<links; i++){
					int x = this->X+VectorX(12*i, angle);
					int y = this->Y+VectorY(12*i, angle);
					MakeHitbox(x, y, 16, 16, damage);
					
					Screen->FastCombo(2, x, y, data, this->CSet, 128);
				}
			}
			
			angle += rot;
			if(angle<0)
				angle += 360;
			else if(angle>360)
				angle -= 360;
			
			Waitframe();
		}
	}
}

// const int RGR_NO_BORDER = 0;
// const int RGR_BROKEN_TOP_HALF_SOLIDITY = 1;
// const int RGR_OUT_OF_BOUNDS_ENEMIES = 0;

//RSPW_NONE, spw_door, spw_clipright, spw_floater, spw_trap, spw_halfstep,
//   spw_water, spw_wizzrobe, RSPW_CLIPBOTTOMRIGHT
	
const int SFX_BABABABA = 77;

const int SPR_BABABABA = 109;
	
const int RSPW_NONE = 0;
const int RSPW_DOOR = 1;
const int RSPW_CLIPRIGHT = 2;
const int RSPW_FLOATER = 3;
const int RSPW_TRAP = 4;
const int RSPW_HALFSTEP = 5;
const int RSPW_WATER = 6;
const int RSPW_WIZZROBE = 7;
const int RSPW_CLIPBOTTOMRIGHT = 8;

const int EWIZZ_TURN = 0;
const int EWIZZ_WALKING = 1;
const int EWIZZ_PHASING = 2;
const int EWIZZ_4DIR = 3;

const int DAMAGE_BABABABA = 4;

ffc script BabaIsYou{
	void run(int enemyid){
		int i; int j; int k;
		
		npc ghost = Ghost_InitAutoGhost(this, enemyid);
		this->Flags[FFCF_ETHEREAL] = true;
		
		Ghost_SetFlag(GHF_4WAY);
		Ghost_SetFlag(GHF_IGNORE_ALL_TERRAIN);
		Ghost_SetFlag(GHF_FLYING_ENEMY);
		
		int vars[16];
		if(Ghost_X<120)
			Ghost_Dir = DIR_RIGHT;
		else
			Ghost_Dir = DIR_LEFT;
		vars[1] = -3;
		vars[2] = Ghost_Dir;
		vars[5] = -1;
		
		int combo = ghost->Attributes[10];
		
		while(true){
			Reproduction_BlueWizz_Update(this, ghost, vars);
			if(IsHardMode()&&vars[3]<=1){
				if(Ghost_X%16==0&&Ghost_Y%16==0&&Rand(64)==0&&Distance(Ghost_X, Ghost_Y, Link->X, Link->Y)<112){
					Ghost_Dir = AngleDir4(Angle(Ghost_X, Ghost_Y, Link->X, Link->Y));
					vars[2]==Ghost_Dir;
				}
			}
			if(vars[0]==1){
				int dir = AngleDir4(Angle(Ghost_X, Ghost_Y, Link->X, Link->Y));
				Ghost_Dir = dir;
				Ghost_Data = combo+4;
				vars[0] = 0;
				int tX; int tY;
				int babaMoveStep[2];
				babaMoveStep[0] = LazyDiffMod(0.5, 0.6, 0.7);
				babaMoveStep[1] = LazyDiffMod(0.0, 0.3, 0.5);
				for(i=0; i<64; i++){
					tX = Ghost_X;
					tY = Ghost_Y;
					if(dir==DIR_UP){
						tX = Link->X;
						tY = Link->Y+48;
					}
					else if(dir==DIR_DOWN){
						tX = Link->X;
						tY = Link->Y-48;
					}
					else if(dir==DIR_LEFT){
						tX = Link->X+48;
						tY = Link->Y;
					}
					else if(dir==DIR_RIGHT){
						tX = Link->X-48;
						tY = Link->Y;
					}
					if(Distance(Ghost_X, Ghost_Y, tX, tY)>babaMoveStep[0]){
						Ghost_MoveAtAngle(Angle(Ghost_X, Ghost_Y, tX, tY), babaMoveStep[0], 0);
					}
					else{
						Ghost_X = tX;
						Ghost_Y = tY;
					}
					Ghost_X = Clamp(Ghost_X, 32, 208);
					Ghost_Y = Clamp(Ghost_Y, 32, 128);
					Q7_Ghost_Waitframe(this, ghost);
				}
				lweapon bah[12];
				if(AllowSomeJokes())
					Game->PlaySound(SFX_BABABABA);
				for(i=0; i<4; i++){
					if(!AllowSomeJokes())
						Game->PlaySound(SFX_WAND);
					for(k=0; k<3; k++){
						bah[i*3+k] = SparkleSpriteAnim(Ghost_X+Rand(-3, 3), Ghost_Y+Rand(-3, 3), SPR_BABABABA, 1, 1, DirAngle(dir), Rand(800, 1000));
						if(dir>=2){
							bah[i*3+k]->OriginalTile += 4;
							bah[i*3+k]->Tile = bah[i*3+k]->OriginalTile;
						}
						if(bah[i*3+k]->Dir==DIR_DOWN)
							bah[i*3+k]->Flip = 2;
						else if(bah[i*3+k]->Dir==DIR_LEFT)
							bah[i*3+k]->Flip = 1;
					}
					
					for(j=0; j<6; j++){
						tX = Ghost_X;
						tY = Ghost_Y;
						if(dir==DIR_UP){
							tX = Link->X;
							tY = Link->Y+24;
						}
						else if(dir==DIR_DOWN){
							tX = Link->X;
							tY = Link->Y-24;
						}
						else if(dir==DIR_LEFT){
							tX = Link->X+24;
							tY = Link->Y;
						}
						else if(dir==DIR_RIGHT){
							tX = Link->X-24;
							tY = Link->Y;
						}
						if(Distance(Ghost_X, Ghost_Y, tX, tY)>babaMoveStep[1]){
							Ghost_MoveAtAngle(Angle(Ghost_X, Ghost_Y, tX, tY), babaMoveStep[1], 0);
						}
						else{
							Ghost_X = tX;
							Ghost_Y = tY;
						}
						Ghost_X = Clamp(Ghost_X, 32, 208);
						Ghost_Y = Clamp(Ghost_Y, 32, 128);
					
						for(k=0; k<12; k++){
							if(bah[k]->isValid()){
								if(LinkCollision(bah[k])){
									eweapon boom = CreateEWeaponAt(EW_BOMBBLAST, bah[k]->X, bah[k]->Y);
									boom->CollDetection = false;
									
									int damage = LazyDiffMod(DAMAGE_BABABABA, DAMAGE_BABABABA+1, DAMAGE_BABABABA+2);
									if(Link->Item[I_DIFF_VERYEASY])
										damage *= 0.25;
									else if(Link->Item[I_DIFF_EASY])
										damage *= 0.5;
									DealDirectDamage(damage);
									Link->Action = LA_GOTHURTLAND;
									Game->PlaySound(SFX_OUCH);
									Link->HitDir = -1;
									
									lweapon nullLWeapon;
									bah[k] = nullLWeapon;
								}
							}
						}
					
						Q7_Ghost_Waitframe(this, ghost);
					}
				}
				Ghost_Data = combo;
				for(j=0; j<12; j++){
					tX = Ghost_X;
					tY = Ghost_Y;
					if(dir==DIR_UP){
						tX = Link->X;
						tY = Link->Y+64;
					}
					else if(dir==DIR_DOWN){
						tX = Link->X;
						tY = Link->Y-64;
					}
					else if(dir==DIR_LEFT){
						tX = Link->X+64;
						tY = Link->Y;
					}
					else if(dir==DIR_RIGHT){
						tX = Link->X-64;
						tY = Link->Y;
					}
					if(Distance(Ghost_X, Ghost_Y, tX, tY)>1){
						Ghost_MoveAtAngle(Angle(Ghost_X, Ghost_Y, tX, tY), 1, 0);
					}
					else{
						Ghost_X = tX;
						Ghost_Y = tY;
					}
					Ghost_X = Clamp(Ghost_X, 32, 208);
					Ghost_Y = Clamp(Ghost_Y, 32, 128);
				
					for(k=0; k<12; k++){
						if(bah[k]->isValid()){
							if(LinkCollision(bah[k])){
								eweapon boom = CreateEWeaponAt(EW_BOMBBLAST, bah[k]->X, bah[k]->Y);
								boom->CollDetection = false;
								
								int damage = LazyDiffMod(DAMAGE_BABABABA, DAMAGE_BABABABA+1, DAMAGE_BABABABA+2);
								if(Link->Item[I_DIFF_VERYEASY])
									damage *= 0.25;
								else if(Link->Item[I_DIFF_EASY])
									damage *= 0.5;
								DealDirectDamage(damage);
								Link->Action = LA_GOTHURTLAND;
								Game->PlaySound(SFX_OUCH);
								Link->HitDir = -1;
								
								lweapon nullLWeapon;
								bah[k] = nullLWeapon;
							}
						}
					}
				
					Q7_Ghost_Waitframe(this, ghost);
				}
			}
			Q7_Ghost_Waitframe(this, ghost);
		}
	}
	void BBIY_UpdateWeapons(lweapon bah){
		for(int k=0; k<12; k++){
			if(bah[k]->isValid()){
				if(LinkCollision(bah[k])&&Link->Action!=LA_DIVING&&Link->Action!=LA_FROZEN){
					eweapon boom = CreateEWeaponAt(EW_BOMBBLAST, bah[k]->X, bah[k]->Y);
					boom->CollDetection = false;
					
					int damage = LazyDiffMod(DAMAGE_BABABABA, DAMAGE_BABABABA+1, DAMAGE_BABABABA+2);
					if(Link->Item[I_DIFF_VERYEASY])
						damage *= 0.25;
					else if(Link->Item[I_DIFF_EASY])
						damage *= 0.5;
					DealDirectDamage(damage);
					Link->Action = LA_GOTHURTLAND;
					Game->PlaySound(SFX_OUCH);
					Link->HitDir = -1;
					
					lweapon nullLWeapon;
					bah[k] = nullLWeapon;
				}
			}
		}
	}
}
	
//{ Blue Wizzrobe Movement Functions
	void Reproduction_BlueWizz_Update(ffc this, npc ghost, int vars){
		//vars[0] - Attack Flag
		//vars[1] - Movement Timer
		//vars[2] - Dir
		//vars[3] - Current Behavior 
		//vars[4] - Firing Clock
		//vars[5] - Fake Dir
		
		if(ghost->HP<=0){
			ghost->DrawYOffset = -2;
			Quit();
		}
		
		if(vars[3]==1||vars[3]==3)
			ghost->DrawYOffset = Cond(vars[1]&1, -1000, -2);
		else
			ghost->DrawYOffset = -2;
			
		
		vars[0] = 0;
		
		if(vars[1]<=0 || ((vars[1]&31)==0 && !Reproduction_BlueWizz_CanMove(vars[2], 1, RSPW_DOOR) && !vars[3])){
			Reproduction_BlueWizz_FixCoords();
			bool checkMove = false;
			if(vars[3]==EWIZZ_WALKING){ //Was walking
				if(!Reproduction_BlueWizz_Walkflag(Ghost_X, Ghost_Y, RSPW_DOOR)){
					vars[3] = 0; //Turning
				}
				else{
					vars[1] = 16;
					if(!Reproduction_BlueWizz_CanMove(vars[2], 1, RSPW_WIZZROBE)){
						Reproduction_BlueWizz_NewDir(vars, 0);
					}
				}
			}
			else if(vars[3]==EWIZZ_PHASING){ //Was about to phase
				int jx = Ghost_X;
				int jy = Ghost_Y;
				int jdir = -1;
				
				int r = Rand(8);
				if(r==0){
					jx -= 32;
					jy -= 32;
					jdir = 15;
				}
				else if(r==1){
					jx += 32;
					jy -= 32;
					jdir = 9;
				}
				else if(r==2){
					jx += 32;
					jy += 32;
					jdir = 11;
				}
				else if(r==3){
					jx -= 32;
					jy += 32;
					jdir = 13;
				}
				
				if(jdir>0&& jx>=32 && jx <= 208 && jy >= 32 && jy <= 128){
					if(jdir==15){ //leftup
						if(vars[2]==DIR_LEFT||vars[2]==DIR_UP)
							vars[5] = vars[2];
						else if(vars[2]==DIR_DOWN)
							vars[5] = DIR_LEFT;
						else if(vars[2]==DIR_RIGHT)
							vars[5] = DIR_UP;
						else
							vars[5] = DIR_LEFT;
					}
					else if(jdir==9){ //rightup
						if(vars[2]==DIR_RIGHT||vars[2]==DIR_UP)
							vars[5] = vars[2];
						else if(vars[2]==DIR_DOWN)
							vars[5] = DIR_RIGHT;
						else if(vars[2]==DIR_LEFT)
							vars[5] = DIR_UP;
						else
							vars[5] = DIR_RIGHT;
					}
					else if(jdir==11){ //right down
						if(vars[2]==DIR_RIGHT||vars[2]==DIR_DOWN)
							vars[5] = vars[2];
						else if(vars[2]==DIR_UP)
							vars[5] = DIR_RIGHT;
						else if(vars[2]==DIR_LEFT)
							vars[5] = DIR_RIGHT;
						else
							vars[5] = DIR_RIGHT;
					}
					else if(jdir==13){ //left down
						if(vars[2]==DIR_LEFT||vars[2]==DIR_DOWN)
							vars[5] = vars[2];
						else if(vars[2]==DIR_UP)
							vars[5] = DIR_LEFT;
						else if(vars[2]==DIR_RIGHT)
							vars[5] = DIR_LEFT;
						else
							vars[5] = DIR_LEFT;
					}
					
					vars[3] = EWIZZ_4DIR; //4-Dir
					vars[1] = 32;
					vars[2] = jdir;
				}
			}
			else if(vars[3]==EWIZZ_4DIR){ //4-Dir
				checkMove = true;
				vars[2] &= 3;
				vars[3] = EWIZZ_TURN; //Turning 0
				vars[5] = -1;
				Reproduction_BlueWizz_NewDir(vars, 64);
			}
			else if(vars[3]==EWIZZ_TURN){ //Turning
				checkMove = true;
				Reproduction_BlueWizz_NewDir(vars, 64);
			}
			if(checkMove){
				//Check if against solidity
				if(!Reproduction_BlueWizz_CanMove(vars[2], 1, RSPW_DOOR)){
					if(Reproduction_BlueWizz_CanMove(vars[2], 15, RSPW_WIZZROBE)){
						vars[3] = EWIZZ_WALKING; //Walking 1
						vars[1] = 16;
					}
					else{
						Reproduction_BlueWizz_NewDir(vars, 64);
						vars[3] = EWIZZ_TURN; //Turning
						vars[1] = 32;
					}
				}
				else{
					vars[1] = 32;
				}
			}
			
			if(vars[3]<0)
				++vars[3];
		}
		--vars[1];
		
		int step;
		if(vars[3]==EWIZZ_WALKING||vars[3]==EWIZZ_4DIR){
			step = 1;
		}
		else if(vars[3]==2){
			step = 0;
		}
		else{
			step = 0.5;
		}
		
		int vX = DirX(__NormalizeDir(vars[2]), step);
		int vY = DirY(__NormalizeDir(vars[2]), step);
		Ghost_MoveXY(vX, vY, 0);
		
		if(vars[3]<=0 && vars[1]==28 ){
			if(__Ghost_LinedUp(8, false)==vars[2]){
				vars[0] = 1;
				vars[4] = 30;
			}
		}
		
		if(vars[3]==EWIZZ_TURN && Rand(128)==0)
			vars[3] = EWIZZ_PHASING;
		
		if(vars[3]==EWIZZ_PHASING && vars[1]==4)
			Reproduction_BlueWizz_FixCoords();
		
		if(vars[4]>0)
			--vars[4];
		
		if(vars[5]>-1)
			Ghost_Dir = vars[5];
		else if(vars[2]<4)
			Ghost_Dir = vars[2];
	}
	bool Reproduction_BlueWizz_CanMove(int dir, int s, int special){
		int dx1 = 0;
		int dy1 = -8;
		int dx2 = 15;
		int dy2 = 15;
		
		int x; int y;
		int ct;
		bool ok;
		if(dir<0||dir>15)
			return false;
		if(dir==DIR_UP||dir==8){
			x = Ghost_X;
			y = Ghost_Y+dy1-s;
			//Screen->PutPixel(6, x, y, Rand(16), 0, 0, 0, 128);
			ct = Screen->ComboT[ComboAt(x, y)];
			if(!(special==RSPW_FLOATER&&ct==CT_NOFLYZONE)){
				ok = !Reproduction_BlueWizz_Walkflag(x,y,Cond(special==RSPW_CLIPBOTTOMRIGHT,RSPW_NONE,special));
			}
			
		}
		else if(dir==DIR_DOWN||dir==12){
			x = Ghost_X;
			y = Ghost_Y+dy2+s;
			//Screen->PutPixel(6, x, y, Rand(16), 0, 0, 0, 128);
			ct = Screen->ComboT[ComboAt(x, y)];
			if(!(special==RSPW_FLOATER&&ct==CT_NOFLYZONE)){
				ok = !Reproduction_BlueWizz_Walkflag(x,y,Cond(special==RSPW_CLIPBOTTOMRIGHT,RSPW_NONE,special));
			}
		}
		else if(dir==DIR_LEFT||dir==14){
			x = Ghost_X+dx1-s;
			y = Ghost_Y+8;
			//Screen->PutPixel(6, x, y, Rand(16), 0, 0, 0, 128);
			ct = Screen->ComboT[ComboAt(x, y)];
			if(!(special==RSPW_FLOATER&&ct==CT_NOFLYZONE)){
				ok = !Reproduction_BlueWizz_Walkflag(x,y,Cond(special==RSPW_CLIPBOTTOMRIGHT,RSPW_NONE,special));
			}
		}
		else if(dir==DIR_RIGHT||dir==10){
			x = Ghost_X+dx2+s;
			y = Ghost_Y+8;
			//Screen->PutPixel(6, x, y, Rand(16), 0, 0, 0, 128);
			ct = Screen->ComboT[ComboAt(x, y)];
			if(!(special==RSPW_FLOATER&&ct==CT_NOFLYZONE)){
				ok = !Reproduction_BlueWizz_Walkflag(x,y,Cond(special==RSPW_CLIPBOTTOMRIGHT,RSPW_NONE,special));
			}
		}
		else if(dir==DIR_LEFTUP||dir==15){
			x = Ghost_X;
			y = Ghost_Y+dy1-s;
			//Screen->PutPixel(6, x, y, Rand(16), 0, 0, 0, 128);
			ct = Screen->ComboT[ComboAt(x, y)];
			if(!(special==RSPW_FLOATER&&ct==CT_NOFLYZONE)){
				ok = !Reproduction_BlueWizz_Walkflag(x,y,Cond(special==RSPW_CLIPBOTTOMRIGHT,RSPW_NONE,special));
				if(!ok)
					return false;
			}
			x = Ghost_X+dx1-s;
			y = Ghost_Y+8;
			//Screen->PutPixel(6, x, y, Rand(16), 0, 0, 0, 128);
			ct = Screen->ComboT[ComboAt(x, y)];
			if(!(special==RSPW_FLOATER&&ct==CT_NOFLYZONE)){
				ok = !Reproduction_BlueWizz_Walkflag(x,y,Cond(special==RSPW_CLIPBOTTOMRIGHT,RSPW_NONE,special));
			}
		}
		else if(dir==DIR_RIGHTUP||dir==9){
			x = Ghost_X;
			y = Ghost_Y+dy1-s;
			//Screen->PutPixel(6, x, y, Rand(16), 0, 0, 0, 128);
			ct = Screen->ComboT[ComboAt(x, y)];
			if(!(special==RSPW_FLOATER&&ct==CT_NOFLYZONE)){
				ok = !Reproduction_BlueWizz_Walkflag(x,y,Cond(special==RSPW_CLIPBOTTOMRIGHT,RSPW_NONE,special));
				if(!ok)
					return false;
			}
			x = Ghost_X+dx2+s;
			y = Ghost_Y+8;
			//Screen->PutPixel(6, x, y, Rand(16), 0, 0, 0, 128);
			ct = Screen->ComboT[ComboAt(x, y)];
			if(!(special==RSPW_FLOATER&&ct==CT_NOFLYZONE)){
				ok = !Reproduction_BlueWizz_Walkflag(x,y,Cond(special==RSPW_CLIPBOTTOMRIGHT,RSPW_NONE,special));
			}
		}
		else if(dir==DIR_LEFTDOWN||dir==13){
			x = Ghost_X;
			y = Ghost_Y+dy2+s;
			//Screen->PutPixel(6, x, y, Rand(16), 0, 0, 0, 128);
			ct = Screen->ComboT[ComboAt(x, y)];
			if(!(special==RSPW_FLOATER&&ct==CT_NOFLYZONE)){
				ok = !Reproduction_BlueWizz_Walkflag(x,y,Cond(special==RSPW_CLIPBOTTOMRIGHT,RSPW_NONE,special));
				if(!ok)
					return false;
			}
			x = Ghost_X+dx1-s;
			y = Ghost_Y+8;
			//Screen->PutPixel(6, x, y, Rand(16), 0, 0, 0, 128);
			ct = Screen->ComboT[ComboAt(x, y)];
			if(!(special==RSPW_FLOATER&&ct==CT_NOFLYZONE)){
				ok = !Reproduction_BlueWizz_Walkflag(x,y,Cond(special==RSPW_CLIPBOTTOMRIGHT,RSPW_NONE,special));
			}
		}
		else if(dir==DIR_RIGHTDOWN||dir==11){
			x = Ghost_X;
			y = Ghost_Y+dy2+s;
			//Screen->PutPixel(6, x, y, Rand(16), 0, 0, 0, 128);
			ct = Screen->ComboT[ComboAt(x, y)];
			if(!(special==RSPW_FLOATER&&ct==CT_NOFLYZONE)){
				ok = !Reproduction_BlueWizz_Walkflag(x,y,Cond(special==RSPW_CLIPBOTTOMRIGHT,RSPW_NONE,special));
				if(!ok)
					return false;
			}
			x = Ghost_X+dx2+s;
			y = Ghost_Y+8;
			//Screen->PutPixel(6, x, y, Rand(16), 0, 0, 0, 128);
			ct = Screen->ComboT[ComboAt(x, y)];
			if(!(special==RSPW_FLOATER&&ct==CT_NOFLYZONE)){
				ok = !Reproduction_BlueWizz_Walkflag(x,y,Cond(special==RSPW_CLIPBOTTOMRIGHT,RSPW_NONE,special));
			}
		}
		else
			ok = true;
		return ok;
	}
	void Reproduction_BlueWizz_NewDir(int vars, int homing){
		if(Ghost_X<32)
			vars[2] = DIR_RIGHT;
		else if(Ghost_X>=224)		
			vars[2] = DIR_LEFT;
		else if(Ghost_Y<32)
			vars[2] = DIR_DOWN;
		else if(Ghost_Y>=144)
			vars[2] = DIR_UP;
		else{
			Reproduction_BlueWizzrobe_NewDir4(vars, 4, homing, 0, 0);
		}
	}
	int Reproduction_BlueWizz_Lined_Up(int range)
	{
		int lx = Link->X;
		int ly = Link->Y;
		if(Abs(lx-Ghost_X)<=range)
		{
			if(ly<Ghost_Y)
				return DIR_UP;
			return DIR_DOWN;
		}
		if(Abs(ly-Ghost_Y)<=range)
		{
			if(lx<Ghost_X)
				return DIR_LEFT;
			return DIR_RIGHT;
		}
		return -1;
	}
	void Reproduction_BlueWizzrobe_NewDir4(int vars, int rate, int homing, int special, int grumble){
		//Screen->FastTile(6, Ghost_X, Ghost_Y, Link->Tile, 6, 128);
		
		// changes enemy's direction, checking restrictions
		// rate:   0 = no random changes, 16 = always random change
		// homing: 0 = none, 256 = always
		// grumble 0 = none, 4 = strongest appetite
		int ndir;
		if(grumble && Rand(4)<grumble)
		{
			lweapon l = LoadLWeaponOf(LW_BAIT);
			if(l->isValid())
			{
				int bx = l->X;
				int by = l->Y;
				if(Abs(Ghost_Y-by)>14)
				{
					ndir = Cond(by<Ghost_Y, DIR_UP, DIR_DOWN);
					if(Reproduction_BlueWizz_CanMove(ndir,1,special))
					{
						vars[2]=ndir;
						return;
					}
				}
				ndir = Cond(bx<Ghost_Y, DIR_LEFT, DIR_RIGHT);
				if(Reproduction_BlueWizz_CanMove(ndir,1,special))
				{
					vars[2]=ndir;
					return;
				}
			}
		}
		if((Rand(256))<homing)
		{
			ndir = Reproduction_BlueWizz_Lined_Up(8);
			if(ndir>=0 && Reproduction_BlueWizz_CanMove(ndir,1,special))
			{
				vars[2]=ndir;
				return;
			}
		}

		int i=0;
		for(i=0; i<32; i++)
		{
			int r=Rand(16);
			if(r<rate)
				ndir=Rand(4);
			else
				ndir=vars[2];
			if(Reproduction_BlueWizz_CanMove(ndir,1,special))
				break;
		}
		if(i==32)
		{
			for(ndir=0; ndir<4; ndir++)
			{
				if(Reproduction_BlueWizz_CanMove(ndir,1,special)){
					vars[2] = ndir;
					return;
				}
			}
			ndir = -1;
		}
		vars[2] = ndir;
	}
	void Reproduction_BlueWizz_FixCoords(){
		Ghost_X=(Ghost_X&0xF0)+Cond((Ghost_X&8),16,0);
		Ghost_Y=(Ghost_Y&0xF0)+Cond((Ghost_Y&8),16,0);
	}
	bool Reproduction_BlueWizz_IsDungeon(){
		return Game->GetCurLevel()>0;
	}
	bool Reproduction_BlueWizz_Walkflag(int x,int y,int special){
		int yg = Cond(special==RSPW_FLOATER, 8, 0);

		if(x<16 || y<16-yg || x>=240 || y>=160)
			return true;

		if(Reproduction_BlueWizz_IsDungeon() || special==RSPW_WIZZROBE)
		{
			if(y<32-yg || y>=144)
				return true;
			if(x<32 || x>=224)
			{
				if(special!=RSPW_DOOR)                                 // walk in door way
					return true;
			}
		}

		if(special==RSPW_CLIPBOTTOMRIGHT){
			if(y>=128) return true;
		}
		else if(special==RSPW_CLIPRIGHT){
			if(x>=208) return true;
		}
		else if(special==RSPW_WIZZROBE||special==RSPW_FLOATER){
			return false;
		}

		x&=Cond(special==RSPW_HALFSTEP,(~7),(~15));
		y&=Cond(special==RSPW_HALFSTEP,(~7),(~15));

		// if(special==spw_water)
		// return water_walkflag(x,y+8,1) || water_walkflag(x+8,y+8,1);

		// Screen->PutPixel(6, x, y+8, Rand(16), 0, 0, 0, 128);
		// Screen->PutPixel(6, x+8, y+8, Rand(16), 0, 0, 0, 128);
				
		return Screen->isSolid(x,y+8) || Screen->isSolid(x+8,y+8);
		// return _walkflag(x,y+8,1) || _walkflag(x+8,y+8,1) ||
			// COMBOTYPE(x,y+8)==cPIT || COMBOTYPE(x+8,y+8)==cPIT;
	}
//}

ffc script Cracktorok{
	void run(int enemyid){
		npc ghost = Ghost_InitAutoGhost(this, enemyid);
		this->Flags[FFCF_ETHEREAL] = true;
		
		if(!IsHardMode())
			ghost->WeaponDamage = ghost->WeaponDamage*0.5;
		int vars[16] = {0, 0, 0, ghost->HP, 0};
		
		while(true){
			CR_Update(this, ghost, vars);
			Ghost_Waitframe2(this, ghost, true, true);
		}
	}
	void CR_Update(ffc this, npc ghost, int vars){
		vars[4]++;
		vars[4] %= 360;
		
		if(vars[1]<vars[0]){
			vars[1] += 0.1;
		}
		if(vars[1]>=6){
			int x = Ghost_X;
			int y = Ghost_Y;
			int damage = ghost->Damage;
			for(int i=0; i<10; i++){
				eweapon e = FireEWeapon(EW_FIREBALL, Ghost_X, Ghost_Y, DegtoRad(36*i), 250, damage, SPR_FIREBALL_UNBLOCKABLE, -1, EWF_UNBLOCKABLE);
				e = FireEWeapon(EW_FIREBALL, Ghost_X, Ghost_Y, DegtoRad(18+36*i), 150, damage, SPR_FIREBALL_UNBLOCKABLE, -1, EWF_UNBLOCKABLE);
			}
			ghost->DrawYOffset = -2;
			ghost->HP = 0;
			ghost->Misc[NPCM_LASTHP] = 0;
			for(int i=0; i<16; i++){
				eweapon e = CreateEWeaponAt(EW_BOMBBLAST, x+Rand(-16, 16), y+Rand(-16, 16));
				e->Damage = damage;
				Waitframes(2);
			}
			this->Data = 0;
			Quit();
		}
		if(vars[1]>0){
			if(ghost->HP<vars[3]){
				vars[3] = ghost->HP;
				vars[2] = 32;
			}
			int cs = ghost->CSet;
			if(vars[2]>0){
				vars[2]--;
				cs = FlashCSet(vars[2]);
			}
			
			int flip;
			if(ghost->Dir==DIR_UP)
				flip = 2;
			else if(ghost->Dir==DIR_RIGHT)
				flip = 1;
			
			ghost->DrawYOffset = -1000;
			int sc = 16+(4*vars[1]+1+Sign(vars[4]*8));
			int layer = 2;
			if(ScreenFlag(1, 4)) //Layer -2
				layer = 1;
			if(Link->HP>0)
				Screen->DrawTile(layer, Ghost_X-(sc-16)*0.5, Ghost_Y-(sc-16)*0.5-2, ghost->Tile, 1, 1, cs, sc, sc, 0, 0, 0, flip, true, 128);
			ghost->HitXOffset = -(sc-16)*0.5;
			ghost->HitYOffset = -(sc-16)*0.5;
			ghost->HitWidth = sc;
			ghost->HitHeight = sc;
		}
		for(int i=Screen->NumLWeapons(); i>=1; i--){
			lweapon l = Screen->LoadLWeapon(i);
			if(l->ID==LW_MAGIC||l->ID==LW_REFMAGIC){
				if(Collision(l, ghost)){
					Game->PlaySound(SFX_CLINK);
					l->CollDetection = false;
					l->DeadState = 0;
					l->Misc[LWM_REFCOUNT] = -1000;
					if(vars[1]>=vars[0]){
						vars[0]++;
						ghost->Stun = 10;
						if(vars[0]==3){
							vars[0] += 8;
							ghost->Stun = 60;
							Game->PlaySound(SFX_CHARGE2);
						}
						else{
							Game->PlaySound(SFX_CHARGE1);
						}
						ghost->WeaponDamage = Min(ghost->WeaponDamage*2, 48);
						ghost->Step = Min(ghost->Step+50, 200);
					}
				}
			}
		}
		if(ghost->HP<=0){
			ghost->DrawYOffset = -2;
			this->Data = 0;
			Quit();
		}
	}
}

const int SFX_SHOCKROBE_DASH = 79;

ffc script ShockWizzrobe{
	void run(int enemyid){
		int i; int j; int k;
		int x; int y;
		
		npc ghost = Ghost_InitAutoGhost(this, enemyid);
		this->Flags[FFCF_ETHEREAL] = true;
		
		Ghost_SetFlag(GHF_4WAY);
		Ghost_SetFlag(GHF_IGNORE_ALL_TERRAIN);
		Ghost_SetFlag(GHF_FLYING_ENEMY);
		
		int vars[16];
		if(Ghost_X<120)
			Ghost_Dir = DIR_RIGHT;
		else
			Ghost_Dir = DIR_LEFT;
		vars[1] = -3;
		vars[2] = Ghost_Dir;
		vars[5] = -1;
		
		int combo = ghost->Attributes[10];
		
		int shockballAngle = Rand(360);
		int shockballDist = 24;
		if(IsHardMode())
			shockballDist = 40;
		int dashCooldown;
		int maxDashCooldown = 70;
		if(IsHardMode())
			maxDashCooldown = 50;
		
		while(true){
			int oldVars3 = Cond(vars[3]==EWIZZ_PHASING, 0, vars[3]);
			Reproduction_BlueWizz_Update(this, ghost, vars);
			if(vars[3]==EWIZZ_PHASING){
				if(dashCooldown>0)
					vars[3] = oldVars3;
			}
			if(dashCooldown>0)
				dashCooldown--;
			if(Link->HP>0){
				if(vars[3]==3){
					if(vars[1]==31)
						Game->PlaySound(SFX_SHOCKROBE_DASH);
					if(vars[1]==0)
						dashCooldown = maxDashCooldown;
					if(vars[1]&1)
						Screen->FastCombo(3, Ghost_X+Rand(-3, 3), Ghost_Y+Rand(-3, 3), combo+4, 1, 128);
				
					shockballAngle += 8;
					shockballAngle %= 360;
					
					for(i=0; i<3; i++){
						x = Ghost_X+VectorX(12+shockballDist*Sin(180/32*vars[1]), shockballAngle+120*i);
						y = Ghost_Y+VectorY(12+shockballDist*Sin(180/32*vars[1]), shockballAngle+120*i);
						Screen->FastCombo(3, x, y, combo+5, 1, 128);
						MakeHitbox(x, y, 16, 16, ghost->WeaponDamage);
					}
				}
				else{
					Screen->FastCombo(3, Ghost_X+Rand(-3, 3), Ghost_Y+Rand(-3, 3), combo+4, 1, 128);
				
					shockballAngle += 2;
					shockballAngle %= 360;
					
					for(i=0; i<3; i++){
						x = Ghost_X+VectorX(12, shockballAngle+120*i);
						y = Ghost_Y+VectorY(12, shockballAngle+120*i);
						Screen->FastCombo(3, x, y, combo+5, 1, 128);
						MakeHitbox(x, y, 16, 16, ghost->WeaponDamage);
					}
				}
			}
			Q7_Ghost_Waitframe(this, ghost);
		}
	}
}

ffc script Firenut{
	void run(int enemyid){
		int i; int j; int k;
		int x; int y;
		int angle;
		
		npc ghost = Ghost_InitAutoGhost(this, enemyid);
		this->Flags[FFCF_ETHEREAL] = true;
		Ghost_SetFlag(GHF_4WAY);
		Ghost_SetFlag(GHF_STUN);
		int combo = ghost->Attributes[10];
		
		Ghost_SpawnAnimationPuff(this, ghost);
		
		int counter = -1;
		
		int dashCooldown = 60;
	
		int fX[16];
		int fY[16];
		for(i=0; i<16; i++){
			fX[i] = -1000;
			fY[i] = -1000;
		}
		int vars[16] = {fX, fY};
	
		while(true){
			Ghost_Data = combo;
			counter = Ghost_ConstantWalk4(counter, ghost->Step, ghost->Rate, ghost->Homing, ghost->Hunger);
			
			if(dashCooldown>0){
				dashCooldown--;
			}
			else{
				if(Ghost_CanMove(Ghost_Dir, 32, 0)&&((__Ghost_LinedUp(8, false)&&Ghost_Dir==OppositeDir(Link->Dir))||(Rand(16)<ghost->Haltrate&&(Ghost_X%16==0&&Ghost_Y%16==0)))){
					dashCooldown = LazyDiffMod(90, 60, 30);
					
					ghost->CollDetection = false;
					ghost->DrawYOffset = -1000;
					for(i=0; i<16; i++){
						fX[i] = Ghost_X;
						fY[i] = Ghost_Y;
					}
					Game->PlaySound(SFX_FIRE);
					j = 0;
					int dashDelay = LazyDiffMod(32, 24, 16);
					for(i=0; i<dashDelay; i++){
						j++;
						if(j%4==0)
							Game->PlaySound(SFX_FIRE);
						FN_Waitframe(this, ghost, vars);
					}
					
					k = 10;
					while(Ghost_CanMove(Ghost_Dir, 1, 0)||k>0){
						k--;
						j++;
						if(j%4==0)
							Game->PlaySound(SFX_FIRE);
						Ghost_Move(Ghost_Dir, LazyDiffMod(3, 3, 4), 0);
						FN_Waitframe(this, ghost, vars);
					}
					
					for(i=0; i<8; i++){
						FN_Waitframe(this, ghost, vars);
					}
					
					fX[0] = -1000;
					fY[0] = -1000;
					
					ghost->CollDetection = true;
					ghost->DrawYOffset = -2;
					
					counter = -1;
				}
			}
			
			FN_Waitframe(this, ghost, vars);
		}
	}
	void FN_DrawFire(npc ghost, int x, int y, int which){
		int combo = ghost->Attributes[10];
		if(Link->HP>0){
			Screen->FastCombo(2, x, y, combo+4+which, 8, 128);
			if(which==0)
				MakeHitbox(x, y, 16, 16, ghost->WeaponDamage);
			else if(which==1)
				MakeHitbox(x+2, y+2, 12, 12, ghost->WeaponDamage);
			else if(which==2)
				MakeHitbox(x+4, y+4, 8, 8, ghost->WeaponDamage);
		}
	}
	void FN_Waitframe(ffc this, npc ghost, int vars){
		int fX = vars[0];
		int fY = vars[1];
		for(int i=15; i>=0; i--){
			if(i==0){
				if(fX[i]>-1000){
					fX[i] = Ghost_X;
					fY[i] = Ghost_Y;
					
					if(i%2==0){
						FN_DrawFire(ghost, fX[i], fY[i], 0);
					}
				}
			}
			else{
				fX[i] = fX[i-1];
				fY[i] = fY[i-1];
				if(fX[i]>-1000){
					if(i%2==0){
						if(i==14)
							FN_DrawFire(ghost, fX[i], fY[i], 2);
						else if(i==12)
							FN_DrawFire(ghost, fX[i], fY[i], 1);
						else
							FN_DrawFire(ghost, fX[i], fY[i], 0);
					}
				}
			}
		}
		Q7_Ghost_Waitframe(this, ghost, true, true);
	}
}

ffc script GibDough{
	void run(int enemyid){
		int i; int j; int k;
		
		npc ghost = Ghost_InitAutoGhost(this, enemyid);
		this->Flags[FFCF_ETHEREAL] = true;
		
		Ghost_SetFlag(GHF_KNOCKBACK);
		Ghost_SetFlag(GHF_STUN);
		int counter = -1;
		
		int dashCooldown = 90;
		int maxDashCooldown = 120;
		if(IsHardMode())
			maxDashCooldown = 60;
		
		int aggression = 0;
		
		while(true){
			counter = Ghost_ConstantWalk4(counter, ghost->Step, ghost->Rate, ghost->Homing, ghost->Hunger);
			if(Ghost_GotHit())
				aggression = 300;
			if(aggression>0)
				aggression--;
			if(dashCooldown>0)
				dashCooldown--;
			else if(counter>-1&&Abs(Link->X-Ghost_X)<64&&Abs(Link->Y-Ghost_Y)<64){
				if(Rand(32)==0){
					dashCooldown = maxDashCooldown;
					if(aggression>0)
						dashCooldown *= ((300-aggression)/300);
					
					Game->PlaySound(SFX_ROCK);
					j = LazyDiffMod(12, 16, 16);
					k = LazyDiffMod(2, 2, 3);
					for(i=0; i<j; i++){
						if(Ghost_GotHit())
							aggression = 300;
						Ghost_Move(Ghost_Dir, k, 0);
						Q7_Ghost_Waitframe(this, ghost);
					}
					counter = -1;
				}
			}
			Q7_Ghost_Waitframe(this, ghost);
		}
	}
}

ffc script KnightKnight{
	void run(int enemyid){
		int i;
		npc ghost = Ghost_InitAutoGhost(this, enemyid);
		this->Flags[FFCF_ETHEREAL] = true;
		
		Ghost_SetFlag(GHF_FAKE_Z);
		Ghost_SetFlag(GHF_FLYING_ENEMY);
		
		int maxMoveCooldown = 60;
		if(IsHardMode())
			maxMoveCooldown = 30;
		int moveCooldown = maxMoveCooldown;
		
		int moveArray[3];
		
		int defenses[18];
		Ghost_StoreDefenses(ghost, defenses);
		while(true){
			KK_SetGFX(this, ghost, 0);
			bool upright = true;
			if(moveCooldown>0)
				moveCooldown--;
			else if(Rand(32)==0){
				if(Distance(Link->X, Link->Y, Ghost_X, Ghost_Y)<ghost->Homing){
					bool foundMove = KK_FindMove(-1, moveArray);
					if(foundMove){
						Ghost_SetFlag(GHF_IGNORE_ALL_TERRAIN);
						//Screen->FastTile(6, Ghost_X+DirX(moveArray[0], 32)+DirX(moveArray[1], 16), Ghost_Y+DirY(moveArray[0], 32)+DirY(moveArray[1], 16), Link->Tile, 6, 128);
						upright = KK_MakeMove(this, ghost, moveArray);
						Ghost_UnsetFlag(GHF_IGNORE_ALL_TERRAIN);
						moveCooldown = maxMoveCooldown;
					}
				}
				else{
					bool foundMove = KK_FindMove(Rand(4), moveArray);
					if(foundMove){
						Ghost_SetFlag(GHF_IGNORE_ALL_TERRAIN);
						//Screen->FastTile(6, Ghost_X+DirX(moveArray[0], 32)+DirX(moveArray[1], 16), Ghost_Y+DirY(moveArray[0], 32)+DirY(moveArray[1], 16), Link->Tile, 6, 128);
						upright = KK_MakeMove(this, ghost, moveArray);
						Ghost_UnsetFlag(GHF_IGNORE_ALL_TERRAIN);
						moveCooldown = maxMoveCooldown;
					}
				}
			}
			if(Ghost_GotHit())
				upright = false;
			if(!upright){
				i=0;
				Ghost_SetAllDefenses(ghost, NPCDT_BLOCK);
				ghost->Defense[NPCD_BOMB] = defenses[NPCD_BOMB];
				Ghost_Jump = 2.6;
				while(Ghost_Jump>0||Ghost_Z>0){
					if(!(++i%4))
						KK_SetGFX(this, ghost, 4+Rand(8));
					Q7_Ghost_Waitframe(this, ghost);
				}
				Ghost_Jump = 1.3;
				while(Ghost_Jump>0||Ghost_Z>0){
					if(!(++i%4))
						KK_SetGFX(this, ghost, 4+Rand(8));
					Q7_Ghost_Waitframe(this, ghost);
				}
				Ghost_Jump = 0.6;
				while(Ghost_Jump>0||Ghost_Z>0){
					if(!(++i%4))
						KK_SetGFX(this, ghost, 4+Rand(8));
					Q7_Ghost_Waitframe(this, ghost);
				}
				KK_SetGFX(this, ghost, Choose(4, 5));
				for(i=0; i<32; i++){
					Q7_Ghost_Waitframe(this, ghost);
				}
				for(i=0; i<32; i++){
					Ghost_X += Cond(i&1, 1, -1);
					Q7_Ghost_Waitframe(this, ghost);
				}
				KK_SetGFX(this, ghost, 0);
				Ghost_Jump = 1.6;
				while(Ghost_Jump>0||Ghost_Z>0){
					Q7_Ghost_Waitframe(this, ghost);
				}
				Ghost_X = GridX(Ghost_X+8);
				Ghost_Y = GridY(Ghost_Y+8);
				Ghost_SetDefenses(ghost, defenses);
			}
			Q7_Ghost_Waitframe(this, ghost);
		}
	}
	bool KK_InBounds(int x, int y){
		return x>=32&&y>=32&&x<=208&&y<=128;
	}
	bool KK_FindMove(int startingDir, int moveArray){
		int i; int j;
		int closestMoveDir1;
		int closestMoveDir2;
		int closestDist = 1000;
		int x; int y;
		int x2; int y2;
		int tempDir;
		int tempDir2;
		if(startingDir>-1){
			x = Ghost_X+DirX(startingDir, 32);
			y = Ghost_Y+DirY(startingDir, 32);
			if(KK_InBounds(x, y)){
				tempDir = startingDir;
				x2 = x; y2 = y;
				
				tempDir2 = RotDirCW4(startingDir);
				x = x2+DirX(tempDir2, 16);
				y = y2+DirY(tempDir2, 16);
				if(KK_InBounds(x, y)&&Ghost_CanPlace(x, y, 16, 16)){
					if(Distance(x, y, Link->X, Link->Y)<closestDist){
						closestDist = Distance(x, y, Link->X, Link->Y);
						closestMoveDir1 = tempDir;
						closestMoveDir2 = tempDir2;
					}
				}
				
				tempDir2 = RotDirCCW4(startingDir);
				x = x2+DirX(tempDir2, 16);
				y = y2+DirY(tempDir2, 16);
				if(KK_InBounds(x, y)&&Ghost_CanPlace(x, y, 16, 16)){
					if(Distance(x, y, Link->X, Link->Y)<closestDist){
						closestDist = Distance(x, y, Link->X, Link->Y);
						closestMoveDir1 = tempDir;
						closestMoveDir2 = tempDir2;
					}
				}
			}
		}
		else{
			for(i=0; i<4; i++){
				x = Ghost_X+DirX(i, 32);
				y = Ghost_Y+DirY(i, 32);
				if(KK_InBounds(x, y)){
					tempDir = i;
					x2 = x; y2 = y;
					
					tempDir2 = RotDirCW4(i);
					x = x2+DirX(tempDir2, 16);
					y = y2+DirY(tempDir2, 16);
					if(KK_InBounds(x, y)&&Ghost_CanPlace(x, y, 16, 16)){
						if(Distance(x, y, Link->X, Link->Y)<closestDist){
							closestDist = Distance(x, y, Link->X, Link->Y);
							closestMoveDir1 = tempDir;
							closestMoveDir2 = tempDir2;
						}
					}
					
					tempDir2 = RotDirCCW4(i);
					x = x2+DirX(tempDir2, 16);
					y = y2+DirY(tempDir2, 16);
					if(KK_InBounds(x, y)&&Ghost_CanPlace(x, y, 16, 16)){
						if(Distance(x, y, Link->X, Link->Y)<closestDist){
							closestDist = Distance(x, y, Link->X, Link->Y);
							closestMoveDir1 = tempDir;
							closestMoveDir2 = tempDir2;
						}
					}
				}
			}
		}
		if(closestDist<1000){
			moveArray[0] = closestMoveDir1;
			moveArray[1] = closestMoveDir2;
			return true;
		}
	}
	bool KK_MakeMove(ffc this, npc ghost, int moveArray){
		bool keepGoing;
		moveArray[2] = 0;
		if(Rand(2)){
			keepGoing = KK_MakeSubMove(this, ghost, moveArray[0], moveArray);
			if(keepGoing)
				keepGoing = KK_MakeSubMove(this, ghost, moveArray[0], moveArray);
			if(keepGoing)
				keepGoing = KK_MakeSubMove(this, ghost, moveArray[1], moveArray);
		}
		else{
			keepGoing = KK_MakeSubMove(this, ghost, moveArray[1], moveArray);
			if(keepGoing)
				keepGoing = KK_MakeSubMove(this, ghost, moveArray[0], moveArray);
			if(keepGoing)
				keepGoing = KK_MakeSubMove(this, ghost, moveArray[0], moveArray);
		}
		return keepGoing;
	}
	bool KK_MakeSubMove(ffc this, npc ghost, int dir, int moveArray){
		int i; int j;
		
		int step = ghost->Step*0.01;
		if(step==0)
			step = 1;
		int totalStep;
		
		int pos = ComboAt(Ghost_X+DirX(dir, 16)+8, Ghost_Y+DirY(dir, 16)+8);
		if(CanPlace(Ghost_X, Ghost_Y, 16, 16)&&CanPlace(ComboX(pos), ComboY(pos), 16, 16)){
			KK_SetGFX(this, ghost, 2);
			for(totalStep=0; totalStep<16; totalStep==totalStep){
				moveArray[2] += step;
				for(i=0; i<Floor(moveArray[2])&&totalStep<16; i++){
					Ghost_Move(dir, 1, 0);
					totalStep++;
				}
				if(Ghost_GotHit())
					return false;
				moveArray[2] -= Floor(moveArray[2]);
				Q7_Ghost_Waitframe(this, ghost);
			}
			Ghost_X = ComboX(pos);
			Ghost_Y = ComboY(pos);
		}
		else{
			KK_SetGFX(this, ghost, 0);
			Game->PlaySound(SFX_JUMP);
			step *= 0.5;
			Ghost_Jump = FindJumpLength(16/step, true);
			for(totalStep=0; totalStep<16; totalStep==totalStep){
				moveArray[2] += step;
				for(i=0; i<Floor(moveArray[2])&&totalStep<16; i++){
					Ghost_Move(dir, 1, 0);
					totalStep++;
				}
				if(Ghost_GotHit())
					return false;
				moveArray[2] -= Floor(moveArray[2]);
				Q7_Ghost_Waitframe(this, ghost);
			}
			Ghost_X = ComboX(pos);
			Ghost_Y = ComboY(pos);
			while(Ghost_Jump>0||Ghost_Z>0){
				if(Ghost_GotHit())
					return false;
				Q7_Ghost_Waitframe(this, ghost);
			}
		}
		return true;
	}
	void KK_SetGFX(ffc this, npc ghost, int gfx){
		int combo = ghost->Attributes[10];
		Ghost_Data = combo+gfx;
		if(gfx==0||gfx==2){
			if(Link->X>Ghost_X)
				Ghost_Data++;
		}
	}
}

const int TIL_NOOSEROPE = 4402;

ffc script AFuckingNooseRope{
	void run(int enemyid){
		int i;
		
		npc ghost = Ghost_InitAutoGhost(this, enemyid);
		this->Flags[FFCF_ETHEREAL] = true;
		
		while(true){
			if(LinkCollision(ghost)&&Link->Action==LA_GOTHURTLAND){
				ghost->HP = -1000;
				ghost->DrawYOffset = -1000;
				ghost->ItemSet = 0;
				Game->GuyCount[Game->GetCurScreen()]++;
				
				int x = Link->X;
				int y = Link->Y;
				int til = Link->Tile;
				int flip = 0;
				if(Link->Dir==DIR_LEFT)
					flip = 1;
				
				Link->Invisible = true;
				Link->CollDetection = false;
				
				for(i=0; i<30; i++){
					Link->X = x;
					Link->Y = y;
					
					Screen->DrawTile(2, Link->X+Link->DrawXOffset, Link->Y+Link->DrawYOffset, til, 1, 1, 6, -1, -1, 0, 0, 0, flip, true, 128);Screen->FastTile(2, Link->X+Link->DrawXOffset, Link->Y+Link->DrawYOffset-6, TIL_NOOSEROPE, 8, 128);
					DrawRopeRope(Link->X+Link->DrawXOffset, Link->Y+Link->DrawYOffset-6, i, 30);
					
					WaitNoAction();
				}
				for(i=0; i<y+16; i+=0.5){
					Link->X = x;
					Link->Y = y;
					
					if(i>96)
						i+=1.5;
					else if(i>48)
						i+=0.5;
					
					Screen->DrawTile(2, Link->X+Link->DrawXOffset, Link->Y+Link->DrawYOffset-i, til, 1, 1, 6, -1, -1, 0, 0, 0, flip, true, 128);
					Screen->FastTile(2, Link->X+Link->DrawXOffset, Link->Y+Link->DrawYOffset-6-i, TIL_NOOSEROPE, 8, 128);
					DrawRopeRope(Link->X+Link->DrawXOffset, Link->Y+Link->DrawYOffset-6-i, 30, 30);
					
					WaitNoAction();
				}
				WarpToStart(WT_IWARPBLACKOUT);
				while(true){
					WaitNoAction();
				}
			}
			Ghost_Waitframe2(this, ghost);
		}
	}
	void DrawRopeRope(int x, int y, int frame, int maxframe){
		int distTop = Ceiling((y+32)*(frame/maxframe));
		Screen->DrawTile(6, x, y-distTop, TIL_NOOSEROPE+1, 1, 1, 8, 16, distTop, 0, 0, 0, 0, true, 128);
	}
}

ffc script WhyAmICompelledToShitpostSo{
	void run(int enemyid){
		npc ghost = Ghost_InitAutoGhost(this, enemyid);
		this->Flags[FFCF_ETHEREAL] = true;
		
		int lastX = ghost->X;
		int lastY = ghost->Y;
		
		int dX;
		int dY;
		
		int avgVx;
		int avgVy;
		
		int shotCooldown = 0; //18
		bool hasFired;
		
		while(true){
			
			dX = ghost->X-lastX;
			dY = ghost->Y-lastY;
			
			lastX = ghost->X;
			lastY = ghost->Y;
			
			avgVx = (dX+avgVx*2)*0.3333;
			avgVy = (dY+avgVy*2)*0.3333;
			
			if(hasFired){
				if(Abs(avgVy)<0.3)
					hasFired = false;
			}
			else if(avgVy<=-0.6){
				for(int i=0; i<3; i++){
					eweapon e = FireNonAngularEWeapon(EW_MAGIC, Ghost_X, Ghost_Y, DIR_LEFT, 200+50*i, ghost->WeaponDamage, -1, -1, EWF_ROTATE);
					e = FireNonAngularEWeapon(EW_MAGIC, Ghost_X, Ghost_Y, DIR_RIGHT, 200+50*i, ghost->WeaponDamage, -1, -1, EWF_ROTATE);
				}
				hasFired = true;
			}
			
			// Screen->DrawInteger(6, 0, 0, FONT_Z1, 0x01, 0x0F, -1, -1, avgVx, 4, 128);
			// Screen->DrawInteger(6, 0, 8, FONT_Z1, 0x01, 0x0F, -1, -1, avgVy, 4, 128);
			
			Ghost_Waitframe2(this, ghost);
		}
	}
}

const int NPC_BRANG_SFX = 310;

const int SPR_SCRIPTBRANG = 110;

ffc script Goriya3{
	void run(int enemyid){
		npc ghost = Ghost_InitAutoGhost(this, enemyid);
		this->Flags[FFCF_ETHEREAL] = true;
		
		Ghost_SetFlag(GHF_4WAY);
		
		int vars[16];
		//vars[0] - brang State
		//vars[1] - brang Original X
		//vars[2] - brang Original Y 
		//vars[3] - brang X
		//vars[4] - brang Y
		//vars[5] - brang Angle (Brangle)
		//vars[6] - brang Damage
		//vars[7] - brang step
		//vars[8] - laststun
		vars[6] = ghost->WeaponDamage;
		eweapon brang[1];
		npc brangSFX[1];
		
		int chill = 90;
		int counter = -1;
		
		int pattern;
		while(true){
			int haltRate = ghost->Haltrate;
			if(vars[0])
				haltRate = 0;
			counter = Ghost_HaltingWalk4(counter, ghost->Step, ghost->Rate, haltRate, ghost->Homing, ghost->Hunger, 1);
			if(chill)
				chill--;
			else if(counter==1){
				if(pattern==0){
					Ghost_Dir = AngleDir4(Angle(Ghost_X, Ghost_Y, Link->X, Link->Y));
					vars[0] = 1;
					vars[3] = Ghost_X;
					vars[4] = Ghost_Y;
					vars[5] = Angle(Ghost_X, Ghost_Y, Link->X, Link->Y);
					vars[7] = LazyDiffMod(6, 8, 8);
				
					brang[0] = FireEWeapon(EW_SCRIPT10, vars[3], vars[4], DegtoRad(vars[5]), 0, vars[6], SPR_SCRIPTBRANG, 0, 0);
					if(Link->Item[I_BRANG3])
						brang[0]->CSet = 8;
					else if(Link->Item[I_BRANG2])
						brang[0]->CSet = 7;
				}
				else{
					Ghost_Dir = AngleDir4(Angle(Ghost_X, Ghost_Y, Link->X, Link->Y));
					vars[0] = 2;
					vars[3] = Ghost_X;
					vars[4] = Ghost_Y;
					vars[5] = DirAngle(Ghost_Dir);
					vars[7] = LazyDiffMod(3, 4, 6);
				
					brang[0] = FireEWeapon(EW_SCRIPT10, vars[3], vars[4], DegtoRad(vars[5]), 0, vars[6], SPR_SCRIPTBRANG, 0, 0);
					if(Link->Item[I_BRANG3])
						brang[0]->CSet = 8;
					else if(Link->Item[I_BRANG2])
						brang[0]->CSet = 7;
				}
				while(vars[0]){
					G3_Waitframe(this, ghost, brang, brangSFX, vars);
				}
				pattern = Cond(pattern, 0, 1);
			}
			G3_Waitframe(this, ghost, brang, brangSFX, vars);
		}
	}
	void G3_UpdateBrang(int vars, eweapon brang, npc brangSFX){
		//vars[0] - brang State
		//vars[1] - brang Original X
		//vars[2] - brang Original Y 
		//vars[3] - brang X
		//vars[4] - brang Y
		//vars[5] - brang Angle (Brangle)
		//vars[6] - brang Damage
		//vars[7] - brang step
		if(vars[0]>0){
			if(!brangSFX[0]->isValid()){
				brangSFX[0] = CreateNPCAt(NPC_BRANG_SFX, 120, -32);
			}
			
			if(vars[0]==1){ //Extending, Normal
				vars[3] += VectorX(vars[7], vars[5]);
				vars[4] += VectorY(vars[7], vars[5]);
				if(vars[3]<32||vars[3]>208||vars[4]<32||vars[4]>128){
					vars[0] = 3;
				}
			}
			else if(vars[0]==2){ //Extending, Redirect
				vars[3] += VectorX(vars[7], vars[5]);
				vars[4] += VectorY(vars[7], vars[5]);
				if(vars[3]<32||vars[3]>208||vars[4]<32||vars[4]>128){
					vars[3] = Clamp(vars[3], 32, 208);
					vars[4] = Clamp(vars[4], 32, 128);
					vars[0] = 1;
					vars[5] = Angle(vars[3], vars[4], Link->X, Link->Y);
				}
			}
			else if(vars[0]==3){ //Return trip
				int angle = Angle(vars[3], vars[4], vars[1], vars[2]);
				if(Distance(vars[3], vars[4], vars[1], vars[2])>8){
					vars[3] += VectorX(vars[7], angle);
					vars[4] += VectorY(vars[7], angle);
				}
				else{
					vars[0] = 0;
					if(brang[0]->isValid())
						brang[0]->DeadState = 0;
					if(brangSFX[0]->isValid())
						brangSFX[0]->HP = -1000;
				}
			}
			
			if(!brang[0]->isValid()){
				if(RectCollision(vars[3], vars[4], vars[3]+15, vars[4]+15, Link->X, Link->Y, Link->X+15, Link->Y+15))
					vars[0] = 3;
				brang[0] = FireEWeapon(EW_SCRIPT10, vars[3], vars[4], DegtoRad(vars[5]), 0, vars[6], SPR_SCRIPTBRANG, 0, 0);
				if(Link->Item[I_BRANG3])
					brang[0]->CSet = 8;
				else if(Link->Item[I_BRANG2])
					brang[0]->CSet = 7;
			}
			else{
				if(vars[0]!=3){
					if(LinkCollision(brang[0])){
						if(Link->Dir==OppositeDir(brang[0]->Dir)){
							if(AngleDir4(Angle(Link->X, Link->Y, brang[0]->X, brang[0]->Y))==Link->Dir){
								vars[0] = 3;
								Game->PlaySound(SFX_CLINK);
							}
						}
					}
				}
				brang[0]->X = vars[3];
				brang[0]->Y = vars[4];
				brang[0]->Angle = DegtoRad(vars[5]);
				brang[0]->Dir = AngleDir4(WrapDegrees(vars[5]));
			}
		}
		else{
			if(brang[0]->isValid())
				brang[0]->DeadState = 0;
			if(brangSFX[0]->isValid())
				brangSFX[0]->HP = -1000;
		}
	}
	void G3_Waitframe(ffc this, npc ghost, eweapon brang, npc brangSFX, int vars){
		bool rep = false;
		do{
			rep = false;
			vars[1] = Ghost_X;
			vars[2] = Ghost_Y;
			if(ghost->Stun>0)
				rep = true;
			G3_UpdateBrang(vars, brang, brangSFX);
			if(!Q7_Ghost_Waitframe(this, ghost, true, false)){
				while(vars[0]>0){
					G3_UpdateBrang(vars, brang, brangSFX);
					Waitframe();
				}
				if(brang[0]->isValid())
					brang[0]->DeadState = 0;
				if(brangSFX[0]->isValid())
					brangSFX[0]->HP = -1000;
				this->Data = 0;
				Quit();
			}
		}while(rep);
	}
}

ffc script FireTektite{
	void run(int enemyid){
		npc ghost = Ghost_InitAutoGhost(this, enemyid);
		this->Flags[FFCF_ETHEREAL] = true;
		
		int lastX = ghost->X;
		int lastY = ghost->Y;
		
		int dX;
		int dY;
		
		int avgVx;
		int avgVy;
		
		int shotCooldown = 0; //18
		bool hasFired;
		
		while(true){
			
			dX = ghost->X-lastX;
			dY = ghost->Y-lastY;
			
			lastX = ghost->X;
			lastY = ghost->Y;
			
			avgVx = (dX+avgVx*2)*0.3333;
			avgVy = (dY+avgVy*2)*0.3333;
			
			if(hasFired){
				if(Abs(avgVy)<0.3)
					hasFired = false;
			}
			else if(avgVy<=-0.6){
				eweapon e = FireEWeapon(EW_FIRE, Ghost_X, Ghost_Y, 0, 0, ghost->WeaponDamage, SPR_FIRE_UNBLOCKABLE, -1, EWF_UNBLOCKABLE);
				e->CSet = 10;
				hasFired = true;
			}
			
			// Screen->DrawInteger(6, 0, 0, FONT_Z1, 0x01, 0x0F, -1, -1, avgVx, 4, 128);
			// Screen->DrawInteger(6, 0, 8, FONT_Z1, 0x01, 0x0F, -1, -1, avgVy, 4, 128);
			
			Ghost_Waitframe2(this, ghost);
		}
	}
}

int DamageNumbers[65536];

//const int NPCM_DAMAGENUMBERSLASTHP = 12; //npc->Misc[] index tracking the enemy's last HP

//Tile and CSet for the first of 8 tiles for enemy damage numbers
const int GFX_DAMAGENUMBERS_ENEMY = 4680;
const int CS_DAMAGENUMBERS_ENEMY = 7;

//Tile and CSet for the first of 8 tiles for enemy healing numbers
const int GFX_DAMAGENUMBERS_ENEMYHEAL = 0;
const int CS_DAMAGENUMBERS_ENEMYHEAL = 5;

//Tile and CSet for the first of 8 tiles for Link damage numbers
const int GFX_DAMAGENUMBERS_LINK = 4700;
const int CS_DAMAGENUMBERS_LINK = 8;

//Tile and CSet for the first of 8 tiles for Link healing numbers
const int GFX_DAMAGENUMBERS_LINKHEAL = 4720;
const int CS_DAMAGENUMBERS_LINKHEAL = 5;

//Width and height of damage number tiles in pixels
const int DAMAGENUMBERS_WIDTH = 4;
const int DAMAGENUMBERS_HEIGHT = 7;

const int DAMAGENUMBERS_MAX = 32; //The max number of damage numbers drawn to the screen at once
const int DAMAGENUMBERS_FRAMES = 40; //How many frames the damage numbers last for
const int DAMAGENUMBERS_SPAWNFRAMES = 24; //How many frames the damage numbers to appear (0 for instant)
const int DAMAGENUMBERS_XOFF = 0; //X offset for the spawning point of the numbers
const int DAMAGENUMBERS_YOFF = -8; //Y offset for the spawning point of the numbers
const int DAMAGENUMBERS_YSPEED = -0.1; //The speed the number moves on the Y-axis (negative = upwards)
const int DAMAGENUMBERS_BOUNCEHEIGHT = 6; //How high in pixels the numbers bounce on the Y axis
const int DAMAGENUMBERS_LINKDAMAGECOOLDOWN = 16; //How often in frames the script can detect Link taking damage
const int DAMAGENUMBERS_LINKHEALCOOLDOWN = 16; //How often in frames the script can detect Link healing HP
const int DAMAGENUMBERS_ALLOW_LARGE_NEGATIVE = 0; //If 1, enemies with <-1000 HP can still draw damage numbers. This is usually used by scripts to kill enemies without making a death sound

//Internal constants used by the script, don't change
const int _DNUM_STARTINDEX = 16;
const int _DNUM_INDICES = 5;

const int _DNUM_LASTLINKHP = 0;
const int _DNUM_LINKDAMAGECOOLDOWN = 1;
const int _DNUM_LINKHEALCOOLDOWN = 2;
const int _DNUM_LASTDMAP = 3;
const int _DNUM_LASTSCREEN = 4;

const int _DNUMI_X = 0;
const int _DNUMI_Y = 1;
const int _DNUMI_TYPE = 2;
const int _DNUMI_DAMAGE = 3;
const int _DNUMI_TIMER = 4;

const int _DNUM_TYPE_ENEMYDAMAGE = 0;
const int _DNUM_TYPE_ENEMYHEAL = 1;
const int _DNUM_TYPE_LINKDAMAGE = 2;
const int _DNUM_TYPE_LINKHEAL = 3;

//Init function, clears the DamageNumbers[] array on every load
void DamageNumbers_Init(){
	int size = SizeOfArray(DamageNumbers);
	for(int i=0; i<size; i++){
		DamageNumbers[i] = 0;
	}
	
	DamageNumbers[_DNUM_LASTLINKHP] = Link->HP;
	DamageNumbers[_DNUM_LASTDMAP] = Game->GetCurDMap();
	DamageNumbers[_DNUM_LASTSCREEN] = Game->GetCurScreen();
}

//Update function for enemies. This can be combined with your own if you have one
// void DamageNumbers_UpdateEnemies(){
	// for(int i=Screen->NumNPCs(); i>0; i--){
		// npc n = Screen->LoadNPC(i);
		// DamageNumbers_UpdateEnemyDamage(n);
	// }
// }

//Update function for individual enemies
void DamageNumbers_UpdateEnemyDamage(npc n, lweapon sword, int npcData){
	//Detect when the enemy's HP has changed
	if(n->HP!=n->Misc[NPCM_LASTHP]){
		//Ignore enemies that don't have conventional HP
		if(DamageNumbers_IgnoreEnemyType(n))
			return;
		
		//NPCs with -1000 HP have usually been killed by scripts
		if(n->HP>-1000||DAMAGENUMBERS_ALLOW_LARGE_NEGATIVE){
			//If it's less make a damage number
			n->Misc[NPCM_HITFRAME] = 0;
			if(n->HP<n->Misc[NPCM_LASTHP]){
				n->Misc[NPCM_HITFRAME] = 1;
				if(Q7_HasRing(I_SPRING13_FLECT)){
					if(sword->isValid()||(G[G_ALTCHARACTER]&&Distance(Link->X, Link->Y, CenterX(n)-8, CenterY(n)-8)<24)){
						if(Collision(n, sword)&&!n->Misc[NPCM_STATUSCOUNTER]){
							n->Misc[NPCM_STATUSTYPE] = NSTAT_POISON;
							n->Misc[NPCM_STATUSCOUNTER] = 240;
						}
					}
				}
				if(!n->Misc[NPCM_DAMAGECALCULATED])
					DamageNumbers_CalculateDamage(n, false);
				n->Misc[NPCM_DAMAGECALCULATED] = 0;
				
				if(n->HP<=0){
					if(Q7_HasRing(I_SPRING6_LOIRE)){
						Link->HP += 2;
					}
				}
				if(GFX_DAMAGENUMBERS_ENEMY!=0){
					DamageNumbers_AddNumberGFX(CenterX(n), CenterY(n), _DNUM_TYPE_ENEMYDAMAGE, Abs(n->HP-n->Misc[NPCM_LASTHP]));
				}
			}
			//else if it wasn't 0 (just spawned in) make a healing number
			else if(n->Misc[NPCM_LASTHP]){
				if(GFX_DAMAGENUMBERS_ENEMYHEAL!=0){
					DamageNumbers_AddNumberGFX(CenterX(n), CenterY(n), _DNUM_TYPE_ENEMYHEAL, Abs(n->HP-n->Misc[NPCM_LASTHP]));
				}
			}
		}
			
		//Update the change in HP
		//n->Misc[NPCM_DAMAGENUMBERSLASTHP] = n->HP;
	}
}

void DamageNumbers_CalculateDamage(npc n, bool fromGhost){
	if(n->Misc[NPCM_LASTHP]<=0)
		return;
	
	//Ignore enemies that don't have conventional HP
	if(DamageNumbers_IgnoreEnemyType(n))
		return;
	
	if(n->HP==0){
		if(n->ID==NPC_POLSVOICE||n->ID==271||n->Type==NPCT_GLEEOK||n->Type==NPCT_DODONGO||n->Type==NPCT_MANHANDLA){
			return;
		}
	}
	
	//NPCs with -1000 HP have usually been killed by scripts
	if(n->HP>-1000||DAMAGENUMBERS_ALLOW_LARGE_NEGATIVE){
		//If it's less, modify HP
		if(n->HP<n->Misc[NPCM_LASTHP]){
			int multiplier = 1;
			multiplier *= G[G_REALDAMAGEMULTIPLIER];
			if(Q7_HasRing(I_SPRING15_ZARATH)){
				if(G[G_ZARATH_MULTIPLIER]!=4){
					if(G[G_ZARATH_MULTIPLIER]>0)
						G[G_ZARATH_FILL] = 100;
					else
						G[G_ZARATH_FILL] = 200;
				}
				if(G[G_ZARATH_MULTIPLIER]==0){
					multiplier *= 0.5;
				}
				else if(G[G_ZARATH_MULTIPLIER]==2){
					multiplier *= 2;
				}
				else if(G[G_ZARATH_MULTIPLIER]==3){
					multiplier *= 3;
				}
				else if(G[G_ZARATH_MULTIPLIER]==4){
					multiplier *= 4;
				}
			}
			if(Q7_HasRing(I_SPRING17_REDTEAR)&&Link->HP<=32){
				multiplier *= 2;
			}
			if(G[G_JANDRARING_BOOSTFRAMES]){
				multiplier *= 1.5;
			}
			int damageBoost;
			int newHP = n->HP;
			if(multiplier>1){
				damageBoost = Round(Abs(n->HP-n->Misc[NPCM_LASTHP])*(multiplier-1));
			}
			else if(multiplier<1){
				damageBoost = -Round(Abs(n->HP-n->Misc[NPCM_LASTHP])*(1-multiplier));
			}
			if(damageBoost!=0){
				newHP -= damageBoost;
				if(fromGhost){
					n->HP = newHP;
					Ghost_HP = newHP;
				}
				else
					n->HP = newHP;
			}
		}
	}
	n->Misc[NPCM_DAMAGECALCULATED] = 1;
}

//Function for finding enemies that should never show damage numbers
bool DamageNumbers_IgnoreEnemyType(npc n){
	bool invalidTypes[256];
	
	invalidTypes[NPCT_GUY] = true;
	invalidTypes[NPCT_ROCK] = true;
	invalidTypes[NPCT_TRAP] = true;
	invalidTypes[NPCT_PROJECTILE] = true;
	invalidTypes[NPCT_NONE] = true;
	invalidTypes[NPCT_FAIRY] = true;
	
	return invalidTypes[n->Type];
}

//Update function for Link
void DamageNumbers_UpdateLink(){
	//Cooldown timer for Link taking damage (for things that damage him every frame)
	if(DamageNumbers[_DNUM_LINKDAMAGECOOLDOWN]>0)
		DamageNumbers[_DNUM_LINKDAMAGECOOLDOWN]--;
	//Cooldown timer for Link healing (for things that heal him every frame)
	if(DamageNumbers[_DNUM_LINKHEALCOOLDOWN]>0)
		DamageNumbers[_DNUM_LINKHEALCOOLDOWN]--;
	
	//Whenever Link's HP changes
	if(Link->HP!=DamageNumbers[_DNUM_LASTLINKHP]){
		//If he took damage and isn't on cooldown
		if(Link->HP<DamageNumbers[_DNUM_LASTLINKHP]){
			if(DamageNumbers[_DNUM_LINKDAMAGECOOLDOWN]<=0){
				if(GFX_DAMAGENUMBERS_LINK!=0)
					DamageNumbers_AddNumberGFX(CenterLinkX(), CenterLinkY(), _DNUM_TYPE_LINKDAMAGE, Abs(Link->HP-DamageNumbers[_DNUM_LASTLINKHP]));
				
				DamageNumbers[_DNUM_LINKDAMAGECOOLDOWN] = DAMAGENUMBERS_LINKDAMAGECOOLDOWN;
			
				DamageNumbers[_DNUM_LASTLINKHP] = Link->HP;
			}
		}
		//otherwise if he healed and isn't on cooldown
		else{
			if(DamageNumbers[_DNUM_LINKHEALCOOLDOWN]<=0){
				if(GFX_DAMAGENUMBERS_LINKHEAL!=0)
					DamageNumbers_AddNumberGFX(CenterLinkX(), CenterLinkY(), _DNUM_TYPE_LINKHEAL, Abs(Link->HP-DamageNumbers[_DNUM_LASTLINKHP]));
				
				DamageNumbers[_DNUM_LINKHEALCOOLDOWN] = DAMAGENUMBERS_LINKHEALCOOLDOWN;
			
				DamageNumbers[_DNUM_LASTLINKHP] = Link->HP;
			}
		}
	}
}

//Update function for scripted damage number draws
void DamageNumbers_UpdateNumberGFX(){
	int j;
	
	//If the screen has changed, reset all damage numbers
	if(Game->GetCurDMap()!=DamageNumbers[_DNUM_LASTDMAP]||Game->GetCurScreen()!=DamageNumbers[_DNUM_LASTSCREEN]){
		DamageNumbers_Init();
	}
	
	//Cycle through all number indices
	for(int i=0; i<DAMAGENUMBERS_MAX; i++){
		j = _DNUM_STARTINDEX+_DNUM_INDICES*i;
		//If >0, is valid
		if(DamageNumbers[j+_DNUMI_TIMER]>0){
			int type = DamageNumbers[j+_DNUMI_TYPE];
			
			//Draw all numbers based on type
			if(type==_DNUM_TYPE_ENEMYDAMAGE){
				DamageNumbers_Draw(DamageNumbers[j+_DNUMI_X]+DAMAGENUMBERS_XOFF, DamageNumbers[j+_DNUMI_Y]+DAMAGENUMBERS_YOFF, GFX_DAMAGENUMBERS_ENEMY, CS_DAMAGENUMBERS_ENEMY, DamageNumbers[j+_DNUMI_DAMAGE], DamageNumbers[j+_DNUMI_TIMER]);
			}
			else if(type==_DNUM_TYPE_ENEMYHEAL){
				DamageNumbers_Draw(DamageNumbers[j+_DNUMI_X]+DAMAGENUMBERS_XOFF, DamageNumbers[j+_DNUMI_Y]+DAMAGENUMBERS_YOFF, GFX_DAMAGENUMBERS_ENEMYHEAL, CS_DAMAGENUMBERS_ENEMYHEAL, DamageNumbers[j+_DNUMI_DAMAGE], DamageNumbers[j+_DNUMI_TIMER]);
			}
			else if(type==_DNUM_TYPE_LINKDAMAGE){
				DamageNumbers_Draw(DamageNumbers[j+_DNUMI_X]+DAMAGENUMBERS_XOFF, DamageNumbers[j+_DNUMI_Y]+DAMAGENUMBERS_YOFF, GFX_DAMAGENUMBERS_LINK, CS_DAMAGENUMBERS_LINK, DamageNumbers[j+_DNUMI_DAMAGE], DamageNumbers[j+_DNUMI_TIMER]);
			}
			else if(type==_DNUM_TYPE_LINKHEAL){
				DamageNumbers_Draw(DamageNumbers[j+_DNUMI_X]+DAMAGENUMBERS_XOFF, DamageNumbers[j+_DNUMI_Y]+DAMAGENUMBERS_YOFF, GFX_DAMAGENUMBERS_LINKHEAL, CS_DAMAGENUMBERS_LINKHEAL, DamageNumbers[j+_DNUMI_DAMAGE], DamageNumbers[j+_DNUMI_TIMER]);
			}
			
			DamageNumbers[j+_DNUMI_Y] += DAMAGENUMBERS_YSPEED;
			DamageNumbers[j+_DNUMI_TIMER]--;
		}
	}
}

//Function to add scripted damage number draws
void DamageNumbers_AddNumberGFX(int x, int y, int type, int damage){
	if(!Link->Item[I_SETTING_DAMAGENUMBERS])
		return;
	
	int j;
	//Cycle through all number indices
	for(int i=0; i<DAMAGENUMBERS_MAX; i++){
		j = _DNUM_STARTINDEX+_DNUM_INDICES*i;
		//If <= 0, is invalid
		if(DamageNumbers[j+_DNUMI_TIMER]<=0){
			DamageNumbers[j+_DNUMI_X] = x;
			DamageNumbers[j+_DNUMI_Y] = y;
			DamageNumbers[j+_DNUMI_TYPE] = type;
			DamageNumbers[j+_DNUMI_DAMAGE] = damage;
			DamageNumbers[j+_DNUMI_TIMER] = DAMAGENUMBERS_FRAMES;
			return;
		}
	}
}

//Function to draw scripted damage number draws for one frame
void DamageNumbers_Draw(int x, int y, int gfx, int cs, int num, int frame){
	int i; int j; int k;
	
	//Frames normally count down, but this function calculates stuff as if they're counting up
	frame = DAMAGENUMBERS_FRAMES-frame;
	
	num = Clamp(num, 0, 99999);
	int drawX = Floor(x-DAMAGENUMBERS_WIDTH/2);
	int drawY = Floor(y-DAMAGENUMBERS_HEIGHT/2);
	int digits[5];
	
	//Get each digit of the number
	digits[0] = num%10;
	digits[1] = Floor(num/10)%10;
	digits[2] = Floor(num/100)%10;
	digits[3] = Floor(num/1000)%10;
	digits[4] = Floor(num/10000)%10;
	
	//Find how many places should be visible
	int places = 1;
	if(num>9999)
		places = 5;
	else if(num>999)
		places = 4;
	else if(num>99)
		places = 3;
	else if(num>9)
		places = 2;
	
	//Center the starting position of the number
	//(this gets added instead of subtracted because the numbers are drawn right to left)
	drawX += Floor((places-1)*DAMAGENUMBERS_WIDTH/2);
	
	int tmpX; int tmpY;
	
	int spawnFreq;
	if(DAMAGENUMBERS_SPAWNFRAMES==0)
		spawnFreq = 0;
	else 
		spawnFreq = (360/DAMAGENUMBERS_SPAWNFRAMES);
	int spawnFreq2 = (180/5);
	
	//Draw each digit in sequence
	for(i=0; i<places; i++){
		k = frame*spawnFreq-i*spawnFreq2;
		j = Abs(Sin(Clamp(k, 0, 180)));
		tmpX = drawX-i*DAMAGENUMBERS_WIDTH;
		tmpY = drawY-DAMAGENUMBERS_BOUNCEHEIGHT*j;
		//Check if each digit should be drawn
		//When k>0, the Abs(Sin(k)) bounce animation has started. k is clamped so it only plays once.
		//Otherwise if spawnFreq is 0, all digits appear instantly
		if(k>=0||spawnFreq==0){
			if(gfx>0)
				Screen->FastTile(6, tmpX, tmpY, gfx+digits[i], cs, 128);
			else
				Screen->FastCombo(6, tmpX, tmpY, Abs(gfx)+digits[i], cs, 128);
		}
	}
}

// global script DamageNumbers_ExampleGlobal{
	// void run(){
		// DamageNumbers_Init();
		// while(true){
			// DamageNumbers_UpdateEnemies();
			// DamageNumbers_UpdateLink();
			// DamageNumbers_UpdateNumberGFX();
			
			// Waitdraw();
			// Waitframe();
		// }
	// }
// }

const int EWM_GLEEOKFIREBALLCHECKED = 0;

ffc script GleeoksAnorexiaPills{
	void run(){
		int i;
		while(true){
			bool convertFireballs;
			for(i=Screen->NumNPCs(); i>0; i--){
				npc n = Screen->LoadNPC(i);
				if(n->Type==NPCT_GLEEOK||n->Type==NPCT_GOHMA||n->Type==NPCT_MANHANDLA)
					convertFireballs = true;
			}
			if(convertFireballs){
				for(i=Screen->NumEWeapons(); i>0; i--){
					eweapon e = Screen->LoadEWeapon(i);
					if(e->ID==EW_FIREBALL){
						if(!(e->Misc[__EWI_FLAGS]&__EWFI_IS_GHZH_EWPN)){
							eweapon e2 = FireEWeapon(EW_FIREBALL, e->X, e->Y, e->Angle, e->Step, e->Damage, SPR_FIREBALL_UNBLOCKABLE, 0, EWF_UNBLOCKABLE);
							e->DeadState = 0;
						}
					}
				}
			}
			Waitframe();
		}
	}
}

ffc script DiffComboReplace{
	void run(int first, int last, int diffHard, int diffVhard){
		if(diffVhard==0)
			diffVhard = diffHard;
		if(last==0)
			last = first;
		
		for(int i=0; i<176; i++){
			int cd = Screen->ComboD[i];
			if(cd>=first&&cd<=last){
				if(IsVeryHardMode()){
					Screen->ComboD[i] = diffVhard+(cd-first);
				}
				else if(IsHardMode()){
					Screen->ComboD[i] = diffHard+(cd-first);
				}
			}
		}
	}
}

ffc script DungeonAutoWalk{
	void run(){
		int i;
		
		int dir = -1;
		if(Link->Y==0){
			dir = DIR_DOWN;
		}
		else if(Link->Y==160){
			dir = DIR_UP;
		}
		else if(Link->X==0){
			dir = DIR_RIGHT;
		}
		else if(Link->X==240)
			dir = DIR_LEFT;
		
		if(dir>-1){
			for(int i=0; i<16; i++){
				NoAction();
				
				if(dir==DIR_UP){
					Link->InputUp = true;
					if(Link->Y<=144)
						break;
				}
				else if(dir==DIR_DOWN){
					Link->InputDown = true;
					if(Link->Y>=16)
						break;
				}
				else if(dir==DIR_LEFT){
					Link->InputLeft = true;
					if(Link->X<=224)
						break;
				}
				else if(dir==DIR_RIGHT){
					Link->InputRight = true;
					if(Link->X>=16)
						break;
				}
				
				Waitframe();
			}
		}
	
		if(dir==DIR_UP||dir==DIR_DOWN)
			Link->Y = GridY(Link->Y+8);
		else if(dir==DIR_LEFT||dir==DIR_RIGHT)
			Link->X = GridX(Link->X+8);
	}
}

const int MAP_GANNONBG = 14;
const int SCREEN_GANNONBG = 0x2F;

ffc script GannonBG{
	void run(){
		int bgX = Rand(256);
		int bgY = Rand(176);
		int angle = Choose(180, 0)+Rand(-40, 40);
		int bgVx = VectorX(0.5, angle);
		int bgVy = VectorY(0.5, angle);
		while(true){
			bgX += bgVx;
			bgY += bgVy;
			
			if(bgX<0)
				bgX += 256;
			if(bgX>=256)
				bgX -= 256;
			if(bgY<0)
				bgY += 176;
			if(bgY>=176)
				bgY -= 176;
			
			int x = Floor(bgX);
			int y = Floor(bgY);
			Screen->DrawLayer(6, MAP_GANNONBG, SCREEN_GANNONBG, 0, x, y, 0, 64);
			Screen->DrawLayer(6, MAP_GANNONBG, SCREEN_GANNONBG, 0, x-256, y, 0, 64);
			Screen->DrawLayer(6, MAP_GANNONBG, SCREEN_GANNONBG, 0, x, y-176, 0, 64);
			Screen->DrawLayer(6, MAP_GANNONBG, SCREEN_GANNONBG, 0, x-256, y-176, 0, 64);
			
			Waitframe();
		}
	}
}

const int I_SECRETMONEY10 = 86;
const int I_SECRETMONEY20 = 38;
const int I_SECRETMONEY30 = 40;
const int I_SECRETMONEY100 = 87;
const int I_RUPOOR10 = 72;
const int I_RUPOOR20 = 70;
const int I_RUPOOR30 = 71;
const int I_RUPOOR50 = 39;

ffc script ScriptCaveItemCellar{
	void run(int w, int passageway, int theDmap, int theScreen, int msg, int guy, int rupeeVal){
		if(passageway<=1){ //Item Cellar / Passage Entrance
			G[G_SCRIPTPASSAGE_OLDDMAP] = Game->GetCurDMap();
			G[G_SCRIPTPASSAGE_OLDSCREEN] = Game->GetCurDMapScreen();
			G[G_SCRIPTPASSAGE_OLDSTRING] = msg;
			G[G_SCRIPTPASSAGE_OLDGUY] = guy;
			
			G[G_SCRIPTPASSAGE_TYPE] = 0;
			if(!Screen->State[ST_SPECIALITEM]){
				G[G_SCRIPTPASSAGE_OLDITEM] = Screen->RoomData;
				if(Randomizer_GetItemReplacement(Game->GetCurMap(), Game->GetCurScreen()))
					G[G_SCRIPTPASSAGE_OLDITEM] = Randomizer_GetItemReplacement(Game->GetCurMap(), Game->GetCurScreen());
				else{	
					if(rupeeVal==-50)
						G[G_SCRIPTPASSAGE_OLDITEM] = I_RUPOOR50;
					else if(rupeeVal==-30)
						G[G_SCRIPTPASSAGE_OLDITEM] = I_RUPOOR30;
					else if(rupeeVal==-20)
						G[G_SCRIPTPASSAGE_OLDITEM] = I_RUPOOR20;
					else if(rupeeVal==-10)
						G[G_SCRIPTPASSAGE_OLDITEM] = I_RUPOOR10;
					else if(rupeeVal==5)
						G[G_SCRIPTPASSAGE_OLDITEM] = I_RUPEE5;
					else if(rupeeVal==10)
						G[G_SCRIPTPASSAGE_OLDITEM] = I_SECRETMONEY10;
					else if(rupeeVal==20)
						G[G_SCRIPTPASSAGE_OLDITEM] = I_SECRETMONEY20;
					else if(rupeeVal==30)
						G[G_SCRIPTPASSAGE_OLDITEM] = I_SECRETMONEY30;
					else if(rupeeVal==100)
						G[G_SCRIPTPASSAGE_OLDITEM] = I_SECRETMONEY100;
				}
			}
			else{
				G[G_SCRIPTPASSAGE_OLDITEM] = 0;
			}
			
			if(passageway==1){
				G[G_SCRIPTPASSAGE_TYPE] = 1;
				G[G_SCRIPTPASSAGE_NEWDMAP] = Screen->GetTileWarpDMap(w);
				G[G_SCRIPTPASSAGE_NEWSCREEN] = Screen->GetTileWarpScreen(w);
			}
			else
				G[G_SCRIPTPASSAGE_TYPE] = 0;
			if(((G[G_MODE_CAVESANITY]&&G[G_MODE_ENTRANCE_RANDO])||theScreen<0)&&passageway==0&&Game->GetCurLevel()==0)
				Quit();
			Screen->SetTileWarp(w, theScreen, theDmap, WT_IWARPBLACKOUT);
		}
		else if(false){ //passageway==1){ //Passage (Old)
			G[G_SCRIPTPASSAGE_OLDDMAP] = Game->GetCurDMap();
			G[G_SCRIPTPASSAGE_OLDSCREEN] = Game->GetCurDMapScreen();
		
			G[G_SCRIPTPASSAGE_TYPE] = 1;
			G[G_SCRIPTPASSAGE_NEWDMAP] = Screen->GetTileWarpDMap(w);
			G[G_SCRIPTPASSAGE_NEWSCREEN] = Screen->GetTileWarpScreen(w);
		
			Screen->SetTileWarp(w, theScreen, theDmap, WT_IWARPBLACKOUT);
		}
		else if(passageway==2){ //On Passage Screen
			if(G[G_SCRIPTPASSAGE_TYPE]==0){ //Is Item Cellar
				Screen->SetSideWarp(w, G[G_SCRIPTPASSAGE_OLDSCREEN], G[G_SCRIPTPASSAGE_OLDDMAP], WT_IWARPBLACKOUT);
			
				Screen->State[ST_SPECIALITEM] = Game->GetScreenState(Game->DMapMap[G[G_SCRIPTPASSAGE_OLDDMAP]], G[G_SCRIPTPASSAGE_OLDSCREEN]+Game->DMapOffset[G[G_SCRIPTPASSAGE_OLDDMAP]], ST_SPECIALITEM);
				this->Flags[FFCF_IGNOREHOLDUP] = true;
				
				Link->X = 48;
				Link->Y = 16;
				
				if(this->Flags[FFCF_PRELOAD])
					Waitframe();
				
				if(!Screen->State[ST_SPECIALITEM]){
					if(G[G_SCRIPTPASSAGE_OLDITEM]){
						item itm = CreateItemAt(G[G_SCRIPTPASSAGE_OLDITEM], this->X, this->Y);
						itm->Pickup = IP_HOLDUP|IP_ST_SPECIALITEM;
						
						int oldMap = Game->DMapMap[G[G_SCRIPTPASSAGE_OLDDMAP]];
						int oldScreen = G[G_SCRIPTPASSAGE_OLDSCREEN]+Game->DMapOffset[G[G_SCRIPTPASSAGE_OLDDMAP]];
						Randomizer_FlagItemVisited(oldMap, oldScreen);
					}
				}
				
				while(true){
					Game->SetScreenState(Game->DMapMap[G[G_SCRIPTPASSAGE_OLDDMAP]], G[G_SCRIPTPASSAGE_OLDSCREEN]+Game->DMapOffset[G[G_SCRIPTPASSAGE_OLDDMAP]], ST_SPECIALITEM, Screen->State[ST_SPECIALITEM]);
					Waitframe();
				}
			}
			else{ //Is Passage
				bool enteredLeft;
				int diffX = (G[G_SCRIPTPASSAGE_OLDSCREEN]%16)-(G[G_SCRIPTPASSAGE_NEWSCREEN]%16);
				int diffY = Floor(G[G_SCRIPTPASSAGE_OLDSCREEN]/16)-Floor(G[G_SCRIPTPASSAGE_NEWSCREEN]/16);
				if(diffX<0)
					enteredLeft = true;
				else if(diffX>0)
					enteredLeft = false;
				else{
					if(diffY<0)
						enteredLeft = true;
					else
						enteredLeft = false;
				}
				if(enteredLeft){
					Link->X = 48;
					Link->Y = 16;
				}
				else{
					Link->X = 192;
					Link->Y = 16;
				}
				
				while(true){
					if(Link->X<120){
						if(enteredLeft)
							Screen->SetSideWarp(w, G[G_SCRIPTPASSAGE_OLDSCREEN], G[G_SCRIPTPASSAGE_OLDDMAP], WT_IWARPBLACKOUT);
						else
							Screen->SetSideWarp(w, G[G_SCRIPTPASSAGE_NEWSCREEN], G[G_SCRIPTPASSAGE_NEWDMAP], WT_IWARPBLACKOUT);
					}
					else{
						if(enteredLeft)
							Screen->SetSideWarp(w, G[G_SCRIPTPASSAGE_NEWSCREEN], G[G_SCRIPTPASSAGE_NEWDMAP], WT_IWARPBLACKOUT);
						else
							Screen->SetSideWarp(w, G[G_SCRIPTPASSAGE_OLDSCREEN], G[G_SCRIPTPASSAGE_OLDDMAP], WT_IWARPBLACKOUT);
					}
					Waitframe();
				}
			}
		}
		else if(passageway==3){ //Cave
			Screen->SetSideWarp(w, G[G_SCRIPTPASSAGE_OLDSCREEN], G[G_SCRIPTPASSAGE_OLDDMAP], WT_IWARPBLACKOUT);
			
			Screen->State[ST_SPECIALITEM] = Game->GetScreenState(Game->DMapMap[G[G_SCRIPTPASSAGE_OLDDMAP]], G[G_SCRIPTPASSAGE_OLDSCREEN]+Game->DMapOffset[G[G_SCRIPTPASSAGE_OLDDMAP]], ST_SPECIALITEM);
			this->Flags[FFCF_IGNOREHOLDUP] = true;
				
			if(this->Flags[FFCF_PRELOAD])
				Waitframe();
				
			int itemID;
			int oldMap;
			int oldScreen;
			if(!Screen->State[ST_SPECIALITEM]){
				if(G[G_SCRIPTPASSAGE_OLDITEM]){
					itemID = G[G_SCRIPTPASSAGE_OLDITEM];
					
					oldMap = Game->DMapMap[G[G_SCRIPTPASSAGE_OLDDMAP]];
					oldScreen = G[G_SCRIPTPASSAGE_OLDSCREEN]+Game->DMapOffset[G[G_SCRIPTPASSAGE_OLDDMAP]];
					Randomizer_FlagItemVisited(oldMap, oldScreen);
				}
			}
			else{
				Quit();
			}
				
			int i; int j;
			bool secretMoney;
			int secretMoneyValue;
			if(itemID==I_RUPEE5){
				secretMoneyValue = 5;
				secretMoney = true;
			}
			if(itemID==I_SECRETMONEY10){
				secretMoneyValue = 10;
				secretMoney = true;
			}
			if(itemID==I_SECRETMONEY20){
				secretMoneyValue = 20;
				secretMoney = true;
			}
			if(itemID==I_SECRETMONEY30){
				secretMoneyValue = 30;
				secretMoney = true;
			}
			if(itemID==I_SECRETMONEY100){
				secretMoneyValue = 100;
				secretMoney = true;
			}
			if(itemID==I_RUPOOR10){
				secretMoneyValue = -10;
				secretMoney = true;
			}
			if(itemID==I_RUPOOR20){
				secretMoneyValue = -20;
				secretMoney = true;
			}
			if(itemID==I_RUPOOR30){
				secretMoneyValue = -30;
				secretMoney = true;
			}
			if(itemID==I_RUPOOR50){
				secretMoneyValue = -50;
				secretMoney = true;
			}
			
			WaitNoAction(8);
			item specialItem;
			npc roomGuys[3];
			
			roomGuys[0] = CreateNPCAt(5, 72, 64);
			roomGuys[0]->DrawYOffset = 0;
			roomGuys[2] = CreateNPCAt(5, 168, 64);
			roomGuys[2]->DrawYOffset = 0;
			
			if(guy==0){
				if(secretMoneyValue<0)
					guy = NPC_ABEI;
				else
					guy = NPC_MOBLIN;
			}
			
			if(msg==0||G[G_MODE_CAVESANITY]){
				if(secretMoneyValue<0)
					msg = 7;
				else
					msg = 8;
			}
			
			
			if(!Screen->State[ST_SPECIALITEM]){
				roomGuys[1] = CreateNPCAt(guy, 120, 64);
				roomGuys[1]->DrawYOffset = 0;
				WaitNoAction(16);
				
				if(secretMoney){
					if(secretMoneyValue>0){
						specialItem = CreateItemAt(I_RUPEE1, 120, 88);
						specialItem->Pickup = IP_DUMMY;
						Randomizer_FlagItemVisited(oldMap, oldScreen);
						WaitNoAction();
						Screen->Message(msg);
						while(!SecretMoney_Collision(specialItem)){
							Waitframe();
						}
						Screen->State[ST_SPECIALITEM] = true;
						Game->DCounter[CR_RUPEES] += secretMoneyValue;
						while(true){
							j = 0;
							if(secretMoneyValue>99)
								j = -16;
							else if(secretMoneyValue>9)
								j = -8;
							Screen->DrawInteger(2, specialItem->X+8+j, specialItem->Y+24, FONT_Z1, 0x01, -1, -1, -1, secretMoneyValue, 0, 128);
							Game->SetScreenState(Game->DMapMap[G[G_SCRIPTPASSAGE_OLDDMAP]], G[G_SCRIPTPASSAGE_OLDSCREEN]+Game->DMapOffset[G[G_SCRIPTPASSAGE_OLDDMAP]], ST_SPECIALITEM, Screen->State[ST_SPECIALITEM]);
							Waitframe();
						}
					}
					else{
						Screen->State[ST_SPECIALITEM] = true;
						Game->SetScreenState(Game->DMapMap[G[G_SCRIPTPASSAGE_OLDDMAP]], G[G_SCRIPTPASSAGE_OLDSCREEN]+Game->DMapOffset[G[G_SCRIPTPASSAGE_OLDDMAP]], ST_SPECIALITEM, Screen->State[ST_SPECIALITEM]);
						G[G_DOORREPAIRTRACKER] = secretMoneyValue;
						Screen->Message(msg);
						Game->SetScreenState(Game->DMapMap[G[G_SCRIPTPASSAGE_OLDDMAP]], G[G_SCRIPTPASSAGE_OLDSCREEN]+Game->DMapOffset[G[G_SCRIPTPASSAGE_OLDDMAP]], ST_SPECIALITEM, Screen->State[ST_SPECIALITEM]);
						WaitNoAction();
						G[G_DOORREPAIRTRACKER] = 0;
						Game->DCounter[CR_RUPEES] += secretMoneyValue;
						while(true){
							Game->SetScreenState(Game->DMapMap[G[G_SCRIPTPASSAGE_OLDDMAP]], G[G_SCRIPTPASSAGE_OLDSCREEN]+Game->DMapOffset[G[G_SCRIPTPASSAGE_OLDDMAP]], ST_SPECIALITEM, Screen->State[ST_SPECIALITEM]);
							Waitframe();
						}
					}
				}
				else{
					specialItem = CreateItemAt(itemID, 120, 88);
					specialItem->Pickup = IP_HOLDUP|IP_ST_SPECIALITEM;
					
					int oldMap = Game->DMapMap[G[G_SCRIPTPASSAGE_OLDDMAP]];
					int oldScreen = G[G_SCRIPTPASSAGE_OLDSCREEN]+Game->DMapOffset[G[G_SCRIPTPASSAGE_OLDDMAP]];
					Randomizer_FlagItemVisited(oldMap, oldScreen);
					WaitNoAction();
					Screen->Message(msg);
					int freezeLink = 1;
					while(specialItem->isValid()){
						if(freezeLink){
							--freezeLink;
							NoAction();
						}
						Game->SetScreenState(Game->DMapMap[G[G_SCRIPTPASSAGE_OLDDMAP]], G[G_SCRIPTPASSAGE_OLDSCREEN]+Game->DMapOffset[G[G_SCRIPTPASSAGE_OLDDMAP]], ST_SPECIALITEM, Screen->State[ST_SPECIALITEM]);
							
						Waitframe();
					}
					for(j=0; j<64; ++j){
						if(j%2==0)
							roomGuys[1]->Y = -32;
						else
							roomGuys[1]->Y = 64;
					
						Game->SetScreenState(Game->DMapMap[G[G_SCRIPTPASSAGE_OLDDMAP]], G[G_SCRIPTPASSAGE_OLDSCREEN]+Game->DMapOffset[G[G_SCRIPTPASSAGE_OLDDMAP]], ST_SPECIALITEM, Screen->State[ST_SPECIALITEM]);
						
						Waitframe();
					}
					roomGuys[1]->Y -= 1000;
				}
			}
		}
	}
	bool SecretMoney_Collision(item itm){
		return Link->X==itm->X&&Link->Y>=itm->Y-4&&Link->Y<=itm->Y+7;
	}
}

const int SFX_TRIFORCECHECK_ADDGEM = 5;
const int SFX_TRIFORCECHECK_COMPLETE = 27;

ffc script TriforceCheck{
	void run(int sp){
		if(sp==1){
			if(G[G_ISRANDOMIZER]&&G[G_RANDOMIZER_REQTRIFORCE]==0){
				npc blocker = CreateNPCAt(NPC_TRIGGER, 0, 0);
				blocker->CollDetection = false;
				while(NumTriforcePieces()<8){
					Waitframe();
				}
				blocker->HP = -1000;
			}
			Quit();
		}
		
		int i; int j; int k;
		
		int cmb = this->Data;
		if(Screen->State[ST_SECRET]){
			this->Data = FFCS_INVISIBLE_COMBO;
			Quit();
		}
		else{
			Waitframe();
			
			Game->PlayMIDI(0);
			
			Waitframes(32);
			
			bool gemsActive[8];
			int triforceCount;
			if(!Q7_CheatEnabled(G_MODE_NOTRIFORCE)&&!TriforceExceptions()){
				for(i=0; i<8; i++){
					bool hadTriforce;
					if(Game->LItems[1+i]&LI_TRIFORCE){
						hadTriforce = true;
						gemsActive[i] = true;
						triforceCount++;
					}
					if(hadTriforce){
						Game->PlaySound(SFX_TRIFORCECHECK_ADDGEM);
						for(j=0; j<40; j++){
							for(k=0; k<8; k++){
								if(gemsActive[k])
									Screen->FastCombo(2, this->X, this->Y, cmb+1+k, 8, 128);
							}
							Waitframe();
						}
					}
				}
			}
			else{
				triforceCount = 8;
			}
			if(triforceCount>=8){
				Game->PlaySound(SFX_TRIFORCECHECK_COMPLETE);
				for(i=0; i<90; i++){
					Screen->FastCombo(2, this->X, this->Y, cmb+9, 8, 128);
					Waitframe();
				}
				Screen->TriggerSecrets();
				Screen->State[ST_SECRET] = true;
				Game->PlaySound(SFX_SHUTTER);
				this->Data = FFCS_INVISIBLE_COMBO;
				Quit();
			}
			else{
				while(true){
					for(k=0; k<8; k++){
						if(gemsActive[k])
							Screen->FastCombo(2, this->X, this->Y, cmb+1+k, 8, 128);
					}
					Waitframe();
				}
			}
		}
	}
	bool TriforceExceptions(){
		if(G[G_ISRANDOMIZER]){
			if(G[G_RANDOMIZER_REQTRIFORCE]==0||G[G_RANDOMIZER_REQTRIFORCE]==2){
				return true;
			}
		}
	}
}

void Q7_DrawStringSP(int strDat, int layer, int x, int y, int w, int format, int str){
	int i;
	
	int lineStart = strDat[0];
	int lineEnd = strDat[1];
	int lineStartColor = strDat[2];
	int numLines = strDat[3];
	int vSpacing = strDat[4];
	bool outline;
	if(strDat[5])
		outline = true;
	int curColor = 0x01;
	int lastWordIndex;
	int lineW;
	int tmpY;
	
	for(i=0; i<numLines; i++){
		tmpY = y+i*vSpacing;
		if(tmpY>-8&&tmpY<176){
			if(lineStart[i]!=lineEnd[i]){
				if(format==TF_CENTERED){
					int wLine = Q7_DrawStringSP_GetLineLength(lineStart[i], lineEnd[i], str);
					Q7_DrawStringSP_Line(layer, x-wLine/2, tmpY, str, lineStart[i], lineEnd[i], lineStartColor[i], outline);
				}
				else
					Q7_DrawStringSP_Line(layer, x, tmpY, str, lineStart[i], lineEnd[i], lineStartColor[i], outline);
			}
		}
	}
}

void Q7_TraceStringSP(int strDat, int w, int str){
	int i; int j; int k;
	
	int lineStart = strDat[0];
	int lineEnd = strDat[1];
	int lineStartColor = strDat[2];
	int numLines = strDat[3];
	int curColor = 0x01;
	int lastWordIndex;
	int lineW;
	int tmpY;
	
	int tmpStr[1024];
	for(i=0; i<numLines; i++){
		k = 0;
		for(j=lineStart[i]; j<lineEnd[i]; j++){
			tmpStr[k] = str[j];
			k++;
		}
		tmpStr[k] = 0;
	}
}

void Q7_DrawStringSP_Prep(int strDat, int w, int str){
	int i;
	
	int lineStart = strDat[0];
	int lineEnd = strDat[1];
	int lineStartColor = strDat[2];
	int numLines;
	int curColor = 0x01;
	int lastWordIndex;
	bool inWord = true;
	int lineW; //Current width of the line
	int spaceW; //Width of the current block of whitespace in the line
	int prevLineW; //Width of the line not counting trailing whitespace
	int lineDatLen = SizeOfArray(lineStart);
	
	lineStart[0] = 0;
	lineEnd[0] = 0;
	lineStartColor[0] = 0x01;
	
	int len = SizeOfArray(str);
	int n[3];
	for(i=0; i<len; i++){
		//End of string
		if(str[i]==0){
			lineEnd[numLines] = i;
			numLines++;
			if(numLines>=lineDatLen){
				int err[] = "ERROR: lineStart[] is not big enough to hold this string! (Size is %i) \n";
				printf(err, lineDatLen);
				return;
			}
			break;
		}
		//Text color
		if(str[i]=='@'){
			//@N - new line
			if(str[i+1]=='N'){
				lineEnd[numLines] = i;
				numLines++;
				i += 2;
				lineStart[numLines] = i;
				lineEnd[numLines] = i;
				lineStartColor[numLines] = curColor;
				
				lineW = 0;
				spaceW = 0;
				continue;
			}
			//@XX - Change color
			n[0] = str[i+1];
			n[1] = str[i+2];
			curColor = Q7_xtoi(n);
			i += 2;
			continue;
		}
		
		if(str[i]==' '){
			spaceW += 8;
			inWord = false;
		}
		else{
			lineW += 8;
			lineW += spaceW;
			spaceW = 0;
			if(!inWord)
				lastWordIndex = i;
			inWord = true;
		}
		//When wrapping to a new line
		if(lineW>w-8){
			//Go back to the start of the last word (non space)
			i = lastWordIndex;
			//Set the end of the previous line to the start of this one
			lineEnd[numLines] = i;
			
			numLines++;
			
			//Set the new line to start at the current index
			lineStart[numLines] = i;
			lineEnd[numLines] = i;
			lineStartColor[numLines] = curColor;
			
			lineW = 0;
			spaceW = 0;
			if(numLines>=lineDatLen){
				int err[] = "ERROR: lineStart[] is not big enough to hold this string! (Size is %i) \n";
				printf(err, lineDatLen);
				return;
			}
		}
	}
	strDat[3] = numLines;
}

void Q7_DrawStringSP_Line(int layer, int x, int y, int str, int lineStart, int lineEnd, int lineColor, bool outline){
	int i = lineStart;
	while(str[i]==' ')
		i++;
	int strLine[2048];
	int sli;
	int tmpX = x;
	int oldTmpX = x;
	int clr = lineColor;
	int n[3];
	while(i<lineEnd){
		if(str[i]==0){
			strLine[sli] = 0;
			sli = 0;
			if(outline)
				Q7_DrawStringOutline(layer, oldTmpX, y, FONT_Z1, clr, 0x0F, TF_NORMAL, strLine, 128);
			else
				Screen->DrawString(layer, oldTmpX, y, FONT_Z1, clr, -1, TF_NORMAL, strLine, 128);
			oldTmpX = tmpX;
			return;
		}
		else if(str[i]=='@'){
			strLine[sli] = 0;
			sli = 0;
			if(outline)
				Q7_DrawStringOutline(layer, oldTmpX, y, FONT_Z1, clr, 0x0F, TF_NORMAL, strLine, 128);
			else
				Screen->DrawString(layer, oldTmpX, y, FONT_Z1, clr, -1, TF_NORMAL, strLine, 128);
			oldTmpX = tmpX;
			n[0] = str[i+1];
			n[1] = str[i+2];
			clr = Q7_xtoi(n);
			i += 3;
			continue;
		}
		else{
			strLine[sli] = str[i];
			sli++;
			tmpX += 8;
		}
		
		i++;
	}
	
	if(sli>0){
		while(strLine[sli-1]==' '){
			sli--;
			if(sli<=0)
				break;
		}
	}
	strLine[sli] = 0;
	sli = 0;
	if(outline)
		Q7_DrawStringOutline(layer, oldTmpX, y, FONT_Z1, clr, 0x0F, TF_NORMAL, strLine, 128);
	else
		Screen->DrawString(layer, oldTmpX, y, FONT_Z1, clr, -1, TF_NORMAL, strLine, 128);
}

int Q7_DrawStringSP_GetLineLength(int lineStart, int lineEnd, int str){
	int lineW;
	int lineWNoSpace;
	for(int i=lineStart; i<lineEnd; i++){
		if(str[i]==0){
			return lineW;
		}
		
		if(str[i]=='@'){
			if(str[i+1]=='N')
				i += 1;
			else
				i += 2;
			continue;
		}
		else{
			lineW += 8;
			if(str[i]!=' ')
				lineWNoSpace = lineW;
		}
	}
	return lineWNoSpace;
}

//Hexadecimal ASCII to Integer
//Returns the (positive) hexadecimal integer pointed by 'string'
int Q7_xtoi(int string, int pos)
{
	int ret = 0;
	for(int i = 0; isHex(string[pos + i]); ++i)
		ret = ret*0x10 + Cond(isNumber(string[pos + i]), string[pos + i] - '0', LowerToUpper(string[pos + i]) - 'A' + 0xA);
	return ret;
}
int Q7_xtoi(int string)
{
	return Q7_xtoi(string, 0);
}

void Q7_DrawStringOutline(int layer, int x, int y, int font, int clr1, int clr2, int format, int ptr, int op){
	Screen->DrawString(layer, x, y-1, font, clr2, -1, format, ptr, op);
	Screen->DrawString(layer, x, y+1, font, clr2, -1, format, ptr, op);
	Screen->DrawString(layer, x-1, y, font, clr2, -1, format, ptr, op);
	Screen->DrawString(layer, x+1, y, font, clr2, -1, format, ptr, op);
	Screen->DrawString(layer, x, y, font, clr1, -1, format, ptr, op);
}

void Q7_DrawIntegerOutline(int layer, int x, int y, int font, int clr1, int clr2, int scaleX, int scaleY, int number, int numPlaces, int op){
	Screen->DrawInteger(layer, x, y-1, font, clr2, -1, scaleX, scaleY, number, numPlaces, op);
	Screen->DrawInteger(layer, x, y+1, font, clr2, -1, scaleX, scaleY, number, numPlaces, op);
	Screen->DrawInteger(layer, x-1, y, font, clr2, -1, scaleX, scaleY, number, numPlaces, op);
	Screen->DrawInteger(layer, x+1, y, font, clr2, -1, scaleX, scaleY, number, numPlaces, op);
	Screen->DrawInteger(layer, x, y, font, clr1, -1, scaleX, scaleY, number, numPlaces, op);
}

void Q7_DrawCharacterOutline(int layer, int x, int y, int font, int clr1, int clr2, int w, int h, int glyph, int op){
	Screen->DrawCharacter(layer, x, y-1, font, clr2, -1, w, h, glyph, op);
	Screen->DrawCharacter(layer, x, y+1, font, clr2, -1, w, h, glyph, op);
	Screen->DrawCharacter(layer, x-1, y, font, clr2, -1, w, h, glyph, op);
	Screen->DrawCharacter(layer, x+1, y, font, clr2, -1, w, h, glyph, op);
	Screen->DrawCharacter(layer, x, y, font, clr1, -1, w, h, glyph, op);
}

int DialogueBox_GetStringLength_LttPSmall(int string){
	int fontDef[] = {
		// Character widths, including any trailing space
		// ASCII characters 32 to 126
		
		// sp !  "  #  $  %  &  '  (  )  *  +  ,  -  .  /
		   4, 2, 4, 6, 6, 4, 5, 2, 3, 3, 4, 4, 3, 4, 2, 4,
		
		// 0  1  2  3  4  5  6  7  8  9
		   4, 3, 4, 4, 4, 4, 4, 4, 4, 4,
		
		// :  ;  <  =  >  ?  @
		   2, 2, 4, 4, 4, 4, 6,
		
		// A  B  C  D  E  F  G  H  I  J  K  L  M  N  O  P  Q  R  S  T  U  V  W  X  Y  Z
		   5, 5, 4, 5, 4, 4, 5, 4, 2, 4, 5, 4, 6, 5, 5, 5, 6, 5, 4, 4, 5, 6, 6, 4, 4, 4,
		
		// [  \  ]  ^  _  `
		   4, 4, 4, 4, 4, 4,
		
		// Note: This font's capital and lowercase letters are identical, but
		// ZC spaces some of them differently. This appears to be unintentional,
		// so it is not duplicated here.
		// a  b  c  d  e  f  g  h  i  j  k  l  m  n  o  p  q  r  s  t  u  v  w  x  y  z
		   5, 5, 4, 5, 4, 4, 5, 4, 2, 4, 5, 4, 6, 5, 5, 5, 6, 5, 4, 4, 5, 6, 6, 4, 4, 4,
		
		// {  |  }  ~
		   4, 2, 4, 5,
		
		// Additional characters
		   6, 10, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6,
		   6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6,
		   6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6,
		   6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6,
		   6, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
		   4, 4, 4, 4, 4, 4, 4, 4, 4
	};
	
	int size;
	for(int i=0; i<SizeOfArray(string); i++){
		if(string[i]!=0){
			size += fontDef[string[i]-' '];
		}
		else
			break;
	}
	return size;
}

int DialogueBox_GetCharLength_LttPSmall(int fontDef, int c){
	if(c>=' ')
		return fontDef[c-' '];
	return 0;
}

int Q7_StringLength(int ptr, int fontDef){
	int i;
	int w;
	while(ptr[i]!=0){
		if(ptr[i]>=' ')
			w += fontDef[ptr[i]-' '];
		++i;
	}
	return w;
}

//Hi, this a more compact drawstrings function. I used the formatted version for things that really didn't need it for some reason and now it's all coming back to bite me.
int Q7_DrawStringsOutline(int layer, int x, int y, int font, int clr1, int clr2, int format, int lineWidth, int lineHeight, int ptr, int op, int fontDef){
	int strBuf[512];
	int pos;
	int wordPos; //The index for the start of a word
	int endPos; //The index for the end of the line being drawn
	int linePos; //The index for the start of the line being drawn
	int bufPos; //The index for the position in the buffer for the current line
	int width;
	int yoff;
	int lineCount;
	while(ptr[pos]!=0){
		linePos = pos;
		width = 0;
		bufPos = 0;
		while((width<lineWidth||ptr[pos]==' ')&&ptr[pos]!=0){
			if(ptr[pos]>=' ')
				width += fontDef[ptr[pos]-' ']; //Font definition starts at the space character
			if(ptr[pos]==' '&&ptr[pos+1]!=' ')
				wordPos = pos+1;
			strBuf[bufPos] = ptr[pos];
			++pos;
			++bufPos;
		}
		if(wordPos!=linePos&&ptr[pos]!=0)
			endPos = wordPos;
		else
			endPos = pos;
		strBuf[endPos-linePos] = 0;
		Q7_DrawStringOutline(layer, x, y+yoff, font, clr1, clr2, format, strBuf, op);
		pos = endPos;
		yoff += lineHeight;
		++lineCount;
		if(lineCount>100)
			break;
	}
	return lineCount;
}

const int SFX_SELECT = 5;
const int SFX_CONFIRM = 85;
const int SFX_PASSWORD_UNLOCKED = 27;

ffc script Q7_Title{
	void run(){
		G[G_DISABLE_SPECIALMODES] = 1;
		int titleScreen = -1;
		int titleCount = 0;
		
		int binaryInputs[8];
		int binarySolution[8] = {1, 1, 1, 1, -1, 1, 1, -1};
		int cheatScript[] = "PasswordMenu";
		int cheatScriptSlot = Game->GetFFCScript(cheatScript);
		
		this->Flags[FFCF_CARRYOVER] = true;
		int i;
		for(i=0; i<60; i++){
			Screen->Rectangle(6, 0, 0, 255, 175, 0x0F, 1, 0, 0, 0, true, 128);
			WaitNoAction();
		}
		Game->PlaySound(82);
		int lineStart[256];
		int lineEnd[256];
		int lineStartColor[256];
		int strDat[6] = {lineStart, lineEnd, lineStartColor, 0, 12, 0};
		int mooshPresents[] = "-MOOSH- PRESENTS";
		Q7_DrawStringSP_Prep(strDat, 80, mooshPresents);
		for(i=0; i<180; i++){
			Screen->Rectangle(6, 0, 0, 255, 175, 0x0F, 1, 0, 0, 0, true, 128);
			Screen->FastTile(6, 120, 48, 212, 7, 128);
			Q7_DrawStringSP(strDat, 6, 128, 68, 80, TF_CENTERED, mooshPresents);
			
			WaitNoAction();
		}
		for(i=0; i<30; i++){
			if(i<10)
				Screen->Rectangle(6, 0, 0, 255, 175, 0x0F, 1, 0, 0, 0, true, 128);
			if(i<20)
				Screen->Rectangle(6, 0, 0, 255, 175, 0x0F, 1, 0, 0, 0, true, 64);
			Screen->Rectangle(6, 0, 0, 255, 175, 0x0F, 1, 0, 0, 0, true, 64);
			WaitNoAction();
		}
		
		Link->Warp(26, 0x00);
		
		int storyCrawl[] = "IT IS WRITTEN THAT LONG AGO THE HERO @52LINK@01 CHALLENGED THE PRINCE OF DARKNESS @81GANON@01 AND RESTORED PEACE TO HYRULE. BUT THAT PEACE IS NOW ONCE AGAIN UNDER ATTACK. A SERVANT OF EVIL NAMED @A2ADJEAN@01 HAS CAST A POWERFUL SPELL OVER HYRULE, PLUNGING ALL ITS INHABITANTS INTO A WORLD OF NIGHTMARES. ONLY THE @72EIGHT HISTORIES OF HYRULE, HYRULE HISTORIA,@01 HOLD THE SECRET TO LIFTING @A2ADJEAN'S CURSE@01. @52THE DESCENDANT OF LINK@01 AWAKENS IN THE @A2NIGHTMARE OF HYRULE@01 AND SETS OUT ON HIS QUEST TO FIND THEM.@N@00GODDAMMITNEWLINE@N@01GO FORTH, @52LINK@01! DEFEAT @A2ADJEAN@01, AWAKEN HYRULE FROM THE NIGHTMARE, AND PREVENT THE REVIVAL OF @81GANON@01!";
		int rainEffect[] = "RainEffect";
		int rainEffectSlot = Game->GetFFCScript(rainEffect);
		
		int titleState = 0;
		int titleTimer = 0;
		int titleVariant = 0;
		
		Q7_DrawStringSP_Prep(strDat, 240, storyCrawl);
		
		ffc f;
		
		while(true){
			if(titleState<=2){
				Q7_ScaryBinary(binaryInputs);
				if(Q7_ArrayCompare(binaryInputs, binarySolution)==0){
					Game->PlaySound(SFX_PASSWORD_UNLOCKED);
					f = Screen->LoadFFC(RunFFCScript(cheatScriptSlot, 0));
					while(f->Script>0){
						Waitframe();
					}
					for(i=0; i<8; i++){
						binaryInputs[i] = 0;
					}
				}
			}
			
			if(titleState==0){ //Title rising
				if(titleVariant==1&&titleTimer==0)
					RunFFCScript(rainEffectSlot, 0);
				titleTimer++;
				if(titleTimer%4==0)
					Screen->DrawLayer(6, 1, 0x20, 0, 0, 176-titleTimer, 0, 128);
				if(titleTimer>=176){
					titleTimer = 0;
					titleState = 1;
				}
				if(Link->PressStart){
					titleTimer = 0;
					titleState = 2;
				}
			}
			else if(titleState==1){ //Title flickering
				titleTimer++;
				if(titleTimer%4<2)
					Screen->DrawLayer(6, 1, 0x20, 0, 0, 0, 0, 128);
				if(titleTimer>=64){
					titleTimer = 0;
					titleState = 2;
				}
				if(Link->PressStart){
					titleTimer = 0;
					titleState = 2;
				}
			}
			else if(titleState==2){ //Title active
				titleTimer++;
				Screen->DrawLayer(6, 1, 0x20, 0, 0, 0, 0, 128);
				if(titleTimer>=1300){
					titleTimer = 0;
					titleState = 3;
				}
				else if(Link->PressStart){
					Game->PlaySound(SFX_CONFIRM);
					NoAction();
					titleTimer = 0;
					titleState = 7;
				}
			}
			else if(titleState==3){ //Title fade out
				titleTimer++;
				Screen->DrawLayer(6, 1, 0x20, 0, 0, 0, 0, 128);
				if(titleTimer>=10)
					Screen->Rectangle(6, 0, 0, 255, 175, 0x0F, 1, 0, 0, 0, true, 64);
				if(titleTimer>=20)
					Screen->Rectangle(6, 0, 0, 255, 175, 0x0F, 1, 0, 0, 0, true, 128);
				Screen->Rectangle(6, 0, 0, 255, 175, 0x0F, 1, 0, 0, 0, true, 64);
				if(titleTimer>=30){
					titleTimer = 0;
					if(titleVariant==0)
						titleState = 4;
					else
						titleState = 6;
				}
			}
			else if(titleState==4){ //Story crawl
				titleTimer += 0.25;
				
				Screen->Rectangle(6, 0, 0, 255, 175, 0x0F, 1, 0, 0, 0, true, 128);
				Q7_DrawStringSP(strDat, 6, 128, 176-titleTimer, 240, TF_CENTERED, storyCrawl);
				//Screen->DrawInteger(6, 0, 0, FONT_Z1, 0x01, 0x0F, -1, -1, titleTimer, 0, 128);
			
				if(titleTimer>=480){
					titleTimer = 0;
					titleState = 5;
					++titleCount;
					if(titleCount>=2){
						titleScreen = Rand(128);
						Q7_UpdateRainFlags(titleScreen);
					}
				}
				else if(Link->PressStart){
					NoAction();
					titleTimer = 0;
					titleState = 5;
					++titleCount;
					if(titleCount>=2){
						titleScreen = Rand(128);
						Q7_UpdateRainFlags(titleScreen);
					}
				}
			}
			else if(titleState==5){ //Title fade back in
				titleTimer++;
				if(titleTimer<10)
					Screen->Rectangle(6, 0, 0, 255, 175, 0x0F, 1, 0, 0, 0, true, 128);
				if(titleTimer<20)
					Screen->Rectangle(6, 0, 0, 255, 175, 0x0F, 1, 0, 0, 0, true, 64);
				Screen->Rectangle(6, 0, 0, 255, 175, 0x0F, 1, 0, 0, 0, true, 64);
				if(titleTimer>=30){
					titleTimer = 0;
					titleState = 0;
					titleVariant++;
					titleVariant %= 2;
					if(titleVariant==1){
						Link->Warp(27, 0x00);
					}
					else{
						Link->Warp(26, 0x00);
					}
				}
			}
			else if(titleState==6){ //Item list
				titleTimer += 0.80;
				
				Screen->Rectangle(6, 0, 0, 255, 175, 0x0F, 1, 0, 0, 0, true, 128);
				Q7_DrawItems(176-titleTimer);
				//Screen->DrawInteger(6, 0, 0, FONT_Z1, 0x01, 0x0F, -1, -1, titleTimer, 0, 128);
			
				if(titleTimer>=2080){
					titleTimer = 0;
					titleState = 5;
					ClearFFCScript(rainEffectSlot);
					++titleCount;
					if(titleCount>=2){
						titleScreen = Rand(128);
						Q7_UpdateRainFlags(titleScreen);
					}
				}
				else if(Link->PressStart){
					NoAction();
					titleTimer = 0;
					titleState = 5;
					ClearFFCScript(rainEffectSlot);
					++titleCount;
					if(titleCount>=2){
						titleScreen = Rand(128);
						Q7_UpdateRainFlags(titleScreen);
					}
				}
			}
			else if(titleState==7){ //Title confirmed
				titleTimer++;
				Screen->DrawLayer(6, 1, 0x20, 0, 0, 0, 0, 128);
				if(titleTimer>=60){
					titleTimer = 0;
					titleState = 8;
				}
			}
			else if(titleState==8){ //Title fade to settings
				titleTimer++;
				Screen->DrawLayer(6, 1, 0x20, 0, 0, 0, 0, 128);
				if(titleTimer>=10)
					Screen->Rectangle(6, 0, 0, 255, 175, 0x0F, 1, 0, 0, 0, true, 64);
				if(titleTimer>=20)
					Screen->Rectangle(6, 0, 0, 255, 175, 0x0F, 1, 0, 0, 0, true, 128);
				Screen->Rectangle(6, 0, 0, 255, 175, 0x0F, 1, 0, 0, 0, true, 64);
				if(titleTimer>=30){
					this->Flags[FFCF_CARRYOVER] = false;
					Link->Warp(30, 0x02);
				}
			}
			if(titleScreen>-1){
				Screen->Rectangle(4, 0, 0, 255, 175, 0x0F, 1, 0, 0, 0, true, 128);
				Screen->DrawScreen(4, 8, titleScreen, 0, 0, 0);
			}
			WaitNoAction();
		}
	}
	void Q7_ScaryBinary(int binaryInputs){
		int input = 0;
		if(Link->PressUp&&!Link->PressDown)
			input = -1;
		else if(Link->PressDown&&!Link->PressUp)
			input = 1;
		
		if(input!=0){
			for(int i=7; i>0; --i){
				binaryInputs[i] = binaryInputs[i-1];
			}
			binaryInputs[0] = input;
		}
	}
	void Q7_DrawItems(int y){
		int s1[] = "HEART";
		int s2[] = "HEART CONTAINER";
		int s3[] = "FAIRY";
		int s4[] = "RUPEE";
		int s5[] = "5 RUPEES";
		int s6[] = "BLUE POTION";
		int s7[] = "RED POTION";
		int s8[] = "LETTER";
		int s9[] = "BAIT";
		int s10[] = "SWORD";
		int s11[] = "WHITE SWORD";
		int s12[] = "MAGIC SWORD";
		int s13[] = "SUPREME SWORD";
		int s14[] = "MAGIC SHIELD";
		int s15[] = "MIRROR SHIELD";
		int s16[] = "TRIMIRROR SHIELD";
		int s17[] = "BOOMERANG";
		int s18[] = "MAGIC BOOMERANG";
		int s19[] = "FIRE BOOMERANG";
		int s20[] = "BOMB";
		int s21[] = "SUPER BOMB";
		int s22[] = "BOW";
		int s23[] = "ARROW";
		int s24[] = "SILVER ARROW";
		int s25[] = "BLUE CANDLE";
		int s26[] = "RED CANDLE";
		int s27[] = "ULTRAVIOLET CANDLE";
		int s28[] = "BLUE RING";
		int s29[] = "RED RING";
		int s30[] = "POWER BRACELET";
		int s31[] = "WHISTLE";
		int s32[] = "MAGIC WAND";
		int s33[] = "HYPER WAND";
		int s34[] = "ECHO TOME";
		int s35[] = "FLIPPERS";
		int s36[] = "SAINT STATUE";
		int s37[] = "SECRETS RING";
		int s38[] = "PHASE CLOAK";
		int s39[] = "DOUBLE PHASER";
		int s40[] = "MAGIC BOOTS";
		int s41[] = "ACCELERATOR";
		int s42[] = "KEY";
		int s43[] = "MAP";
		int s44[] = "COMPASS";
		int s45[] = "HISTORIA";
		
		int allt[] = "ALL ITEMS";
		
		int itemS[]   = {s1, s2, s3, s4, s5, s6, s7, s8, s9, s10, s11, s12, s14, s15, s16, s17, s18, s19, s20, s21,  s22, s23, s24,  s25, s26, s27, s28, s29, s30, s31, s32, s33,  s34, s35,  s36,  s37, s38, s39, s40, s41,  s42, s43, s44, s45};
		int itemX[]   = {0,  1,  0,  1,  0,  1,  0,  1,  0,  1,   0,   1,   0,   1,   0,   1,   0,   1,   0,   1,    0,   1,   0,    1,   0,   1,   0,   1,   0,   1,   0,   1,    0,   1,    0,    1,   0,   1,   0,   1,    0,   1,   0,   1};
		int itemTil[] = {82, 69, 63, 49, 49, 55, 55, 81, 79, 41,  41,  59,  40,  526, 566, 51,  51,  51,  50,  1355, 80,  45,  1317, 44,  44,  44,  58,  58,  62,  37,  60,  4120, 832, 1500, 1511, 870, 871, 871, 546, 4460, 48,  81,  70,  830};
		int itemCS[]  = {8,  8,  8,  8,  7,  7,  8,  7,  8,  6,   7,   8,   6,   6,   6,   6,   7,   8,   7,   8,    6,   6,   7,    7,   8,   10,  7,   8,   8,   8,   7,   8,    1,   7,    11,   10,  11,  10,  8,   5,    8,   8,   8,  8};
	
		int lineStart[256];
		int lineEnd[256];
		int lineStartColor[256];
		int strDat[6] = {lineStart, lineEnd, lineStartColor, 0, 12};
		
		Screen->DrawString(6, 128, y, FONT_Z1, 0x01, 0, TF_CENTERED, allt, 128);
		for(int i=0; i<44; i++){
			int tmpx = 48+144*itemX[i];
			int tmpy = y+80+Floor(i/2)*80;
			if(tmpy>-32&&tmpy<176){
				Screen->FastTile(6, tmpx, tmpy, itemTil[i], itemCS[i], 128);
				
				Q7_DrawStringSP_Prep(strDat, 96, itemS[i]);
				Q7_DrawStringSP(strDat, 6, tmpx+8, tmpy+20, 80, TF_CENTERED, itemS[i]);
			
			}
		}
	}
	void Q7_UpdateRainFlags(int scrn){
		for(int i=0; i<176; ++i){
			int f = Game->GetComboFlag(8, scrn, i);
			if(f==97)
				Screen->ComboF[i] = 97;
			else
				Screen->ComboF[i] = 0;
		}
	}
}

int Q7_ArrayCompare(int arr1, int arr2){
	int diff = 0;
	int size = SizeOfArray(arr1);
	for(int i=0; i<size; ++i){
		if(arr1[i]!=arr2[i])
			++diff;
	}
	return diff;
}

const int SFX_DIFFSELECTION = 5;
const int SFX_GLASSCRACK = 83;
const int SFX_GLASSHATTER = 84;

const int RT_GLASSWIPE = 1; //Offscreen bitmap to use for the wipe (RT_ constants in std_constants.zh)
const int C_GLASSWIPE_BG = 0x0F; //The color black. Used to draw the background for tilesets that use transparent tiles on layer 0

const int RT_REALLYJOEL_TENDRIL = 2;
const int TIL_REALLYJOEL_TENDRIL = 5443;

ffc script Q7_Options{
	void run(){
		this->Flags[FFCF_CARRYOVER] = true;
		
		int i; int j; int k;
		int vX; int vY;
		
		int lineStart[256];
		int lineEnd[256];
		int lineStartColor[256];
		int strDat[6] = {lineStart, lineEnd, lineStartColor, 0, 12, 1};
		
		for(i=0; i<30; i++){
			if(i<10)
				Screen->Rectangle(6, 0, 0, 255, 175, 0x0F, 1, 0, 0, 0, true, 128);
			if(i<20)
				Screen->Rectangle(6, 0, 0, 255, 175, 0x0F, 1, 0, 0, 0, true, 64);
			Screen->Rectangle(6, 0, 0, 255, 175, 0x0F, 1, 0, 0, 0, true, 64);
			WaitNoAction();
		}
		
		int selDiff[] = "SELECT YOUR DIFFICULTY:";
		
		int veasy[] = "VERY EASY";
		int easy[] = "EASY";
		int normal[] = "NORMAL";
		int hard[] = "HARD";
		int vhard[] = "VERY HARD";
		int joel[] = "REALLYJOEL'S DAD";
		
		int diffs[] = {veasy, easy, normal, hard, vhard, joel};
		
		int d_veasy[] = "FOR PEOPLE WHO MAINLY WANT TO SEE SOME FLASHING LIGHTS AND COLORS.";
		int d_easy[] = "IF YOU DON'T WANT TO BE CHALLENGED.";
		int d_normal[] = "SHOULD BE ABOUT AVERAGE QUEST DIFFICULTY.";
		int d_hard[] = "THE DIFFICULTY THE QUEST WAS DESIGNED AT.";
		int d_vhard[] = "THE LIMITS OF WHAT A TYPE-A PLAYER CAN TOLERATE.";
		int d_joel[] = "ARE YOU REALLYJOEL'S DAD? HE'D BEAT THIS WITHOUT BREAKING A SWEAT.";
		
		int d_diffs[] = {d_veasy, d_easy, d_normal, d_hard, d_vhard, d_joel};
		
		int sel = 2;
		int maxDiff = 5;
		int reallyJoelCount;
		int reallyJoelTimer;
		bool playCursorSound; //It's really dumb how warps take a frame and kill sfx
		
		//Glass shard stuff
		int CPX[56];
		int CPY[56];
		int CPZ[56];
		int AngA[56];
		int AngB[56];
		int AngC[56];
		int DA[56];
		int DB[56];
		int DC[56];
		int BaseAngA[56];
		int BaseAngB[56];
		int RotA[56];
		int RotB[56];
		int VX[56];
		int VY[56];
		int shardState[56];
		int crackW[56];
		
		for(i=0; i<56; i++){
			crackW[i] = Rand(0, 3);
		}
		
		int shardVars[] = {CPX, CPY, CPZ, AngA, AngB, AngC, DA, DB, DC, BaseAngA, BaseAngB, RotA, RotB, VX, VY, shardState, 56, crackW};
		
		int tendrilACycles[8];
		int tendrilGroups[54];
		int tendrilDist = 0;
		
		for(i=0; i<54; i++){
			tendrilGroups[i] = Rand(4);
		}
		for(i=0; i<8; i++){
			tendrilACycles[i] = Rand(360);
		}
		
		GlassWipe_Init(RT_GLASSWIPE, shardVars);
		
		while(true){
			if(playCursorSound){
				Game->PlaySound(SFX_DIFFSELECTION);
				playCursorSound = false;
			}
			
			if(Link->PressA||Link->PressStart){
				Game->PlaySound(SFX_CONFIRM);
				
				for(i=0; i<30; i++){
					if(sel==5){
						tendrilDist = Min(tendrilDist+2, 32);
						if(tendrilDist>0)
							Q7_DrawTendrils(tendrilACycles, tendrilGroups, tendrilDist);
					}
					else{
						tendrilDist = Max(tendrilDist-4, 0);
						if(tendrilDist>0)
							Q7_DrawTendrils(tendrilACycles, tendrilGroups, tendrilDist);
					}
					
					if(reallyJoelTimer>0)
						reallyJoelTimer--;
					
					if(i%4<2){
						Q7_DiffSelect_DrawOptions(sel, reallyJoelCount, reallyJoelTimer, maxDiff, selDiff, diffs, d_diffs, strDat, true);
					}
					else{
						Q7_DiffSelect_DrawOptions(sel, reallyJoelCount, reallyJoelTimer, maxDiff, selDiff, diffs, d_diffs, strDat, false);
					}
					
					WaitNoAction();
				}
				for(i=0; i<30; i++){
					if(sel==5){
						tendrilDist = Min(tendrilDist+2, 32);
						if(tendrilDist>0)
							Q7_DrawTendrils(tendrilACycles, tendrilGroups, tendrilDist);
					}
					else{
						tendrilDist = Max(tendrilDist-4, 0);
						if(tendrilDist>0)
							Q7_DrawTendrils(tendrilACycles, tendrilGroups, tendrilDist);
					}
					
					if(reallyJoelTimer>0)
						reallyJoelTimer--;
					
					if(i%4<2){
						Q7_DiffSelect_DrawOptions(sel, reallyJoelCount, reallyJoelTimer, maxDiff, selDiff, diffs, d_diffs, strDat, true);
					}
					else{
						Q7_DiffSelect_DrawOptions(sel, reallyJoelCount, reallyJoelTimer, maxDiff, selDiff, diffs, d_diffs, strDat, false);
					}
					
					if(i>=10)
						Screen->Rectangle(6, 0, 0, 255, 175, 0x0F, 1, 0, 0, 0, true, 64);
					if(i>=20)
						Screen->Rectangle(6, 0, 0, 255, 175, 0x0F, 1, 0, 0, 0, true, 128);
					Screen->Rectangle(6, 0, 0, 255, 175, 0x0F, 1, 0, 0, 0, true, 64);
					
					WaitNoAction();
				}
				this->Flags[FFCF_CARRYOVER] = false;
				if(sel==0){
					Link->Item[I_DIFF_VERYEASY] = true;
					Link->Item[I_DIFF_EASY] = false;
					Link->Item[I_DIFF_NORMAL] = false;
					Link->Item[I_DIFF_HARD] = false;
					Link->Item[I_DIFF_VERYHARD] = false;
					Link->Item[I_DIFF_REALLYJOEL] = false;
				}
				else if(sel==1){
					Link->Item[I_DIFF_VERYEASY] = false;
					Link->Item[I_DIFF_EASY] = true;
					Link->Item[I_DIFF_NORMAL] = false;
					Link->Item[I_DIFF_HARD] = false;
					Link->Item[I_DIFF_VERYHARD] = false;
					Link->Item[I_DIFF_REALLYJOEL] = false;
				}
				else if(sel==2){
					Link->Item[I_DIFF_VERYEASY] = false;
					Link->Item[I_DIFF_EASY] = false;
					Link->Item[I_DIFF_NORMAL] = true;
					Link->Item[I_DIFF_HARD] = false;
					Link->Item[I_DIFF_VERYHARD] = false;
					Link->Item[I_DIFF_REALLYJOEL] = false;
				}
				else if(sel==3){
					Link->Item[I_DIFF_VERYEASY] = false;
					Link->Item[I_DIFF_EASY] = false;
					Link->Item[I_DIFF_NORMAL] = false;
					Link->Item[I_DIFF_HARD] = true;
					Link->Item[I_DIFF_VERYHARD] = false;
					Link->Item[I_DIFF_REALLYJOEL] = false;
				}
				else if(sel==4){
					Link->Item[I_DIFF_VERYEASY] = false;
					Link->Item[I_DIFF_EASY] = false;
					Link->Item[I_DIFF_NORMAL] = false;
					Link->Item[I_DIFF_HARD] = false;
					Link->Item[I_DIFF_VERYHARD] = true;
					Link->Item[I_DIFF_REALLYJOEL] = false;
				}
				else{
					Link->Item[I_DIFF_VERYEASY] = false;
					Link->Item[I_DIFF_EASY] = false;
					Link->Item[I_DIFF_NORMAL] = false;
					Link->Item[I_DIFF_HARD] = false;
					Link->Item[I_DIFF_VERYHARD] = false;
					Link->Item[I_DIFF_REALLYJOEL] = true;
				}
				Difficulty_Init();
				Link->Warp(Game->GetCurDMap(), 0x03);
			}
			
			if(Link->PressUp){
				if(reallyJoelCount<10){
					sel = Max(sel-1, 0);
					Link->Warp(28+Clamp(sel, 0, 5), 0x02);
					playCursorSound = true;
				}
				else{
					sel--;
					if(sel<0)
						sel = maxDiff-1;
					Link->Warp(28+Clamp(sel, 0, 5), 0x02);
					playCursorSound = true;
				}
			}
			else if(Link->PressDown){
				if(reallyJoelCount<10){
					if(sel==maxDiff-1){
						reallyJoelTimer = 16;
						reallyJoelCount++;
					}
					sel = Min(sel+1, maxDiff-1);
					if(Game->GetCurDMap()!=28+Clamp(sel, 0, 5))
						Link->Warp(28+Clamp(sel, 0, 5), 0x02);
					playCursorSound = true;
				}
				else{
					sel++;
					if(sel>maxDiff-1)
						sel = 0;
					if(Game->GetCurDMap()!=28+Clamp(sel, 0, 5))
						Link->Warp(28+Clamp(sel, 0, 5), 0x02);
					playCursorSound = true;
				}
			}
			
			if(sel==5){
				tendrilDist = Min(tendrilDist+2, 32);
				if(tendrilDist>0)
					Q7_DrawTendrils(tendrilACycles, tendrilGroups, tendrilDist);
			}
			else{
				tendrilDist = Max(tendrilDist-4, 0);
				if(tendrilDist>0)
					Q7_DrawTendrils(tendrilACycles, tendrilGroups, tendrilDist);
			}
			
			if(reallyJoelCount==10){
				playCursorSound = false;
				reallyJoelTimer = 0;
				
				Game->PlaySound(SFX_GLASSCRACK);
				for(i=0; i<40; i++){
					Q7_DiffSelect_DrawOptions(sel, reallyJoelCount, reallyJoelTimer, maxDiff, selDiff, diffs, d_diffs, strDat, true);
					GlassWipe_DrawCracks(6, shardVars);
					WaitNoAction();
				}
				Link->Warp(28+5, 0x02);
				Screen->Rectangle(6, 0, 0, 255, 175, 0x0F, 1, 0, 0, 0, true, 128);
				Waitframe();
				
				reallyJoelCount = 11;
				sel = 5;
				maxDiff = 6;
				
				Game->PlaySound(SFX_GLASSHATTER);
				while(shardVars[16]>0){	
					//Draw the new screen to the bitmap
					Screen->SetRenderTarget(RT_GLASSWIPE);
					Screen->Rectangle(0, 0, 0, 255, 175, C_GLASSWIPE_BG, 1, 0, 0, 0, true, 128);
					Screen->DrawScreen(0, Game->GetCurMap(), Game->GetCurScreen(), 0, 0, 0);
					Q7_DiffSelect_DrawOptions(sel, reallyJoelCount, reallyJoelTimer, maxDiff, selDiff, diffs, d_diffs, strDat, true);
					
					//Draw the old screen to the screen
					Screen->SetRenderTarget(RT_SCREEN);
					Screen->Rectangle(0, 0, 0, 255, 175, C_GLASSWIPE_BG, 1, 0, 0, 0, true, 128);
					
					//Erase the triangles from the bitmap
					GlassWipe_Update(6, RT_GLASSWIPE, 128, 88, 512, 4, 0.08, shardVars);
					
					//Draw the bitmap to the screen
					Screen->DrawBitmap(6, RT_GLASSWIPE, 0, 0, 256, 176, 0, 0, 256, 176, 0, true);
					WaitNoAction();
				}
			}
			
			if(reallyJoelTimer>0)
				reallyJoelTimer--;
			
			Q7_DiffSelect_DrawOptions(sel, reallyJoelCount, reallyJoelTimer, maxDiff, selDiff, diffs, d_diffs, strDat, true);
					
			WaitNoAction();
		}
	}
	void Q7_DiffSelect_DrawOptions(int sel, int reallyJoelCount, int reallyJoelTimer, int maxDiff, int selDiff, int diffs, int d_diffs, int strDat, bool drawSelection){
		Q7_DrawStringOutline(6, 128, 16, FONT_Z1, 0x01, 0x0F, TF_CENTERED, selDiff, 128);
			
		for(int i=0; i<maxDiff; i++){
			int j = 0;
			int vX = 0;
			int vY = 0;
			if(reallyJoelTimer>0){
				j = Floor(reallyJoelCount*(reallyJoelTimer/16)/2);
				if(j>0){
					vX = Rand(-j, j);
					vY = Rand(-j, j);
				}
			}
			if(sel==i&&drawSelection){
				Q7_DrawStringOutline(6, 128+vX, 40+12*i+vX, FONT_Z1, 0x01, 0x0F, TF_CENTERED, diffs[i], 128);
			}
			else{
				Q7_DrawStringOutline(6, 128+vX, 40+12*i+vY, FONT_Z1, 0x02, 0x0F, TF_CENTERED, diffs[i], 128);
			}
		}
		
		Q7_DrawStringSP_Prep(strDat, 224, d_diffs[sel]);
		Q7_DrawStringSP(strDat, 6, 128, 128, 224, TF_CENTERED, d_diffs[sel]);
		
	}
	void Q7_DrawTendrils(int tendrilACycles, int tendrilGroups, int len){
		int i; int j; int k;
		Screen->SetRenderTarget(RT_REALLYJOEL_TENDRIL);
		
		int cycleSpeed[8];
		
		Screen->Rectangle(0, 256, 0, 511, 175, 0x00, 1, 0, 0, 0, true, 128);
		for(i=0; i<8; i++){
			tendrilACycles[i] += 1.5+0.5*i;
			tendrilACycles[i] %= 360;
			Screen->DrawTile(0, 256, 8+32*i, TIL_REALLYJOEL_TENDRIL, 2, 1, 11, len, 16, 0, 0, 0, 0, true, 128);
		
			for(j=0; j<32; j++){
				k = 8-(j/32)*4;
				Screen->DrawBitmap(0, RT_REALLYJOEL_TENDRIL, 256+j, 8+32*i, 1, 16, 256+64+j, 8+32*i-k*Sin(tendrilACycles[i]+16*j), 1, 16, 0, true);
			}
		}
		Screen->SetRenderTarget(RT_SCREEN);
		
		for(i=0; i<11; i++){
			Screen->DrawBitmap(0, RT_REALLYJOEL_TENDRIL, 256+64, 32*tendrilGroups[i], 32, 32, 0, -8+16*i, 32, 32, 0, true);
			Screen->DrawBitmap(0, RT_REALLYJOEL_TENDRIL, 256+64, 32*tendrilGroups[11+i], 32, 32, 224, -8+16*i, 32, 32, 180, true);
		}
		for(i=0; i<16; i++){
			Screen->DrawBitmap(0, RT_REALLYJOEL_TENDRIL, 256+64, 32*tendrilGroups[22+i], 32, 32, -8+16*i, 0, 32, 32, 90, true);
			Screen->DrawBitmap(0, RT_REALLYJOEL_TENDRIL, 256+64, 32*tendrilGroups[36+i], 32, 32, -8+16*i, 144, 32, 32, -90, true);
		}
	}
	//Call once to initialize the wipe
	//rt - The bitmap to use (RT_ constants in std_constants.zh)
	//vars - An array with array pointers for all the data of the glass wipe. 15 in total, all size 56. The last index is 56.
	//			{CPX, CPY, CPZ, AngA, AngB, AngC, DA, DB, DC, BaseAngA, BaseAngB, RotA, RotB, VX, VY, shardState, 56}
	void GlassWipe_Init(int rt, int vars){
		int CPX = vars[0];
		int CPY = vars[1];
		int CPZ = vars[2];
		int AngA = vars[3];
		int AngB = vars[4];
		int AngC = vars[5];
		int DA = vars[6];
		int DB = vars[7];
		int DC = vars[8];
		
		int PointX[40];
		int PointY[40];
		int i;
		for(i=0; i<40; i++){
			PointX[i] = -48+48*(i%8)+(Floor(i/8)%2)*0.5*48;
			PointY[i] = -16+Floor(i/8)*48;
			PointX[i] += Rand(-8, 8);
			PointY[i] += Rand(-8, 8);
		}
		int TA[56];
		int TB[56];
		int TC[56];
		for(i=0; i<7; i++){
			TA[i] = i;
			TB[i] = i+1;
			TC[i] = i+8;
		}
		for(i=0; i<7; i++){
			TA[7+i] = i+1;
			TB[7+i] = 8+i;
			TC[7+i] = 8+i+1;
		}
		for(i=0; i<7; i++){
			TA[14+i] = 8+i;
			TB[14+i] = 8+i+1;
			TC[14+i] = 8+i+9;
		}
		for(i=0; i<7; i++){
			TA[21+i] = 8+i;
			TB[21+i] = 16+i;
			TC[21+i] = 16+i+1;
		}
		for(i=0; i<7; i++){
			TA[28+i] = 16+i;
			TB[28+i] = 16+i+1;
			TC[28+i] = 16+i+8;
		}
		for(i=0; i<7; i++){
			TA[35+i] = 16+i+1;
			TB[35+i] = 24+i;
			TC[35+i] = 24+i+1;
		}
		for(i=0; i<7; i++){
			TA[42+i] = 24+i;
			TB[42+i] = 24+i+1;
			TC[42+i] = 24+i+9;
		}
		for(i=0; i<7; i++){
			TA[49+i] = 24+i;
			TB[49+i] = 32+i;
			TC[49+i] = 32+i+1;
		}
		int BaseAngA[56];
		int BaseAngB[56];
		int RotA[56];
		int RotB[56];
		int VX[56];
		int VY[56];
		Screen->SetRenderTarget(rt);
		Screen->Rectangle(0, 0, 0, 255, 175, 0x0F, 1, 0, 0, 0, true, 128);
		Screen->SetRenderTarget(RT_SCREEN);
		for(i=0; i<56; i++){
			CPX[i] = (PointX[TA[i]]+PointX[TB[i]]+PointX[TC[i]])/3;
			CPY[i] = (PointY[TA[i]]+PointY[TB[i]]+PointY[TC[i]])/3;
			AngA[i] = Angle(CPX[i], CPY[i], PointX[TA[i]], PointY[TA[i]]);
			AngB[i] = Angle(CPX[i], CPY[i], PointX[TB[i]], PointY[TB[i]]);
			AngC[i] = Angle(CPX[i], CPY[i], PointX[TC[i]], PointY[TC[i]]);
			DA[i] = Distance(CPX[i], CPY[i], PointX[TA[i]], PointY[TA[i]])+1;
			DB[i] = Distance(CPX[i], CPY[i], PointX[TB[i]], PointY[TB[i]])+1;
			DC[i] = Distance(CPX[i], CPY[i], PointX[TC[i]], PointY[TC[i]])+1;
			VX[i] = VectorX(Distance(128, 88, CPX[i], CPY[i])/120, Angle(128, 88, CPX[i], CPY[i]));
			VY[i] = VectorY(Distance(128, 88, CPX[i], CPY[i])/80, Angle(128, 88, CPX[i], CPY[i]));
		}
	}
	//Erases triangles from the bitmap
	//Call every frame until vars[16] is less than or equal to 0.
	//Layer - The layer to draw to
	//rt - The bitmap to use (RT_ constants in std_constants.zh)
	//cx,cy - Center point for the shatter effect
	//radius - How far from the shatter point to activate shards
	//shardSpeed - How fast the shards should move in pixels per frame, not accounting for gravity
	void GlassWipe_Update(int layer, int rt, int cx, int cy, int radius, float shardSpeed, float gravity, int vars){
		int i;
		
		int CPX = vars[0];
		int CPY = vars[1];
		int CPZ = vars[2];
		int AngA = vars[3];
		int AngB = vars[4];
		int AngC = vars[5];
		int DA = vars[6];
		int DB = vars[7];
		int DC = vars[8];
		int BaseAngA = vars[9];
		int BaseAngB = vars[10];
		int RotA = vars[11];
		int RotB = vars[12];
		int VX = vars[13];
		int VY = vars[14];
		int shardState = vars[15];
		int numShards = 56;
		
		// Screen->Rectangle(Layer, -8, -8, 264, 184, 0x0F, 1, 0, 0, 0, true, 128);
		// Screen->DrawScreen(Layer, OldMap, OldScreen, 0, 0, 0);
		// Screen->DrawBitmap(Layer, rt, 0, 0, 256, 176, 0, 0, 256, 176, 0, true);
		// Screen->SetRenderTarget(rt);
		// Screen->Rectangle(6, -8, -8, 264, 184, 0x0F, 1, 0, 0, 0, true, 128);
		// Screen->DrawScreen(6, NewMap, NewScreen, 0, 0, 0);
		Screen->SetRenderTarget(rt);
		int X[3];
		int Y[3];
		int Z[3];
		for(i=0; i<56; i++){
			if(shardState[i]==0&&Distance(CPX[i], CPY[i], cx, cy)<radius){
				shardState[i] = 1;
				int angle = Angle(cx, cy, CPX[i], CPY[i])+Rand(-30, 30);
				int step = shardSpeed*Rand(10, 20)/10;
				VX[i] = VectorX(step, angle);
				VY[i] = VectorY(step, angle);
				RotA[i] = Choose(-1, 1)*Rand(5, 50)/10;
				RotB[i] = Choose(-1, 1)*Rand(5, 50)/10;
			}
			if(shardState[i]==1){
				if(CPX[i]>-48&&CPX[i]<304&&CPY[i]>-48&&CPY[i]<224){
					CPX[i] += VX[i];
					CPY[i] += VY[i];
					VY[i] = Min(VY[i]+gravity, 3.2); //Gravity - 0.6
				}
				else{
					numShards--;
				}
				BaseAngA[i] += RotA[i];
				BaseAngB[i] += RotB[i];
			}
			
			int freshprinceofdickbutt = 90;
			//you tread upon the hall of the forbidden Mathemancy. Nobody knows how it works. Well someone might. But it isn't Moosh.
			int x0; int y0; int z0; int xtmp;
			x0 = DA[i]*Sin(freshprinceofdickbutt)*Cos(AngA[i]);
			y0 = DA[i]*Sin(freshprinceofdickbutt)*Sin(AngA[i]);
			z0 = DA[i]*Cos(freshprinceofdickbutt);
			X[0] = x0;
			Y[0] = y0*Cos(BaseAngA[i])-z0*Sin(BaseAngA[i]);
			Z[0] = y0*Sin(BaseAngA[i])+z0*Cos(BaseAngA[i]);
			xtmp = X[0];
			X[0] = X[0]*Cos(BaseAngB[i])+Z[0]*Sin(BaseAngB[i]);
			Z[0] = -xtmp*Sin(BaseAngB[i])+Z[0]*Cos(BaseAngB[i]);
			
			x0 = DB[i]*Sin(freshprinceofdickbutt)*Cos(AngB[i]);
			y0 = DB[i]*Sin(freshprinceofdickbutt)*Sin(AngB[i]);
			z0 = DB[i]*Cos(freshprinceofdickbutt);
			X[1] = x0;
			Y[1] = y0*Cos(BaseAngA[i])-z0*Sin(BaseAngA[i]);
			Z[1] = y0*Sin(BaseAngA[i])+z0*Cos(BaseAngA[i]);
			xtmp = X[1];
			X[1] = X[1]*Cos(BaseAngB[i])+Z[1]*Sin(BaseAngB[i]);
			Z[1] = -xtmp*Sin(BaseAngB[i])+Z[1]*Cos(BaseAngB[i]);
			
			x0 = DC[i]*Sin(freshprinceofdickbutt)*Cos(AngC[i]);
			y0 = DC[i]*Sin(freshprinceofdickbutt)*Sin(AngC[i]);
			z0 = DC[i]*Cos(freshprinceofdickbutt);
			X[2] = x0;
			Y[2] = y0*Cos(BaseAngA[i])-z0*Sin(BaseAngA[i]);
			Z[2] = y0*Sin(BaseAngA[i])+z0*Cos(BaseAngA[i]);
			xtmp = X[2];
			X[2] = X[2]*Cos(BaseAngB[i])+Z[2]*Sin(BaseAngB[i]);
			Z[2] = -xtmp*Sin(BaseAngB[i])+Z[2]*Cos(BaseAngB[i]);
			
			if(shardState[i]==1)
				Screen->Triangle(0, CPX[i]+X[0], CPY[i]+Y[0]+1, CPX[i]+X[1], CPY[i]+Y[1]+1, CPX[i]+X[2], CPY[i]+Y[2]+1, 2, 2, 0x01, 0, -1, PT_FLAT);
			else
				Screen->Triangle(0, CPX[i]+X[0], CPY[i]+Y[0]+1, CPX[i]+X[1], CPY[i]+Y[1]+1, CPX[i]+X[2], CPY[i]+Y[2]+1, 2, 2, 0x00, 0, -1, PT_FLAT);
			Screen->Triangle(0, CPX[i]+X[0], CPY[i]+Y[0], CPX[i]+X[1], CPY[i]+Y[1], CPX[i]+X[2], CPY[i]+Y[2], 1, 1, 0x00, 0, -1, PT_FLAT);
		}
		Screen->SetRenderTarget(RT_SCREEN);
		vars[16] = numShards;
	}
	void GlassWipe_DrawCracks(int layer, int vars){
		int i; int j; int k;
		int p1; int p2;
		
		int CPX = vars[0];
		int CPY = vars[1];
		int CPZ = vars[2];
		int AngA = vars[3];
		int AngB = vars[4];
		int AngC = vars[5];
		int DA = vars[6];
		int DB = vars[7];
		int DC = vars[8];
		int BaseAngA = vars[9];
		int BaseAngB = vars[10];
		int RotA = vars[11];
		int RotB = vars[12];
		int VX = vars[13];
		int VY = vars[14];
		int shardState = vars[15];
		int crackW = vars[17];
		
		int X[3];
		int Y[3];
		int Z[3];
		
		int qX[4];
		int qY[4];
		for(i=0; i<56; i++){
			int freshprinceofdickbutt = 90;
			//you tread upon the hall of the forbidden Mathemancy. Nobody knows how it works. Well someone might. But it isn't Moosh.
			int x0; int y0; int z0; int xtmp;
			x0 = DA[i]*Sin(freshprinceofdickbutt)*Cos(AngA[i]);
			y0 = DA[i]*Sin(freshprinceofdickbutt)*Sin(AngA[i]);
			z0 = DA[i]*Cos(freshprinceofdickbutt);
			X[0] = x0;
			Y[0] = y0*Cos(BaseAngA[i])-z0*Sin(BaseAngA[i]);
			Z[0] = y0*Sin(BaseAngA[i])+z0*Cos(BaseAngA[i]);
			xtmp = X[0];
			X[0] = X[0]*Cos(BaseAngB[i])+Z[0]*Sin(BaseAngB[i]);
			Z[0] = -xtmp*Sin(BaseAngB[i])+Z[0]*Cos(BaseAngB[i]);
			
			x0 = DB[i]*Sin(freshprinceofdickbutt)*Cos(AngB[i]);
			y0 = DB[i]*Sin(freshprinceofdickbutt)*Sin(AngB[i]);
			z0 = DB[i]*Cos(freshprinceofdickbutt);
			X[1] = x0;
			Y[1] = y0*Cos(BaseAngA[i])-z0*Sin(BaseAngA[i]);
			Z[1] = y0*Sin(BaseAngA[i])+z0*Cos(BaseAngA[i]);
			xtmp = X[1];
			X[1] = X[1]*Cos(BaseAngB[i])+Z[1]*Sin(BaseAngB[i]);
			Z[1] = -xtmp*Sin(BaseAngB[i])+Z[1]*Cos(BaseAngB[i]);
			
			x0 = DC[i]*Sin(freshprinceofdickbutt)*Cos(AngC[i]);
			y0 = DC[i]*Sin(freshprinceofdickbutt)*Sin(AngC[i]);
			z0 = DC[i]*Cos(freshprinceofdickbutt);
			X[2] = x0;
			Y[2] = y0*Cos(BaseAngA[i])-z0*Sin(BaseAngA[i]);
			Z[2] = y0*Sin(BaseAngA[i])+z0*Cos(BaseAngA[i]);
			xtmp = X[2];
			X[2] = X[2]*Cos(BaseAngB[i])+Z[2]*Sin(BaseAngB[i]);
			Z[2] = -xtmp*Sin(BaseAngB[i])+Z[2]*Cos(BaseAngB[i]);
			
			for(j=0; j<3; j++){
				p1 = j-1;
				if(p1<0)
					p1 = 2;
				p2 = j;
				k = Angle(X[p1], Y[p1], X[p2], Y[p2]);
				
				qX[0] = CPX[i]+X[p1]; //+VectorX(-crackW[i*2+0]/2, k+90);
				qY[0] = CPY[i]+Y[p1]; //+VectorY(-crackW[i*2+0]/2, k+90);
				
				qX[1] = CPX[i]+(X[p1]+X[p2])/2+VectorX(-crackW[i]/2, k+90);
				qY[1] = CPY[i]+(Y[p1]+Y[p2])/2+VectorY(-crackW[i]/2, k+90);
				
				qX[2] = CPX[i]+X[p2]; //+VectorX(-crackW[i*2+1]/2, k+90);
				qY[2] = CPY[i]+Y[p2]; //+VectorY(-crackW[i*2+1]/2, k+90);
				
				qX[3] = CPX[i]+(X[p1]+X[p2])/2+VectorX(crackW[i]/2, k+90);
				qY[3] = CPY[i]+(Y[p1]+Y[p2])/2+VectorY(crackW[i]/2, k+90);
				
				Screen->Quad(6, qX[0], qY[0], qX[1], qY[1], qX[2], qY[2], qX[3], qY[3], 1, 1, 0x01, 0, -1, PT_FLAT);
			}
		}
	}
}

const int I_SETTING_DAMAGENUMBERS = 173;
const int I_SETTING_BOSSSHORTCUTS = 174;
const int I_SETTING_TRUEKEYS = 175;
const int I_SETTING_3HEARTCONTINUE = 176;
const int I_SETTING_NOJOKE = 177;
const int I_SETTING_VISION = 191;
const int I_SETTING_NOITEMTEXT = 231;

int Q7_WrapInt(int i, int min, int max){
	int scale = max-min+1;
	while(i<min)
		i += scale;
	while(i>max)
		i -= scale;
	return i;
}

ffc script Q7_ExtraSettings{
	void run(){
		int i;
		
		int lineStart[256];
		int lineEnd[256];
		int lineStartColor[256];
		int strDat[6] = {lineStart, lineEnd, lineStartColor, 0, 12, 1};
		
		int sDamageNumbers[] = "DAMAGE NUMBERS";
		int sBossShortcuts[] = "BOSS SHORTCUTS";
		int s3Heart[] = "CONTINUE HP";
		int sTrueKeys[] = "TRUE KEYS";
		int sVision[] = "VISION ADJUSTMENTS";
		int sMemes[] = "DISABLE GOOFS";
		int sItemStrings[] = "ITEM MESSAGES";
		
		int confirm[] = "CONFIRM";
		int settingList[] = {sDamageNumbers, sBossShortcuts, sTrueKeys, s3Heart, sItemStrings, sVision, sMemes, confirm};
		int settingActive[] = {0, 0, 0, 4, 1, 0, 2, 0};
		if(G[G_MODE_BLEEDINGWALLET]){
			settingActive[3] = 5;
		}
		
		int d_DamageNumbers[] = "SHOW HOW MUCH DAMAGE ENEMIES AND LINK TAKE WHEN GETTING HIT";
		int d_BossShortcuts[] = "ADD BOSS SHORTCUT PORTALS IN DUNGEONS";
		int d_TrueKeys[] = "DUNGEON KEYS CAN ONLY BE USED IN THEIR OWN DUNGEONS";
		int d_3Heart[] = "DETERMINES HOW MUCH HP YOU CONTINUE WITH";
		int d_Vision[] = "ADJUSTMENTS FOR COLORBLINDNESS AND OTHER PERCEPTUAL DIFFICULTIES";
		int d_Memes[] = "CERTAIN JOKE CONTENT WILL BE ALTERED";
		int d_ItemStrings[] = "ITEMS DISPLAY PICKUP MESSAGES";
		int d_setting[] = {d_DamageNumbers, d_BossShortcuts, d_TrueKeys, d_3Heart, d_ItemStrings, d_Vision, d_Memes, 0};
	
		int sel = 0;
		
		for(i=0; i<30; i++){
			if(i<10)
				Screen->Rectangle(6, 0, 0, 255, 175, 0x0F, 1, 0, 0, 0, true, 128);
			if(i<20)
				Screen->Rectangle(6, 0, 0, 255, 175, 0x0F, 1, 0, 0, 0, true, 64);
			Screen->Rectangle(6, 0, 0, 255, 175, 0x0F, 1, 0, 0, 0, true, 64);
			WaitNoAction();
		}
		
		while(true){
			
			if((Link->PressA||Link->PressStart)&&sel==7){
				Game->PlaySound(SFX_CONFIRM);
				
				for(i=0; i<30; i++){
					if(i%4<2){
						Q7_Settings_DrawOptions(sel, settingList, d_setting, settingActive, strDat, true);
					}
					else{
						Q7_Settings_DrawOptions(sel, settingList, d_setting, settingActive, strDat, false);
					}
					
					WaitNoAction();
				}
				for(i=0; i<30; i++){
					if(i%4<2){
						Q7_Settings_DrawOptions(sel, settingList, d_setting, settingActive, strDat, true);
					}
					else{
						Q7_Settings_DrawOptions(sel, settingList, d_setting, settingActive, strDat, false);
					}
					
					if(i>=10)
						Screen->Rectangle(6, 0, 0, 255, 175, 0x0F, 1, 0, 0, 0, true, 64);
					if(i>=20)
						Screen->Rectangle(6, 0, 0, 255, 175, 0x0F, 1, 0, 0, 0, true, 128);
					Screen->Rectangle(6, 0, 0, 255, 175, 0x0F, 1, 0, 0, 0, true, 64);
				
					WaitNoAction();
				}
				
				Link->Item[I_SETTING_DAMAGENUMBERS] = false;
				Link->Item[I_SETTING_BOSSSHORTCUTS] = false;
				Link->Item[I_SETTING_TRUEKEYS] = false;
				Link->Item[I_SETTING_3HEARTCONTINUE] = false;
				Link->Item[I_SETTING_NOITEMTEXT] = false;
				Link->Item[I_SETTING_VISION] = false;
				Link->Item[I_SETTING_NOJOKE] = false;
				if(settingActive[0])
					Link->Item[I_SETTING_DAMAGENUMBERS] = true;
				if(settingActive[1])
					Link->Item[I_SETTING_BOSSSHORTCUTS] = true;
				if(settingActive[2])
					Link->Item[I_SETTING_TRUEKEYS] = true;
				if(settingActive[3]!=4){
					Link->Item[I_SETTING_3HEARTCONTINUE] = true;
					G[G_CONTINUEHP] = settingActive[3];
				}
				if(!settingActive[4])
					Link->Item[I_SETTING_NOITEMTEXT] = true;
				if(settingActive[5])
					Link->Item[I_SETTING_VISION] = true;
				if(settingActive[6]){
					G[G_PARTIALJOKE] = 0;
					if(settingActive[6]==1)
						G[G_PARTIALJOKE] = 1;
					else
						Link->Item[I_SETTING_NOJOKE] = true;
				}
				
				if(G[G_MODE_RANDOMIZER]){
					int randMenuScript[] = "Q7_RandomizerMenu";
					int randMenuSlot = Game->GetFFCScript(randMenuScript);
					ffc f = Screen->LoadFFC(RunFFCScript(randMenuSlot, 0));
					while(f->Script==randMenuSlot){
						Waitframe();
					}
				}
				if(G[G_MODE_ALTCHARACTER]){
					// int charMenuScript[] = "Q7_CharacterSelectMenu";
					// int charMenuSlot = Game->GetFFCScript(charMenuScript);
					// ffc f = Screen->LoadFFC(RunFFCScript(charMenuSlot, 0));
					Screen->SetSideWarp(0, 0x04, Game->GetCurDMap(), WT_IAWARP);
					this->Data = CMB_AUTOWARPA;
					G[G_SPECIALWARP] = 1;

					while(true){
						Screen->Rectangle(6, 0, 0, 255, 175, 0x0F, 1, 0, 0, 0, true, 128);
						
						WaitNoAction();
					}
				}
				
				Q7_StartGame(this);
			}
			
			if(Link->PressUp){
				sel--;
				if(sel<0)
					sel = 7;
				Game->PlaySound(SFX_SELECT);
			}
			else if(Link->PressDown){
				sel++;
				if(sel>7)
					sel = 0;
				Game->PlaySound(SFX_SELECT);
			}
			else if(Link->PressLeft||Link->PressRight){
				if(sel<7){
					if(sel==3){
						if(Link->PressLeft)
							--settingActive[sel];
						else if(Link->PressRight)
							++settingActive[sel];
						settingActive[sel] = Q7_WrapInt(settingActive[sel], 0, 5);
					}
					else if(sel==6){
						if(Link->PressLeft)
							--settingActive[sel];
						else if(Link->PressRight)
							++settingActive[sel];
						settingActive[sel] = Q7_WrapInt(settingActive[sel], 0, 2);
					}
					else{
						settingActive[sel] = Cond(settingActive[sel], 0, 1);
					}
					Game->PlaySound(SFX_SELECT);
				}
			}
			
			Q7_Settings_DrawOptions(sel, settingList, d_setting, settingActive, strDat, true);
					
			WaitNoAction();
		}
	}
	void Q7_Settings_DrawOptions(int sel, int settingList, int d_setting, int settingActive, int strDat, bool drawSelection){
		int on[] = "ON";
		int off[] = "OFF";
		int one[] = "ONE";
		int three[] = "THREE";
		int half[] = "50%";
		int seventyfive[] = "75%";
		int full[] = "FULL";
		int permadeath[] = "PERMADEATH";
		int partial[] = "PARTIAL";
		int warning[] = "IF YOU DIE IN THE GAME, YOU DIE FOR REAL";
		int midgoofs[] = "ONLY REMOVES THE TWO MOST IMMERSION BREAKING JOKES";
		int allgoofs[] = "ALL JOKE CONTENT LEFT UNCHANGED";
		
		int settings[] = "SETTINGS:";
		
		Q7_DrawStringOutline(6, 16, 8, FONT_Z1, 0x01, 0x0F, TF_NORMAL, settings, 128);
	
		int c;
		int set;
		int setDesc = d_setting[sel];
		int scroll = Clamp(sel-3, 0, 1);
		
		for(int j=0; j<6; j++){
			int i = scroll+j;
			c = 0x02;
			if(sel==i&&drawSelection)
				c = 0x01;
			if(i<7){
				Q7_DrawStringOutline(6, 8, 24+12*j, FONT_Z1, c, 0x0F, TF_NORMAL, settingList[i], 128);
			
				if(i==3){
					if(settingActive[i]==0)
						set = one;
					else if(settingActive[i]==1)
						set = three;
					else if(settingActive[i]==2)
						set = half;
					else if(settingActive[i]==3)
						set = seventyfive;
					else if(settingActive[i]==4)
						set = full;
					else if(settingActive[i]==5){
						set = permadeath;
						if(sel==3&&drawSelection){
							if(G[G_ANIM]%4<2)
								c = 0x81;
							else
								c = 0x82;
							setDesc = warning;
						}
					}
				}
				else if(i==6){
					if(settingActive[i]==0){
						set = off;
						if(sel==6&&drawSelection)
							setDesc = allgoofs;
					}
					else if(settingActive[i]==1){
						set = partial;
						if(sel==6&&drawSelection)
							setDesc = midgoofs;
					}
					else if(settingActive[i]==2)
						set = on;
				}
				else{
					if(settingActive[i])
						set = on;
					else
						set = off;
				}
				Q7_DrawStringOutline(6, 248, 24+12*j, FONT_Z1, c, 0x0F, TF_RIGHT, set, 128);
					
			}
		}
		c = 0x02;
		if(sel==7&&drawSelection)
			c = 0x01;
		Q7_DrawStringOutline(6, 8, 112, FONT_Z1, c, 0x0F, TF_NORMAL, settingList[7], 128);
		
		if(setDesc>0){
			Q7_DrawStringSP_Prep(strDat, 224, setDesc);
			Q7_DrawStringSP(strDat, 6, 128, 128, 224, TF_CENTERED, setDesc);
		}
	}
}

void Q7_StartGame(ffc this){
	G[G_DISABLE_SPECIALMODES] = 0;
	if(Q7_CheatEnabled(G_MODE_BLEEDINGWALLET)){
		Game->Counter[CR_RUPEES] = 100;
		G[G_LASTRUPEECOUNT] = 100;
	}
	int scramblePages[] = {0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 25, 26, 27, 28, 29, 30, 31, 40, 41, 42, 43, 44, 100, 101, 102, 103, 104, 105, 106, 200};
	Game->SetComboData(1, 0x0F, 87, 9);
	G[G_ALLOWCOPYTILEINIT] = 1;
	Main2_Init(scramblePages);
	
	if(G[G_MODE_BSIDES]){
		Screen->SetSideWarp(0, Screen->GetSideWarpScreen(0), 200, Screen->GetSideWarpType(0));
	}
	this->Data = CMB_AUTOWARPA;
	G[G_SPECIALWARP] = 1;

	while(true){
		Screen->Rectangle(6, 0, 0, 255, 175, 0x0F, 1, 0, 0, 0, true, 128);
		
		NoPause();
		WaitNoAction();
	}
}

const int CMB_BOSSSHORTCUT = 673;
const int SFX_BOSSWARP = 86;

int GetWarpReplacement(int dmap){
	if(IsRaining()){
		if(dmap==7){
			dmap = 37;
		}
	}
	return dmap;
}

int Q7_FindSafeSpawn(bool cmbTaken){
	int pos;
	for(int i=0; i<352; ++i){
		if(i<176)
			pos = Rand(176);
		else
			pos = i-176;
		if(Abs(Link->X-ComboX(pos))>48||Abs(Link->Y-ComboY(pos))>48){
			if(!cmbTaken[pos]){
				if(Screen->ComboS[pos]==0){
					cmbTaken[pos] = true;
					return pos;
				}
			}
		}
	}
	return 0;
}

ffc script BossShortcut{
	void run(int destDMap, int destScreen, int sp, int warp){
		if(warp==0)
			warp = 3;
		
		destDMap = GetWarpReplacement(destDMap);
		
		int i;
		
		bool triggered;
		
		if(destDMap==-1){
			if(sp==1){
				int cd = Screen->ComboD[ComboAt(this->X+8, this->Y+8)];
				while(cd==Screen->ComboD[ComboAt(this->X+8, this->Y+8)]){
					Waitframe();
				}
				G[G_DIMENTIOSHORTCUT] = 1;
				Quit();
			}
			else{
				Screen->State[ST_BOSSLOCKBLOCK] = true;
				Quit();
			}
		}
		if(Link->Item[I_SETTING_BOSSSHORTCUTS]){
			int data = this->Data;
			while(true){
				if(sp==1&&G[G_DIMENTIOSHORTCUT]){
					triggered = true;
				}
				if(Screen->State[ST_BOSSLOCKBLOCK]||triggered){
					while(Link->X!=this->X||Link->Y!=this->Y){
						Screen->FastCombo(2, this->X, this->Y, data, this->CSet, 128);
						Screen->FastCombo(4, this->X, this->Y, data+1, this->CSet, 128);
						if(Abs(Link->X-this->X)<8&&Abs(Link->Y-this->Y)<8){
							if(Abs(Link->X-this->X)>0)
								Link->X += Sign(this->X-Link->X);
							if(Abs(Link->Y-this->Y)>0)
								Link->Y += Sign(this->Y-Link->Y);
						}
						Waitframe();
					}
					int yOff = Link->DrawYOffset;
					Game->PlaySound(SFX_BOSSWARP);
					for(i=0; i<64; i++){
						Screen->FastCombo(2, this->X, this->Y, data, this->CSet, 128);
						Screen->FastCombo(4, this->X, this->Y, data+1, this->CSet, 128);
						
						if(i%4==0){
							Link->Dir = RotDirCW4(Link->Dir);
						}
						
						WaitNoAction();
					}
					for(i=0; i<64; i++){
						Screen->FastCombo(2, this->X, this->Y, data, this->CSet, 128);
						Screen->FastCombo(4, this->X, this->Y, data+1, this->CSet, 128);
						
						if(i%4==0){
							Link->Dir = RotDirCW4(Link->Dir);
						}
						
						Link->DrawYOffset -= 4;
						
						WaitNoAction();
					}
					Screen->SetSideWarp(warp, destScreen, destDMap, WT_IWARPZAP);
					this->Data = CMB_AUTOWARPA+warp;
					G[G_SPECIALWARP] = 1;
					Link->DrawYOffset = yOff;
					Quit();
				}
				Waitframe();
			}
		}
	}
}

ffc script DungeonEntrance{
	void run(){
		npc wallmasterArray[10];
		bool wallmasterArrayDead[10];
		if(G[G_ALTCHARACTER]==CHAR_DIMI){
			bool cmbTaken[176];
			for(int i=0; i<10; ++i){
				if(G[G_WALLMASTERSTORAGE1+i]>0){
					int pos = Q7_FindSafeSpawn(cmbTaken);
					wallmasterArray[i] = CreateNPCAt(G[G_WALLMASTERSTORAGE1+i], ComboX(pos), ComboY(pos));
				}
			}
		}
		while(true){
			UpdateWallmasterStorage(wallmasterArray, wallmasterArrayDead);
			Waitframe();
		}
	}
	void UpdateWallmasterStorage(npc wallmasterArray, bool wallmasterArrayDead){
		if(G[G_ALTCHARACTER]!=CHAR_DIMI)
			return;
		for(int i=0; i<10; ++i){
			if(wallmasterArray[i]->isValid()){
				if(wallmasterArray[i]->HP<=0&&!wallmasterArrayDead[i]){
					for(int j=0; j<10; ++j){
						if(G[G_WALLMASTERSTORAGE1+j]==wallmasterArray[i]->ID){
							G[G_WALLMASTERSTORAGE1+j] = 0;
							break;
						}
					}
					wallmasterArrayDead[i] = true;
				}
			}
		}
	}
}

ffc script NightmareSpawn{
	void run(){
		if(!GetLevelItem(LI_BOSS)){
			npc n;
			if(!AllowAllJokes()){
				n = CreateNPCAt(314, 120, 80);
			}
			else{
				n = CreateNPCAt(290, 120, 80);
			}
			while(n->isValid()){
				Waitframe();
			}
			SetLevelItem(LI_BOSS, true);
		}
	}
}

int Q7_GlideX(int x1, int y1, int x2, int y2, int frames, int i){
	int dist = Distance(x1, y1, x2, y2);
	int ang = Angle(x1, y1, x2, y2);
	return x1+VectorX(dist*(i/frames), ang);
}

int Q7_GlideY(int x1, int y1, int x2, int y2, int frames, int i){
	int dist = Distance(x1, y1, x2, y2);
	int ang = Angle(x1, y1, x2, y2);
	return y1+VectorY(dist*(i/frames), ang);
}

const int CMB_ADJEAN_FLOORS = 2868;
const int CMB_ADJEAN_LIGHTNING = 2876;
const int CMB_ADJEAN_PORTAL = 2852;
const int CMB_ADJEAN_FIREBALL = 2855;

const int CS_ADJEAN_PORTAL = 10;

const int DAMAGE_ADJEAN_LIGHTNING = 8;
const int DAMAGE_ADJEAN_WRECKER = 8;

const int SPR_ADJEAN_FIREBALL = 114;
const int SPR_ADJEAN_WRECKER = 115;
const int SPR_ADJEAN_TURRET = 116;

const int SFX_ADJEAN_CHARGE = 87;
const int SFX_ADJEAN_FIRE = 88;
const int SFX_ADJEAN_DASH = 89;
const int SFX_ADJEAN_TELEPORT = 93;

const int EW_ADJEAN_FIREBALL = 40;
const int EW_ADJEAN_WRECKER = 39;

const int EWM_ADJEAN_FIREBALL_REFLECTED = 0;

const int RT_ADJEAN_FLOORCHECKER = 1;

ffc script Adjean{
	void run(int enemyid){
		int i; int j; int k; int m;
		int dist; int angle;
		int x; int y;
		int x2; int y2;
		int sfxTimer;
		
		npc ghost = Ghost_InitAutoGhost(this, enemyid);
		NJFMode_IncreaseBossHP(ghost);
		
		Ghost_SetFlag(GHF_4WAY);
		Ghost_SetFlag(GHF_FLYING_ENEMY);
		Ghost_SetFlag(GHF_IGNORE_SOLIDITY);
		
		Ghost_Transform(this, ghost, -1, -1, 2, 2);
		Ghost_SetHitOffsets(ghost, 0, 0, 8, 8);
		
		int combo = ghost->Attributes[10];
		
		int attack;
		
		int floorST[176];
		int floorT[176];
		int PortalX[3];
		int PortalY[3];
		int PortalST[3];
		int PortalT[3];
		int vars[16] = {floorST, floorT, 0, 0, 0, 0, 0, Ghost_HP, PortalX, PortalY, PortalST, PortalT, 0};
		//vars[2] - Firing pos X
		//vars[3] - Firing pos Y
		//vars[4] - Reflect fireballs?
		//vars[5] - Skip attack?
		//vars[6] - Num Floors Broken
		//vars[7] - Current HP
		//vars[8] - PortalX
		//vars[9] - PortalY
		//vars[10] - PortalST
		//vars[11] - PortalT
		//vars[12] - Num Broken Floors
		
		Ghost_X = 112;
		Ghost_Y = 48;
		ghost->DrawYOffset = -1000;
		ghost->CollDetection = false;
		this->Data = GH_INVISIBLE_COMBO;
		
		int diffMod[4];
		
		while(Link->Y>=128){
			Waitframe();
		}
		Game->PlayMIDI(0);
		sfxTimer = 0;
		for(i=-96; i<48; i+=4){
			++sfxTimer;
			if(!(sfxTimer%20))
				Game->PlaySound(SFX_ADJEAN_DASH);
			if(!(sfxTimer%4))
				ShadowTrail(112, i, 2, 2, 2837, 10, 20);
			
			Screen->DrawCombo(2, 112, i, 2837, 2, 2, 10, -1, -1, 0, 0, 0, 0, 0, true, 128);
			
			Q7_WaitNoAction();
		}
		
		for(i=0; i<48; i++){
			
			if(i==32){
				if(!Screen->D[6]){
					if(NumTriforcePieces()>=8){
						Screen->Message(188);
					}
					else{
						Screen->Message(184);
					}
				}
			}
			
			Screen->DrawCombo(2, 112, 48, 2837, 2, 2, 10, -1, -1, 0, 0, 0, 0, 0, true, 128);
			
			Q7_WaitNoAction();
		}
		
		vars[7] = ghost->HP;
		Ghost_HP = ghost->HP;
		
		ghost->DrawYOffset = -2;
		ghost->CollDetection = true;
		
		Screen->D[6] = 1;
		
		Ghost_Dir = DIR_DOWN;
		
		int bossMusic[] = "RubyIllusions.nsf";
		Game->PlayEnhancedMusic(bossMusic, 6);
		
		eweapon e;
		while(true){
			attack = Rand(0,2);
			if(vars[12]>24)
				attack = 3;
			
			A_TryBlockFireball(this, ghost, vars);
			if(attack==0){ //Fireball -> Dash
				Ghost_Dir = AngleDir4(Angle(Ghost_X+8, Ghost_Y+8, Link->X, Link->Y));
				A_ChargeAnim(this, ghost, vars, combo+12, 8, 90);
				e = FireAimedEWeapon(EW_SCRIPT10, vars[2], vars[3], 0, 250, ghost->WeaponDamage, SPR_ADJEAN_FIREBALL, SFX_ADJEAN_FIRE, EWF_UNBLOCKABLE);
				A_SetWeaponData(e, 0, 3, 0);
				
				x = Clamp(Link->X-8, 32, 192);
				y = Clamp(Link->Y-8, 32, 112);
				
				angle = Angle(Ghost_X, Ghost_Y, x, y);
				Ghost_Dir = AngleDir4(angle);
				
				sfxTimer = 0;
				diffMod[0] = LazyDiffMod(1.2, 1.5, 2);
				while(!vars[5]&&Distance(Ghost_X, Ghost_Y, x, y)>diffMod[0]){
					angle = Angle(Ghost_X, Ghost_Y, x, y);
					Ghost_MoveAtAngle(angle, diffMod[0], 0);
					++sfxTimer;
					if(!(sfxTimer%20))
						Game->PlaySound(SFX_ADJEAN_DASH);
					if(!(sfxTimer%4))
						Ghost_ShadowTrail(this, ghost, true, 20);
					A_TryBlockFireball(this, ghost, vars);
					A_Waitframe(this, ghost, vars);
				}
				
				if(!vars[5]){
					x2 = x;
					y2 = y;
					x = Clamp(Link->X-8, 32, 192);
					y = Clamp(Link->Y-8, 32, 112);
					
					A_Waitframe(this, ghost, vars, 32);
					
					angle = Angle(Ghost_X, Ghost_Y, x, y);
					Ghost_Dir = AngleDir4(angle);
				}
				
				sfxTimer = 0;
				while(!vars[5]&&Distance(Ghost_X, Ghost_Y, x, y)>diffMod[0]){
					angle = Angle(Ghost_X, Ghost_Y, x, y);
					Ghost_MoveAtAngle(angle, diffMod[0], 0);
					++sfxTimer;
					if(!(sfxTimer%20))
						Game->PlaySound(SFX_ADJEAN_DASH);
					if(!(sfxTimer%4))
						Ghost_ShadowTrail(this, ghost, true, 20);
					A_TryBlockFireball(this, ghost, vars);
					A_Waitframe(this, ghost, vars);
				}
				
				if(!vars[5]){
					x2 += VectorX(2, Angle(128, 88, x2, y2));
					y2 += VectorY(2, Angle(128, 88, x2, y2));
					// Screen->ComboF[ComboAt(x2+16, y2+16)] = 98;
				}
				
				A_Waitframe(this, ghost, vars, 64);
				A_CreatePortal(vars);
			}
			if(attack==1){ //Fireball -> Fire Stream
				diffMod[0] = LazyDiffMod(1.2, 1.5, 2);
				for(i = 0; i<2; i++){
					do{
						x = Rand(32, 192);
						y = Rand(32, 112);
					}
					while(Distance(Link->X, Link->Y, x, y) < 64);
					Ghost_Dir = AngleDir4(Angle(Ghost_X+8, Ghost_Y+8, x, y));
					while(Distance(Ghost_X, Ghost_Y, x, y)>diffMod[0]){
						angle = Angle(Ghost_X, Ghost_Y, x, y);
						Ghost_MoveAtAngle(angle, diffMod[0], 0);
						++sfxTimer;
						if(!(sfxTimer%20))
							Game->PlaySound(SFX_ADJEAN_DASH);
						if(!(sfxTimer%4))
							Ghost_ShadowTrail(this, ghost, true, 20);
						A_Waitframe(this, ghost, vars);
					}
					A_Waitframe(this, ghost, vars, 60);
					Ghost_Data += 4;
					Ghost_Dir = AngleDir4(Angle(Ghost_X+8, Ghost_Y+8, Link->X, Link->Y));
					for(j = -60; j<=60; j+=30){
						Ghost_Dir = AngleDir4(Angle(Ghost_X+8, Ghost_Y+8, Link->X, Link->Y));
						e = FireAimedEWeapon(EW_SCRIPT1, Ghost_X+8, Ghost_Y, DegtoRad(j), LazyDiffMod(200, 250, 300), ghost->WeaponDamage, 111, 40, EWF_UNBLOCKABLE);
						A_Waitframe(this, ghost, vars, 5);
					}
					Ghost_Data -= 4;
					A_Waitframe(this, ghost, vars, 30);
					if(i == 0)
						e = FireEWeapon(EW_SCRIPT3, Ghost_X+8, Ghost_Y+8, DegtoRad(j), 0, ghost->WeaponDamage, SPR_ADJEAN_TURRET, 21, EWF_UNBLOCKABLE);
					else
						e = FireEWeapon(EW_SCRIPT4, Ghost_X+8, Ghost_Y+8, DegtoRad(j), 0, ghost->WeaponDamage, SPR_ADJEAN_TURRET, 21, EWF_UNBLOCKABLE);
					e->CollDetection = false;
				}
				for(i=0; i<16; i++){
					Ghost_Dir = AngleDir4(Angle(Ghost_X+8, Ghost_Y+8, Link->X, Link->Y));
					
					if(i%4<2)
						Ghost_Data = combo;
					else
						Ghost_Data = combo+8;
					
					A_Waitframe(this, ghost, vars);
				}
				Ghost_Data = combo+8;
				
				ghost->CollDetection = false;
				diffMod[0] = LazyDiffMod(0.8, 1, 1.2);
				for(i=0; i<180; i++){
					Ghost_MoveAtAngle(Angle(Ghost_X+8, Ghost_Y+8, Link->X, Link->Y), diffMod[0], 0);
					
					if(i%20==0)
						Game->PlaySound(SFX_ADJEAN_DASH);
					if(i%60 == 0 || (i+30)%60 == 0){
						for(j = Screen->NumEWeapons(); j>0; j--){
							e = Screen->LoadEWeapon(j);
							if((e->ID == EW_SCRIPT3 && i%60 == 0) || (e->ID == EW_SCRIPT4 && (i+30)%60 == 0))
								FireAimedEWeapon(EW_SCRIPT1, e->X, e->Y, 0, 250, ghost->WeaponDamage, 17, 40, 0);
						}
					}
					A_Waitframe(this, ghost, vars);
				}
				ghost->CollDetection = true;
				
				for(i=0; i<16; i++){
					Ghost_Dir = AngleDir4(Angle(Ghost_X+8, Ghost_Y+8, Link->X, Link->Y));
					
					if(i%4<2)
						Ghost_Data = combo;
					else
						Ghost_Data = combo+8;
					
					A_Waitframe(this, ghost, vars);
				}
				Ghost_Data = combo;
				for(j = Screen->NumEWeapons(); j>0; j--){
					e = Screen->LoadEWeapon(j);
					if(e->ID == EW_SCRIPT3 || e->ID == EW_SCRIPT4)
						Remove(e);
				}
				A_CreatePortal(vars);
			}
			else if(attack==2){ //Curving shots
				for(i = 0; i<2; i++){
					x = Clamp(Link->X-8, 32, 192);
					y = Clamp(Link->Y-8, 32, 112);
					
					angle = Angle(Ghost_X, Ghost_Y, x, y);
					Ghost_Dir = AngleDir4(angle);
					
					sfxTimer = 0;
					diffMod[0] = LazyDiffMod(1.2, 1.5, 2);
					while(!vars[5]&&Distance(Ghost_X, Ghost_Y, x, y)>diffMod[0]){
						angle = Angle(Ghost_X, Ghost_Y, x, y);
						Ghost_MoveAtAngle(angle, diffMod[0], 0);
						++sfxTimer;
						if(!(sfxTimer%20))
							Game->PlaySound(SFX_ADJEAN_DASH);
						if(!(sfxTimer%4))
							Ghost_ShadowTrail(this, ghost, true, 20);
						A_TryBlockFireball(this, ghost, vars);
						A_Waitframe(this, ghost, vars);
					}
					A_Waitframe(this, ghost, vars, 64);
					A_ChargeAnim(this, ghost, vars, CMB_ADJEAN_FIREBALL, 8, 60);
					for(j = -45; j<=45; j+=45){
						eweapon e = FireAimedEWeapon(EW_SCRIPT1, vars[2], vars[3], DegtoRad(j), 200, ghost->WeaponDamage, 111, 40, EWF_UNBLOCKABLE);
						SetEWeaponMovement(e, EWM_HOMING_REAIM, 1, 60); 
					}
					A_Waitframe(this, ghost, vars, 64);
				}
				A_Waitframe(this, ghost, vars, 64);
				A_CreatePortal(vars);
			}
			else if(attack==3){ //Floor Repair
				A_Waitframe(this, ghost, vars, 48);
				
				m = Rand(2);
				
				Ghost_Dir = DIR_DOWN;
				Ghost_Data = combo+4;
				
				Screen->SetRenderTarget(RT_ADJEAN_FLOORCHECKER);
				Screen->Rectangle(0, 0, 0, 255, 175, 0x00, 1, 0, 0, 0, true, 128);
				Screen->SetRenderTarget(RT_SCREEN);
				
				A_Waitframe(this, ghost, vars, 32);
				
				Ghost_Data = combo+8;
				ghost->CollDetection = false;
				sfxTimer = 0;
				diffMod[0] = LazyDiffMod(4, 6, 8);
				for(j=0; j<256; j+=diffMod[0]){
					Screen->SetRenderTarget(RT_ADJEAN_FLOORCHECKER);
					Screen->Rectangle(0, 0, 0, 255, 175, 0x00, 1, 0, 0, 0, true, 128);
					++sfxTimer;
					if(sfxTimer%4<2){
						for(i=0; i<176; i++){
							if(i>32&&i<144&&i%16>1&&i%16<14){
								if((i+Floor(i/16))%2==m){
									x = ComboX(i);
									y = ComboY(i);
									Screen->Rectangle(0, x, y, x+15, y+15, 0x81, 1, 0, 0, 0, true, 128);
								}
							}
						}
					}
					Screen->Rectangle(0, -8, 0, Ghost_X+16-j, 175, 0x00, 1, 0, 0, 0, true, 128);
					Screen->Rectangle(0, Ghost_X+16+j, 0, 264, 175, 0x00, 1, 0, 0, 0, true, 128);
					Screen->SetRenderTarget(RT_SCREEN);
					
					Screen->DrawBitmap(2, RT_ADJEAN_FLOORCHECKER, 0, 0, 256, 176, 0, 0, 256, 176, 0, true);
					
					A_Waitframe(this, ghost, vars);
				}
				for(j=0; j<256; j+=diffMod[0]){
					Screen->SetRenderTarget(RT_ADJEAN_FLOORCHECKER);
					Screen->Rectangle(0, 0, 0, 255, 175, 0x00, 1, 0, 0, 0, true, 128);
					++sfxTimer;
					if(sfxTimer%4<2){
						for(i=0; i<176; i++){
							if(i>32&&i<144&&i%16>1&&i%16<14){
								if((i+(Floor(i/16)%2))%2==m){
									x = ComboX(i);
									y = ComboY(i);
									Screen->Rectangle(0, x, y, x+15, y+15, 0x81, 1, 0, 0, 0, true, 128);
								}
							}
						}
					}
					Screen->Rectangle(0, Ghost_X+16-j, 0, Ghost_X+16+j, 175, 0x00, 1, 0, 0, 0, true, 128);
					Screen->SetRenderTarget(RT_SCREEN);
					
					Screen->DrawBitmap(2, RT_ADJEAN_FLOORCHECKER, 0, 0, 256, 176, 0, 0, 256, 176, 0, true);
					
					A_Waitframe(this, ghost, vars);
				}
			
				diffMod[0] = LazyDiffMod(8, 6, 4);
				for(j=2; j<14+8; j++){
					for(i=2; i<9; i++){
						x = j-i;
						y = i;
						if(x>1&&x<14&&y>1&&y<9){
							k = y*16+x;
							if((k+Floor(k/16))%2==m){
								Game->PlaySound(SFX_LIGHTNING_STRIKE);
								floorST[k] = 6;
								floorT[k] = 0;
							}
						}
					}
					A_Waitframe(this, ghost, vars, diffMod[0]);
				}
				
				A_Waitframe(this, ghost, vars, LazyDiffMod(64, 32, 8));
				
				m = Cond(!m, 1, 0);
				
				for(j=2; j<14+8; j++){
					for(i=2; i<9; i++){
						x = j-i;
						y = i;
						if(x>1&&x<14&&y>1&&y<9){
							k = y*16+x;
							if((k+Floor(k/16))%2==m){
								Game->PlaySound(SFX_LIGHTNING_STRIKE);
								floorST[k] = 6;
								floorT[k] = 0;
							}
						}
					}
					A_Waitframe(this, ghost, vars, diffMod[0]);
				}
				Ghost_Data = combo;
				ghost->CollDetection = true;
			}
			
			
			vars[5] = 0;
			if(PortalX[2] != 0){ //Portal dash attack
				A_Waitframe(this, ghost, vars, 64);
				Ghost_Dir = AngleDir4(Angle(Ghost_X+8, Ghost_Y+8, PortalX[0], PortalY[0]));
				while(Distance(Ghost_X, Ghost_Y, PortalX[0], PortalY[0])>1.5){
					angle = Angle(Ghost_X, Ghost_Y, PortalX[0], PortalY[0]);
					Ghost_MoveAtAngle(angle, 2, 0);
					++sfxTimer;
					if(!(sfxTimer%20))
						Game->PlaySound(SFX_ADJEAN_DASH);
					if(!(sfxTimer%4))
						Ghost_ShadowTrail(this, ghost, true, 20);
					if(!(sfxTimer%10))
						eweapon e = FireAimedEWeapon(EW_SCRIPT2, Ghost_X, Ghost_Y, 0, 0, ghost->WeaponDamage, 111, 40, EWF_UNBLOCKABLE);
					A_Waitframe(this, ghost, vars);
				}
				Game->PlaySound(SFX_ADJEAN_TELEPORT);
				Ghost_X = PortalX[1];
				Ghost_Y = PortalY[1];
				for(i = 0; i<2; i++){
					// PortalX[i] = 0;
					// PortalY[i] = 0;
					PortalST[i] = 1;
					PortalT[i] = 16;
				}
				Ghost_Dir = AngleDir4(Angle(Ghost_X+8, Ghost_Y+8, PortalX[2], PortalY[2]));
				while(Distance(Ghost_X, Ghost_Y, PortalX[2], PortalY[2])>1.5){
					angle = Angle(Ghost_X, Ghost_Y, PortalX[2], PortalY[2]);
					Ghost_MoveAtAngle(angle, 2, 0);
					++sfxTimer;
					if(!(sfxTimer%20))
						Game->PlaySound(SFX_ADJEAN_DASH);
					if(!(sfxTimer%4))
						Ghost_ShadowTrail(this, ghost, true, 20);
					if(!(sfxTimer%10))
						eweapon e = FireAimedEWeapon(EW_SCRIPT2, Ghost_X, Ghost_Y, 0, 0, ghost->WeaponDamage, 111, 40, EWF_UNBLOCKABLE);
					A_Waitframe(this, ghost, vars);
				}
				do{
					x = Rand(32, 192);
					y = Rand(32, 112);
				}
				while(Distance(Link->X, Link->Y, x, y) < 64);
				Game->PlaySound(SFX_ADJEAN_TELEPORT);
				Ghost_X = x;
				Ghost_Y = y;
				// PortalX[2] = 0;
				// PortalY[2] = 0;
				PortalST[2] = 1;
				PortalT[2] = 16;
				Ghost_Dir = AngleDir4(Angle(Ghost_X+8, Ghost_Y+8, Link->X, Link->Y));
				A_ChargeAnim(this, ghost, vars, combo+12, 7, 90);
				int wrecker[] = "Adjean_Wrecker";
				j = 1;
				if(IsHardMode())
					j = 2;
				for(i = 0; i<j; i++){
					int args[8];
					args[0] = vars[2]; 
					args[1] = vars[3];
					args[2] = DirAngle(Ghost_Dir)+Rand(-30, 30);
					RunFFCScript(Game->GetFFCScript(wrecker), args);
					Game->PlaySound(SFX_ADJEAN_FIRE);
				}
				for(i = Screen->NumEWeapons(); i>0; i--){
					e = Screen->LoadEWeapon(i);
					if(e->ID == EW_SCRIPT2 && e->Step == 0){
						e->Angle = DegtoRad(Angle(e->X, e->Y, Link->X, Link->Y));
						e->Step = LazyDiffMod(200, 300, 350);
					}
				}
			}
			A_Waitframe(this, ghost, vars);
		}
	}
	void A_UpdateFloors(int vars){
		int i; int j; int k;
		
		int floorST = vars[0];
		int floorT = vars[1];
		
		int pos = ComboAt(Link->X+8, Link->Y+12);
		if(floorST[pos]==3){
			Link->HP -= 8;
			Link->X = 120;
			Link->Y = 128;
			Link->Action = LA_GOTHURTLAND;
			Link->HitDir = -1;
			Game->PlaySound(SFX_FALL);
			Game->PlaySound(SFX_OUCH);
		}
		
		vars[12] = 0;
		
		int crackFrames = 16;
		for(i=0; i<176; i++){
			if(i>32){
				if(floorST[i]==0){ //Regular Floor
					if(Screen->ComboF[i]==98){
						Screen->ComboF[i] = 0;
						floorST[i] = 1;
						floorT[i] = 0;
						Game->PlaySound(SFX_LIGHTNING_STRIKE);
					}
				}
				else if(floorST[i]==1){ //Lightning Strike
					floorT[i]++;
					Screen->DrawCombo(6, ComboX(i), ComboY(i)-160, CMB_ADJEAN_LIGHTNING, 1, 11, 8, -1, -1, 0, 0, 0, 0, 0, true, 128);
					MakeHitbox(ComboX(i), ComboY(i), 16, 16, DAMAGE_ADJEAN_LIGHTNING);
					if(floorT[i]>12){
						floorST[i] = 2;
						floorT[i] = 0;
					}
					Screen->ComboD[i] = CMB_ADJEAN_FLOORS+1;
				}
				else if(floorST[i]==2){ //Crack
					floorT[i]++;
					for(j=0; j<3; j++){
						k = Clamp(96-j*32-96*(floorT[i]/crackFrames), 0, 16);
						Screen->Rectangle(4, ComboX(i)-k, ComboY(i)-k, ComboX(i)+15+k, ComboY(i)+15+k, Choose(0x71, 0x72, 0x73), 1, 0, 0, 0, false, 128);
					}
					if(floorT[i]>=crackFrames){
						if(i>50&&i<125&&i%16>2&&i%16<13)
							floorST[i] = 3;
						else
							floorST[i] = 4;
						floorT[i] = 0;
					}
					Screen->ComboD[i] = CMB_ADJEAN_FLOORS+1;
				}
				else if(floorST[i]==3){ //Lava
					Screen->ComboD[i] = CMB_ADJEAN_FLOORS+4;
					vars[12]++;
				}
				else if(floorST[i]==4){ //Spike
					Screen->ComboD[i] = 307;
					vars[12] += 2;
				}
				else if(floorST[i]==5){ //Repair
					Screen->ComboF[i] = 0;
					floorT[i]++;
					
					if(floorT[i]>32){
						floorST[i] = 0;
						floorT[i] = 0;
						Screen->ComboD[i] = CMB_ADJEAN_FLOORS;
					}
					else
						Screen->ComboD[i] = CMB_ADJEAN_FLOORS+2;
				}
				else if(floorST[i]==6){ //Lightning Strike, Repair
					floorT[i]++;
					Screen->DrawCombo(6, ComboX(i), ComboY(i)-160, CMB_ADJEAN_LIGHTNING, 1, 11, 8, -1, -1, 0, 0, 0, 0, 0, true, 128);
					MakeHitbox(ComboX(i), ComboY(i), 16, 16, DAMAGE_ADJEAN_LIGHTNING);
					if(floorT[i]>12){
						floorST[i] = 5;
						floorT[i] = 0;
					}
					Screen->ComboD[i] = CMB_ADJEAN_FLOORS+2;
				}
				
				
				if(Screen->ComboD[i]==CMB_ADJEAN_FLOORS+4){
					if(floorST[i-16]!=3){
						Screen->ComboD[i] = CMB_ADJEAN_FLOORS+3;
					}
				}
			}
		}
	}
	void A_UpdateWeapons(ffc this, npc ghost, int vars){
		int i;
		lweapon sword = LoadLWeaponOf(LW_SWORD);
		lweapon arrow = LoadLWeaponOf(LW_ARROW);
		for(i=Screen->NumLWeapons(); i>0; i--){
			lweapon l = Screen->LoadLWeapon(i);
			if(l->ID==LW_MAGIC){
				if(Collision(ghost, l)){
					l->Misc[LWM_REFCOUNT] = -1000;
					l->DeadState = 0;
					Game->PlaySound(SFX_CLINK);
				}
			}
			else if(l->ID==LW_REFMAGIC){
				if(Collision(ghost, l)){
					vars[5] = 1;
					// Screen->ComboF[ComboAt(Ghost_X+16, Ghost_Y+16)] = 98;
			
					Ghost_HP -= 4*G[G_HPSCALE];
					Game->PlaySound(15);
					Ghost_StartFlashing();
					l->DeadState = 0;
					l->Misc[LWM_REFCOUNT] = -1000;
				}
			}
		}
		for(i=Screen->NumEWeapons(); i>0; i--){
			eweapon e = Screen->LoadEWeapon(i);
			if(e->ID==EW_ADJEAN_FIREBALL){
				int hitArrow = (e->Misc[EWM_ADJEAN_FIREBALL_REFLECTED]>>13)&1;
				int refFrames = (e->Misc[EWM_ADJEAN_FIREBALL_REFLECTED]>>9)&15;
				int sfxCount = (e->Misc[EWM_ADJEAN_FIREBALL_REFLECTED]>>5)&15;
				int reflections = (e->Misc[EWM_ADJEAN_FIREBALL_REFLECTED]>>1)&15;
				int direction = e->Misc[EWM_ADJEAN_FIREBALL_REFLECTED]&1;
				// Screen->DrawInteger(6, e->X, e->Y, FONT_Z1, 0x01, 0x0F, -1, -1, direction, 0, 128);
				// Screen->DrawInteger(6, e->X, e->Y+8, FONT_Z1, 0x01, 0x0F, -1, -1, reflections, 0, 128);
				// Screen->DrawInteger(6, e->X, e->Y+16, FONT_Z1, 0x01, 0x0F, -1, -1, sfxCount, 0, 128);
				
				if(refFrames>0){
					refFrames--;
				}
				if(direction==0){
					if(arrow->isValid()&&direction==0){
						if(Collision(arrow, e)&&!refFrames&&AngleDir4(Angle(arrow->X, arrow->Y, e->X, e->Y))==arrow->Dir){
							direction = 1;
							hitArrow = 1;
							Game->PlaySound(100+sfxCount);
							sfxCount = Min(sfxCount+1, 10);
						}
					}
					if(sword->isValid()&&direction==0){
						if(Collision(sword, e)&&!refFrames){
							e->Angle = DegtoRad(Angle(e->X, e->Y, CenterX(ghost)-8, CenterY(ghost)-8));
							direction = 1;
							Game->PlaySound(100+sfxCount);
							sfxCount = Min(sfxCount+1, 10);
						}
					}
				}
				else{
					if(hitArrow){
						if(arrow->isValid()){
							e->Angle = DegtoRad(DirAngle(arrow->Dir));
							arrow->X = e->X;
							arrow->Y = e->Y;
							if(arrow->Dir==DIR_UP){
								arrow->Y += 8;
							}
							else if(arrow->Dir==DIR_DOWN){
								arrow->Y -= 8;
							}
							else if(arrow->Dir==DIR_LEFT){
								arrow->X += 8;
							}
							else if(arrow->Dir==DIR_RIGHT){
								arrow->X -= 8;
							}
						}
						else
							hitArrow = 0;
					}
					else if(ghost->CollDetection){
						int angle = RadtoDeg(e->Angle);
						angle = TurnToAngle(angle, Angle(e->X, e->Y, CenterX(ghost)-8, CenterY(ghost)-8), 10);
						e->Angle = DegtoRad(angle);
					}
					if(Collision(ghost, e)){
						vars[5] = 1;
						if(vars[4]&&reflections>0&&!hitArrow){
							// Screen->ComboF[ComboAt(Ghost_X+16, Ghost_Y+16)] = 98;
				
							e->Angle = DegtoRad(Angle(e->X, e->Y, Link->X, Link->Y));
							direction = 0;
							Game->PlaySound(100+sfxCount);
							refFrames = 15;
							sfxCount = Min(sfxCount+1, 10);
							reflections--;
						}
						else{
							// Screen->ComboF[ComboAt(Ghost_X+16, Ghost_Y+16)] = 98;
				
							Ghost_HP -= 8*G[G_HPSCALE];
							if(Ghost_HP<1)
								Ghost_HP = 1;
							Game->PlaySound(15);
							Ghost_StartFlashing();
							e->DeadState = 0;
						}
					}
				}
				
				e->Misc[EWM_ADJEAN_FIREBALL_REFLECTED] = direction|(reflections<<1)|(sfxCount<<5)|(refFrames<<9)|(hitArrow<<13);
			}
		}
	}
	void A_SetWeaponData(eweapon e, int direction, int reflections, int sfxCount){
		e->Misc[EWM_ADJEAN_FIREBALL_REFLECTED] = direction|(reflections<<1)|(sfxCount<<5);
	}
	void A_ChargeAnim(ffc this, npc ghost, int vars, int cmb, int cset, int frames){
		int i;
		int x; int y;
		int angle;
		
		int pathX[6];
		int pathY[6];
		int combo = ghost->Attributes[10];
		int oldData = Ghost_Data;
		Ghost_Data = combo+4;
		Game->PlaySound(SFX_ADJEAN_CHARGE);
		for(i=0; i<frames; i++){
			Ghost_Dir = AngleDir4(Angle(Ghost_X+8, Ghost_Y+8, Link->X, Link->Y));
			if(Ghost_Dir==DIR_UP){
				pathX[0] = 3;
				pathY[0] = 3;
				pathX[2] = 15;
				pathY[2] = -4;
				
				pathX[1] = 28;
				pathY[1] = 3;
				pathX[3] = 16;
				pathY[3] = -4;
			}
			else if(Ghost_Dir==DIR_DOWN){
				pathX[0] = 2;
				pathY[0] = 5;
				pathX[2] = 15;
				pathY[2] = 15;
				
				pathX[1] = 29;
				pathY[1] = 5;
				pathX[3] = 16;
				pathY[3] = 15;
			}
			else if(Ghost_Dir==DIR_LEFT){
				pathX[0] = 7;
				pathY[0] = 6;
				pathX[2] = 4;
				pathY[2] = 15;
				
				pathX[1] = 25;
				pathY[1] = 4;
				pathX[3] = 4;
				pathY[3] = 15;
			}
			else if(Ghost_Dir==DIR_RIGHT){
				pathX[0] = 24;
				pathY[0] = 6;
				pathX[2] = 27;
				pathY[2] = 15;
				
				pathX[1] = 6;
				pathY[1] = 4;
				pathX[3] = 27;
				pathY[3] = 15;
			}
			pathX[4] = Q7_GlideX(pathX[0], pathY[0], pathX[2], pathY[2], frames, i);
			pathY[4] = Q7_GlideY(pathX[0], pathY[0], pathX[2], pathY[2], frames, i);
			
			Screen->FastCombo(4, Ghost_X+pathX[4]-8, Ghost_Y+pathY[4]-8, cmb, cset, 128);
			
			pathX[5] = Q7_GlideX(pathX[1], pathY[1], pathX[3], pathY[3], frames, i);
			pathY[5] = Q7_GlideY(pathX[1], pathY[1], pathX[3], pathY[3], frames, i);
			
			Screen->FastCombo(4, Ghost_X+pathX[5]-8, Ghost_Y+pathY[5]-8, cmb, cset, 128);
			
			A_Waitframe(this, ghost, vars);
		}
		
		vars[2] = Ghost_X+Round((pathX[4]+pathX[5])/2);
		vars[3] = Ghost_Y+Round((pathY[4]+pathY[5])/2);
		Ghost_Data = oldData;
	}
	void A_TryBlockFireball(ffc this, npc ghost, int vars){
		int i;
		bool collided;
		for(i=Screen->NumEWeapons(); i>0; i--){
			eweapon e = Screen->LoadEWeapon(i);
			if(e->ID==EW_ADJEAN_FIREBALL){
				int direction = e->Misc[EWM_ADJEAN_FIREBALL_REFLECTED]&1;
				if(Collision(e, ghost)){
					collided = true;
				}
			}
		}
		int combo = ghost->Attributes[10];
		bool reflected;
		if(collided){
			Ghost_Data = combo+4;
			vars[4] = 1;
			for(i=0; i<16; i++){
				A_Waitframe(this, ghost, vars);
			}
			vars[4] = 0;
			Ghost_Data = combo;
		}
	}
	void A_UpdateHP(ffc this, npc ghost, int vars){
		int floorST = vars[0];
		if(Ghost_HP < vars[7]){
			vars[7] = Ghost_HP;
			int xOff[] = {16, 08, 24, 08, 24};
			int yOff[] = {16, 08, 08, 24, 24};
			for(int i=0; i<5; i++){
				int pos = ComboAt(Ghost_X+xOff[i], Ghost_Y+yOff[i]);
				if(floorST[pos]==0){
					Screen->ComboF[pos] = 98;
					break;
				}
			}
		}
	}
	void A_CreatePortal(int vars){
		int PortalX = vars[8];
		int PortalY = vars[9];
		int PortalST = vars[10];
		int PortalT = vars[11];
		if(PortalX[0] == 0){
			PortalX[0] = Ghost_X;
			PortalY[0] = Ghost_Y;
			PortalST[0] = -2;
			PortalT[0] = 16;
		}
		else if(PortalX[1] == 0){
			PortalX[1] = Ghost_X;
			PortalY[1] = Ghost_Y;
			PortalST[1] = -2;
			PortalT[1] = 16;
		}
		else{
			PortalX[2] = Ghost_X;
			PortalY[2] = Ghost_Y;
			PortalST[2] = -2;
			PortalT[2] = 16;
		}
	}
	void A_UpdatePortals(int vars){
		int PortalX = vars[8];
		int PortalY = vars[9];
		int PortalST = vars[10];
		int PortalT = vars[11];
		for(int i = 0; i<3; i++){
			if(PortalX[i] > 0){
				if(PortalST[i]==-2){
					--PortalT[i];
					if(PortalT[i]<=0){
						PortalT[i] = 16;
						PortalST[i] = -1;
					}
				}
				else if(PortalST[i]==-1){
					--PortalT[i];
					if(PortalT[i]<=0){
						PortalT[i] = 0;
						PortalST[i] = 0;
					}
				}
				else if(PortalST[i]==1){
					--PortalT[i];
					if(PortalT[i]<=0){
						PortalT[i] = 16;
						PortalST[i] = 2;
					}
				}
				else if(PortalST[i]==2){
					--PortalT[i];
					if(PortalT[i]<=0){
						PortalT[i] = 0;
						PortalST[i] = 0;
						PortalX[i] = 0;
						PortalY[i] = 0;
					}
				}
				
				if(PortalX[i]>0)
					Screen->DrawCombo(2, PortalX[i], PortalY[i], CMB_ADJEAN_PORTAL+Abs(PortalST[i]), 2, 2, CS_ADJEAN_PORTAL, -1, -1,	0, 0, 0, 0, 0, true, OP_OPAQUE);
			}
		}
	}
	void A_Waitframe(ffc this, npc ghost, int vars, int frames){
		for(int i=0; i<frames; i++){
			A_Waitframe(this, ghost, vars);
		}
	}
	void A_Waitframe(ffc this, npc ghost, int vars){
		A_UpdateWeapons(this, ghost, vars);
		A_UpdateFloors(vars);
		A_UpdateHP(this, ghost, vars);
		A_UpdatePortals(vars);
		
		if(!Q7_Ghost_Waitframe(this, ghost, false, false)){
			A_DeathAnim(this, ghost);
			Quit();
		}
	}
	void A_DeathAnim(ffc this, npc ghost){
		int i; int j; int k;
		
		int wrecker[] = "Adjean_Wrecker";
		int wreckerSlot = Game->GetFFCScript(wrecker);
		
		for(i=1; i<=32; i++){
			ffc f = Screen->LoadFFC(i);
			if(f->Script==wreckerSlot)
				f->Script = 0;
		}
		
		for(i=Screen->NumEWeapons(); i>0; i--){
			eweapon e = Screen->LoadEWeapon(i);
			e->DeadState = 0;
		}
		
		int combo = ghost->Attributes[10];
		
		Ghost_Dir = DIR_DOWN;
		Ghost_Data = combo;
		
		__DeathAnimStart(this, ghost);
		__DeathAnimSFX(ghost->ID, ghost->X);
		
		__Ghost_FlashCounter=0;
		
		Game->PlayMIDI(0);
		
		for(i=0; i<32; i++){
			
			if(i==16){
				Screen->Message(191);
			}
			
			Ghost_WaitframeLight(this, ghost);
		}
		
		int sfxTimer;
		
		while(Ghost_Y>-48){
			
			Ghost_Y -= 2;
			
			++sfxTimer;
			if(!(sfxTimer%20))
				Game->PlaySound(SFX_ADJEAN_DASH);
			if(!(sfxTimer%4))
				Ghost_ShadowTrail(this, ghost, true, 20);
			
			Ghost_WaitframeLight(this, ghost);
		}
		
		__DeathAnimEnd(this, ghost);
	}
}

bool CanWalkEx(int x, int y, int dir, int step, bool full_tile, int whitelistCT) {
    int c=8;
    int xx = x+15;
    int yy = y+15;
    if(full_tile) c=0;
    if(dir==0) return !(y-step<0||isSolidEx(x,y+c-step, whitelistCT)||isSolidEx(x+8,y+c-step, whitelistCT)||isSolidEx(xx,y+c-step, whitelistCT));
    else if(dir==1) return !(yy+step>=176||isSolidEx(x,yy+step, whitelistCT)||isSolidEx(x+8,yy+step, whitelistCT)||isSolidEx(xx,yy+step, whitelistCT));
    else if(dir==2) return !(x-step<0||isSolidEx(x-step,y+c, whitelistCT)||isSolidEx(x-step,y+c+7, whitelistCT)||isSolidEx(x-step,yy, whitelistCT));
    else if(dir==3) return !(xx+step>=256||isSolidEx(xx+step,y+c, whitelistCT)||isSolidEx(xx+step,y+c+7, whitelistCT)||isSolidEx(xx+step,yy, whitelistCT));
    return false; //invalid direction
}

bool CanSwim(int x, int y, int dir, int step, bool full_tile) {
    int c=8;
    int xx = x+15;
    int yy = y+15;
    if(full_tile) c=0;
    if(dir==0) return (!(y-step<0)&&Q7_IsWater(x,y+c-step)&&Q7_IsWater(x+8,y+c-step)&&Q7_IsWater(xx,y+c-step));
    else if(dir==1) return (!(yy+step>=176)&&Q7_IsWater(x,yy+step)&&Q7_IsWater(x+8,yy+step)&&Q7_IsWater(xx,yy+step));
    else if(dir==2) return (!(x-step<0)&&Q7_IsWater(x-step,y+c)&&Q7_IsWater(x-step,y+c+7)&&Q7_IsWater(x-step,yy));
    else if(dir==3) return (!(xx+step>=256)&&Q7_IsWater(xx+step,y+c)&&Q7_IsWater(xx+step,y+c+7)&&Q7_IsWater(xx+step,yy));
    return false; //invalid direction
}

bool isSolidEx(int x, int y, int whitelistCT){
	if(whitelistCT[Screen->ComboT[ComboAt(x, y)]])
		return false;
	return Screen->isSolid(x, y);
}

//Like clamp, but doesn't clamp the value if it's outside of the range moving inwards
int Q7_Clamp2(int val, int diff, int min, int max){
	if(val<min)
		return Clamp(val+diff, val, max);
	else if(val>max)
		return Clamp(val+diff, min, val);
	return Clamp(val+diff, min, max);
}

ffc script Adjean_Wrecker{
	void run(int x, int y, int angle){
		int i; int j;
		int vX = VectorX(1, angle); 
		int vY = VectorY(1, angle);;
		int whitelistCT[512];
		whitelistCT[CT_HOOKSHOTONLY] = 1;
		whitelistCT[CT_LADDERHOOKSHOT] = 1;
		eweapon e = FireEWeapon(EW_ADJEAN_WRECKER, x, y, DegtoRad(angle), 0, DAMAGE_ADJEAN_WRECKER, SPR_ADJEAN_WRECKER, 0, EWF_UNBLOCKABLE);
		int refCooldown;
		for(i=0; i<600; i++){
			x += vX;
			y += vY;
			
			if((vX<0&&!CanWalkEx(x, y, DIR_LEFT, 1, true, whitelistCT))||(vX>0&&!CanWalkEx(x, y, DIR_RIGHT, 1, true, whitelistCT))){
				vX = -vX;
			}
			if((vY<0&&!CanWalkEx(x, y, DIR_UP, 1, true, whitelistCT))||(vY>0&&!CanWalkEx(x, y, DIR_DOWN, 1, true, whitelistCT))){
				vY = -vY;
			}
			vX = Q7_Clamp2(vX, Sign(Link->X-x)*0.005, -0.5, 0.5);
			vY = Q7_Clamp2(vY, Sign(Link->Y-y)*0.005, -0.5, 0.5);
			lweapon sword = LoadLWeaponOf(LW_SWORD);
			lweapon arrow = LoadLWeaponOf(LW_ARROW);
			if(refCooldown>0)
				refCooldown--;
			else if(e->isValid()){
				if(arrow->isValid()){
					if(Collision(e, arrow)&&arrow->DeadState==WDS_ALIVE){
						arrow->DeadState = WDS_ARROW;
						angle = Angle(arrow->X, arrow->Y, x, y);
						vX = VectorX(1, angle);
						vY = VectorY(1, angle);
						Game->PlaySound(SFX_CLINK);
						refCooldown = 32;
					}
				}
				if(sword->isValid()){
					if(Collision(e, sword)){
						angle = Angle(Link->X, Link->Y, x, y);
						vX = VectorX(0.5, angle);
						vY = VectorY(0.5, angle);
						Game->PlaySound(SFX_CLINK);
						refCooldown = 32;
					}
				}
			}
			angle = Angle(0, 0, vX, vY);
			if(e->isValid()){
				e->DeadState = WDS_ALIVE;
				if(LinkCollision(e)&&Link->Action==LA_GOTHURTLAND&&refCooldown==0){
					refCooldown = 32;
					Screen->ComboF[ComboAt(Link->X+8, Link->Y+8)] = 98;
				}
				if(i>600-120){
					e->X = x+Rand(-1, 1);
					e->Y = y+Rand(-1, 1);
				}
				else{
					e->X = x;
					e->Y = y;
				}
			}
			else{
				e = FireEWeapon(EW_ADJEAN_WRECKER, x, y, DegtoRad(angle), 0, DAMAGE_ADJEAN_WRECKER, SPR_ADJEAN_WRECKER, 0, EWF_UNBLOCKABLE);
			}
			Waitframe();
		}
		for(i=0; i<60; i++){
			if(e->isValid()){
				e->DeadState = WDS_ALIVE;
				if(LinkCollision(e)&&Link->Action==LA_GOTHURTLAND){
					Screen->ComboF[ComboAt(Link->X+8, Link->Y+8)] = 98;
				}
				e->X = x+Rand(-2, 2);
				e->Y = y+Rand(-2, 2);
			}
			else{
				e = FireEWeapon(EW_ADJEAN_WRECKER, x, y, DegtoRad(angle), 0, DAMAGE_ADJEAN_WRECKER, SPR_ADJEAN_WRECKER, 0, EWF_UNBLOCKABLE);
			}
			Waitframe();
		}
		if(e->isValid())
			e->DeadState = 0;
		int tmpX;
		int tmpY;
		int pos;
		// for(i=0; i<5; i++){
			// for(j=0; j<3; j++){
				// tmpX = x+8-16+i*16-j*16;
				// tmpY = y+8-16+j*16;
				// if(i-j>=0&&i-j<3){
					// pos = ComboAt(tmpX, tmpY);
					// if(pos>31&&pos<144&&pos%16>1&&pos%16<14)
						// Screen->ComboF[pos] = 98;
				// }
			// }
			// Waitframes(8);
		// }
		pos = ComboAt(GridX(e->X), GridY(e->Y));
		if(pos>31&&pos<144&&pos%16>1&&pos%16<14)
			Screen->ComboF[pos] = 98;
		pos += 1;
		if(pos>31&&pos<144&&pos%16>1&&pos%16<14)
			Screen->ComboF[pos] = 98;
		pos += 15;
		if(pos>31&&pos<144&&pos%16>1&&pos%16<14)
			Screen->ComboF[pos] = 98;
		pos += 1;
		if(pos>31&&pos<144&&pos%16>1&&pos%16<14)
			Screen->ComboF[pos] = 98;
	}
}
void Ghost_ShadowTrail(ffc this, npc ghost, bool addDir, int duration){
	int til;
	if(addDir)
		til = Game->ComboTile(Ghost_Data+Ghost_Dir);
	else
		til = Game->ComboTile(Ghost_Data);
	int cset = this->CSet;
	int w = Ghost_TileWidth;
	int h = Ghost_TileHeight;
	
	lweapon trail = CreateLWeaponAt(LW_SCRIPT10, Ghost_X, Ghost_Y);
	trail->OriginalTile = til;
	trail->Tile = til;
	trail->CSet = cset;
	trail->Extend = 3;
	trail->TileWidth = w;
	trail->TileHeight = h;
	trail->CollDetection = false;
	trail->DeadState = duration;
	trail->DrawStyle = DS_PHANTOM;
}

void ShadowTrail(int x, int y, int w, int h, int cmb, int cset, int duration){
	int til;
	til = Game->ComboTile(cmb);
	
	lweapon trail = CreateLWeaponAt(LW_SCRIPT10, x, y);
	trail->OriginalTile = til;
	trail->Tile = til;
	trail->CSet = cset;
	trail->Extend = 3;
	trail->TileWidth = w;
	trail->TileHeight = h;
	trail->CollDetection = false;
	trail->DeadState = duration;
	trail->DrawStyle = DS_PHANTOM;
}


const int RT_FAKEASSENDING = 1;
const int RT_FAKEASSENDING2 = 2;
const int RT_FAKEASSGLASS = 3;

ffc script FakeAssEnding{
	bool PressSkipEnding(){
		return Link->PressStart&&G[G_MODE_RANDOMIZER];
	}
	void run(int justSpawnTheBoss){
		int i; int j; int k; int m;
		int x; int y; int x2; int y2;
		int step; int angle;
		npc n;
		
		int finalBossTrack[] = "Q7 - FinalB.nsf";
		
		Waitframe();
		
		if(justSpawnTheBoss){
			Game->PlayEnhancedMusic(finalBossTrack, 0);
			n = CreateNPCAt(316, 104+16, 16+16);
			Quit();
		}
		
		while(Link->Y>82){
			Waitframe();
		}
		
		this->Flags[FFCF_CARRYOVER] = true;
		
		if(G[G_SAWBANNONCUTSCENE]){
			this->Flags[FFCF_CARRYOVER] = false;
			
			Bannon_ClearLayer2(14, 0x3F);
			Link->Dir = DIR_UP;
			Screen->SetSideWarp(0, 0x33, 18, WT_IWARPWAVE);
			this->Data = CMB_AUTOWARPA;
			G[G_SPECIALWARP] = 1;
			Quit();
		}
		
		Screen->FastTile(6, 120, 72, 35, 6, 128);
		Link->X = 120+16;
		Link->Y = 72;
		Link->Dir = DIR_LEFT;
		Screen->DrawTile(6, Link->X, Link->Y, Link->Tile, 1, 1, 6, -1, -1, 0, 0, 0, 0, true, 128);
		Link->PitWarp(17, Game->GetCurDMapScreen());
		Q7_WaitNoAction();
		
		Screen->SetRenderTarget(RT_FAKEASSENDING);
		FakeAssSubscreen(0, 0);
		Screen->SetRenderTarget(RT_SCREEN);
		
		G[G_NODRAWSUBSCREEN] = 1;
		
		Game->PlayMIDI(0);
		Game->PlaySound(SFX_ZELDA);
		
		bool skip;
		for(i=0; i<288&&!skip; i++){
			Screen->FastTile(6, 120, 72, 35, 6, 128);
			Link->X = 120+16;
			Link->Y = 72;
			Link->Dir = DIR_LEFT;
			Screen->DrawTile(6, Link->X, Link->Y, Link->Tile, 1, 1, 6, -1, -1, 0, 0, 0, 0, true, 128);
			skip = PressSkipEnding();
			Q7_WaitNoAction();
		}
		for(i=0; i<75&&!skip; i++){
			Screen->Rectangle(6, 0, 0, 7+8*Floor(i/5), 175, 0x0F, 1, 0, 0, 0, true, 128);
			Screen->Rectangle(6, 248-8*Floor(i/5), 0, 255, 175, 0x0F, 1, 0, 0, 0, true, 128);
			Screen->FastTile(6, 120, 72, 35, 6, 128);
			Screen->DrawTile(6, Link->X, Link->Y, Link->Tile, 1, 1, 6, -1, -1, 0, 0, 0, 0, true, 128);
			skip = PressSkipEnding();
			Q7_WaitNoAction();
		}
		
		int es1[] = "THANKS LINK,YOU'RE";
		int es2[] = "THE HERO OF HYRULE.";
		
		int es3[] = "FINALLY,";
		int es4[] = "PEACE RETURNS TO HYRULE.";
		int es5[] = "THIS ENDS THE STORY.";
		
		int len = SizeOfArray(es1);
		for(i=0; i<len*6&&!skip; i++){
			Screen->Rectangle(7, 0, -56, 255, 175, 0x0F, 1, 0, 0, 0, true, 128);
			Screen->FastTile(7, 120, 72, 35, 6, 128);
			Screen->DrawTile(7, Link->X, Link->Y, Link->Tile, 1, 1, 6, -1, -1, 0, 0, 0, 0, true, 128);
			if(i%6==0)
				Game->PlaySound(SFX_MSG);
			Q7_DrawPartialString(7, 32, 40, FONT_Z1, 0x01, -1, TF_NORMAL, es1, 128, Floor(i/6));
			Screen->DrawBitmap(7, RT_FAKEASSENDING, 0, 0, 256, 56, 0, -56, 256, 56, 0, true);
			skip = PressSkipEnding();
			Q7_WaitNoAction();
		}
		len = SizeOfArray(es2);
		for(i=0; i<len*6&&!skip; i++){
			Screen->Rectangle(7, 0, -56, 255, 175, 0x0F, 1, 0, 0, 0, true, 128);
			Screen->FastTile(7, 120, 72, 35, 6, 128);
			Screen->DrawTile(7, Link->X, Link->Y, Link->Tile, 1, 1, 6, -1, -1, 0, 0, 0, 0, true, 128);
			if(i%6==0)
				Game->PlaySound(SFX_MSG);
			Screen->DrawString(7, 32, 40, FONT_Z1, 0x01, -1, TF_NORMAL, es1, 128);
			Q7_DrawPartialString(7, 32, 56, FONT_Z1, 0x01, -1, TF_NORMAL, es2, 128, Floor(i/6));
			Screen->DrawBitmap(7, RT_FAKEASSENDING, 0, 0, 256, 56, 0, -56, 256, 56, 0, true);
			skip = PressSkipEnding();
			Q7_WaitNoAction();
		}
		
		for(i=0; i<260&&!skip; i++){
			Screen->Rectangle(7, 0, -56, 255, 175, 0x0F, 1, 0, 0, 0, true, 128);
			Screen->FastTile(7, 120, 72, 35, 6, 128);
			Screen->DrawTile(7, Link->X, Link->Y, Link->Tile, 1, 1, 6, -1, -1, 0, 0, 0, 0, true, 128);
			Screen->DrawString(7, 32, 40, FONT_Z1, 0x01, -1, TF_NORMAL, es1, 128);
			Screen->DrawString(7, 32, 56, FONT_Z1, 0x01, -1, TF_NORMAL, es2, 128);
			Screen->DrawBitmap(7, RT_FAKEASSENDING, 0, 0, 256, 56, 0, -56, 256, 56, 0, true);
			skip = PressSkipEnding();
			Q7_WaitNoAction();
		}
		
		for(i=0; i<64&&!skip; i++){
			Screen->Rectangle(7, 0, -56, 255, 175, 0x0F, 1, 0, 0, 0, true, 128);
			Screen->FastTile(7, 120, 72, 36, 6, 128);
			Screen->FastCombo(7, 120, 72-16, 442, 8, 128);
			Screen->FastTile(7, Link->X, Link->Y, 13017, 6, 128);
			Screen->FastCombo(7, Link->X, Link->Y-16, 442, 8, 128);
			Screen->DrawString(7, 32, 40, FONT_Z1, 0x01, -1, TF_NORMAL, es1, 128);
			Screen->DrawString(7, 32, 56, FONT_Z1, 0x01, -1, TF_NORMAL, es2, 128);
			Screen->DrawBitmap(7, RT_FAKEASSENDING, 0, 0, 256, 56, 0, -56, 256, 56, 0, true);
			skip = PressSkipEnding();
			Q7_WaitNoAction();
		}	
		
		int flashPal[] = {0x0F, 0x71, 0x81, 0x52};
		
		for(i=0; i<128&&!skip; i++){
			Screen->Rectangle(7, 0, -56, 255, 175, flashPal[(i%4)], 1, 0, 0, 0, true, 128);
			Screen->FastTile(7, 120, 72, 36, 6, 128);
			Screen->FastCombo(7, 120, 72-16, 442, 8, 128);
			Screen->FastTile(7, Link->X, Link->Y, 13017, 6, 128);
			Screen->FastCombo(7, Link->X, Link->Y-16, 442, 8, 128);
			Screen->DrawString(7, 32, 40, FONT_Z1, 0x01, -1, TF_NORMAL, es1, 128);
			Screen->DrawString(7, 32, 56, FONT_Z1, 0x01, -1, TF_NORMAL, es2, 128);
			Screen->DrawBitmap(7, RT_FAKEASSENDING, 0, 0, 256, 56, 0, -56, 256, 56, 0, true);
			skip = PressSkipEnding();
			Q7_WaitNoAction();
		}
		
		int zelda[] = "zelda.nsf";
		if(!Game->PlayEnhancedMusic(zelda, 2))
			Game->PlayMIDI(2);
		
		for(i=0; i<68&&!skip; i++){
			Screen->Rectangle(7, 0, -56, 255, 175, 0x0F, 1, 0, 0, 0, true, 128);
			Screen->FastTile(7, 120, 72, 36, 6, 128);
			Screen->FastCombo(7, 120, 72-16, 442, 8, 128);
			Screen->FastTile(7, Link->X, Link->Y, 13017, 6, 128);
			Screen->FastCombo(7, Link->X, Link->Y-16, 442, 8, 128);
			Screen->DrawString(7, 32, 40, FONT_Z1, 0x01, -1, TF_NORMAL, es1, 128);
			Screen->DrawString(7, 32, 56, FONT_Z1, 0x01, -1, TF_NORMAL, es2, 128);
			Screen->DrawBitmap(7, RT_FAKEASSENDING, 0, 0, 256, 56, 0, -56, 256, 56, 0, true);
			skip = PressSkipEnding();
			Q7_WaitNoAction();
		}
		
		len = SizeOfArray(es3);
		for(i=0; i<len*6&&!skip; i++){
			Screen->Rectangle(7, 0, -56, 255, 175, 0x0F, 1, 0, 0, 0, true, 128);
			Screen->FastTile(7, 120, 72, 36, 6, 128);
			Screen->FastCombo(7, 120, 72-16, 442, 8, 128);
			Screen->FastTile(7, Link->X, Link->Y, 13017, 6, 128);
			Screen->FastCombo(7, Link->X, Link->Y-16, 442, 8, 128);
			if(i%6==0)
				Game->PlaySound(SFX_MSG);
			Screen->DrawString(7, 32, 40, FONT_Z1, 0x01, -1, TF_NORMAL, es1, 128);
			Screen->DrawString(7, 32, 56, FONT_Z1, 0x01, -1, TF_NORMAL, es2, 128);
			Q7_DrawPartialString(7, 96, 104, FONT_Z1, 0x01, -1, TF_NORMAL, es3, 128, Floor(i/6));
			Screen->DrawBitmap(7, RT_FAKEASSENDING, 0, 0, 256, 56, 0, -56, 256, 56, 0, true);
			skip = PressSkipEnding();
			Q7_WaitNoAction();
		}
		
		len = SizeOfArray(es4);
		for(i=0; i<len*6&&!skip; i++){
			Screen->Rectangle(7, 0, -56, 255, 175, 0x0F, 1, 0, 0, 0, true, 128);
			Screen->FastTile(7, 120, 72, 36, 6, 128);
			Screen->FastCombo(7, 120, 72-16, 442, 8, 128);
			Screen->FastTile(7, Link->X, Link->Y, 13017, 6, 128);
			Screen->FastCombo(7, Link->X, Link->Y-16, 442, 8, 128);
			if(i%6==0)
				Game->PlaySound(SFX_MSG);
			Screen->DrawString(7, 32, 40, FONT_Z1, 0x01, -1, TF_NORMAL, es1, 128);
			Screen->DrawString(7, 32, 56, FONT_Z1, 0x01, -1, TF_NORMAL, es2, 128);
			Screen->DrawString(7, 96, 104, FONT_Z1, 0x01, -1, TF_NORMAL, es3, 128);
			Q7_DrawPartialString(7, 32, 120, FONT_Z1, 0x01, -1, TF_NORMAL, es4, 128, Floor(i/6));
			Screen->DrawBitmap(7, RT_FAKEASSENDING, 0, 0, 256, 56, 0, -56, 256, 56, 0, true);
			skip = PressSkipEnding();
			Q7_WaitNoAction();
		}
		
		len = SizeOfArray(es5);
		for(i=0; i<len*6&&!skip; i++){
			Screen->Rectangle(7, 0, -56, 255, 175, 0x0F, 1, 0, 0, 0, true, 128);
			Screen->FastTile(7, 120, 72, 36, 6, 128);
			Screen->FastCombo(7, 120, 72-16, 442, 8, 128);
			Screen->FastTile(7, Link->X, Link->Y, 13017, 6, 128);
			Screen->FastCombo(7, Link->X, Link->Y-16, 442, 8, 128);
			if(i%6==0)
				Game->PlaySound(SFX_MSG);
			Screen->DrawString(7, 32, 40, FONT_Z1, 0x01, -1, TF_NORMAL, es1, 128);
			Screen->DrawString(7, 32, 56, FONT_Z1, 0x01, -1, TF_NORMAL, es2, 128);
			Screen->DrawString(7, 96, 104, FONT_Z1, 0x01, -1, TF_NORMAL, es3, 128);
			Screen->DrawString(7, 32, 120, FONT_Z1, 0x01, -1, TF_NORMAL, es4, 128);
			Q7_DrawPartialString(7, 48, 144, FONT_Z1, 0x01, -1, TF_NORMAL, es5, 128, Floor(i/6));
			Screen->DrawBitmap(7, RT_FAKEASSENDING, 0, 0, 256, 56, 0, -56, 256, 56, 0, true);
			skip = PressSkipEnding();
			Q7_WaitNoAction();
		}
		
		for(i=0; i<158&&!skip; i++){
			Screen->Rectangle(7, 0, -56, 255, 175, 0x0F, 1, 0, 0, 0, true, 128);
			Screen->FastTile(7, 120, 72, 36, 6, 128);
			Screen->FastCombo(7, 120, 72-16, 442, 8, 128);
			Screen->FastTile(7, Link->X, Link->Y, 13017, 6, 128);
			Screen->FastCombo(7, Link->X, Link->Y-16, 442, 8, 128);
			Screen->DrawString(7, 32, 40, FONT_Z1, 0x01, -1, TF_NORMAL, es1, 128);
			Screen->DrawString(7, 32, 56, FONT_Z1, 0x01, -1, TF_NORMAL, es2, 128);
			Screen->DrawString(7, 96, 104, FONT_Z1, 0x01, -1, TF_NORMAL, es3, 128);
			Screen->DrawString(7, 32, 120, FONT_Z1, 0x01, -1, TF_NORMAL, es4, 128);
			Screen->DrawString(7, 48, 144, FONT_Z1, 0x01, -1, TF_NORMAL, es5, 128);
			Screen->DrawBitmap(7, RT_FAKEASSENDING, 0, 0, 256, 56, 0, -56, 256, 56, 0, true);
			skip = PressSkipEnding();
			Q7_WaitNoAction();
		}
		
		int c1[] = "STAFF";
		int c2[] = "EXECUTIVE";
		int c3[] = "PRODUCER... H.YAMAUCHI";
		int c4[] = "PRODUCER.... S.MIYAHON";
		int c5[] = "DIRECTOR.... S.MIYAHON";
		int c6[] = "        ...... TEN TEN";
		int c7[] = "DESIGNER...... HOWEVER";
		int c8[] = "PROGRAMMER........ THE";
		int c9[] = "          .. NIGHTMARE";
		int c10[] = "          ........ YET";
		int c11[] = "SOUND";
		int c12[] = "COMPOSER........ LIVES";
		
		int c13[] = "ANOTHER NIGHTMARE WILL";
		int c14[] = "SOON BEGIN.";
		int c15[] = "YOUR DEATH APPROACHES.";
		
		Screen->SetRenderTarget(RT_FAKEASSENDING);
		Screen->Rectangle(0, 256, 0, 511, 511, 0, 1, 0, 0, 0, true, 128);
		for(i=0; i<22; i++){
			Screen->FastTile(0, 256+0, i*16, 2068, 0, 128);
			Screen->FastTile(0, 256+200, i*16, 2068, 0, 128);
		}
		for(i=0; i<5; i++){
			Screen->FastTile(0, 256+i*16, 0, 2028, 0, 128);
		}
		for(i=0; i<4; i++){
			Screen->FastTile(0, 256+136+i*16, 0, 2028, 0, 128);
		}
		for(i=0; i<12; i++){
			Screen->FastTile(0, 256+8+i*16, 344, 2028, 0, 128);
		}
		Screen->DrawString(0, 256+88, 0, FONT_Z1, 0x01, -1, TF_NORMAL, c1, 128);
		Screen->DrawString(0, 256+16, 32, FONT_Z1, 0x72, -1, TF_NORMAL, c2, 128);
		Screen->DrawString(0, 256+16, 40, FONT_Z1, 0x72, -1, TF_NORMAL, c3, 128);
		Screen->DrawString(0, 256+16, 80, FONT_Z1, 0x52, -1, TF_NORMAL, c4, 128);
		Screen->DrawString(0, 256+16, 120, FONT_Z1, 0x81, -1, TF_NORMAL, c5, 128);
		Screen->DrawString(0, 256+16, 144, FONT_Z1, 0x81, -1, TF_NORMAL, c6, 128);
		Screen->DrawString(0, 256+16, 184, FONT_Z1, 0x72, -1, TF_NORMAL, c7, 128);
		Screen->DrawString(0, 256+16, 224, FONT_Z1, 0x52, -1, TF_NORMAL, c8, 128);
		Screen->DrawString(0, 256+16, 248, FONT_Z1, 0x52, -1, TF_NORMAL, c9, 128);
		Screen->DrawString(0, 256+16, 272, FONT_Z1, 0x52, -1, TF_NORMAL, c10, 128);
		Screen->DrawString(0, 256+16, 312, FONT_Z1, 0x81, -1, TF_NORMAL, c11, 128);
		Screen->DrawString(0, 256+16, 320, FONT_Z1, 0x81, -1, TF_NORMAL, c12, 128);
		
		Screen->SetRenderTarget(RT_SCREEN);
		
		for(i=0; i<624&&!skip; i+=0.4){
			if(i<176)
				i+=0.1;
			Screen->SetRenderTarget(RT_FAKEASSENDING2);
			Screen->Rectangle(0, 0, 0, 255, 255, 0x0F, 1, 0, 0, 0, true, 128);
			
			Screen->DrawString(0, 32, 40+56-i, FONT_Z1, 0x01, -1, TF_NORMAL, es1, 128);
			Screen->DrawString(0, 32, 56+56-i, FONT_Z1, 0x01, -1, TF_NORMAL, es2, 128);
			Screen->DrawString(0, 96, 104+56-i, FONT_Z1, 0x01, -1, TF_NORMAL, es3, 128);
			Screen->DrawString(0, 32, 120+56-i, FONT_Z1, 0x01, -1, TF_NORMAL, es4, 128);
			Screen->DrawString(0, 48, 144+56-i, FONT_Z1, 0x01, -1, TF_NORMAL, es5, 128);
			Screen->DrawBitmap(0, RT_FAKEASSENDING, 0, 0, 256, 56, 0, -i, 256, 56, 0, true);
			
			Screen->DrawBitmap(0, RT_FAKEASSENDING, 256, 0, 208, 352, 24, 184+56-i, 208, 352, 0, true);
			
			Screen->DrawString(0, 128, 184+352+64+56-i, FONT_Z1, 0x01, -1, TF_CENTERED, c13, 128);
			Screen->DrawString(0, 128, 184+352+64+16+56-i, FONT_Z1, 0x01, -1, TF_CENTERED, c14, 128);
			Screen->DrawString(0, 128, 184+352+64+40+56-i, FONT_Z1, 0x01, -1, TF_CENTERED, c15, 128);
			
			Screen->DrawTile(0, 112, 184+352+64+40+32+56-i, 4975, 2, 2, 10, -1, -1, 0, 0, 0, 0, true, 128);
			
			Screen->SetRenderTarget(RT_SCREEN);
			
			Screen->DrawBitmap(7, RT_FAKEASSENDING2, 0, 0, 256, 256, 0, -56, 256, 256, 0, false);
			
			skip = PressSkipEnding();
			Q7_WaitNoAction();
		}
		
		for(j=0; j<120&&!skip; j++){
			Screen->SetRenderTarget(RT_FAKEASSENDING2);
			Screen->Rectangle(0, 0, 0, 255, 255, 0x0F, 1, 0, 0, 0, true, 128);
			
			Screen->DrawString(0, 32, 40+56-i, FONT_Z1, 0x01, -1, TF_NORMAL, es1, 128);
			Screen->DrawString(0, 32, 56+56-i, FONT_Z1, 0x01, -1, TF_NORMAL, es2, 128);
			Screen->DrawString(0, 96, 104+56-i, FONT_Z1, 0x01, -1, TF_NORMAL, es3, 128);
			Screen->DrawString(0, 32, 120+56-i, FONT_Z1, 0x01, -1, TF_NORMAL, es4, 128);
			Screen->DrawString(0, 48, 144+56-i, FONT_Z1, 0x01, -1, TF_NORMAL, es5, 128);
			Screen->DrawBitmap(0, RT_FAKEASSENDING, 0, 0, 256, 56, 0, -i, 256, 56, 0, true);
			
			Screen->DrawBitmap(0, RT_FAKEASSENDING, 256, 0, 208, 352, 24, 184+56-i, 208, 352, 0, true);
			
			Screen->DrawString(0, 128, 184+352+64+56-i, FONT_Z1, 0x01, -1, TF_CENTERED, c13, 128);
			Screen->DrawString(0, 128, 184+352+64+16+56-i, FONT_Z1, 0x01, -1, TF_CENTERED, c14, 128);
			Screen->DrawString(0, 128, 184+352+64+40+56-i, FONT_Z1, 0x01, -1, TF_CENTERED, c15, 128);
			
			Screen->DrawTile(0, 112, 184+352+64+40+32+56-i, 4975, 2, 2, 10, -1, -1, 0, 0, 0, 0, true, 128);
			
			Screen->SetRenderTarget(RT_SCREEN);
			
			Screen->DrawBitmap(7, RT_FAKEASSENDING2, 0, 0, 256, 256, 0, -56, 256, 256, 0, false);
			
			skip = PressSkipEnding();
			Q7_WaitNoAction();
		}
		
		//Glass shard stuff
		int CPX[56];
		int CPY[56];
		int CPZ[56];
		int AngA[56];
		int AngB[56];
		int AngC[56];
		int DA[56];
		int DB[56];
		int DC[56];
		int BaseAngA[56];
		int BaseAngB[56];
		int RotA[56];
		int RotB[56];
		int VX[56];
		int VY[56];
		int shardState[56];
		int crackW[56];
		
		for(j=0; j<56&&!skip; j++){
			crackW[j] = Rand(0, 3);
		}
		
		int shardVars[] = {CPX, CPY, CPZ, AngA, AngB, AngC, DA, DB, DC, BaseAngA, BaseAngB, RotA, RotB, VX, VY, shardState, 56, crackW};
		
		GlassWipe_Init(RT_FAKEASSGLASS, shardVars);
		
		Game->PlayMIDI(0);
		Game->PlaySound(SFX_GLASSCRACK);
		for(j=0; j<40&&!skip; j++){
			Screen->SetRenderTarget(RT_FAKEASSENDING2);
			Screen->Rectangle(0, 0, 0, 255, 255, 0x0F, 1, 0, 0, 0, true, 128);
			
			Screen->DrawString(0, 32, 40+56-i, FONT_Z1, 0x01, -1, TF_NORMAL, es1, 128);
			Screen->DrawString(0, 32, 56+56-i, FONT_Z1, 0x01, -1, TF_NORMAL, es2, 128);
			Screen->DrawString(0, 96, 104+56-i, FONT_Z1, 0x01, -1, TF_NORMAL, es3, 128);
			Screen->DrawString(0, 32, 120+56-i, FONT_Z1, 0x01, -1, TF_NORMAL, es4, 128);
			Screen->DrawString(0, 48, 144+56-i, FONT_Z1, 0x01, -1, TF_NORMAL, es5, 128);
			Screen->DrawBitmap(0, RT_FAKEASSENDING, 0, 0, 256, 56, 0, -i, 256, 56, 0, true);
			
			Screen->DrawBitmap(0, RT_FAKEASSENDING, 256, 0, 208, 352, 24, 184+56-i, 208, 352, 0, true);
			
			Screen->DrawString(0, 128, 184+352+64+56-i, FONT_Z1, 0x01, -1, TF_CENTERED, c13, 128);
			Screen->DrawString(0, 128, 184+352+64+16+56-i, FONT_Z1, 0x01, -1, TF_CENTERED, c14, 128);
			Screen->DrawString(0, 128, 184+352+64+40+56-i, FONT_Z1, 0x01, -1, TF_CENTERED, c15, 128);
			
			Screen->DrawTile(0, 112, 184+352+64+40+32+56-i, 4975, 2, 2, 10, -1, -1, 0, 0, 0, 0, true, 128);
			
			Screen->SetRenderTarget(RT_SCREEN);
			
			Screen->DrawBitmap(7, RT_FAKEASSENDING2, 0, 0, 256, 256, 0, -56, 256, 256, 0, false);
			
			GlassWipe_DrawCracks(7, shardVars);
			
			Q7_WaitNoAction();
		}
		
		Game->PlaySound(SFX_GLASSHATTER);
		while(shardVars[16]>0&&!skip){	
			//Draw the new screen to the bitmap
			Screen->SetRenderTarget(RT_FAKEASSGLASS);
			Screen->Rectangle(0, 0, 0, 255, 255, 0x01, 1, 0, 0, 0, true, 128);
			
			//Draw the old screen to the screen
			Screen->SetRenderTarget(RT_SCREEN);
			
			Screen->SetRenderTarget(RT_FAKEASSENDING2);
			Screen->Rectangle(0, 0, 0, 255, 255, 0x0F, 1, 0, 0, 0, true, 128);
			
			Screen->DrawString(0, 32, 40+56-i, FONT_Z1, 0x01, -1, TF_NORMAL, es1, 128);
			Screen->DrawString(0, 32, 56+56-i, FONT_Z1, 0x01, -1, TF_NORMAL, es2, 128);
			Screen->DrawString(0, 96, 104+56-i, FONT_Z1, 0x01, -1, TF_NORMAL, es3, 128);
			Screen->DrawString(0, 32, 120+56-i, FONT_Z1, 0x01, -1, TF_NORMAL, es4, 128);
			Screen->DrawString(0, 48, 144+56-i, FONT_Z1, 0x01, -1, TF_NORMAL, es5, 128);
			Screen->DrawBitmap(0, RT_FAKEASSENDING, 0, 0, 256, 56, 0, -i, 256, 56, 0, true);
			
			Screen->DrawBitmap(0, RT_FAKEASSENDING, 256, 0, 208, 352, 24, 184+56-i, 208, 352, 0, true);
			
			Screen->DrawString(0, 128, 184+352+64+56-i, FONT_Z1, 0x01, -1, TF_CENTERED, c13, 128);
			Screen->DrawString(0, 128, 184+352+64+16+56-i, FONT_Z1, 0x01, -1, TF_CENTERED, c14, 128);
			Screen->DrawString(0, 128, 184+352+64+40+56-i, FONT_Z1, 0x01, -1, TF_CENTERED, c15, 128);
			
			Screen->DrawTile(0, 112, 184+352+64+40+32+56-i, 4975, 2, 2, 10, -1, -1, 0, 0, 0, 0, true, 128);
			
			Screen->SetRenderTarget(RT_SCREEN);
			
			Screen->DrawBitmap(7, RT_FAKEASSENDING2, 0, 0, 256, 256, 0, -56, 256, 256, 0, false);
			
			//Erase the triangles from the bitmap
			GlassWipe_Update(7, RT_FAKEASSGLASS, 128, 88, 512, 4, 0.08, shardVars);
			
			//Draw the bitmap to the screen
			Screen->DrawBitmap(7, RT_FAKEASSGLASS, 0, 0, 256, 256, 0, -56, 256, 256, 0, true);
			Q7_WaitNoAction();
		}
	
		int pixOrder[64];
		for(i=0; i<64; i++){
			pixOrder[i] = i;
		}
		for(i=0; i<256; i++){
			k = Rand(64);
			m = Rand(64);
			j = pixOrder[k];
			pixOrder[k] = pixOrder[m];
			pixOrder[m] = j;
		}
		
		Link->Dir = DIR_UP;
		Link->Warp(18, 0x33);
		Screen->Rectangle(7, 0, 0, 255, 175, 0x01, 1, 0, 0, 0, true, 128);
		Q7_WaitNoAction();
		
		Screen->SetRenderTarget(RT_FAKEASSGLASS);
		Screen->Rectangle(0, 0, 0, 255, 255, 0x01, 1, 0, 0, 0, true, 128);
		Screen->SetRenderTarget(RT_SCREEN);
		for(i=0; i<600; i+=5){
			Screen->SetRenderTarget(RT_FAKEASSGLASS);
			for(j=0; j<256; j++){
				k = i-(j%16)*16-Floor(j/16)*16;
				if(k>=0&&k<=64){
					k = (k+j)%64;
					for(m=0; m<4; m++){
						k = (k+m*16)%64;
						x = (j%16)*16+(pixOrder[k]%8)*2;
						y = Floor(j/16)*16+Floor(pixOrder[k]/8)*2;
						Screen->Circle(0, x, y, Rand(2, 4), 0x00, 1, 0, 0, 0, true, 128);
					}
				}
			}
			Screen->SetRenderTarget(RT_SCREEN);
			Screen->DrawLayer(6, 17, 0x6F, 0, 0, 0, 0, 128);
			Screen->DrawScreen(6, 14, 0x4E, 0, 0, 0);
			Screen->DrawBitmap(7, RT_FAKEASSGLASS, 0, 0, 256, 256, 0, -56, 256, 256, 0, true);
			Q7_WaitNoAction();
		}
		
		Bannon_ClearLayer2();
		int inevitabilis[] = "Inevitabilis.nsf";
		G[G_NODRAWSUBSCREEN] = 0;
		Game->PlayEnhancedMusic(inevitabilis, 0);
		for(i=0; i<40; i++){
			if(i==20)
				Screen->Message(156);
			Screen->DrawLayer(6, 17, 0x6F, 0, 0, 0, 0, 128);
			Screen->DrawScreen(6, 14, 0x4E, 0, 0, 0);
			Q7_WaitNoAction();
		}
		for(i=0; i<176; i+=2){
			Screen->DrawLayer(6, 17, 0x6F, 0, 0, i, 0, 128);
			Screen->DrawScreen(6, 14, 0x4E, 0, i, 0);
			Screen->DrawLayer(6, 17, 0x6F, 0, 0, -176+i, 0, 128);
			Screen->DrawScreen(6, 14, 0x3E, 0, -176+i, 0);
			Q7_DrawLinkToLayer(6, Link->X, Link->Y-176+i);
			Screen->FastCombo(6, Link->X, Link->Y-176+i-16, 439, 7, 128);
			if(G[G_ANIM]%16==0){
				if(Rand(2))
					Link->Dir = RotDirCCW4(Link->Dir);
				else 
					Link->Dir = RotDirCW4(Link->Dir);
			}
			Q7_WaitNoAction();
		}
		for(i=0; i<176; i+=2){
			Screen->DrawLayer(6, 17, 0x6F, 0, 0, i, 0, 128);
			Screen->DrawScreen(6, 14, 0x3E, 0, i, 0);
			Screen->DrawLayer(6, 17, 0x6F, 0, 0, -176+i, 0, 128);
			Screen->DrawScreen(6, 14, 0x2E, 0, -176+i, 0);
			Q7_DrawLinkToLayer(6, Link->X, Link->Y+i);
			Screen->FastCombo(6, Link->X, Link->Y+i-16, 439, 7, 128);
			if(G[G_ANIM]%16==0){
				if(Rand(2))
					Link->Dir = RotDirCCW4(Link->Dir);
				else 
					Link->Dir = RotDirCW4(Link->Dir);
			}
			Q7_WaitNoAction();
		}
		for(i=0; i<30; i++){
			Screen->DrawLayer(6, 17, 0x6F, 0, 0, 0, 0, 128);
			Screen->DrawScreen(6, 14, 0x2E, 0, 0, 0);
			Q7_WaitNoAction();
		}
		Game->PlaySound(SFX_SUMMON);
		for(i=0; i<30; i++){
			Screen->DrawLayer(6, 17, 0x6F, 0, 0, 0, 0, 128);
			Screen->DrawScreen(6, 14, 0x2E, 0, 0, 0);
			if(i%4<2)
				Screen->DrawCombo(6, 112, 96, 2837, 2, 2, 10, -1, -1, 0, 0, 0, 0, 0, true, 128);
			Q7_WaitNoAction();
		}
		for(i=0; i<20; i++){
			if(i==19)
				Screen->Message(157);
			Screen->DrawLayer(6, 17, 0x6F, 0, 0, 0, 0, 128);
			Screen->DrawScreen(6, 14, 0x2E, 0, 0, 0);
			Screen->DrawCombo(6, 112, 96, 2837, 2, 2, 10, -1, -1, 0, 0, 0, 0, 0, true, 128);
			Q7_WaitNoAction();
		}
		Game->PlayEnhancedMusic(finalBossTrack, 0);
		int effectsScript[] = "Bannon_Effects";
		for(i=0; i<40; i++){
			Screen->DrawLayer(6, 17, 0x6F, 0, 0, 0, 0, 128);
			Q7_DrawTileC(6, 128, 64+80-2*i, 6512, 3, 3, 9, -1, -1, 0, 0, 0, 0, true, 128);
			Screen->DrawScreen(6, 14, 0x2E, 0, 0, 0);
			Screen->DrawCombo(6, 112, 96, 2837, 2, 2, 10, -1, -1, 0, 0, 0, 0, 0, true, 128);
			Q7_WaitNoAction();
		}
		for(j=0; j<3; j++){
			for(i=0; i<30; i++){
				Screen->DrawLayer(6, 17, 0x6F, 0, 0, 0, 0, 128);
				Q7_DrawTileC(6, 128+Rand(-1, 1), 64+Rand(-1, 1), 6512, 3, 3, 9, -1, -1, 0, 0, 0, 0, true, 128);
				Screen->DrawScreen(6, 14, 0x2E, 0, 0, 0);
				Screen->DrawCombo(6, 112, 96, 2841, 2, 2, 10, -1, -1, 0, 0, 0, 0, 0, true, 128);
				Q7_WaitNoAction();
			}
			x = 128;
			y = 64;
			x2 = 128+Rand(-48, 48);
			y2 = -32;
			
			Q7_RunFFCScript(effectsScript, 1, x, y, x2, y2, 24, 8, 12);
			for(i=0; i<30; i++){
				Screen->DrawLayer(6, 17, 0x6F, 0, 0, 0, 0, 128);
				Q7_DrawTileC(6, 128, 64, 6512, 3, 3, 9, 48+48*Sin(180/30*i), 48+48*Sin(180/30*i), 0, 0, 0, 0, true, 64);
				Q7_DrawTileC(6, 128, 64, 6512, 3, 3, 9, 48+8*Sin(180/30*i), 48+8*Sin(180/30*i), 0, 0, 0, 0, true, 128);
				Screen->DrawScreen(6, 14, 0x2E, 0, 0, 0);
				Screen->DrawCombo(6, 112, 96, 2841, 2, 2, 10, -1, -1, 0, 0, 0, 0, 0, true, 128);
				Q7_WaitNoAction();
			}
		}
		for(i=0; i<60; i++){
			Screen->DrawLayer(6, 17, 0x6F, 0, 0, 0, 0, 128);
			j = 2+4*(i/60);
			Q7_DrawTileC(6, 128+Rand(-j, j), 64+Rand(-j, j)-24*(i/60), 6512, 3, 3, 9, -1, -1, 0, 0, 0, 0, true, 128);
			Screen->DrawScreen(6, 14, 0x2E, 0, 0, 0);
			Screen->DrawCombo(6, 112, 96, 2841, 2, 2, 10, -1, -1, 0, 0, 0, 0, 0, true, 128);
			Q7_WaitNoAction();
		}
		
		for(i=0; i<60; i++){
			if(i%4==0){
				x = 128+Rand(-16, 16);
				y = 64-24+Rand(-16, 16);
				x2 = 128+Rand(-64, 64);
				y2 = -Rand(32, 64);
				Q7_RunFFCScript(effectsScript, 1, x, y, x2, y2, 24, 8, 12);
			}
			Screen->DrawLayer(6, 17, 0x6F, 0, 0, 0, 0, 128);
			Q7_DrawTileC(6, 128, 64-24, 6512, 3, 3, 9, 48+48*Sin(90/60*i), 48+48*Sin(90/60*i), 0, 0, 0, 0, true, 64);
			Q7_DrawTileC(6, 128, 64-24, 6512, 3, 3, 9, 48+8*Sin(90/60*i), 48+8*Sin(90/60*i), 0, 0, 0, 0, true, 128);
			Screen->DrawScreen(6, 14, 0x2E, 0, 0, 0);
			Screen->DrawCombo(6, 112, 96, 2841, 2, 2, 10, -1, -1, 0, 0, 0, 0, 0, true, 128);
			Screen->Rectangle(7, 0, 0, 255, 175, 0x01, 1, 0, 0, 0, true, 64);
			Q7_WaitNoAction();
		}
		for(i=0; i<20; i++){
			Screen->Rectangle(7, 0, 0, 255, 175, 0x01, 1, 0, 0, 0, true, 128);
			Q7_WaitNoAction();
		}
		Screen->D[7] = 1;
		for(i=0; i<20; i++){
			Screen->DrawLayer(6, 17, 0x6F, 0, 0, 0, 0, 128);
			Screen->DrawScreen(6, 14, 0x2E, 0, 0, 0);
			Screen->DrawTile(6, 104, 24, 6826, 3, 3, 9, -1, -1, 0, 0, 0, 0, true, 128);
			Screen->DrawCombo(6, 112, 96, 2841, 2, 2, 10, -1, -1, 0, 0, 0, 0, 0, true, 128);
			Screen->Rectangle(7, 0, 0, 255, 175, 0x01, 1, 0, 0, 0, true, 64);
			Q7_WaitNoAction();
		}
		
		int adjeanRamblingsA[] = "A CREATURE BORN OF THE MOST POWERFUL AND WICKED SOULS TO EVER LIVE, WHO EVEN THE GODDESS HERSELF FEARED...";
		int adjeanRamblingsB[] = "THAT IS THE NIGHTMARE OF HYLIA:@N@N@N@81THE DARK BEAST BANNON!";
		
		int lineStart[256];
		int lineEnd[256];
		int lineStartColor[256];
		int strDat[6] = {lineStart, lineEnd, 0x01, 0, 12, 1};
		Q7_DrawStringSP_Prep(strDat, 224, adjeanRamblingsA);
		
		y = 96;
		for(i=0; i<40; i++){
			Screen->DrawLayer(6, 17, 0x6F, 0, 0, 0, 0, 128);
			Screen->DrawScreen(6, 14, 0x2E, 0, 0, 0);
			Screen->DrawTile(6, 104, 24, 6826, 3, 3, 9, -1, -1, 0, 0, 0, 0, true, 128);
			Screen->DrawCombo(6, 112, 96, 2841, 2, 2, 10, -1, -1, 0, 0, 0, 0, 0, true, 128);
			
			Q7_WaitNoAction();
		}
		for(i=0; i<240; i++){
			if(i<30)
				y -= 1;
			else
				y -= 0.25;
			Screen->DrawLayer(6, 17, 0x6F, 0, 0, 0, 0, 128);
			Screen->DrawScreen(6, 14, 0x2E, 0, 0, 0);
			Screen->DrawTile(6, 104, 24, 6826, 3, 3, 9, -1, -1, 0, 0, 0, 0, true, 128);
			Screen->DrawCombo(6, 112, 96, 2841, 2, 2, 10, -1, -1, 0, 0, 0, 0, 0, true, 128);
			
			Screen->Rectangle(7, 0, 0, 255, 175, 0x0F, 1, 0, 0, 0, true, 64);
			if(i>20&&i<220||i%4<2)
				Q7_DrawStringSP(strDat, 7, 128, y, 224, TF_CENTERED, adjeanRamblingsA);
		
			Q7_WaitNoAction();
		}
		y = 96;
		Q7_DrawStringSP_Prep(strDat, 224, adjeanRamblingsB);
		for(i=0; i<240; i++){
			if(i<30)
				y -= 1;
			else
				y -= 0.25;
			Screen->DrawLayer(6, 17, 0x6F, 0, 0, 0, 0, 128);
			Screen->DrawScreen(6, 14, 0x2E, 0, 0, 0);
			Screen->DrawTile(6, 104, 24, 6826, 3, 3, 9, -1, -1, 0, 0, 0, 0, true, 128);
			Screen->DrawCombo(6, 112, 96, 2841, 2, 2, 10, -1, -1, 0, 0, 0, 0, 0, true, 128);
			
			Screen->Rectangle(7, 0, 0, 255, 175, 0x0F, 1, 0, 0, 0, true, 64);
			if(i>20&&i<220||i%4<2)
				Q7_DrawStringSP(strDat, 7, 128, y, 224, TF_CENTERED, adjeanRamblingsB);
		
			Q7_WaitNoAction();
		}
		for(i=0; i<30; i++){
			Screen->DrawLayer(6, 17, 0x6F, 0, 0, 0, 0, 128);
			Screen->DrawScreen(6, 14, 0x2E, 0, 0, 0);
			Screen->DrawTile(6, 104, 24, 6826, 3, 3, 9, -1, -1, 0, 0, 0, 0, true, 128);
			Screen->DrawCombo(6, 112, 96, 2841, 2, 2, 10, -1, -1, 0, 0, 0, 0, 0, true, 128);
			
			Q7_WaitNoAction();
		}
		int dashColors[] = {0x9F, 0x96, 0x97};
		int dashSeed[2];
		dashSeed[0] = Rand(256);
		dashSeed[1] = Rand(256);
		Game->PlaySound(SFX_SWORD);
		for(i=0; i<4; i++){
			Screen->DrawLayer(6, 17, 0x6F, 0, 0, 0, 0, 128);
			Screen->DrawScreen(6, 14, 0x2E, 0, 0, 0);
			Q7_DrawSpeedLines(dashSeed, 6, 104, 24, 112, 96, 48, 48, 16, dashColors);
			Screen->DrawCombo(6, 112, 96, 2841, 2, 2, 10, -1, -1, 0, 0, 0, 0, 0, true, 128);
			
			Q7_WaitNoAction();
		}
		Game->PlaySound(SFX_PLACE);
		for(i=0; i<4; i++){
			Screen->DrawLayer(6, 17, 0x6F, 0, 0, 0, 0, 128);
			Screen->DrawScreen(6, 14, 0x2E, 0, 0, 0);
			Screen->DrawTile(6, 112, 64, 6829, 3, 3, 9, -1, -1, 0, 0, 0, 0, true, 128);
			Screen->DrawCombo(6, 112, 96, 2841, 2, 2, 10, -1, -1, 0, 0, 0, 0, 0, true, 128);
			
			Q7_WaitNoAction();
		}
		for(i=0; i<4; i++){
			Screen->DrawLayer(6, 17, 0x6F, 0, 0, 0, 0, 128);
			Screen->DrawScreen(6, 14, 0x2E, 0, 0, 0);
			Screen->DrawTile(6, 112, 64, 6889, 3, 3, 9, -1, -1, 0, 0, 0, 0, true, 128);
			Screen->DrawCombo(6, 144, 56, 2837, 2, 2, 10, -1, -1, 0, 0, 0, 0, 0, true, 128);
			
			Q7_WaitNoAction();
		}
		for(i=0; i<40; i++){
			Screen->DrawLayer(6, 17, 0x6F, 0, 0, 0, 0, 128);
			Screen->DrawScreen(6, 14, 0x2E, 0, 0, 0);
			Screen->DrawTile(6, 112, 64, 6832, 3, 3, 9, -1, -1, 0, 0, 0, 0, true, 128);
			Screen->DrawCombo(6, 120, 56, 2832, 2, 2, 10, -1, -1, 0, 0, 0, 0, 0, true, 128);
			
			Q7_WaitNoAction();
		}
		int adjeanSplatterAngles[] = {-200, 20, -160, -20, -140, -40};
		int adjeanSplatterSteps[] = {1, 1, 0.4, 0.4, 1.2, 1.2};
		int adjeanSplatterFlip[] = {2, 3, 0, 1, 0, 1};
		Game->PlaySound(SFX_GASP);
		Game->PlaySound(SFX_EDEAD);
		for(i=0; i<120; i++){
			Screen->DrawLayer(6, 17, 0x6F, 0, 0, 0, 0, 128);
			Screen->DrawScreen(6, 14, 0x2E, 0, 0, 0);
			
			Screen->Rectangle(7, 0, 0, 255, 175, 0x01, 1, 0, 0, 0, true, 64);
			if(i>8&&i<112)
				Screen->Rectangle(7, 0, 0, 255, 175, 0x01, 1, 0, 0, 0, true, 128);
			
			Screen->DrawTile(7, 112, 64, 6835, 3, 3, 9, -1, -1, 0, 0, 0, 0, true, 128);
			
			if(i<60)
				Screen->DrawTile(7, 120, 56, 5040+2*Floor(i/20), 2, 2, 9, -1, -1, 0, 0, 0, 0, true, 128);
			for(j=0; j<3; j++){
				step = adjeanSplatterSteps[j*2];
				angle = adjeanSplatterAngles[j*2];
				Screen->DrawTile(7, 120+VectorX(step*i*0.5, angle), 64+VectorY(step*i*0.5, angle), 5081, 1, 1, 9, -1, -1, 0, 0, 0, adjeanSplatterFlip[j*2], true, 128);
				
				step = adjeanSplatterSteps[j*2+1];
				angle = adjeanSplatterAngles[j*2+1];
				Screen->DrawTile(7, 136+VectorX(step*i*0.5, angle), 64+VectorY(step*i*0.5, angle), 5081, 1, 1, 9, -1, -1, 0, 0, 0, adjeanSplatterFlip[j*2+1], true, 128);
			}
			
			Q7_WaitNoAction();
		}
		
		Link->Dir = DIR_UP;
		for(i=0; i<176; i+=2){
			Screen->DrawLayer(6, 17, 0x6F, 0, 0, -i, 0, 128);
			Screen->DrawScreen(6, 14, 0x2E, 0, -i, 0);
			Screen->DrawLayer(6, 17, 0x6F, 0, 0, 176-i, 0, 128);
			Screen->DrawScreen(6, 14, 0x3E, 0, 176-i, 0);
			
			angle = Angle(112, 64, 104, 16);
			step = Distance(112, 64, 104, 16);
			x = 112+VectorX(step*(i/176), angle);
			y = 64+VectorY(step*(i/176), angle);
			Screen->DrawTile(6, x, y, 6775, 3, 3, 9, -1, -1, 0, 0, 0, 0, true, 128);
			if(i/176<0.3333)
				Screen->DrawTile(6, x, y, 6835, 3, 3, 9, -1, -1, 0, 0, 0, 0, true, 64);
			if(i/176<0.6666)
				Screen->DrawTile(6, x, y, 6835, 3, 3, 9, -1, -1, 0, 0, 0, 0, true, 64);
			
			
			Q7_DrawLinkToLayer(6, Link->X, Link->Y+176-i);
			
			Q7_WaitNoAction();
		}
		Screen->D[7] = 0;
		n = CreateNPCAt(316, 104+16, 16+16);
		
		G[G_SAWBANNONCUTSCENE] = 1;
		
		this->Flags[FFCF_CARRYOVER] = false;
	}
	void FakeAssSubscreen(int x, int y){
		int i;
		
		Screen->Rectangle(0, x, y, x+255, y+55, 0x00, 1, 0, 0, 0, true, 128);
		
		Screen->DrawTile(0, 16, 0, 2029, 4, 2, 0, -1, -1, 0, 0, 0, 0, true, 128);
		
		Screen->FastTile(0, 88, 16, 2033, 8, 128);
		if(Game->Counter[CR_RUPEES]>99){
			Screen->DrawInteger(0, 88+8, 16, FONT_Z1, 0x01, -1, -1, -1, Game->Counter[CR_RUPEES], 0, 128);
		}
		else{
			Screen->DrawCharacter(0, 88+8, 16, FONT_Z1, 0x01, -1, -1, -1, 'X', 128);
			Screen->DrawInteger(0, 88+16, 16, FONT_Z1, 0x01, -1, -1, -1, Game->Counter[CR_RUPEES], 0, 128);
		}
		Screen->FastTile(0, 88, 16+16, 2034, 8, 128);
		if(Game->Counter[CR_KEYS]>99){
			Screen->DrawInteger(0, 88+8, 16+16, FONT_Z1, 0x01, -1, -1, -1, Game->Counter[CR_KEYS], 0, 128);
		}
		else{
			Screen->DrawCharacter(0, 88+8, 16+16, FONT_Z1, 0x01, -1, -1, -1, 'X', 128);
			Screen->DrawInteger(0, 88+16, 16+16, FONT_Z1, 0x01, -1, -1, -1, Game->Counter[CR_KEYS], 0, 128);
		}
		Screen->FastTile(0, 88, 16+24, 2035, 7, 128);
		Screen->DrawCharacter(0, 88+8, 16+24, FONT_Z1, 0x01, -1, -1, -1, 'X', 128);
		Screen->DrawInteger(0, 88+16, 16+24, FONT_Z1, 0x01, -1, -1, -1, Game->Counter[CR_KEYS], 0, 128);
	
		Screen->DrawTile(0, 120, 16, 1949, 3, 2, 0, -1, -1, 0, 0, 0, 0, true, 128);
	
		int life[] = "-LIFE-";
		Screen->DrawString(0, 208, 16, FONT_Z1, 0x81, -1, TF_CENTERED, life, 128);
		
		int maxHeart = Floor(Link->MaxHP/16);
		int capHeart = Floor(Link->HP/16);
	
		int tmpX; int tmpY;
		for(i=0; i<maxHeart; i++){
			tmpX = 176+8*(i%8);
			tmpY = 40;
			if(i>7)
				tmpY = 32;
			if(i<capHeart)
				Screen->FastTile(0, tmpX, tmpY, 2057, 8, 128);
			else if(i>capHeart)
				Screen->FastTile(0, tmpX, tmpY, 2053, 8, 128);
			else
				Screen->FastTile(0, tmpX, tmpY, 2053+Floor((Link->HP%16)/4), 8, 128);
		}
		
		if(Link->Item[I_CRIT4])
			Screen->FastTile(0, 208, 32, 851, 10, 128);
		if(Link->Item[I_CRIT3])
			Screen->FastTile(0, 216, 32, 851, 10, 128);
		if(Link->Item[I_CRIT2])
			Screen->FastTile(0, 224, 32, 851, 10, 128);
		if(Link->Item[I_CRIT1])
			Screen->FastTile(0, 232, 32, 851, 10, 128);
	}
	void GlassWipe_Init(int rt, int vars){
		int CPX = vars[0];
		int CPY = vars[1];
		int CPZ = vars[2];
		int AngA = vars[3];
		int AngB = vars[4];
		int AngC = vars[5];
		int DA = vars[6];
		int DB = vars[7];
		int DC = vars[8];
		
		int PointX[40];
		int PointY[40];
		int i;
		for(i=0; i<40; i++){
			PointX[i] = -48+48*(i%8)+(Floor(i/8)%2)*0.5*48;
			PointY[i] = -16+Floor(i/8)*48;
			PointX[i] += Rand(-8, 8);
			PointY[i] += Rand(-8, 8);
		}
		int TA[56];
		int TB[56];
		int TC[56];
		for(i=0; i<7; i++){
			TA[i] = i;
			TB[i] = i+1;
			TC[i] = i+8;
		}
		for(i=0; i<7; i++){
			TA[7+i] = i+1;
			TB[7+i] = 8+i;
			TC[7+i] = 8+i+1;
		}
		for(i=0; i<7; i++){
			TA[14+i] = 8+i;
			TB[14+i] = 8+i+1;
			TC[14+i] = 8+i+9;
		}
		for(i=0; i<7; i++){
			TA[21+i] = 8+i;
			TB[21+i] = 16+i;
			TC[21+i] = 16+i+1;
		}
		for(i=0; i<7; i++){
			TA[28+i] = 16+i;
			TB[28+i] = 16+i+1;
			TC[28+i] = 16+i+8;
		}
		for(i=0; i<7; i++){
			TA[35+i] = 16+i+1;
			TB[35+i] = 24+i;
			TC[35+i] = 24+i+1;
		}
		for(i=0; i<7; i++){
			TA[42+i] = 24+i;
			TB[42+i] = 24+i+1;
			TC[42+i] = 24+i+9;
		}
		for(i=0; i<7; i++){
			TA[49+i] = 24+i;
			TB[49+i] = 32+i;
			TC[49+i] = 32+i+1;
		}
		int BaseAngA[56];
		int BaseAngB[56];
		int RotA[56];
		int RotB[56];
		int VX[56];
		int VY[56];
		Screen->SetRenderTarget(rt);
		Screen->Rectangle(0, 0, 0, 255, 175, 0x0F, 1, 0, 0, 0, true, 128);
		Screen->SetRenderTarget(RT_SCREEN);
		for(i=0; i<56; i++){
			CPX[i] = (PointX[TA[i]]+PointX[TB[i]]+PointX[TC[i]])/3;
			CPY[i] = (PointY[TA[i]]+PointY[TB[i]]+PointY[TC[i]])/3;
			AngA[i] = Angle(CPX[i], CPY[i], PointX[TA[i]], PointY[TA[i]]);
			AngB[i] = Angle(CPX[i], CPY[i], PointX[TB[i]], PointY[TB[i]]);
			AngC[i] = Angle(CPX[i], CPY[i], PointX[TC[i]], PointY[TC[i]]);
			DA[i] = Distance(CPX[i], CPY[i], PointX[TA[i]], PointY[TA[i]])+1;
			DB[i] = Distance(CPX[i], CPY[i], PointX[TB[i]], PointY[TB[i]])+1;
			DC[i] = Distance(CPX[i], CPY[i], PointX[TC[i]], PointY[TC[i]])+1;
			VX[i] = VectorX(Distance(128, 88, CPX[i], CPY[i])/120, Angle(128, 88, CPX[i], CPY[i]));
			VY[i] = VectorY(Distance(128, 88, CPX[i], CPY[i])/80, Angle(128, 88, CPX[i], CPY[i]));
		}
	}
	//Erases triangles from the bitmap
	//Call every frame until vars[16] is less than or equal to 0.
	//Layer - The layer to draw to
	//rt - The bitmap to use (RT_ constants in std_constants.zh)
	//cx,cy - Center point for the shatter effect
	//radius - How far from the shatter point to activate shards
	//shardSpeed - How fast the shards should move in pixels per frame, not accounting for gravity
	void GlassWipe_Update(int layer, int rt, int cx, int cy, int radius, float shardSpeed, float gravity, int vars){
		int i;
		
		int CPX = vars[0];
		int CPY = vars[1];
		int CPZ = vars[2];
		int AngA = vars[3];
		int AngB = vars[4];
		int AngC = vars[5];
		int DA = vars[6];
		int DB = vars[7];
		int DC = vars[8];
		int BaseAngA = vars[9];
		int BaseAngB = vars[10];
		int RotA = vars[11];
		int RotB = vars[12];
		int VX = vars[13];
		int VY = vars[14];
		int shardState = vars[15];
		int numShards = 56;
		
		// Screen->Rectangle(Layer, -8, -8, 264, 184, 0x0F, 1, 0, 0, 0, true, 128);
		// Screen->DrawScreen(Layer, OldMap, OldScreen, 0, 0, 0);
		// Screen->DrawBitmap(Layer, rt, 0, 0, 256, 176, 0, 0, 256, 176, 0, true);
		// Screen->SetRenderTarget(rt);
		// Screen->Rectangle(6, -8, -8, 264, 184, 0x0F, 1, 0, 0, 0, true, 128);
		// Screen->DrawScreen(6, NewMap, NewScreen, 0, 0, 0);
		Screen->SetRenderTarget(rt);
		int X[3];
		int Y[3];
		int Z[3];
		for(i=0; i<56; i++){
			if(shardState[i]==0&&Distance(CPX[i], CPY[i], cx, cy)<radius){
				shardState[i] = 1;
				int angle = Angle(cx, cy, CPX[i], CPY[i])+Rand(-30, 30);
				int step = shardSpeed*Rand(10, 20)/10;
				VX[i] = VectorX(step, angle);
				VY[i] = VectorY(step, angle);
				RotA[i] = Choose(-1, 1)*Rand(5, 50)/10;
				RotB[i] = Choose(-1, 1)*Rand(5, 50)/10;
			}
			if(shardState[i]==1){
				if(CPX[i]>-48&&CPX[i]<304&&CPY[i]>-48&&CPY[i]<288){
					CPX[i] += VX[i];
					CPY[i] += VY[i];
					VY[i] = Min(VY[i]+gravity, 3.2); //Gravity - 0.6
				}
				else{
					numShards--;
				}
				BaseAngA[i] += RotA[i];
				BaseAngB[i] += RotB[i];
			}
			
			int freshprinceofdickbutt = 90;
			//you tread upon the hall of the forbidden Mathemancy. Nobody knows how it works. Well someone might. But it isn't Moosh.
			int x0; int y0; int z0; int xtmp;
			x0 = DA[i]*Sin(freshprinceofdickbutt)*Cos(AngA[i]);
			y0 = DA[i]*Sin(freshprinceofdickbutt)*Sin(AngA[i]);
			z0 = DA[i]*Cos(freshprinceofdickbutt);
			X[0] = x0;
			Y[0] = y0*Cos(BaseAngA[i])-z0*Sin(BaseAngA[i]);
			Z[0] = y0*Sin(BaseAngA[i])+z0*Cos(BaseAngA[i]);
			xtmp = X[0];
			X[0] = X[0]*Cos(BaseAngB[i])+Z[0]*Sin(BaseAngB[i]);
			Z[0] = -xtmp*Sin(BaseAngB[i])+Z[0]*Cos(BaseAngB[i]);
			
			x0 = DB[i]*Sin(freshprinceofdickbutt)*Cos(AngB[i]);
			y0 = DB[i]*Sin(freshprinceofdickbutt)*Sin(AngB[i]);
			z0 = DB[i]*Cos(freshprinceofdickbutt);
			X[1] = x0;
			Y[1] = y0*Cos(BaseAngA[i])-z0*Sin(BaseAngA[i]);
			Z[1] = y0*Sin(BaseAngA[i])+z0*Cos(BaseAngA[i]);
			xtmp = X[1];
			X[1] = X[1]*Cos(BaseAngB[i])+Z[1]*Sin(BaseAngB[i]);
			Z[1] = -xtmp*Sin(BaseAngB[i])+Z[1]*Cos(BaseAngB[i]);
			
			x0 = DC[i]*Sin(freshprinceofdickbutt)*Cos(AngC[i]);
			y0 = DC[i]*Sin(freshprinceofdickbutt)*Sin(AngC[i]);
			z0 = DC[i]*Cos(freshprinceofdickbutt);
			X[2] = x0;
			Y[2] = y0*Cos(BaseAngA[i])-z0*Sin(BaseAngA[i]);
			Z[2] = y0*Sin(BaseAngA[i])+z0*Cos(BaseAngA[i]);
			xtmp = X[2];
			X[2] = X[2]*Cos(BaseAngB[i])+Z[2]*Sin(BaseAngB[i]);
			Z[2] = -xtmp*Sin(BaseAngB[i])+Z[2]*Cos(BaseAngB[i]);
			
			if(shardState[i]==1)
				Screen->Triangle(0, CPX[i]+X[0], CPY[i]+Y[0]+1, CPX[i]+X[1], CPY[i]+Y[1]+1, CPX[i]+X[2], CPY[i]+Y[2]+1, 2, 2, 0x01, 0, -1, PT_FLAT);
			else
				Screen->Triangle(0, CPX[i]+X[0], CPY[i]+Y[0]+1, CPX[i]+X[1], CPY[i]+Y[1]+1, CPX[i]+X[2], CPY[i]+Y[2]+1, 2, 2, 0x00, 0, -1, PT_FLAT);
			Screen->Triangle(0, CPX[i]+X[0], CPY[i]+Y[0], CPX[i]+X[1], CPY[i]+Y[1], CPX[i]+X[2], CPY[i]+Y[2], 1, 1, 0x00, 0, -1, PT_FLAT);
		}
		Screen->SetRenderTarget(RT_SCREEN);
		vars[16] = numShards;
	}
	void GlassWipe_DrawCracks(int layer, int vars){
		int i; int j; int k;
		int p1; int p2;
		
		int CPX = vars[0];
		int CPY = vars[1];
		int CPZ = vars[2];
		int AngA = vars[3];
		int AngB = vars[4];
		int AngC = vars[5];
		int DA = vars[6];
		int DB = vars[7];
		int DC = vars[8];
		int BaseAngA = vars[9];
		int BaseAngB = vars[10];
		int RotA = vars[11];
		int RotB = vars[12];
		int VX = vars[13];
		int VY = vars[14];
		int shardState = vars[15];
		int crackW = vars[17];
		
		int X[3];
		int Y[3];
		int Z[3];
		
		int qX[4];
		int qY[4];
		for(i=0; i<56; i++){
			int freshprinceofdickbutt = 90;
			//you tread upon the hall of the forbidden Mathemancy. Nobody knows how it works. Well someone might. But it isn't Moosh.
			int x0; int y0; int z0; int xtmp;
			x0 = DA[i]*Sin(freshprinceofdickbutt)*Cos(AngA[i]);
			y0 = DA[i]*Sin(freshprinceofdickbutt)*Sin(AngA[i]);
			z0 = DA[i]*Cos(freshprinceofdickbutt);
			X[0] = x0;
			Y[0] = y0*Cos(BaseAngA[i])-z0*Sin(BaseAngA[i]);
			Z[0] = y0*Sin(BaseAngA[i])+z0*Cos(BaseAngA[i]);
			xtmp = X[0];
			X[0] = X[0]*Cos(BaseAngB[i])+Z[0]*Sin(BaseAngB[i]);
			Z[0] = -xtmp*Sin(BaseAngB[i])+Z[0]*Cos(BaseAngB[i]);
			
			x0 = DB[i]*Sin(freshprinceofdickbutt)*Cos(AngB[i]);
			y0 = DB[i]*Sin(freshprinceofdickbutt)*Sin(AngB[i]);
			z0 = DB[i]*Cos(freshprinceofdickbutt);
			X[1] = x0;
			Y[1] = y0*Cos(BaseAngA[i])-z0*Sin(BaseAngA[i]);
			Z[1] = y0*Sin(BaseAngA[i])+z0*Cos(BaseAngA[i]);
			xtmp = X[1];
			X[1] = X[1]*Cos(BaseAngB[i])+Z[1]*Sin(BaseAngB[i]);
			Z[1] = -xtmp*Sin(BaseAngB[i])+Z[1]*Cos(BaseAngB[i]);
			
			x0 = DC[i]*Sin(freshprinceofdickbutt)*Cos(AngC[i]);
			y0 = DC[i]*Sin(freshprinceofdickbutt)*Sin(AngC[i]);
			z0 = DC[i]*Cos(freshprinceofdickbutt);
			X[2] = x0;
			Y[2] = y0*Cos(BaseAngA[i])-z0*Sin(BaseAngA[i]);
			Z[2] = y0*Sin(BaseAngA[i])+z0*Cos(BaseAngA[i]);
			xtmp = X[2];
			X[2] = X[2]*Cos(BaseAngB[i])+Z[2]*Sin(BaseAngB[i]);
			Z[2] = -xtmp*Sin(BaseAngB[i])+Z[2]*Cos(BaseAngB[i]);
			
			for(j=0; j<3; j++){
				p1 = j-1;
				if(p1<0)
					p1 = 2;
				p2 = j;
				k = Angle(X[p1], Y[p1], X[p2], Y[p2]);
				
				qX[0] = CPX[i]+X[p1]; //+VectorX(-crackW[i*2+0]/2, k+90);
				qY[0] = CPY[i]+Y[p1]; //+VectorY(-crackW[i*2+0]/2, k+90);
				
				qX[1] = CPX[i]+(X[p1]+X[p2])/2+VectorX(-crackW[i]/2, k+90);
				qY[1] = CPY[i]+(Y[p1]+Y[p2])/2+VectorY(-crackW[i]/2, k+90);
				
				qX[2] = CPX[i]+X[p2]; //+VectorX(-crackW[i*2+1]/2, k+90);
				qY[2] = CPY[i]+Y[p2]; //+VectorY(-crackW[i*2+1]/2, k+90);
				
				qX[3] = CPX[i]+(X[p1]+X[p2])/2+VectorX(crackW[i]/2, k+90);
				qY[3] = CPY[i]+(Y[p1]+Y[p2])/2+VectorY(crackW[i]/2, k+90);
				
				Screen->Quad(7, qX[0], qY[0], qX[1], qY[1], qX[2], qY[2], qX[3], qY[3], 1, 1, 0x01, 0, -1, PT_FLAT);
			}
		}
	}
}

void Q7_DrawPartialString(int layer, int x, int y, int font, int clr1, int clr2, int format, int ptr, int opacity, int chars){
	int buf[1024];
	int size = SizeOfArray(ptr);
	for(int i=0; i<size; i++){
		if(i>chars)
			buf[i] = ' ';
		else
			buf[i] = ptr[i];
	}
	Screen->DrawString(layer, x, y, font, clr1, clr2, format, buf, opacity);
}

void Q7_DrawLinkToLayer(int layer){
	if(Link->Dir==DIR_LEFT)
		Screen->DrawTile(layer, Link->X+Link->DrawXOffset, Link->Y+Link->DrawYOffset, Link->Tile, 1, 1, 6, -1, -1, 0, 0, 0, 1, true, 128);
	else
		Screen->DrawTile(layer, Link->X+Link->DrawXOffset, Link->Y+Link->DrawYOffset, Link->Tile, 1, 1, 6, -1, -1, 0, 0, 0, 0, true, 128);
}

void Q7_DrawLinkToLayer(int layer, int x, int y){
	if(Link->Dir==DIR_LEFT)
		Screen->DrawTile(layer, x, y, Link->Tile, 1, 1, 6, -1, -1, 0, 0, 0, 1, true, 128);
	else
		Screen->DrawTile(layer, x, y, Link->Tile, 1, 1, 6, -1, -1, 0, 0, 0, 0, true, 128);
}

ffc script Bannon_FGParticles{
	void run(){
		int i;
		
		Screen->D[7] = 0;
		
		int pX[32];
		int pY[32];
		int pAng[32];
		int pStep[32];
		int pTimer[32];
		int pAmp[32];
		int particles[] = {pX, pY, pAng, pStep, pTimer, pAmp};
		
		for(i=0; i<32; i++){
			pX[i] = Rand(-16, 272);
			pY[i] = Rand(-16, 192);
			pAng[i] = -45+Rand(-15, 15);
			pStep[i] = Rand(8, 14)*0.1;
			pTimer[i] = Rand(64);
			pAmp[i] = Rand(6, 8)*Choose(-1, 1);
		}
		
		int lastSt;
		while(true){
			// if(Link->PressA)
				// Screen->D[7] = Cond(Screen->D[7], 0, 1);
			if(lastSt==2&&Screen->D[7]==3){
				for(i=0; i<32; i++){
					pX[i] = Rand(-16, 272);
					pY[i] = Rand(-16, 192);
					pAng[i] = -90+Rand(-15, 15);
					pStep[i] = Rand(4, 7)*0.1;
					pTimer[i] = Rand(64);
					pAmp[i] = Rand(6, 8)*Choose(-1, 1);
				}
			}
			lastSt = Screen->D[7];
			BFGParticles_Update(particles);
			Waitframe();
		}
	}
	void BFGParticles_Update(int particles){
		int pX = particles[0];
		int pY = particles[1];
		int pAng = particles[2];
		int pStep = particles[3];
		int pTimer = particles[4];
		int pAmp = particles[5];
		
		int tmpX;
		int tmpY;
		int tmpSc;
		
		int clr;
		
		for(int i=0; i<32; i++){
			if(pTimer[i]>=0){
				pX[i] += VectorX(pStep[i], pAng[i]);
				pY[i] += VectorY(pStep[i], pAng[i]);
				
				if(Screen->D[7]==1){
					pX[i] += 4;
					pY[i] -= 4;
					pTimer[i] = Max(pTimer[i]-4, 0);
				}
				
				tmpX = pX[i]+VectorX(pAmp[i]*Sin((32-pTimer[i])*2), pAng[i]-90);
				tmpY = pY[i]+VectorY(pAmp[i]*Sin((32-pTimer[i])*2), pAng[i]-90);
				
				tmpSc = pTimer[i]/20;
				
				clr = 0x0F;
				if(Screen->D[7]==3){
					clr = 4*16+1+Floor((((G[G_ANIM]+i*4)%360)%60)/4);
				}
				
				if(tmpSc>=2)
					Screen->Rectangle(6, tmpX-1, tmpY-1, tmpX+1, tmpY+1, clr, 1, 0, 0, 0, true, 128);
				else if(tmpSc<1)
					Screen->PutPixel(6, tmpX, tmpY, clr, 0, 0, 0, 128);
				else
					Screen->Circle(6, tmpX, tmpY, 1, clr, 1, 0, 0, 0, true, 128);
			
				pTimer[i]--;
				if(pTimer[i]<0||pX[i]<-16||pX[i]>272||pY[i]<-16||pY[i]>192){
					if(Screen->D[7]!=2){
						pX[i] = Rand(-16, 272);
						pY[i] = Rand(-16, 192);
						pAng[i] = -45+Rand(-15, 15);
						pStep[i] = Rand(8, 14)*0.1;
						if(Screen->D[7]==3){
							pAng[i] = -90+Rand(-15, 15);
							pStep[i] = Rand(4, 7)*0.1;
						}
						pTimer[i] = 64;
						pAmp[i] = Rand(12, 16)*Choose(-1, 1);
					}
				}
			}
		}
	}
}

const int EW_BANNON_FLIES = 39;

const int EWM_BANNON_FLIES = 0;

const int SFX_BANNON_STOMP = 91;
const int SFX_BANNON_SHOCKWAVE = 90;
const int SFX_BANNON_ARMOR_REGROW = 56;

const int SFX_BANNON_CHARGE1 = 35;
const int SFX_BANNON_CHARGE2 = 36;
const int SFX_BANNON_FLIES = 13;
const int SFX_BANNON_CHARGEBALL = 40;
const int SFX_BANNON_CHARGEBALL_BOUNCE = 21;
const int SFX_BANNON_TRIDENT_SPIN = 92;
const int SFX_BANNON_PORTALOUT = 93;
const int SFX_BANNON_PORTALIN = 94;
const int SFX_BANNON_FORMCHANGE = 95;
const int SFX_BANNON_LAUGH = 96;

const int TIL_BANNON_TRIDENT = 7808;
const int TIL_BANNON_CRACK = 7968;

const int CMB_BANNON_SMALLBALL = 2913;
const int CMB_BANNON_LARGEBALL = 2912;
const int CMB_BANNON_FLIES = 2914;
const int CMB_BANNON_TELEPORT = 2916;
const int CMB_BANNON_EYEGLINT = 2915;

const int RT_BANNON_SHOCKWAVES = 1;
const int RT_BANNON_TELEPORT = 2;

const int DAMAGE_BANNON_SMALLSHOCK = 8;
const int DAMAGE_BANNON_MEGASHOCK = 80;
const int DAMAGE_BANNON_FLIES = 4;
const int DAMAGE_BANNON_TRIDENT = 8;
const int DAMAGE_BANNON_GRAB = 8;
const int DAMAGE_BANNON_GRAB2 = 16;
const int DAMAGE_BANNON_GRAB2FLIES = 1;

void Bannon_ClearLayer2(){
	for(int i=0; i<176; i++){
		SetLayerComboD(2, i, 0);
	}
}

void Bannon_ClearLayer2(int map, int scrn){
	for(int i=0; i<176; i++){
		Game->SetComboData(map, scrn, i, 0);
	}
}

//Modifications to the boss's damage to counteract overcompensated difficulty scaling
int Bannon_DamageMods(){
	if(IsHardMode())
		return 1;
	if(Link->Item[I_DIFF_NORMAL])
		return 2;
	else if(Link->Item[I_DIFF_EASY])
		return 2;
	else if(Link->Item[I_DIFF_VERYEASY])
		return 2;
}

ffc script BannonObstacleToCompletion{
	void run(int enemyid){
		Game->LastEntranceDMap = Game->GetCurDMap();
		Game->LastEntranceScreen = Game->GetCurScreen();
		
		Bannon_ClearLayer2();
		int i; int j; int k; int m; int o;
		int x; int y; int x2; int y2;
		int til; int flip;
		int angle; int step;
		int angle2; 
		int reps;
		int arr1[256];
		int arr2[256];
		
		eweapon e;
		eweapon earr[64];
		
		npc ghost = Ghost_InitAutoGhost(this, enemyid);
		NJFMode_IncreaseBossHP(ghost);
		Ghost_SetFlag(GHF_FAKE_Z);
		Ghost_SetFlag(GHF_NO_FALL);
		int effectsScript[] = "Bannon_Effects";
		
		Ghost_Transform(this, ghost, -1, -1, 3, 3);
		ghost->DrawYOffset = -1000;
		
		Ghost_SetHitOffsets(ghost, 16, 6, 8, 8);
		
		int combo = ghost->Attributes[10];
		int defs[18];
		if(G[G_ALTCHARACTER])
			Ghost_SetAllDefenses(ghost, NPCDT_NONE);
		Ghost_StoreDefenses(ghost, defs);
		Ghost_SetAllDefenses(ghost, NPCDT_BLOCK);
		int vars[20] = {0, 0, 0, 0, 32, 1, 0, 0, 12, 100, defs, effectsScript, 0, 0, 0, 0, 0, 0, 0};
		//vars[0] - Anim Timer
		//vars[1] - Head Anim
		//vars[2] - Step Timer
		//vars[3] - Step State
		//vars[4] - Max Step Timer
		//vars[5] - HasArmor
		//vars[6] - Armor break damage
		//vars[7] - Armor break time
		//vars[8] - Armor state
		//vars[9] - Armor state durability
		//vars[10] - Defenses
		//vars[11] - Effects Script
		//vars[12] - No Draw
		//vars[13] - Armor Regain Frames
		//vars[14] - Max HP
		//vars[15] - Current Phase
		//vars[16] - Target Phase
		//vars[17] - Draw in CS3
		//vars[18] - Fly Damage Cooldown
		//vars[19] - Armor HitDelay
		vars[11] = Game->GetFFCScript(effectsScript);
		
		vars[14] = ghost->HP;
		if(IsHardMode()){
			ghost->HP += Round(ghost->HP*0.3333);
			Ghost_HP = ghost->HP;
			vars[14] = ghost->HP;
		}
		
		int phase = 0;
		vars[15] = phase;
		vars[16] = phase;
		int attack;
		int attackCooldown = 120;
		int attackCycle;
		
		int diffMod[4];
		
		// B_StopFeet(vars);
		// B_Waitframe(this, ghost, vars, 40);
		// B_StartFeet(vars);
		
		if(!IsHardMode()&&!Link->Item[I_DIFF_VERYEASY]){
			ghost->Damage *= Bannon_DamageMods();
			ghost->WeaponDamage *= Bannon_DamageMods();
		}
		
		while(true){
			if(vars[15]!=vars[16]){
				B_StopFeet(vars);
				vars[1] = 0;
				Ghost_Data = combo+13;
				
				vars[17] = 1;
				Game->PlaySound(SFX_BANNON_FORMCHANGE);
				for(i=0; i<64; i++){
					for(j=0; j<Min(i, 16); j++){
						for(k=0; k<3; k++){
							Screen->Circle(6, Ghost_X+24+Rand(-2, 2), Ghost_Y+24+Rand(-2, 2), 16*j+(i%4)*4+k, 0x0F, 1, 0, 0, 0, false, 128);
						}
					}
					if(i>16){
						Screen->Rectangle(6, 0, 0, 255, 175, Choose(0x91, 0x92, 0x93, 0x01), 1, 0, 0, 0, true, 64);
					}
					if(!AllowAllJokes()){
						Screen->FastCombo(6, Ghost_X+16+5-8, Ghost_Y+16+7-8, CMB_BANNON_EYEGLINT, 8, 128);
						Screen->FastCombo(6, Ghost_X+16+10-8, Ghost_Y+16+7-8, CMB_BANNON_EYEGLINT, 8, 128);
					}
					else{
						Screen->FastCombo(6, Ghost_X+16+7-8, Ghost_Y+16+6-8, CMB_BANNON_EYEGLINT, 8, 128);
					}
					B_Waitframe(this, ghost, vars);
				}
				for(i=0; i<256; i+= 20){
					for(j=0; j<Min(i, 16); j++){
						for(k=0; k<3; k++){
							Screen->Circle(6, Ghost_X+24+Rand(-2, 2), Ghost_Y+24+Rand(-2, 2), i+16*j+k, 0x0F, 1, 0, 0, 0, false, 128);
						}
					}
					B_Waitframe(this, ghost, vars);
				}
				vars[17] = 0;
				Game->PlaySound(SFX_BANNON_LAUGH);
				
				Ghost_Data = combo;
				B_StartFeet(vars);
				
				vars[15] = vars[16];
				phase = vars[15];
				
				attackCycle = 0;
				attackCooldown = Max(attackCooldown, 60);
			}
			
			if(attackCooldown>0)
				attackCooldown--;
			else if(Rand(32)==0){
				if(phase==0){
					if(attackCycle<=1)
						attack = Choose(0, 1);
					else if(attackCycle<=3){
						attack = Choose(0, 3);
						if(Abs(Link->X-16-Ghost_X)<32&&Link->Y>Ghost_Y+16){
							if(Link->Y<Ghost_Y+48+48||Rand(3)==0)
								attack = 2;
						}
					}
				
					attackCycle++;
					if(attackCycle>=5){
						attack = 4;
						attackCycle = 0;
					}
				}
				else if(phase==1){
					if(attackCycle==0)
						attack = Choose(8, 9, 9, 9);
					else if(attackCycle==1){
						attack = Choose(3, 6);
						if(Abs(Link->X-16-Ghost_X)<32&&Link->Y>Ghost_Y+16){
							if(Link->Y<Ghost_Y+48+48||Rand(4)==0)
								attack = 2;
						}
					}
					else if(attackCycle==2)
						attack = 8;
					else if(attackCycle==3){
						attack = Choose(5, 6, 7); 
						if(Abs(Link->X-16-Ghost_X)<32&&Link->Y>Ghost_Y+16){
							if(Link->Y<Ghost_Y+48+48||Rand(4)==0)
								attack = 2;
						}
					}
				
					attackCycle++;
					if(attackCycle>=5){
						attack = 4;
						attackCycle = 0;
					}
				}
				else if(phase==2){
					if(attackCycle==0)
						attack = Choose(3, 12, 11);
					else if(attackCycle==1)
						attack = 14;
					else if(attackCycle==2)
						attack = Choose(3, 10, 15, 9);
					else if(attackCycle==3){
						attack = Choose(12, 10, 11, 15);
						if(Abs(Link->X-16-Ghost_X)<32&&Link->Y>Ghost_Y+16){
							if(Link->Y<Ghost_Y+48+48||Rand(4)==0)
								attack = 2;
						}
					}
					attackCycle++;
					if(attackCycle>=5){
						attack = 4;
						attackCycle = 0;
					}
				}
				else if(phase==3){
					if(attackCycle==0)
						attack = Choose(14, 0);
					else if(attackCycle==1)
						attack = Choose(13, 3);
					else if(attackCycle==2)
						attack = Choose(6, 10, 15);
					else if(attackCycle==3)
						attack = Choose(13, 15, 11);
					attackCycle++;
					if(attackCycle>=5){
						attack = 4;
						attackCycle = 0;
					}
				}
				
				//attack = 15;
				
				if(attack==0){ //Dashing stomp
					B_TurnHead(vars);
					flip = 1;
					if(Link->X<Ghost_X+16)
						flip = 0;
					
					x = Ghost_X;
					y = Ghost_Y;
					angle = Angle(Ghost_X+16, Ghost_Y+32, Link->X, Link->Y);
					Game->PlaySound(SFX_BANNON_CHARGE1);
					
					vars[2] = 0;
					if(flip==0)
						vars[3] = 2;
					else
						vars[3] = 3;
					
					reps = 1;
					if(phase==3)
						reps = 2;
					for(j=0; j<reps; j++){
						m = LazyDiffMod(60, 50, 40);
						if(j>0)
							m /= 2;
						for(i=0; i<m; i++){
							if(j==0){
								Ghost_X = x+Rand(-1, 1);
								Ghost_Y = y+Rand(-1, 1);
							}
							vars[2] = 90*(i/m);
							B_Waitframe(this, ghost, vars);
						}
						Ghost_X = x;
						Ghost_Y = y;
						for(i=0; i<20; i++){
							Ghost_MoveAtAngle(angle, 4, 0);
							B_DestroyRocksContact(ghost);
							B_Waitframe(this, ghost, vars);
						}
						Ghost_Data = combo+13;
						for(i=0; i<4; i++){
							vars[2] = 90+90*(i/4);
							Ghost_MoveAtAngle(angle, 2, 0);
							B_Waitframe(this, ghost, vars);
						}
						Game->PlaySound(SFX_BANNON_STOMP);
						Game->PlaySound(SFX_BANNON_SHOCKWAVE);
						if(flip==0)
							Q7_RunFFCScript(effectsScript, 0, Ghost_X+24-11, Ghost_Y+46, 20, 0, 0, 0, 0);
						else
							Q7_RunFFCScript(effectsScript, 0, Ghost_X+24+11, Ghost_Y+46, 20, 0, 0, 0, 0);
						B_Waitframe(this, ghost, vars, 20);
						Ghost_Data = combo;
						
						x = Ghost_X;
						y = Ghost_Y;
						angle = Angle(Ghost_X+16, Ghost_Y+32, Link->X, Link->Y);
						B_TurnHead(vars);
						
						flip = 1;
						if(Link->X<Ghost_X+16)
							flip = 0;
						
						vars[2] = 0;
						if(flip==0)
							vars[3] = 2;
						else
							vars[3] = 3;
					}
					vars[2] = 0;
					if(vars[3]==2)
						vars[3] = 0;
					else
						vars[3] = 1;
					
					Q7_RunFFCScript(effectsScript, 2, 0, 0, 0, 0, 0, 0, 0);		
				}
				else if(attack==1){ //Stomp
					B_TurnHead(vars);
					j = 1;
					if(Link->X<Ghost_X+16)
						j = 0;
					
					angle = Angle(Ghost_X+16, Ghost_Y+32, Link->X, Link->Y);
					
					vars[2] = 0;
					vars[3] = 2;
					if(Distance(Ghost_X+16, Ghost_Y+32, 120, 80)<48){
						Game->PlaySound(SFX_JUMP);
						Ghost_Jump = 1;
						Ghost_UnsetFlag(GHF_NO_FALL);
						while(Ghost_Jump>0||Ghost_Z>0){
							Ghost_MoveAtAngle(angle, 2, 0);
							B_Waitframe(this, ghost, vars);
						}
						Ghost_SetFlag(GHF_NO_FALL);
					}
					
					if(Distance(Ghost_X+16, Ghost_Y+32, 120, 80)<48){
						angle = Angle(120, 80, Ghost_X+16, Ghost_Y+32);
						B_Waitframe(this, ghost, vars, 24);
						Game->PlaySound(SFX_JUMP);
						Ghost_Jump = 1;
						Ghost_UnsetFlag(GHF_NO_FALL);
						while(Ghost_Jump>0||Ghost_Z>0){
							Ghost_MoveAtAngle(angle, 2, 0);
							B_Waitframe(this, ghost, vars);
						}
						Ghost_SetFlag(GHF_NO_FALL);
					}
					
					x = Ghost_X;
					y = Ghost_Y;
					
					diffMod[0] = LazyDiffMod(80, 70, 60);
					
					Ghost_Data = combo+8;
					Game->PlaySound(SFX_BANNON_CHARGE2);
					if(j==0){
						vars[2] = 0;
						vars[3] = 2;
						
						for(i=0; i<diffMod[0]; i++){
							j = 3*(i/diffMod[0]);
							Ghost_X = x+Rand(-j, j);
							Ghost_Y = y+Rand(-j, j);
							if(i<diffMod[0]*0.5)
								vars[2] = 90*(i/(diffMod[0]*0.5));
							B_Waitframe(this, ghost, vars);
						}
						Ghost_X = x;
						Ghost_Y = y;
						m = 25;
						if(Rand(2)==0){
							m += 5;
							Ghost_Data = combo+13;
							for(i=0; i<8; i++){
								vars[2] = 90+90*(i/8);
								B_Waitframe(this, ghost, vars);
							}
							Game->PlaySound(SFX_BANNON_STOMP);
							Q7_RunFFCScript(effectsScript, 0, Ghost_X+24-11, Ghost_Y+46, 10, 0, 0, 0, 0);
							B_Waitframe(this, ghost, vars, 16);
							Ghost_Data = combo+8;
							for(i=0; i<16; i++){
								vars[2] = 180-90*(i/16);
								B_Waitframe(this, ghost, vars);
							}
							B_Waitframe(this, ghost, vars, 32);
						}
						Ghost_Data = combo+13;
						for(i=0; i<4; i++){
							vars[2] = 90+90*(i/4);
							B_Waitframe(this, ghost, vars);
						}
						Game->PlaySound(SFX_BANNON_STOMP);
						for(i=0; i<3; i++){
							Game->PlaySound(SFX_BANNON_SHOCKWAVE);
							Q7_RunFFCScript(effectsScript, 0, Ghost_X+24-11, Ghost_Y+46, m, 0, 0, 0, 0);
							B_Waitframe(this, ghost, vars, 4);
						}
						B_Waitframe(this, ghost, vars, 50);
						vars[2] = 0;
						vars[3] = 0;
					}
					else if(j==1){
						vars[2] = 0;
						vars[3] = 3;
						
						for(i=0; i<diffMod[0]; i++){
							j = 3*(i/diffMod[0]);
							Ghost_X = x+Rand(-j, j);
							Ghost_Y = y+Rand(-j, j);
							if(i<diffMod[0]*0.5)
								vars[2] = 90*(i/(diffMod[0]*0.5));
							B_Waitframe(this, ghost, vars);
						}
						Ghost_X = x;
						Ghost_Y = y;
						m = 25;
						if(Rand(2)==0){
							m += 5;
							Ghost_Data = combo+13;
							for(i=0; i<8; i++){
								vars[2] = 90+90*(i/8);
								B_Waitframe(this, ghost, vars);
							}
							Game->PlaySound(SFX_BANNON_STOMP);
							Q7_RunFFCScript(effectsScript, 0, Ghost_X+24+11, Ghost_Y+46, 10, 0, 0, 0, 0);
							B_Waitframe(this, ghost, vars, 16);
							Ghost_Data = combo+8;
							for(i=0; i<16; i++){
								vars[2] = 180-90*(i/16);
								B_Waitframe(this, ghost, vars);
							}
							B_Waitframe(this, ghost, vars, 32);
						}
						Ghost_Data = combo+13;
						for(i=0; i<4; i++){
							vars[2] = 90+90*(i/4);
							B_Waitframe(this, ghost, vars);
						}
						Game->PlaySound(SFX_BANNON_STOMP);
						for(i=0; i<3; i++){
							Game->PlaySound(SFX_BANNON_SHOCKWAVE);
							Q7_RunFFCScript(effectsScript, 0, Ghost_X+24+11, Ghost_Y+46, m, 0, 0, 0, 0);
							B_Waitframe(this, ghost, vars, 4);
						}
						B_Waitframe(this, ghost, vars, 50);
						vars[2] = 0;
						vars[3] = 1;
					}
					Q7_RunFFCScript(effectsScript, 2, Link->X, Link->Y, 0, 0, 0, 0, 0);		
					Ghost_Data = combo;
				}
				else if(attack==2){ //Grab
					bool grabbed;
					B_StopFeet(vars);
					
					diffMod[0] = LazyDiffMod(32, 24, 16);
					
					bool killedLink;
					
					if(Ghost_X+16>Link->X){
						Ghost_Data = combo+10;
						B_Waitframe(this, ghost, vars, 16);
						angle = Angle(Ghost_X+16, Ghost_Y+32, Link->X, Link->Y);
						Ghost_Data = combo+15;
						for(i=0; i<32; i++){
							Ghost_MoveAtAngle(angle, 2, 0);
							if(RectCollision(Ghost_X+8, Ghost_Y+40, Ghost_X+8+31, Ghost_Y+40+31, Link->X, Link->Y, Link->X+15, Link->Y+15)){
								if(Link->Action==LA_GOTHURTLAND){
									grabbed = true;
									break;
								}
							}
							B_Waitframe(this, ghost, vars);
						}
						if(grabbed){
							Game->PlaySound(SFX_PLACE);
							
							Link->Invisible = true;
							Link->CollDetection = false;
							
							til = Link->Tile;
							if(Link->Dir==DIR_LEFT)
								flip = 1;
							
							for(i=0; i<3; i++){
								Ghost_Data = combo+10;
								for(j=0; j<16; j++){
									B_MoveInvisibleLink(Ghost_X+32, Ghost_Y);
									Screen->DrawTile(4, Ghost_X+32, Ghost_Y, til, 1, 1, 6, -1, -1, 0, 0, 0, flip, true, 128);
									NoAction();
									B_Waitframe(this, ghost, vars);
								}
								Ghost_Data = combo+15;
								Game->PlaySound(SFX_BANNON_STOMP);
								Game->PlaySound(SFX_BOMB);
								Game->PlaySound(SFX_OUCH);
								
								k = DAMAGE_BANNON_GRAB;
								if(IsEasyMode())
									k *= DiffMultiplier();
								DealDirectDamage(k);
								
								if(Link->HP<=0){
									Link->HP = 1;
									killedLink = true;
								}
								
								for(j=0; j<8; j++){
									B_MoveInvisibleLink(Ghost_X+16, Ghost_Y+40);
									Screen->DrawTile(4, Ghost_X+16, Ghost_Y+40, til, 1, 1, 6, -1, -1, 0, 0, 0, flip, true, 128);
									NoAction();
									B_Waitframe(this, ghost, vars);
								}
							}
							
							Link->X = Ghost_X+16;
							Link->Y = Ghost_Y+40;
							Link->Action = LA_GOTHURTLAND;
							Link->HitDir = -1;
							Link->CollDetection = true;
							Link->Invisible = false;
						}
					}
					else{
						Ghost_Data = combo+9;
						B_Waitframe(this, ghost, vars, 16);
						Ghost_Data = combo+14;
						angle = Angle(Ghost_X+16, Ghost_Y+32, Link->X, Link->Y);
						for(i=0; i<32; i++){
							Ghost_MoveAtAngle(angle, 2, 0);
							if(RectCollision(Ghost_X+8, Ghost_Y+40, Ghost_X+8+31, Ghost_Y+40+31, Link->X, Link->Y, Link->X+15, Link->Y+15)){
								if(Link->Action==LA_GOTHURTLAND){
									grabbed = true;
									break;
								}
							}
							B_Waitframe(this, ghost, vars);
						}
						if(grabbed){
							Game->PlaySound(SFX_PLACE);
							
							Link->Invisible = true;
							Link->CollDetection = false;
							
							til = Link->Tile;
							if(Link->Dir==DIR_LEFT)
								flip = 1;
							
							for(i=0; i<3; i++){
								Ghost_Data = combo+9;
								for(j=0; j<16; j++){
									B_MoveInvisibleLink(Ghost_X, Ghost_Y);
									Screen->DrawTile(4, Ghost_X, Ghost_Y, til, 1, 1, 6, -1, -1, 0, 0, 0, flip, true, 128);
									NoAction();
									B_Waitframe(this, ghost, vars);
								}
								Ghost_Data = combo+14;
								Game->PlaySound(SFX_BANNON_STOMP);
								Game->PlaySound(SFX_BOMB);
								Game->PlaySound(SFX_OUCH);
								
								k = DAMAGE_BANNON_GRAB;
								if(IsEasyMode())
									k *= DiffMultiplier();
								DealDirectDamage(k);
								
								if(Link->HP<=0){
									Link->HP = 1;
									killedLink = true;
								}
								
								for(j=0; j<8; j++){
									B_MoveInvisibleLink(Ghost_X+16, Ghost_Y+40);
									Screen->DrawTile(4, Ghost_X+16, Ghost_Y+40, til, 1, 1, 6, -1, -1, 0, 0, 0, flip, true, 128);
									NoAction();
									B_Waitframe(this, ghost, vars);
								}
							}
							
							Link->X = Ghost_X+16;
							Link->Y = Ghost_Y+40;
							Link->Action = LA_GOTHURTLAND;
							Link->HitDir = -1;
							Link->CollDetection = true;
							Link->Invisible = false;
							
							if(killedLink)
								Link->HP = 0;
						}
					}
				
					Ghost_Data = combo;
					B_StartFeet(vars);
				}
				else if(attack==3){ //Charge Ball
					B_StopFeet(vars);
					
					flip = Rand(2);
					
					if(flip==0)
						Ghost_Data = combo+9;
					else
						Ghost_Data = combo+10;
					
					reps = 1;
					if(phase==3)
						reps = 3;
					
					for(o=0; o<reps; o++){
						if(o==0){
							Game->PlaySound(SFX_BANNON_CHARGE1);
							for(i=0; i<48; i++){
								j = 8*(i/48);
								k = Choose(0xA1, 0xA2, 0xA3, 0x0F);
								m = 2*(i/48);
								x = Rand(-m, m);
								y = Rand(-m, m);
								
								if(flip==0){
									Screen->Circle(4, Ghost_X+5+x, Ghost_Y+13+y, j, k, 1, 0, 0, 0, true, 128);
									
									k = Choose(0xA1, 0xA2, 0xA3, 0x0F);
									
									Screen->Circle(4, Ghost_X+5+x+Rand(-2, 2), Ghost_Y+13+y+Rand(-2, 2), j, k, 1, 0, 0, 0, false, 128);
									Screen->Circle(4, Ghost_X+5+x+Rand(-2, 2), Ghost_Y+13+y+Rand(-2, 2), j, k, 1, 0, 0, 0, false, 128);
									Screen->Circle(4, Ghost_X+5+x+Rand(-2, 2), Ghost_Y+13+y+Rand(-2, 2), j, k, 1, 0, 0, 0, false, 128);
								}
								else{
									Screen->Circle(4, Ghost_X+42+x, Ghost_Y+13+y, j, k, 1, 0, 0, 0, true, 128);
									
									k = Choose(0xA1, 0xA2, 0xA3, 0x0F);
									
									Screen->Circle(4, Ghost_X+42+x+Rand(-2, 2), Ghost_Y+13+y+Rand(-2, 2), j, k, 1, 0, 0, 0, false, 128);
									Screen->Circle(4, Ghost_X+42+x+Rand(-2, 2), Ghost_Y+13+y+Rand(-2, 2), j, k, 1, 0, 0, 0, false, 128);
									Screen->Circle(4, Ghost_X+42+x+Rand(-2, 2), Ghost_Y+13+y+Rand(-2, 2), j, k, 1, 0, 0, 0, false, 128);
								}
								
								B_Waitframe(this, ghost, vars);
							}
						}
						else{
							if(flip==0)
								Ghost_Data = combo+14;
							else
								Ghost_Data = combo+15;
							for(i=0; i<24; i++){
								j = 8;
								k = Choose(0xA1, 0xA2, 0xA3, 0x0F);
								m = 2;
								x = Rand(-m, m);
								y = Rand(-m, m);
								
								if(flip==0){
									Screen->Circle(4, Ghost_X+20+x, Ghost_Y+44+y, j, k, 1, 0, 0, 0, true, 128);
									
									k = Choose(0xA1, 0xA2, 0xA3, 0x0F);
									
									Screen->Circle(4, Ghost_X+20+x+Rand(-2, 2), Ghost_Y+44+y+Rand(-2, 2), j, k, 1, 0, 0, 0, false, 128);
									Screen->Circle(4, Ghost_X+20+x+Rand(-2, 2), Ghost_Y+44+y+Rand(-2, 2), j, k, 1, 0, 0, 0, false, 128);
									Screen->Circle(4, Ghost_X+20+x+Rand(-2, 2), Ghost_Y+44+y+Rand(-2, 2), j, k, 1, 0, 0, 0, false, 128);
								}
								else{
									Screen->Circle(4, Ghost_X+28+x, Ghost_Y+44+y, j, k, 1, 0, 0, 0, true, 128);
									
									k = Choose(0xA1, 0xA2, 0xA3, 0x0F);
									
									Screen->Circle(4, Ghost_X+28+x+Rand(-2, 2), Ghost_Y+44+y+Rand(-2, 2), j, k, 1, 0, 0, 0, false, 128);
									Screen->Circle(4, Ghost_X+28+x+Rand(-2, 2), Ghost_Y+44+y+Rand(-2, 2), j, k, 1, 0, 0, 0, false, 128);
									Screen->Circle(4, Ghost_X+28+x+Rand(-2, 2), Ghost_Y+44+y+Rand(-2, 2), j, k, 1, 0, 0, 0, false, 128);
								}
								
								B_Waitframe(this, ghost, vars);
							}
							if(flip==0)
								Ghost_Data = combo+9;
							else
								Ghost_Data = combo+10;
							for(i=0; i<24; i++){
								j = 8;
								k = Choose(0xA1, 0xA2, 0xA3, 0x0F);
								m = 2;
								x = Rand(-m, m);
								y = Rand(-m, m);
								
								if(flip==0){
									Screen->Circle(4, Ghost_X+5+x, Ghost_Y+13+y, j, k, 1, 0, 0, 0, true, 128);
									
									k = Choose(0xA1, 0xA2, 0xA3, 0x0F);
									
									Screen->Circle(4, Ghost_X+5+x+Rand(-2, 2), Ghost_Y+13+y+Rand(-2, 2), j, k, 1, 0, 0, 0, false, 128);
									Screen->Circle(4, Ghost_X+5+x+Rand(-2, 2), Ghost_Y+13+y+Rand(-2, 2), j, k, 1, 0, 0, 0, false, 128);
									Screen->Circle(4, Ghost_X+5+x+Rand(-2, 2), Ghost_Y+13+y+Rand(-2, 2), j, k, 1, 0, 0, 0, false, 128);
								}
								else{
									Screen->Circle(4, Ghost_X+42+x, Ghost_Y+13+y, j, k, 1, 0, 0, 0, true, 128);
									
									k = Choose(0xA1, 0xA2, 0xA3, 0x0F);
									
									Screen->Circle(4, Ghost_X+42+x+Rand(-2, 2), Ghost_Y+13+y+Rand(-2, 2), j, k, 1, 0, 0, 0, false, 128);
									Screen->Circle(4, Ghost_X+42+x+Rand(-2, 2), Ghost_Y+13+y+Rand(-2, 2), j, k, 1, 0, 0, 0, false, 128);
									Screen->Circle(4, Ghost_X+42+x+Rand(-2, 2), Ghost_Y+13+y+Rand(-2, 2), j, k, 1, 0, 0, 0, false, 128);
								}
								
								B_Waitframe(this, ghost, vars);
							}
						}
						
						if(flip==0)
							Ghost_Data = combo+14;
						else
							Ghost_Data = combo+15;
						
						angle = 90+AngDiff(Angle(Ghost_X+16, Ghost_Y+32, Link->X, Link->Y), 90)/2;
						Q7_RunFFCScript(effectsScript, 3, Ghost_X+16, Ghost_Y+32, angle, 0, 0, 0, 0);
					}
						
					B_Waitframe(this, ghost, vars, 24);
					B_StartFeet(vars);
					Ghost_Data = combo;
				}
				else if(attack==4){ //Super Shockwave Wombo Slambo
					B_StopFeet(vars);
					Ghost_Data = combo+8;
					B_Waitframe(this, ghost, vars, 30);
					Ghost_Data = combo+11;
					B_Waitframe(this, ghost, vars, 30);
					
					Screen->SetRenderTarget(RT_BANNON_SHOCKWAVES);
					Screen->Rectangle(0, 0, 0, 511, 511, 0x00, 1, 0, 0, 0, true, 128);
					Screen->SetRenderTarget(RT_SCREEN);
					bool safe = false;
					for(i=0; i<176; i++){
						if(GetLayerComboS(2, i))
							arr1[i] = 1;
						else
							arr1[i] = 0;
					}
					diffMod[0] = LazyDiffMod(220, 160, 120);
					for(i=0; i<diffMod[0]; i++){
						x = Ghost_X+24;
						y = Ghost_Y+44;
						
						safe = false;
						Screen->SetRenderTarget(RT_BANNON_SHOCKWAVES);
						Screen->Rectangle(0, 0, 0, 511, 511, 0x00, 1, 0, 0, 0, true, 128);
						if(i<48){
							if(i<24){
								for(j=0; j<(i/48)*256; j+=8){
									Screen->Circle(0, x+Rand(-2, 2), y+Rand(-2, 2), j, 0x02, 1, 0, 0, 0, false, 128);
								}
							}
							else{
								for(j=(i/48)*256; j>0; j-=8){
									Screen->Circle(0, x+Rand(-2, 2), y+Rand(-2, 2), j, 0x02, 1, 0, 0, 0, false, 128);
								}
							}
							for(j=0; j<176; j++){
								if(arr1[j]){
									safe = B_EraseRay(safe, x, y, j);
								}
							}
						}
						Screen->SetRenderTarget(RT_SCREEN);
						Screen->DrawBitmap(2, RT_BANNON_SHOCKWAVES, 0, 0, 256, 176, 0, 0, 256, 176, 0, true);
						
						if(i==60&&phase==3){
							x = Ghost_X;
							y = Ghost_Y;
							m = 0;
							for(j=0; j<8; j++){
								angle = Angle(Ghost_X+16, Ghost_Y+32, Link->X, Link->Y)+Choose(-90, 90)+Rand(-40, 40);
								Ghost_MoveAtAngle(angle, Rand(96, 128), 0);
								if(Distance(Ghost_X, Ghost_Y, x, y)>16&&Distance(Ghost_X+16, Ghost_Y+16, Link->X, Link->Y)>40){
									x2 = Ghost_X;
									y2 = Ghost_Y;
									Ghost_X = x;
									Ghost_Y = y;
									m = 1;
									break;
								}
								Ghost_X = x;
								Ghost_Y = y;
							}
							
							if(m){
								int dashColors[] = {0x91, 0x92, 0x93};
								int dashSeed[2];
								dashSeed[0] = Rand(256);
								dashSeed[1] = Rand(256);
								Game->PlaySound(SFX_SWORD);
								vars[12] = 1;
								ghost->CollDetection = false;
								for(j=0; j<4; j++){
									Q7_DrawSpeedLines(dashSeed, 6, Ghost_X, Ghost_Y, x2, y2, 48, 48, 16, dashColors);
									
									B_Waitframe(this, ghost, vars);
								}
								ghost->CollDetection = true;
								vars[12] = 0;
								Ghost_X = x2;
								Ghost_Y = y2;
							}
						}
						
						if(i%10==0)
							Game->PlaySound(SFX_BANNON_CHARGE1);
						if(i%10==5)
							Game->PlaySound(SFX_BANNON_CHARGE2);
						
						j = 4+16*(i/diffMod[0]);
						k = Choose(0xA1, 0xA2, 0xA3, 0x0F);
						m = 4*(i/diffMod[0]);
						x = Rand(-m, m);
						y = Rand(-m, m);
						
						Screen->Circle(4, Ghost_X+24+x, Ghost_Y+9+y, j, k, 1, 0, 0, 0, true, 128);
						
						k = Choose(0xA1, 0xA2, 0xA3, 0x0F);
						
						Screen->Circle(4, Ghost_X+24+x+Rand(-2, 2), Ghost_Y+9+y+Rand(-2, 2), j, k, 1, 0, 0, 0, false, 128);
						Screen->Circle(4, Ghost_X+24+x+Rand(-2, 2), Ghost_Y+9+y+Rand(-2, 2), j, k, 1, 0, 0, 0, false, 128);
						Screen->Circle(4, Ghost_X+24+x+Rand(-2, 2), Ghost_Y+9+y+Rand(-2, 2), j, k, 1, 0, 0, 0, false, 128);
						
						B_Waitframe(this, ghost, vars);
					}
					Ghost_Data = combo+16;
					for(i=0; i<176; i++){
						if(GetLayerComboS(2, i))
							arr1[i] = 1;
						else
							arr1[i] = 0;
					}
					Screen->SetRenderTarget(RT_BANNON_SHOCKWAVES);
					Screen->Rectangle(0, 0, 0, 511, 511, 0x00, 1, 0, 0, 0, true, 128);
					Screen->SetRenderTarget(RT_SCREEN);
					for(i=0; i<=8; i++){
						Screen->DrawCombo(4, Ghost_X+24-16, Ghost_Y+9+35*(i/8)-16, CMB_BANNON_LARGEBALL, 2, 2, 10, -1, -1, 0, 0, 0, 0, 0, true, 128);
						B_Waitframe(this, ghost, vars);
					}
					x = Ghost_X+24;
					y = Ghost_Y+44;
					Game->PlaySound(37);
					Game->PlaySound(SFX_BANNON_SHOCKWAVE);
					Game->PlaySound(SFX_BOMB);
					int holmReflectDist = -1;
					for(i=12; i<256; i+=8){
						safe = false;
						angle = Angle(x, y, CenterLinkX(), CenterLinkY());
						Screen->SetRenderTarget(RT_BANNON_SHOCKWAVES);
						Screen->Rectangle(0, 0, 0, 511, 511, 0x00, 1, 0, 0, 0, true, 128);
						for(j=0; j<32; j++){
							if(i-j>0){
								if(holmReflectDist==-1||i-j<holmReflectDist)
									Screen->Circle(0, x+Rand(-2, 2), y+Rand(-2, 2), i-j, Choose(0xA1, 0xA2, 0xA3, 0x0F), 1, 0, 0, 0, false, 128);
							}
						}
						for(j=0; j<176; j++){
							if(arr1[j]){
								safe = B_EraseRay(safe, x, y, j);
								if(Distance(x, y, ComboX(j)+8, ComboY(j)+8)>i)
									SetLayerComboD(2, j, CMB_BANNON_ROCKFALL+2);
							}
						}
						Screen->SetRenderTarget(RT_SCREEN);
						Screen->DrawBitmap(2, RT_BANNON_SHOCKWAVES, 0, 0, 256, 176, 0, 0, 256, 176, 0, true);
						Screen->Rectangle(6, 0, 0, 255, 175, Choose(0xA1, 0xA2, 0xA3, 0x0F), 1, 0, 0, 0, true, 64);
						if(holmReflectDist==-1){
							step = Distance(Link->X+8, Link->Y+8, x, y);
							if(step<i&&step>i-32&&!safe){
								Game->PlaySound(SFX_EHIT);
								if(Link->Action!=LA_GOTHURTLAND){
									DealDirectDamage(LazyDiffMod(DAMAGE_BANNON_MEGASHOCK*0.4, DAMAGE_BANNON_MEGASHOCK*0.4, DAMAGE_BANNON_MEGASHOCK*0.6, DAMAGE_BANNON_MEGASHOCK*0.8, DAMAGE_BANNON_MEGASHOCK));
									Game->PlaySound(SFX_OUCH);
									Link->Action = LA_GOTHURTLAND;
									Link->HitDir = -1;
								}
								//DamageLink(DAMAGE_BANNON_MEGASHOCK);
							}
							for(j=Screen->NumLWeapons(); j>0; --j){
								lweapon l = Screen->LoadLWeapon(j);
								if(l->Misc[LWM_CHARMODS]==CHAR_HOLM){
									step = Distance(l->X+l->HitXOffset+l->HitWidth/2, l->Y+l->HitYOffset+l->HitHeight/2, x, y);
									if(step<i&&step>i-32&&!safe){
										Game->PlaySound(SFX_HOLM_REFLECT);
										holmReflectDist = step;
									}
								}
							}
						}
						B_Waitframe(this, ghost, vars);
					}
					B_Waitframe(this, ghost, vars, 30);
					for(j=0; j<256; j++){
						if(arr1[j]){
							eweapon sbomb = FireEWeapon(EW_SBOMBBLAST, ComboX(j), ComboY(j), 0, 0, DAMAGE_BANNON_ROCKFALL*Bannon_DamageMods(), -1, -1, 0);
							SetLayerComboD(2, j, 0);
						}
					}
					if(holmReflectDist>-1){
						Game->PlaySound(SFX_BANNON_SHOCKWAVE);
						for(i=12; i<256; i+=8){
							for(j=0; j<32; ++j){
								if(i-j>0){
									Screen->Circle(2, Link->X+8+Rand(-2, 2), Link->Y+8+Rand(-2, 2), i-j, Choose(0xA1, 0xA2, 0xA3, 0x0F), 1, 0, 0, 0, false, 128);
								}
							}
							for(j=0; j<36; ++j){
								MakeHitbox(LW_BEAM, Link->X+VectorX(i-16, 10*j), Link->Y+VectorY(i-16, 10*j), 16, 16, -1, 32*G[G_HPSCALE]);
							}
							
							Screen->Rectangle(6, 0, 0, 255, 175, Choose(0xA1, 0xA2, 0xA3, 0x0F), 1, 0, 0, 0, true, 64);
						
							B_Waitframe(this, ghost, vars);
						}
					}
					
					Ghost_Data = combo;
					
					B_StartFeet(vars);
				}
				else if(attack==5){ //Flies, Sweep Screen
					B_TurnHead(vars);
					B_StopFeet(vars);
					
					Ghost_Data = combo+12;
					B_Waitframe(this, ghost, vars, 24);
					
					m = Rand(2);
					if(m==0){
						x = 16;
						y = 24;
					}
					else{
						x = 192;
						y = 24;
					}
					
					
					Ghost_SetFlag(GHF_IGNORE_ALL_TERRAIN);
					Game->PlaySound(SFX_JUMP);
					Ghost_Jump = FindJumpLength(40, true);
					Ghost_UnsetFlag(GHF_NO_FALL);
					step = Distance(Ghost_X, Ghost_Y, x, y)/40;
					Ghost_Data = combo+8;
					
					while(Ghost_Jump>0||Ghost_Z>0){
						B_TurnHead(vars);
						Ghost_MoveAtAngle(Angle(Ghost_X, Ghost_Y, x, y), step, 0);
						
						B_Waitframe(this, ghost, vars);
					}
					
					Ghost_SetFlag(GHF_NO_FALL);
					
					Ghost_Data = combo+13;
					B_Waitframe(this, ghost, vars, 24);
					Ghost_Data = combo;
					
					k = vars[4];
					vars[4] = Round(vars[4]*0.5);
					B_StartFeet(vars);
					j = 0;
					diffMod[0] = LazyDiffMod(1.2, 1.6, 1.8);
					for(i=0; i<152; i+=diffMod[0]){
						if(m==0)
							Ghost_MoveXY(diffMod[0], 0, 0);
						else
							Ghost_MoveXY(-diffMod[0], 0, 0);
						Screen->Circle(4, Ghost_X+24+Rand(-4, 4), Ghost_Y+16+Rand(-4, 4), 12, Choose(0x0F, 0x51, 0x52, 0x53), 1, 0, 0, 0, true, 128);
						if(j%2==0){
							Game->PlaySound(SFX_BANNON_FLIES);
							e = FireEWeapon(EW_BANNON_FLIES, Ghost_X+16, Ghost_Y+8, DegtoRad(90+Rand(-15, 15)), Rand(250, 350), DAMAGE_BANNON_FLIES, 0, 0, 0);
							e->CollDetection = false;
							e->DrawYOffset = -1000;
							SetEWeaponMovement(e, EWM_SINE_WAVE, Rand(12, 16), Rand(12, 16));
						}
						j++;
						B_TurnHead(vars);
						
						B_Waitframe(this, ghost, vars);
					}
					Ghost_UnsetFlag(GHF_IGNORE_ALL_TERRAIN);
					vars[4] = k;
				}
				else if(attack==6){ //Flies, Side shots
					B_StopFeet(vars);
					if(Ghost_X+16>Link->X){
						m = 0;
						
						B_TurnHead(vars);
						Ghost_Data = combo+15;
						B_Waitframe(this, ghost, vars, 24);
						for(i=0; i<24; i++){
							Screen->Circle(4, Ghost_X+16+12+Rand(-2, 2), Ghost_Y+32+12+Rand(-4, 4), 6, Choose(0x0F, 0x51, 0x52, 0x53), 1, 0, 0, 0, true, 128);
							B_Waitframe(this, ghost, vars);
						}
						for(i=0; i<24; i++){
							Screen->Circle(4, Ghost_X+16+12+Rand(-2, 2), Ghost_Y+32+12+Rand(-4, 4), 6, Choose(0x0F, 0x51, 0x52, 0x53), 1, 0, 0, 0, true, 128);
							if(i%2==0){
								Game->PlaySound(SFX_BANNON_FLIES);
								e = FireEWeapon(EW_BANNON_FLIES, Ghost_X+16+12-8, Ghost_Y+32+12-8, DegtoRad(90+45), Rand(250, 350), DAMAGE_BANNON_FLIES, 0, 0, 0);
								e->CollDetection = false;
								e->DrawYOffset = -1000;
								SetEWeaponMovement(e, EWM_SINE_WAVE, Rand(12, 16), Rand(12, 16));
							}
							B_Waitframe(this, ghost, vars);
						}
					}
					else{
						m = 1;
						
						B_TurnHead(vars);
						Ghost_Data = combo+14;
						B_Waitframe(this, ghost, vars, 24);
						for(i=0; i<24; i++){
							Screen->Circle(4, Ghost_X+16+3+Rand(-2, 2), Ghost_Y+32+12+Rand(-4, 4), 6, Choose(0x0F, 0x51, 0x52, 0x53), 1, 0, 0, 0, true, 128);
							B_Waitframe(this, ghost, vars);
						}
						for(i=0; i<24; i++){
							Screen->Circle(4, Ghost_X+16+3+Rand(-2, 2), Ghost_Y+32+12+Rand(-4, 4), 6, Choose(0x0F, 0x51, 0x52, 0x53), 1, 0, 0, 0, true, 128);
							if(i%2==0){
								Game->PlaySound(SFX_BANNON_FLIES);
								e = FireEWeapon(EW_BANNON_FLIES, Ghost_X+16+3-8, Ghost_Y+32+12-8, DegtoRad(90-45), Rand(250, 350), DAMAGE_BANNON_FLIES, 0, 0, 0);
								e->CollDetection = false;
								e->DrawYOffset = -1000;
								SetEWeaponMovement(e, EWM_SINE_WAVE, Rand(12, 16), Rand(12, 16));
							}
							B_Waitframe(this, ghost, vars);
						}
					}
					
					if(Rand(2)){
						B_StartFeet(vars);
						diffMod[0] = LazyDiffMod(32, 16, 8);
						diffMod[1] = LazyDiffMod(1, 2, 4);
						if(m==0){
							for(k=0; k<3&&Ghost_CanMove(DIR_UP, 1, 0); k++){
								for(i=0; i<diffMod[0]; i++){
									x = Link->X-16+64;
									y = Link->Y-16-64;
									
									if(Abs(x-Ghost_X)>=diffMod[1])
										Ghost_MoveXY(Sign(x-Ghost_X)*diffMod[1], 0, 0);
									if(Abs(y-Ghost_Y)>=diffMod[1])
										Ghost_MoveXY(0, Sign(y-Ghost_Y)*diffMod[1], 0);
									B_Waitframe(this, ghost, vars);
								}
								for(i=0; i<24; i++){
									Screen->Circle(4, Ghost_X+16+12+Rand(-2, 2), Ghost_Y+32+12+Rand(-4, 4), 6, Choose(0x0F, 0x51, 0x52, 0x53), 1, 0, 0, 0, true, 128);
									B_Waitframe(this, ghost, vars);
								}
								for(i=0; i<24; i++){
									Screen->Circle(4, Ghost_X+16+12+Rand(-2, 2), Ghost_Y+32+12+Rand(-4, 4), 6, Choose(0x0F, 0x51, 0x52, 0x53), 1, 0, 0, 0, true, 128);
									if(i%2==0){
										Game->PlaySound(SFX_BANNON_FLIES);
										e = FireEWeapon(EW_BANNON_FLIES, Ghost_X+16+12-8, Ghost_Y+32+12-8, DegtoRad(90+45), Rand(250, 350), DAMAGE_BANNON_FLIES, 0, 0, 0);
										e->CollDetection = false;
										e->DrawYOffset = -1000;
										SetEWeaponMovement(e, EWM_SINE_WAVE, Rand(12, 16), Rand(12, 16));
									}
									B_Waitframe(this, ghost, vars);
								}
							}
						}
						else{
							for(k=0; k<3&&Ghost_CanMove(DIR_UP, 1, 0); k++){
								for(i=0; i<diffMod[0]; i++){
									x = Link->X-16-64;
									y = Link->Y-16-64;
									
									if(Abs(x-Ghost_X)>=diffMod[1])
										Ghost_MoveXY(Sign(x-Ghost_X)*diffMod[1], 0, 0);
									if(Abs(y-Ghost_Y)>=diffMod[1])
										Ghost_MoveXY(0, Sign(y-Ghost_Y)*diffMod[1], 0);
									B_Waitframe(this, ghost, vars);
								}
								for(i=0; i<24; i++){
									Screen->Circle(4, Ghost_X+16+3+Rand(-2, 2), Ghost_Y+32+12+Rand(-4, 4), 6, Choose(0x0F, 0x51, 0x52, 0x53), 1, 0, 0, 0, true, 128);
									B_Waitframe(this, ghost, vars);
								}
								for(i=0; i<24; i++){
									Screen->Circle(4, Ghost_X+16+3+Rand(-2, 2), Ghost_Y+32+12+Rand(-4, 4), 6, Choose(0x0F, 0x51, 0x52, 0x53), 1, 0, 0, 0, true, 128);
									if(i%2==0){
										Game->PlaySound(SFX_BANNON_FLIES);
										e = FireEWeapon(EW_BANNON_FLIES, Ghost_X+16+3-8, Ghost_Y+32+12-8, DegtoRad(90-45), Rand(250, 350), DAMAGE_BANNON_FLIES, 0, 0, 0);
										e->CollDetection = false;
										e->DrawYOffset = -1000;
										SetEWeaponMovement(e, EWM_SINE_WAVE, Rand(12, 16), Rand(12, 16));
									}
									B_Waitframe(this, ghost, vars);
								}
							}
						}
						if(!Ghost_CanMove(DIR_UP, 1, 0)&&phase==3){
							B_TeleportOut(this, ghost, vars, DIR_UP);
							
							B_Waitframe(this, ghost, vars, Choose(16, 32, 48));
							
							Ghost_X = Link->X-16;
							Ghost_Y = Link->Y-16;
							Ghost_X = Clamp(Ghost_X, 32, 176);
							Ghost_Y = Clamp(Ghost_Y, 32, 96);
							
							Ghost_Data = combo+8;
							
							B_TeleportIn(this, ghost, vars, DIR_UP, Ghost_X, Ghost_Y-96);
							
							Ghost_Z = 96;
							
							Game->PlaySound(SFX_FALL);
							while(Ghost_Z>0){
								Ghost_Z -= 4;
								B_Waitframe(this, ghost, vars);
							}
							
							Game->PlaySound(SFX_BANNON_SHOCKWAVE);
							Game->PlaySound(SFX_BOMB);
							Game->PlaySound(SFX_BANNON_STOMP);
							
							Q7_RunFFCScript(effectsScript, 0, Ghost_X+24, Ghost_Y+47, 15, 0, 0, 0, 0);
				
							Ghost_Data = combo+11;
							B_Waitframe(this, ghost, vars, 16);
							Ghost_Data = combo+16;
							B_Waitframe(this, ghost, vars, 16);
							Game->PlaySound(SFX_BANNON_CHARGE1);
							for(i=0; i<16; i++){
								Screen->Circle(4, Ghost_X+24+Rand(-2, 2), Ghost_Y+44+Rand(-4, 4), 6, Choose(0x0F, 0x51, 0x52, 0x53), 1, 0, 0, 0, true, 128);
										
								B_Waitframe(this, ghost, vars);
							}
							m = Rand(2);
							for(i=0; i<8; i++){
								for(j=0; j<4; j++){
									Game->PlaySound(SFX_BANNON_FLIES);
									e = FireEWeapon(EW_BANNON_FLIES, Ghost_X+24-8, Ghost_Y+44-8, DegtoRad(45*m-45+90*j), Rand(250, 350), DAMAGE_BANNON_FLIES, 0, 0, 0);
									e->CollDetection = false;
									e->DrawYOffset = -1000;
									SetEWeaponMovement(e, EWM_SINE_WAVE, Rand(12, 16), Rand(12, 16));
								}
								
								for(j=0; j<2; j++){
									Screen->Circle(4, Ghost_X+24+Rand(-2, 2), Ghost_Y+44+Rand(-4, 4), 6, Choose(0x0F, 0x51, 0x52, 0x53), 1, 0, 0, 0, true, 128);
										
									B_Waitframe(this, ghost, vars);
								}
							}
							diffMod[0] = LazyDiffMod(24, 24, 16);
							for(i=0; i<diffMod[0]; i++){
								Screen->Circle(4, Ghost_X+24+Rand(-2, 2), Ghost_Y+44+Rand(-4, 4), 6, Choose(0x0F, 0x51, 0x52, 0x53), 1, 0, 0, 0, true, 128);
										
								B_Waitframe(this, ghost, vars);
							}
							for(i=0; i<8; i++){
								for(j=0; j<4; j++){
									Game->PlaySound(SFX_BANNON_FLIES);
									e = FireEWeapon(EW_BANNON_FLIES, Ghost_X+24-8, Ghost_Y+44-8, DegtoRad(45*m+90*j), Rand(250, 350), DAMAGE_BANNON_FLIES, 0, 0, 0);
									e->CollDetection = false;
									e->DrawYOffset = -1000;
									SetEWeaponMovement(e, EWM_SINE_WAVE, Rand(12, 16), Rand(12, 16));
								}
								
								for(j=0; j<2; j++){
									Screen->Circle(4, Ghost_X+24+Rand(-2, 2), Ghost_Y+44+Rand(-4, 4), 6, Choose(0x0F, 0x51, 0x52, 0x53), 1, 0, 0, 0, true, 128);
										
									B_Waitframe(this, ghost, vars);
								}
							}
						}
						
						Ghost_Data = combo;
						B_StartFeet(vars);
					}
					else{
						B_TurnHead(vars);
						Ghost_Data = combo+12;
						B_Waitframe(this, ghost, vars, 24);
						
						x = Link->X-16;
						y = Link->Y-16;
						
						
						Game->PlaySound(SFX_JUMP);
						Ghost_Jump = FindJumpLength(40, true);
						Ghost_UnsetFlag(GHF_NO_FALL);
						step = Distance(Ghost_X, Ghost_Y, x, y)/40;
						Ghost_Data = combo+8;
						
						while(Ghost_Jump>0||Ghost_Z>0){
							B_TurnHead(vars);
							Ghost_MoveAtAngle(Angle(Ghost_X, Ghost_Y, x, y), step, 0);
							
							B_Waitframe(this, ghost, vars);
						}
						
						Ghost_SetFlag(GHF_NO_FALL);
						
						if(Abs(Ghost_X+16-Link->X)<48&&Link->Y>Ghost_Y+32){
							Ghost_Data = combo+16;
							
							if(!IsVeryHardMode()){
								B_Waitframe(this, ghost, vars, LazyDiffMod(32, 16, 16));
							}
							
							for(i=0; i<32; i++){
								Screen->Circle(4, Ghost_X+24+Rand(-2, 2), Ghost_Y+32+12+Rand(-4, 4), 6, Choose(0x0F, 0x51, 0x52, 0x53), 1, 0, 0, 0, true, 128);
								
								B_Waitframe(this, ghost, vars);
							}
							angle = 90;
							for(i=0; i<64; i++){
								Screen->Circle(4, Ghost_X+24+Rand(-2, 2), Ghost_Y+32+12+Rand(-4, 4), 6, Choose(0x0F, 0x51, 0x52, 0x53), 1, 0, 0, 0, true, 128);
								
								if(phase==3){
									angle = TurnToAngle(angle, Angle(Ghost_X+24-8, Ghost_Y+32+12-8, Link->X, Link->Y), 1.2);
								}
								
								if(i%2==0){
									Game->PlaySound(SFX_BANNON_FLIES);
									e = FireEWeapon(EW_BANNON_FLIES, Ghost_X+24-8, Ghost_Y+32+12-8, DegtoRad(angle+Rand(-30, 30)), Rand(250, 350), DAMAGE_BANNON_FLIES, 0, 0, 0);
									e->CollDetection = false;
									e->DrawYOffset = -1000;
									SetEWeaponMovement(e, EWM_SINE_WAVE, Rand(12, 16), Rand(12, 16));
								}
								
								B_Waitframe(this, ghost, vars);
							}
						}
						else{
							Ghost_Data = combo+12;
							
							if(!IsVeryHardMode()){
								B_Waitframe(this, ghost, vars, LazyDiffMod(32, 16, 16));
							}
							
							for(i=0; i<32; i++){
								Screen->Circle(4, Ghost_X+2+Rand(-2, 2), Ghost_Y+32+3+Rand(-4, 4), 6, Choose(0x0F, 0x51, 0x52, 0x53), 1, 0, 0, 0, true, 128);
								Screen->Circle(4, Ghost_X+32+13+Rand(-2, 2), Ghost_Y+32+3+Rand(-4, 4), 6, Choose(0x0F, 0x51, 0x52, 0x53), 1, 0, 0, 0, true, 128);
								
								B_Waitframe(this, ghost, vars);
							}
							angle = 0;
							m = Choose(-1, 1);
							for(i=0; i<64; i++){
								Screen->Circle(4, Ghost_X+2+Rand(-2, 2), Ghost_Y+32+3+Rand(-4, 4), 6, Choose(0x0F, 0x51, 0x52, 0x53), 1, 0, 0, 0, true, 128);
								Screen->Circle(4, Ghost_X+32+13+Rand(-2, 2), Ghost_Y+32+3+Rand(-4, 4), 6, Choose(0x0F, 0x51, 0x52, 0x53), 1, 0, 0, 0, true, 128);
								
								if(phase==3){
									angle += m*1.4;
								}
								
								if(i%2==0){
									Game->PlaySound(SFX_BANNON_FLIES);
									e = FireEWeapon(EW_BANNON_FLIES, Ghost_X+2-8, Ghost_Y+32+3-8, DegtoRad(180+angle+Rand(-30, 30)), Rand(250, 350), DAMAGE_BANNON_FLIES, 0, 0, 0);
									e->CollDetection = false;
									e->DrawYOffset = -1000;
									SetEWeaponMovement(e, EWM_SINE_WAVE, Rand(12, 16), Rand(12, 16));
									
									e = FireEWeapon(EW_BANNON_FLIES, Ghost_X+32+13-8, Ghost_Y+32+3-8, DegtoRad(angle+Rand(-30, 30)), Rand(250, 350), DAMAGE_BANNON_FLIES, 0, 0, 0);
									e->CollDetection = false;
									e->DrawYOffset = -1000;
									SetEWeaponMovement(e, EWM_SINE_WAVE, Rand(12, 16), Rand(12, 16));
								}
								
								B_Waitframe(this, ghost, vars);
							}
						}
						
						Ghost_Data = combo;
						B_StartFeet(vars);
					}
				}
				else if(attack==7){ //Flies Screen Wrap
					vars[1] = 0;
					B_StopFeet(vars);
					Ghost_Data = combo+8;
					B_Waitframe(this, ghost, vars, 8);
					Ghost_Data = combo+11;
					B_Waitframe(this, ghost, vars, 8);
					Ghost_Data = combo+16;
					
					for(i=0; i<32; i++){
						Screen->Circle(4, Ghost_X+24+Rand(-2, 2), Ghost_Y+20+Rand(-4, 4), 6, Choose(0x0F, 0x51, 0x52, 0x53), 1, 0, 0, 0, true, 128);
						B_Waitframe(this, ghost, vars);
					}
					Q7_RunFFCScript(effectsScript, 4, Ghost_X+16, Ghost_Y+12, 4, 0, 0, 0, 0);
					diffMod[0] = LazyDiffMod(48, 40, 32);
					diffMod[1] = LazyDiffMod(4, 5, 6);
					for(i=0; i<diffMod[0]*diffMod[1]; i++){
						Screen->Circle(4, Ghost_X+24+Rand(-2, 2), Ghost_Y+20+Rand(-4, 4), 6, Choose(0x0F, 0x51, 0x52, 0x53), 1, 0, 0, 0, true, 128);
						B_Waitframe(this, ghost, vars);
					}
					Ghost_Data = combo;
					B_StartFeet(vars);
				}
				else if(attack==8){ //Jump, X flies, drop rocks
					B_StopFeet(vars);
					B_TurnHead(vars);
					Ghost_Data = combo+12;
					B_Waitframe(this, ghost, vars, LazyDiffMod(32, 24, 16));
					
					x = Link->X-16;
					y = Link->Y-16;
					
					
					Game->PlaySound(SFX_JUMP);
					Ghost_Jump = FindJumpLength(40, true);
					Ghost_UnsetFlag(GHF_NO_FALL);
					angle = Angle(Ghost_X, Ghost_Y, x, y);
					step = Distance(Ghost_X, Ghost_Y, x, y)/40;
					Ghost_Data = combo+8;
					
					if(Rand(2)){
						angle += Choose(-30, 30);
					}
					else if(Rand(2)){
						step = 0;
					}
					
					while(Ghost_Jump>0||Ghost_Z>0){
						B_TurnHead(vars);
						Ghost_MoveAtAngle(angle, step, 0);
						
						B_Waitframe(this, ghost, vars);
					}
					
					Ghost_SetFlag(GHF_NO_FALL);
					
					Ghost_Data = combo+16;
					Game->PlaySound(SFX_BOMB);
					Game->PlaySound(SFX_BANNON_SHOCKWAVE);
					Q7_RunFFCScript(effectsScript, 0, Ghost_X+24, Ghost_Y+44, 15, 0, 0, 0, 0);		
					
					if(!IsVeryHardMode())
						B_Waitframe(this, ghost, vars, LazyDiffMod(32, 24, 24));
					
					for(i=0; i<8; i++){
						
						for(j=0; j<4; j++){
							Game->PlaySound(SFX_BANNON_FLIES);
							e = FireEWeapon(EW_BANNON_FLIES, Ghost_X+24-8, Ghost_Y+44-8, DegtoRad(-45+90*j), Rand(250, 350), DAMAGE_BANNON_FLIES, 0, 0, 0);
							e->CollDetection = false;
							e->DrawYOffset = -1000;
							SetEWeaponMovement(e, EWM_SINE_WAVE, Rand(12, 16), Rand(12, 16));
						}
						
						for(j=0; j<2; j++){
							Screen->Circle(4, Ghost_X+24+Rand(-2, 2), Ghost_Y+44+Rand(-4, 4), 6, Choose(0x0F, 0x51, 0x52, 0x53), 1, 0, 0, 0, true, 128);
								
							B_Waitframe(this, ghost, vars);
						}
					}
					Q7_RunFFCScript(effectsScript, 2, Link->X, Link->Y, 0, 0, 0, 0, 0);		
					
					Ghost_Data = combo;
					B_StartFeet(vars);
				}
				else if(attack==9){ //Jump upwards
					B_StopFeet(vars);
					B_TurnHead(vars);
					Ghost_Data = combo+12;
					B_Waitframe(this, ghost, vars, LazyDiffMod(48, 32, 24));
					
					Game->PlaySound(SFX_JUMP);
					Ghost_Jump = FindJumpLength(40, true);
					Ghost_UnsetFlag(GHF_NO_FALL);
					angle = -90;
					step = 4;
					Ghost_Data = combo+8;
					
					while(Ghost_Jump>0||Ghost_Z>0){
						B_TurnHead(vars);
						Ghost_MoveAtAngle(angle, step, 0);
						
						B_Waitframe(this, ghost, vars);
					}
					
					Ghost_SetFlag(GHF_NO_FALL);
					
					Ghost_Data = combo+16;
					Game->PlaySound(SFX_BOMB);
					Game->PlaySound(SFX_BANNON_SHOCKWAVE);
					Q7_RunFFCScript(effectsScript, 0, Ghost_X+24, Ghost_Y+44, LazyDiffMod(25, 25, 30), 0, 0, 0, 0);		
					B_Waitframe(this, ghost, vars, 16);
					Q7_RunFFCScript(effectsScript, 2, 0, 0, 0, 0, 0, 0, 0);	
					Q7_RunFFCScript(effectsScript, 2, Link->X, Link->Y, 0, 0, 0, 0, 0);						
				
					Ghost_Data = combo;
					B_StartFeet(vars);
				}
				else if(attack==10){ //Okay Mawwio, TELEPOAT
					B_StopFeet(vars);
					
					B_TeleportOut(this, ghost, vars, DIR_DOWN);
					
					B_Waitframe(this, ghost, vars, 48);
					
					Ghost_X = Clamp(Link->X-16, 32, 176);
					Ghost_Y = Max(Link->Y-64, 0);
					
					Ghost_Data = combo+10;
					
					B_TeleportIn(this, ghost, vars, DIR_UP, Ghost_X, Ghost_Y);
					
					B_StartFeet(vars);
					for(i=0; i<64; i++){
						Ghost_MoveTowardLink(LazyDiffMod(0.6, 0.8, 0.9), 0);
						B_TurnHead(vars);
			
						m = 128;
						if(i<8)
							m = 64;
						
						B_DrawTrident(4, Ghost_X+42, Ghost_Y+14, -45, 0, m, false);
						
						B_Waitframe(this, ghost, vars);
					}
					Game->PlaySound(SFX_SWORD);
					Ghost_Data = combo+15;
					for(i=0; i<16; i++){
						B_TurnHead(vars);
						for(j=0; j<i; j++){
							B_DrawTrident(4, Ghost_X+Q7_Interpolate(42, 24, j, 16), Ghost_Y+Q7_Interpolate(14, 47, j, 16), Q7_Interpolate(-45, 180, j, 16), Q7_Interpolate(0, 24, j, 16), 64, true);
						}
						B_DrawTrident(4, Ghost_X+Q7_Interpolate(42, 24, i, 16), Ghost_Y+Q7_Interpolate(14, 47, i, 16), Q7_Interpolate(-45, 180, i, 16), Q7_Interpolate(0, 24, i, 16), 128, true);
						
						B_Waitframe(this, ghost, vars);
					}
					for(i=0; i<16; i+=2){
						B_TurnHead(vars);
						for(j=i; j<16; j++){
							B_DrawTrident(4, Ghost_X+Q7_Interpolate(42, 24, j, 16), Ghost_Y+Q7_Interpolate(14, 47, j, 16), Q7_Interpolate(-45, 180, j, 16), Q7_Interpolate(0, 24, j, 16), 64, true);
						}
						
						B_Waitframe(this, ghost, vars);
					}
					
					B_StopFeet(vars);
					
					if(phase==3){
						B_TeleportOut(this, ghost, vars, DIR_DOWN);
						
						B_Waitframe(this, ghost, vars, 32);
						
						Ghost_X = Clamp(Link->X-16, 32, 176);
						Ghost_Y = 128;
						
						Ghost_SetFlag(GHF_IGNORE_ALL_TERRAIN);
						
						Ghost_Data = combo+11;
						
						B_TeleportIn(this, ghost, vars, DIR_DOWN, Ghost_X, Ghost_Y);
						Ghost_Y += 8;
						Ghost_Z = 8;
						
						angle2 = 0;
						diffMod[0] = LazyDiffMod(2.5, 3.5, 4);
						while(Distance(Ghost_X, Ghost_Y, 104, 0)>diffMod[0]){
							angle2 = WrapDegrees(angle2+32);
							SFXLoop(SFX_BANNON_TRIDENT_SPIN, 4);
							
							Ghost_Z = Clamp(Distance(Ghost_X, Ghost_Y, 104, 0)/8, 0, 8);
							
							Ghost_MoveAtAngle(Angle(Ghost_X, Ghost_Y, 104, 0), diffMod[0], 0);
							
							B_DrawTrident(4, Ghost_X+24, Ghost_Y+9-Ghost_Z, angle2, 0, 128, true);
							B_Waitframe(this, ghost, vars);
						}
						Ghost_UnsetFlag(GHF_IGNORE_ALL_TERRAIN);
						Ghost_Z = 0;
					}
					
					Ghost_Data = combo;
					B_StartFeet(vars);
				}
				else if(attack==11){ //Trident Toss
					B_StopFeet(vars);
					Ghost_Data = combo+10;
				
					angle2 = 45;
					
					diffMod[0] = LazyDiffMod(64, 48, 32);
					for(i=0; i<diffMod[0]; i++){
						B_TurnHead(vars);
						m = 128;
						if(i<8)
							m = 64;
						B_DrawTrident(4, Ghost_X+42, Ghost_Y+14, angle2, 0, m, false);
						B_Waitframe(this, ghost, vars);
					}
					Ghost_Data = combo+15;
					k = 80;
					x = Ghost_X+28;
					y = Ghost_Y+44;
					
					angle = Angle(Ghost_X+28, Ghost_Y+44, Link->X, Link->Y);
					
					diffMod[0] = LazyDiffMod(16, 12, 8);
					for(i=0; i<diffMod[0]; i++){
						B_TurnHead(vars);
						angle2 = 0;
						
						x = Q7_Interpolate(Ghost_X+42, Ghost_X+28, i, diffMod[0]);
						y = Q7_Interpolate(Ghost_Y+14, Ghost_Y+44, i, diffMod[0]);
						angle2 = Q7_Interpolate(WrapDegrees(angle2), 45, i, diffMod[0]);
						
						B_DrawTrident(4, x, y, angle2, 0, 128, true);
					
						B_Waitframe(this, ghost, vars);
					}
					
					diffMod[0] = LazyDiffMod(2.5, 2.5, 3);
					diffMod[1] = LazyDiffMod(4, 4, 5);
					diffMod[2] = LazyDiffMod(3, 3, 4);
					if(Rand(2)){
						B_StartFeet(vars);
						while(x>0&&x<255&&y>0&&y<175){
							Ghost_MoveTowardLink(0.6, 0);
							B_TurnHead(vars);
							angle2 = WrapDegrees(angle2+32);
							SFXLoop(SFX_BANNON_TRIDENT_SPIN, 4);
							
							x += VectorX(diffMod[0], angle);
							y += VectorY(diffMod[0], angle);
							
							B_DrawTrident(4, x, y, angle2, 0, 128, true);
						
							B_Waitframe(this, ghost, vars);
						}
						while(Distance(x, y, Ghost_X+28, Ghost_Y+44)>6){
							Ghost_MoveTowardLink(0.6, 0);
							B_TurnHead(vars);
							angle2 = WrapDegrees(angle2+32);
							SFXLoop(SFX_BANNON_TRIDENT_SPIN, 4);
							
							angle = Angle(x, y, Ghost_X+28, Ghost_Y+44);
							x += VectorX(6, angle);
							y += VectorY(6, angle);
							
							B_DrawTrident(4, x, y, angle2, 0, 128, true);
						
							B_Waitframe(this, ghost, vars);
						}
						B_StopFeet(vars);
						for(i=0; i<32; i++){
							B_TurnHead(vars);
							m = 128;
							if(i>=32-8)
								m = 64;
							B_DrawTrident(4, Ghost_X+28, Ghost_Y+44, 45, 0, m, false);
							B_Waitframe(this, ghost, vars);
						}
					}
					else{
						angle = Angle(x, y, Link->X+8, Link->Y+8)+Choose(45, 60, 80)*Choose(-1, 1);
						while(x>0&&x<255&&y>0&&y<175){
							B_TurnHead(vars);
							angle2 = WrapDegrees(angle2+32);
							SFXLoop(SFX_BANNON_TRIDENT_SPIN, 4);
							
							x += VectorX(diffMod[1], angle);
							y += VectorY(diffMod[1], angle);
							
							B_DrawTrident(4, x, y, angle2, 0, 128, true);
						
							B_Waitframe(this, ghost, vars);
						}
						x = Clamp(x, 1, 254);
						y = Clamp(y, 1, 174);
						for(i=0; i<32; i++){
							if(i==16)
								angle = Angle(x, y, Link->X+8, Link->Y+8);
							
							B_TurnHead(vars);
							angle2 = WrapDegrees(angle2+32);
							SFXLoop(SFX_BANNON_TRIDENT_SPIN, 4);
							
							B_DrawTrident(4, x, y, angle2, 0, 128, true);
						
							B_Waitframe(this, ghost, vars);
						}
						while(x>0&&x<255&&y>0&&y<175){
							B_TurnHead(vars);
							angle2 = WrapDegrees(angle2+32);
							SFXLoop(SFX_BANNON_TRIDENT_SPIN, 4);
							
							x += VectorX(diffMod[2], angle);
							y += VectorY(diffMod[2], angle);
							
							B_DrawTrident(4, x, y, angle2, 0, 128, true);
						
							B_Waitframe(this, ghost, vars);
						}
						for(i=0; i<32; i++){
							B_TurnHead(vars);
							angle2 = WrapDegrees(angle2+32);
							SFXLoop(SFX_BANNON_TRIDENT_SPIN, 4);
							
							B_DrawTrident(4, x, y, angle2, 0, 128, true);
						
							B_Waitframe(this, ghost, vars);
						}
						while(Distance(x, y, Ghost_X+28, Ghost_Y+44)>6){
							B_TurnHead(vars);
							angle2 = WrapDegrees(angle2+32);
							SFXLoop(SFX_BANNON_TRIDENT_SPIN, 4);
							
							angle = Angle(x, y, Ghost_X+28, Ghost_Y+44);
							x += VectorX(diffMod[1], angle);
							y += VectorY(diffMod[1], angle);
							
							B_DrawTrident(4, x, y, angle2, 0, 128, true);
						
							B_Waitframe(this, ghost, vars);
						}
						B_StopFeet(vars);
						for(i=0; i<32; i++){
							B_TurnHead(vars);
							m = 128;
							if(i>=32-8)
								m = 64;
							B_DrawTrident(4, Ghost_X+28, Ghost_Y+44, 45, 0, m, false);
							B_Waitframe(this, ghost, vars);
						}
					}
					
					Ghost_Data = combo;
					B_StartFeet(vars);
				}
				else if(attack==12){ //Flies Spin
					B_StopFeet(vars);
					Ghost_Data = combo+10;
				
					angle2 = 45;
					for(i=0; i<16; i++){
						B_TurnHead(vars);
						m = 128;
						if(i<8)
							m = 64;
						B_DrawTrident(4, Ghost_X+42, Ghost_Y+14, angle2, 0, m, false);
						B_Waitframe(this, ghost, vars);
					}
					for(i=0; i<32; i++){
						B_TurnHead(vars);
						angle2 = WrapDegrees(angle2+4);
						SFXLoop(SFX_BANNON_TRIDENT_SPIN, 32);
						B_DrawTrident(4, Ghost_X+42, Ghost_Y+14, angle2, 0, 128, true);
						B_Waitframe(this, ghost, vars);
					}
					if(Rand(2)){
						Ghost_Data = combo+11;
						angle = Angle(Ghost_X+16, Ghost_Y+16, Link->X, Link->Y);
						step = LazyDiffMod(1.5, 1.75, 2);
						if(Rand(2)){
							angle += Choose(-20, 20);
							step = LazyDiffMod(2.4, 3.5, 4);
						}
						for(i=0; i<48; i++){
							angle2 = WrapDegrees(angle2+32);
							SFXLoop(SFX_BANNON_TRIDENT_SPIN, 4);
							
							if(i<32){
								Ghost_Z = 8*(i/32);
							}
							else{
								Ghost_Z = 8*((32-(i-32))/32);
							}
							Ghost_MoveAtAngle(angle, step, 0);
							
							B_DrawTrident(4, Ghost_X+24, Ghost_Y+9-Ghost_Z, angle2, 0, 128, true);
							B_Waitframe(this, ghost, vars);
						}
						Ghost_Z = 0;
					}
					Ghost_Data = combo+10;
					for(i=0; i<16; i++){
						B_TurnHead(vars);
						angle2 = WrapDegrees(angle2+4);
						SFXLoop(SFX_BANNON_TRIDENT_SPIN, 32);
						B_DrawTrident(4, Ghost_X+42, Ghost_Y+14, angle2, 0, 128, true);
						B_Waitframe(this, ghost, vars);
					}
					for(i=0; i<16; i++){
						B_TurnHead(vars);
						angle2 = WrapDegrees(angle2+8);
						SFXLoop(SFX_BANNON_TRIDENT_SPIN, 16);
						B_DrawTrident(4, Ghost_X+42, Ghost_Y+14, angle2, 0, 128, true);
						B_Waitframe(this, ghost, vars);
					}
					for(i=0; i<8; i++){
						arr1[0+i] = 0;
						arr1[8+i] = Rand(6, 8);
						arr1[16+i] = Rand(6, 8);
					}
					
					diffMod[0] = LazyDiffMod(32, 40, 48);
					diffMod[1] = LazyDiffMod(96, 64, 48);
					diffMod[2] = LazyDiffMod(2, 3, 4);
					
					m = Rand(360);
					for(i=0; i<32; i++){
						B_TurnHead(vars);
						angle2 = WrapDegrees(angle2+16);
						SFXLoop(SFX_BANNON_TRIDENT_SPIN, 8);
						m = WrapDegrees(m+diffMod[2]);
						B_DrawTrident(4, Ghost_X+42, Ghost_Y+14, angle2, 0, 128, true);
						
						B_FliesRing(Ghost_X+42, Ghost_Y+14, 8, 32*(i/32), m, arr1, earr);
						
						B_Waitframe(this, ghost, vars);
					}
					for(i=0; i<64; i++){
						B_TurnHead(vars);
						angle2 = WrapDegrees(angle2+16);
						SFXLoop(SFX_BANNON_TRIDENT_SPIN, 8);
						m = WrapDegrees(m+diffMod[2]);
						B_DrawTrident(4, Ghost_X+42, Ghost_Y+14, angle2, 0, 128, true);
						
						B_FliesRing(Ghost_X+42, Ghost_Y+14, 8, 32+diffMod[0]*(i/64), m, arr1, earr);
						
						B_Waitframe(this, ghost, vars);
					}
					for(i=0; i<diffMod[1]; i++){
						B_TurnHead(vars);
						angle2 = WrapDegrees(angle2+16);
						SFXLoop(SFX_BANNON_TRIDENT_SPIN, 8);
						m = WrapDegrees(m+diffMod[2]);
						B_DrawTrident(4, Ghost_X+42, Ghost_Y+14, angle2, 0, 128, true);
						
						B_FliesRing(Ghost_X+42, Ghost_Y+14, 8, 32+diffMod[0], m, arr1, earr);
						
						B_Waitframe(this, ghost, vars);
					}
					if(Distance(Ghost_X+42, Ghost_Y+14, Link->X+8, Link->Y+8)>32+diffMod[0]+32){
						Ghost_Data = combo+15;
						k = 32+diffMod[0];
						x = Ghost_X+24;
						y = Ghost_Y+47;
						
						for(i=0; i<8; i++){
							B_TurnHead(vars);
							angle2 = 0;
							m = WrapDegrees(m+diffMod[2]*2);
							
							x = Q7_Interpolate(Ghost_X+42, Ghost_X+24, i, 8);
							y = Q7_Interpolate(Ghost_Y+14, Ghost_Y+47, i, 8);
							angle2 = Q7_Interpolate(WrapDegrees(angle2), 45, i, 8);
							
							B_DrawTrident(4, x, y, angle2, 0, 128, true);
							
							B_FliesRing(x, y, 8, k, m, arr1, earr);
						
							B_Waitframe(this, ghost, vars);
						}
						angle = Angle(Ghost_X+24, Ghost_Y+47, Link->X, Link->Y);
						for(i=0; i<32; i++){
							B_TurnHead(vars);
							angle2 = 0;
							m = WrapDegrees(m+diffMod[2]*2);
							
							x = Ghost_X+24;
							y = Ghost_Y+47;
							angle2 = 45;
							
							B_DrawTrident(4, x, y, angle2, 0, 128, true);
							
							B_FliesRing(x, y, 8, k, m, arr1, earr);
						
							B_Waitframe(this, ghost, vars);
						}
						
						while(x>-64&&x<240+64&&y>-64&&y<160+64){
							B_TurnHead(vars);
							angle2 = WrapDegrees(angle2+32);
							SFXLoop(SFX_BANNON_TRIDENT_SPIN, 4);
							m = WrapDegrees(m+diffMod[2]*2);
							
							x += VectorX(3.5, angle);
							y += VectorY(3.5, angle);
							
							B_DrawTrident(4, x, y, angle2, 0, 128, true);
							
							if(k>24)
								k = Max(k-2, 24);
							
							B_FliesRing(x, y, 8, k, m, arr1, earr);
						
							B_Waitframe(this, ghost, vars);
						}
					}
					else{
						for(i=0; i<32; i++){
							B_TurnHead(vars);
							angle2 = WrapDegrees(angle2+16);
							SFXLoop(SFX_BANNON_TRIDENT_SPIN, 8);
							m = WrapDegrees(m+diffMod[2]);
							B_DrawTrident(4, Ghost_X+42, Ghost_Y+14, angle2, 0, 128, true);
							
							B_FliesRing(Ghost_X+42, Ghost_Y+14, 8, (32+diffMod[0])-(32+diffMod[0])*(i/32), m, arr1, earr);
							
							B_Waitframe(this, ghost, vars);
						}
						for(i=0; i<16; i++){
							B_TurnHead(vars);
							angle2 = WrapDegrees(angle2+8);
							SFXLoop(SFX_BANNON_TRIDENT_SPIN, 16);
							B_DrawTrident(4, Ghost_X+42, Ghost_Y+14, angle2, 0, 128, true);
							B_Waitframe(this, ghost, vars);
						}
						for(i=0; i<16; i++){
							m = 128;
							if(i>=8)
								m = 64;
							
							B_TurnHead(vars);
							angle2 = WrapDegrees(angle2+4);
							SFXLoop(SFX_BANNON_TRIDENT_SPIN, 32);
							B_DrawTrident(4, Ghost_X+42, Ghost_Y+14, angle2, 0, m, true);
							B_Waitframe(this, ghost, vars);
						}
					}
					
					Ghost_Data = combo;
					B_StartFeet(vars);
				}
				else if(attack==13){ //Teleport Dash
					B_StopFeet(vars);
					vars[1] = 0;
					
					m = Choose(DIR_UP, DIR_UP, DIR_LEFT, DIR_RIGHT);
					k = 24;
					
					if(m==DIR_UP){
						B_TeleportOut(this, ghost, vars, DIR_DOWN);
						Ghost_Data = combo+15;
					}
					else if(m==DIR_LEFT){
						B_TeleportOut(this, ghost, vars, DIR_RIGHT);
						Ghost_Data = combo+16;
					}
					else if(m==DIR_RIGHT){
						B_TeleportOut(this, ghost, vars, DIR_LEFT);
						Ghost_Data = combo+16;
					}
					x = Link->X;
					y = Link->Y;
					
					Ghost_SetFlag(GHF_IGNORE_ALL_TERRAIN);
					
					B_Waitframe(this, ghost, vars, k);
					
					diffMod[0] = LazyDiffMod(3, 3, 4);
					diffMod[1] = LazyDiffMod(4, 4, 5);
					diffMod[2] = LazyDiffMod(5, 5, 6);
					
					if(m==DIR_UP){
						Ghost_X = Clamp(x-16, 32, 176);
						Ghost_Y = 0;
						
						B_TeleportIn(this, ghost, vars, DIR_UP, Ghost_X, Ghost_Y);
						Game->PlaySound(SFX_SWORD);
						while(Ghost_Y<128){
							Ghost_MoveXY(0, diffMod[0], 0);
							
							B_DrawTrident(4, Ghost_X+28, Ghost_Y+44, 160, 0, 128, true);
							
							B_Waitframe(this, ghost, vars);
						}
						B_TeleportOut(this, ghost, vars, DIR_DOWN);
						
						x = Link->X;
						y = Link->Y;
						if(Rand(2)){
							B_Waitframe(this, ghost, vars, k);
							
							Ghost_X = 0;
							Ghost_Y = Clamp(y-16, 16, 128);
							
							Ghost_Data = combo+11;
							angle2 = Rand(360);
							B_TeleportIn(this, ghost, vars, DIR_LEFT, Ghost_X, Ghost_Y);
							
							Ghost_Y += 4;
							Ghost_Z = 4;
							while(Ghost_X<208){
								angle2 = WrapDegrees(angle2+32);
								SFXLoop(SFX_BANNON_TRIDENT_SPIN, 4);
								
								Ghost_MoveXY(diffMod[0], 0, 0);
								
								B_DrawTrident(4, Ghost_X+24, Ghost_Y+9-Ghost_Z, angle2, 0, 128, true);
								
								B_Waitframe(this, ghost, vars);
							}
							Ghost_Y -= 4;
							Ghost_Z = 0;
							
							B_TeleportOut(this, ghost, vars, DIR_RIGHT);
						}
						else{
							B_Waitframe(this, ghost, vars, k);
							
							Ghost_X = 208;
							Ghost_Y = Clamp(y-16, 16, 128);
							
							Ghost_Data = combo+11;
							angle2 = Rand(360);
							B_TeleportIn(this, ghost, vars, DIR_RIGHT, Ghost_X, Ghost_Y);
							
							Ghost_Y += 4;
							Ghost_Z = 4;
							while(Ghost_X>0){
								angle2 = WrapDegrees(angle2+32);
								SFXLoop(SFX_BANNON_TRIDENT_SPIN, 4);
								
								Ghost_MoveXY(-diffMod[0], 0, 0);
								
								B_DrawTrident(4, Ghost_X+24, Ghost_Y+9-Ghost_Z, angle2, 0, 128, true);
								
								B_Waitframe(this, ghost, vars);
							}
							Ghost_Y -= 4;
							Ghost_Z = 0;
							
							B_TeleportOut(this, ghost, vars, DIR_LEFT);
						}
						x = Link->X;
						y = Link->Y;
						
						B_Waitframe(this, ghost, vars, k);
							
						Ghost_X = Clamp(x-16, 32, 176);
						Ghost_Y = 0;
						
						Ghost_Data = combo+15;
						B_TeleportIn(this, ghost, vars, DIR_UP, Ghost_X, Ghost_Y);
						Game->PlaySound(SFX_SWORD);
						while(Ghost_Y<128){
							Ghost_MoveXY(0, diffMod[0], 0);
							
							B_DrawTrident(4, Ghost_X+28, Ghost_Y+44, 160, 0, 128, true);
							
							B_Waitframe(this, ghost, vars);
						}
						B_TeleportOut(this, ghost, vars, DIR_DOWN);
						
						B_Waitframe(this, ghost, vars, k);
					}
					else{
						if(m==DIR_LEFT){
							B_Waitframe(this, ghost, vars, k);
							
							Ghost_X = 0;
							Ghost_Y = Clamp(y-16, 16, 128);
							
							Ghost_Data = combo+11;
							angle2 = Rand(360);
							B_TeleportIn(this, ghost, vars, DIR_LEFT, Ghost_X, Ghost_Y);
							
							Ghost_Y += 4;
							Ghost_Z = 4;
							while(Ghost_X<208){
								if(Abs(Ghost_X+16-Link->X)<8)
									break;
								angle2 = WrapDegrees(angle2+32);
								SFXLoop(SFX_BANNON_TRIDENT_SPIN, 4);
								
								Ghost_MoveXY(diffMod[0], 0, 0);
								
								B_DrawTrident(4, Ghost_X+24, Ghost_Y+9-Ghost_Z, angle2, 0, 128, true);
								
								B_Waitframe(this, ghost, vars);
							}
							Ghost_Y -= 4;
							Ghost_Z = 0;
							
							B_TeleportOut(this, ghost, vars, DIR_RIGHT);
						}
						else{
							B_Waitframe(this, ghost, vars, k);
							
							Ghost_X = 208;
							Ghost_Y = Clamp(y-16, 16, 128);
							
							Ghost_Data = combo+11;
							angle2 = Rand(360);
							B_TeleportIn(this, ghost, vars, DIR_RIGHT, Ghost_X, Ghost_Y);
							
							Ghost_Y += 4;
							Ghost_Z = 4;
							while(Ghost_X>0){
								if(Abs(Ghost_X+16-Link->X)<8)
									break;
								angle2 = WrapDegrees(angle2+32);
								SFXLoop(SFX_BANNON_TRIDENT_SPIN, 4);
								
								Ghost_MoveXY(-diffMod[0], 0, 0);
								
								B_DrawTrident(4, Ghost_X+24, Ghost_Y+9-Ghost_Z, angle2, 0, 128, true);
								
								B_Waitframe(this, ghost, vars);
							}
							Ghost_Y -= 4;
							Ghost_Z = 0;
							
							B_TeleportOut(this, ghost, vars, DIR_LEFT);
						}
						x = Link->X;
						y = Link->Y;
						
						B_Waitframe(this, ghost, vars, k);
							
						Ghost_X = Clamp(x-16, 32, 176);
						Ghost_Y = 0;
						
						Ghost_Data = combo+15;
						B_TeleportIn(this, ghost, vars, DIR_UP, Ghost_X, Ghost_Y);
						Game->PlaySound(SFX_SWORD);
						while(Ghost_Y<128){
							Ghost_MoveXY(0, diffMod[1], 0);
							
							B_DrawTrident(4, Ghost_X+28, Ghost_Y+44, 160, 0, 128, true);
							
							B_Waitframe(this, ghost, vars);
						}
						B_TeleportOut(this, ghost, vars, DIR_DOWN);
						
						x = Link->X;
						y = Link->Y;
						
						B_Waitframe(this, ghost, vars, k);
							
						Ghost_X = Clamp(x-16, 32, 176);
						Ghost_Y = 0;
						
						Ghost_Data = combo+15;
						B_TeleportIn(this, ghost, vars, DIR_UP, Ghost_X, Ghost_Y);
						Game->PlaySound(SFX_SWORD);
						while(Ghost_Y<128){
							Ghost_MoveXY(0, diffMod[2], 0);
							
							B_DrawTrident(6, Ghost_X+28, Ghost_Y+44, 160, 0, 128, true);
							
							B_Waitframe(this, ghost, vars);
						}
						B_TeleportOut(this, ghost, vars, DIR_DOWN);
						
						B_Waitframe(this, ghost, vars, k);
					}
					
					Ghost_UnsetFlag(GHF_IGNORE_ALL_TERRAIN);
					
					Ghost_Data = combo;
					B_TeleportIn(this, ghost, vars, DIR_UP, 104, 0);
					Ghost_X = 104;
					Ghost_Y = 0;
					
					B_StartFeet(vars);
				}
				else if(attack==14){ //Trident Slam
					B_StopFeet(vars);
					B_TurnHead(vars);
					
					Ghost_Data = combo+12;
					B_Waitframe(this, ghost, vars, 24);
					
					x = Link->X-16;
					y = Link->Y-16;
					
					
					Game->PlaySound(SFX_JUMP);
					Ghost_Jump = FindJumpLength(40, true);
					Ghost_UnsetFlag(GHF_NO_FALL);
					angle = Angle(Ghost_X, Ghost_Y, x, y);
					step = 0.5;
					Ghost_Data = combo+8;
					
					if(Rand(2)){
						angle += Choose(-20, 20);
					}
					
					while(Ghost_Jump>0||Ghost_Z>0){
						B_TurnHead(vars);
						Ghost_MoveAtAngle(angle, step, 0);
						
						B_Waitframe(this, ghost, vars);
					}
					Ghost_SetFlag(GHF_NO_FALL);
					
					B_TeleportOut(this, ghost, vars, DIR_DOWN);
					
					B_Waitframe(this, ghost, vars, 16);
					
					diffMod[0] = LazyDiffMod(112, 96, 80);
					Ghost_X = 104;
					Ghost_Y = 64-diffMod[0];
					Ghost_Data = combo+11;
					
					B_TeleportIn(this, ghost, vars, DIR_UP, Ghost_X, Ghost_Y);
					
					Ghost_Y += diffMod[0];
					Ghost_Z = diffMod[0];
					
					angle2 = Rand(360);
					for(i=0; i<60; i++){
						angle2 = WrapDegrees(angle2+32);
						SFXLoop(SFX_BANNON_TRIDENT_SPIN, 4);
						
						Ghost_MoveTowardLink(1, 0);
						
						B_DrawTrident(4, Ghost_X+24, Ghost_Y+9-Ghost_Z, angle2, 0, 128, true);
						
						B_Waitframe(this, ghost, vars);
					}
					for(i=0; i<40; i++){
						angle2 = WrapDegrees(angle2+32);
						SFXLoop(SFX_BANNON_TRIDENT_SPIN, 4);
						
						B_DrawTrident(4, Ghost_X+24, Ghost_Y+9-Ghost_Z, angle2, 0, 128, true);
						
						B_Waitframe(this, ghost, vars);
					}
					Game->PlaySound(SFX_FALL);
					while(Ghost_Z>0){
						Ghost_Z -= 4;
						
						if(Ghost_Z>40){
							Ghost_Data = combo+11;
							B_DrawTrident(4, Ghost_X+24, Ghost_Y+9-Ghost_Z, 90, 0, 128, true);
						}
						else{
							Ghost_Data = combo+16;
							B_DrawTrident(4, Ghost_X+24, Ghost_Y+44-Ghost_Z, 90, 0, 128, true);
						}
						
						B_Waitframe(this, ghost, vars);
					}
					
					Game->PlaySound(SFX_BANNON_SHOCKWAVE);
					Game->PlaySound(SFX_BOMB);
					Game->PlaySound(SFX_BANNON_STOMP);
					Game->PlaySound(SFX_BANNON_TRIDENT_SPIN);
					
					Q7_RunFFCScript(effectsScript, 0, Ghost_X+24, Ghost_Y+48+16, 30, 0, 0, 0, 0);
					
					for(i=0; i<32; i++){
						Ghost_Data = combo+16;
						B_DrawTrident(4, Ghost_X+24, Ghost_Y+44-Ghost_Z, 90, 0, 128, true);
						B_Waitframe(this, ghost, vars);
					}
					if(phase==3){
						Game->PlaySound(SFX_BANNON_CHARGE1);
						for(i=0; i<48; i++){
							Ghost_Data = combo+11;
							B_DrawTrident(4, Ghost_X+24, Ghost_Y+9-Ghost_Z, 90, 0, 128, false);
							
							j = 8*(i/48);
							k = Choose(0xA1, 0xA2, 0xA3, 0x0F);
							m = 2*(i/48);
							x = Rand(-m, m);
							y = Rand(-m, m);
							
							Screen->Circle(4, Ghost_X+24+x, Ghost_Y+9+24+y, j, k, 1, 0, 0, 0, true, 128);
							
							k = Choose(0xA1, 0xA2, 0xA3, 0x0F);
							
							Screen->Circle(4, Ghost_X+24+x+Rand(-2, 2), Ghost_Y+9+24+y+Rand(-2, 2), j, k, 1, 0, 0, 0, false, 128);
							Screen->Circle(4, Ghost_X+24+x+Rand(-2, 2), Ghost_Y+9+24+y+Rand(-2, 2), j, k, 1, 0, 0, 0, false, 128);
							Screen->Circle(4, Ghost_X+24+x+Rand(-2, 2), Ghost_Y+9+24+y+Rand(-2, 2), j, k, 1, 0, 0, 0, false, 128);
							
							B_Waitframe(this, ghost, vars);
						}
						Game->PlaySound(SFX_BANNON_SHOCKWAVE);
						Game->PlaySound(SFX_BANNON_TRIDENT_SPIN);
						
						Q7_RunFFCScript(effectsScript, 0, Ghost_X+24, Ghost_Y+48+16, 10, 0, 0, 0, 0);
						
						Q7_RunFFCScript(effectsScript, 3, Ghost_X+24-16, Ghost_Y+48+16-16, -135, 2, 1, 0, 0);
						Q7_RunFFCScript(effectsScript, 3, Ghost_X+24-16, Ghost_Y+48+16+16, -45, 2, 1, 0, 0);
						Q7_RunFFCScript(effectsScript, 3, Ghost_X+24+16, Ghost_Y+48+16-16, 135, 2, 1, 0, 0);
						Q7_RunFFCScript(effectsScript, 3, Ghost_X+24+16, Ghost_Y+48+16+16, 45, 2, 1, 0, 0);
					
						for(i=0; i<32; i++){
							m = 128;
							if(i>=24)
								m = 64;
							Ghost_Data = combo+16;
							B_DrawTrident(4, Ghost_X+24, Ghost_Y+44-Ghost_Z, 90, 0, m, false);
							
							if(i%4<2){
								j = 8+24*(i/48);
								k = Choose(0xA1, 0xA2, 0xA3, 0x0F);
								m = 2*(i/48);
								x = Rand(-m, m);
								y = Rand(-m, m);
								
								Screen->Circle(4, Ghost_X+24+x, Ghost_Y+48+24+y, j, k, 1, 0, 0, 0, true, 128);
								
								k = Choose(0xA1, 0xA2, 0xA3, 0x0F);
								
								Screen->Circle(4, Ghost_X+24+x+Rand(-2, 2), Ghost_Y+48+24+y+Rand(-2, 2), j, k, 1, 0, 0, 0, false, 128);
								Screen->Circle(4, Ghost_X+24+x+Rand(-2, 2), Ghost_Y+48+24+y+Rand(-2, 2), j, k, 1, 0, 0, 0, false, 128);
								Screen->Circle(4, Ghost_X+24+x+Rand(-2, 2), Ghost_Y+48+24+y+Rand(-2, 2), j, k, 1, 0, 0, 0, false, 128);
							}
								
							B_Waitframe(this, ghost, vars);
						}
						Ghost_Data = combo;
						B_Waitframe(this, ghost, vars, 64);
					}
					else{
						for(i=0; i<32; i++){
							m = 128;
							if(i>=24)
								m = 64;
							Ghost_Data = combo+16;
							B_DrawTrident(4, Ghost_X+24, Ghost_Y+44-Ghost_Z, 90, 0, m, false);
							
							B_Waitframe(this, ghost, vars);
						}
					}
					
					Ghost_Data = combo;
					B_StartFeet(vars);
					
					Q7_RunFFCScript(effectsScript, 2, Link->X, Link->Y, 0, 0, 0, 0, 0);
					Q7_RunFFCScript(effectsScript, 2, 0, 0, 0, 0, 0, 0, 0);
				}
				else if(attack==15){ //Skewer
					B_TurnHead(vars);
					
					k = vars[4];
					vars[4] = Round(vars[4]*0.5);
					
					j = 1;
					if(Link->X<Ghost_X+16)
						j = -1;
					
					for(i=0; i<20&&Ghost_CanMove(DIR_UP, 1, 0); i++){
						Ghost_MoveXY(j*2, -6, 0);
						B_TurnHead(vars);
						B_Waitframe(this, ghost, vars);
					}
					
					B_StopFeet(vars);
					
					Ghost_Data = combo+10;
					
					diffMod[0] = LazyDiffMod(32, 24, 16);
					for(i=0; i<diffMod[0]; i++){
						B_TurnHead(vars);
						
						m = 128;
						if(i<8)
							m = 64;
						angle = Angle(Ghost_X+42, Ghost_Y+14, Link->X+8, Link->Y+8);
						
						B_DrawTrident(4, Ghost_X+42, Ghost_Y+14, angle, 0, m, false);
						
						B_Waitframe(this, ghost, vars);
					}
					
					Ghost_Data = combo+15;
					
					angle = Angle(Ghost_X+28, Ghost_Y+44, Link->X+8, Link->Y+8);
					
					B_StartFeet(vars);
					bool grabbed;
					Game->PlaySound(SFX_SWORD);
					diffMod[0] = LazyDiffMod(2, 2.5, 3);
					for(i=0; i<24; i++){
						B_TurnHead(vars);
						
						Ghost_MoveAtAngle(angle, diffMod[0], 0);
						
						if(B_DrawTrident(4, Ghost_X+28, Ghost_Y+44, angle, i, m, true)){
							if(Link->Action==LA_GOTHURTLAND){
								grabbed = true;
								break;
							}
						}
						
						B_Waitframe(this, ghost, vars);
					}
					B_StopFeet(vars);
					
					bool killedLink;
					
					if(grabbed){
						til = Link->Tile;
						flip = 0;
						if(Link->Dir==DIR_LEFT)
							flip = 1;
						
						Link->CollDetection = false;
						Link->Invisible = true;
						
						for(j=0; j<3; j++){
							Ghost_Data = combo+10;
							for(i=0; i<24; i++){
								
								if(i>=16)
									Ghost_MoveXY(0, 2, 0);
								
								B_DrawTrident(4, Ghost_X+42, Ghost_Y+14, 90, 0, 128, false);
								x = Ghost_X+42-8;
								y = Ghost_Y+14+16;
								B_MoveInvisibleLink(x, y);
								Screen->DrawTile(4, x, y, til, 1, 1, 6, -1, -1, x, y, 90, 0, true, 128);
								
								NoAction();
								B_Waitframe(this, ghost, vars);
							}
							
							m = DAMAGE_BANNON_GRAB2;
							if(IsEasyMode())
								m *= DiffMultiplier();
							DealDirectDamage(m);
							if(Link->HP<=0){
								killedLink = true;
								Link->HP = 1;
							}
								
							Game->PlaySound(SFX_OUCH);
							Game->PlaySound(SFX_BANNON_SHOCKWAVE);
							Game->PlaySound(SFX_BOMB);
							Game->PlaySound(SFX_BANNON_STOMP);
							Game->PlaySound(SFX_BANNON_TRIDENT_SPIN);
							
							Q7_RunFFCScript(effectsScript, 0, Ghost_X+28-8+8, Ghost_Y+44+16+8, 10, 0, 0, 0, 0);
					
							Ghost_Data = combo+15;
							for(i=0; i<16; i++){
								
								B_DrawTrident(4, Ghost_X+28, Ghost_Y+44, 90, 0, 128, false);
								x = Ghost_X+28-8;
								y = Ghost_Y+44+16;
								B_MoveInvisibleLink(x, y);
								Screen->DrawTile(4, x, y, til, 1, 1, 6, -1, -1, x, y, 90, 0, true, 128);
							
								NoAction();
								B_Waitframe(this, ghost, vars);
							}
						}
						
						if(phase==3){
							Ghost_Data = combo+10;
							for(i=0; i<32; i++){
								B_DrawTrident(4, Ghost_X+42, Ghost_Y+14, -45, 24, 128, false);
								x = Ghost_X+42-8+VectorX(16, -45);
								y = Ghost_Y+14-8+VectorY(16, -45);
								B_MoveInvisibleLink(x, y);
								Screen->DrawTile(4, x, y, til, 1, 1, 6, -1, -1, x, y, -45, 0, true, 128);
								
								NoAction();
								B_Waitframe(this, ghost, vars);
							}
							Game->PlaySound(SFX_BANNON_CHARGE1);
							for(i=0; i<32; i++){
								B_DrawTrident(4, Ghost_X+42, Ghost_Y+14, -45, 24, 128, false);
								x = Ghost_X+42-8+VectorX(16, -45);
								y = Ghost_Y+14-8+VectorY(16, -45);
								B_MoveInvisibleLink(x, y);
								Screen->DrawTile(4, x, y, til, 1, 1, 6, -1, -1, x, y, -45, 0, true, 128);
								
								j = (i/32)*4;
								Screen->Circle(4, Ghost_X+42+Rand(-j, j), Ghost_Y+14+Rand(-j, j), (i/32)*12, Choose(0x0F, 0x51, 0x52, 0x53), 1, 0, 0, 0, true, 128);
						
								NoAction();
								B_Waitframe(this, ghost, vars);
							}
							for(i=0; i<128; i++){
								B_DrawTrident(4, Ghost_X+42, Ghost_Y+14, -45, 24, 128, false);
								x = Ghost_X+42-8+VectorX(16+(i/128)*16, -45);
								y = Ghost_Y+14-8+VectorY(16+(i/128)*16, -45);
								B_MoveInvisibleLink(x, y);
								Screen->DrawTile(4, x, y, til, 1, 1, 6, -1, -1, x, y, -45, 0, true, 128);
								
								Screen->Circle(4, Ghost_X+42+Rand(-4, 4), Ghost_Y+14+Rand(-4, 4), 12, Choose(0x0F, 0x51, 0x52, 0x53), 1, 0, 0, 0, true, 128);
								if(i%2==0){
									Game->PlaySound(SFX_BANNON_FLIES);
									Game->PlaySound(SFX_OUCH);
									e = FireEWeapon(EW_BANNON_FLIES, Ghost_X+42-8, Ghost_Y+14-8, DegtoRad(-45+Rand(-20, 20)), Rand(500, 700), DAMAGE_BANNON_FLIES, 0, 0, 0);
									e->CollDetection = false;
									e->DrawYOffset = -1000;
									SetEWeaponMovement(e, EWM_SINE_WAVE, Rand(12, 16)*Choose(-1, 1), Rand(12, 16));
								}
								if(i%8==0){
									DealDirectDamage(Ceiling(DAMAGE_BANNON_GRAB2FLIES*DiffMultiplier()));
									if(Link->HP<=0)
										Link->HP = 1;
									
									Q7_RunFFCScript(effectsScript, 6, Ghost_X+42, Ghost_Y+14, -45+Rand(-5, 5), i, 0, 0, 0);
								}
								if(i>64)
									Screen->Rectangle(6, 0, 0, 255, 175, Choose(0x51, 0x52, 0x53, 0x0F), 1, 0, 0, 0, true, 64);
							
								NoAction();
								B_Waitframe(this, ghost, vars);
							}
							for(i=0; i<32; i++){
								B_DrawTrident(4, Ghost_X+42, Ghost_Y+14, -45, 24, 128, false);
								x = Ghost_X+42-8+VectorX(16+16, -45);
								y = Ghost_Y+14-8+VectorY(16+16, -45);
								B_MoveInvisibleLink(x, y);
								Screen->DrawTile(4, x, y, til, 1, 1, 6, -1, -1, x, y, -45, 0, true, 128);
							
								NoAction();
								B_Waitframe(this, ghost, vars);
							}
							
							x = Ghost_X+16;
							y = Ghost_Y+32;
							Game->PlaySound(SFX_SWORD);
							Ghost_Data = combo+15;
							Link->Invisible = false;
							for(i=0; i<16; i++){
								Ghost_MoveXY(0, -1, 0);
								B_TurnHead(vars);
								for(j=0; j<i; j++){
									B_DrawTrident(4, Ghost_X+Q7_Interpolate(42, 24, j, 16), Ghost_Y+Q7_Interpolate(14, 47, j, 16), Q7_Interpolate(-45, 180, j, 16), Q7_Interpolate(0, 24, j, 16), 64, true);
								}
								B_DrawTrident(4, Ghost_X+Q7_Interpolate(42, 24, i, 16), Ghost_Y+Q7_Interpolate(14, 47, i, 16), Q7_Interpolate(-45, 180, i, 16), Q7_Interpolate(0, 24, i, 16), 128, true);
								
								for(j=0; j<4; j++){
									if(CanWalk(x, y, DIR_DOWN, 1, false))
										y++;
								}
								Link->Action = LA_GOTHURTLAND;
								Link->HitDir = -1;
								Link->Dir = DIR_UP;
								B_MoveInvisibleLink(x, y);
								NoAction();
								B_Waitframe(this, ghost, vars);
							}
							for(i=0; i<16; i+=2){
								Ghost_MoveXY(0, -1, 0);
								B_TurnHead(vars);
								for(j=i; j<16; j++){
									B_DrawTrident(4, Ghost_X+Q7_Interpolate(42, 24, j, 16), Ghost_Y+Q7_Interpolate(14, 47, j, 16), Q7_Interpolate(-45, 180, j, 16), Q7_Interpolate(0, 24, j, 16), 64, true);
								}
								
								for(j=0; j<4; j++){
									if(CanWalk(x, y, DIR_DOWN, 1, false))
										y++;
								}
								Link->Action = LA_GOTHURTLAND;
								Link->HitDir = -1;
								Link->Dir = DIR_UP;
								B_MoveInvisibleLink(x, y);
								NoAction();
								B_Waitframe(this, ghost, vars);
							}
						}
						else{
							Link->Invisible = false;
							Link->Dir = DIR_UP;
							
							Link->X = Ghost_X+16;
							Link->Y = Ghost_Y+32;
							
							Ghost_Data = combo+10;
							for(i=0; i<24; i++){
								
								Ghost_MoveXY(0, -1, 0);
								
								m = 128;
								if(i>=16)
									m = 64;
								
								B_DrawTrident(4, Ghost_X+42, Ghost_Y+14, 90, 0, m, false);
								
								Link->Action = LA_GOTHURTLAND;
								Link->HitDir = -1;
								NoAction();
								B_Waitframe(this, ghost, vars);
							}
						}
						
						if(killedLink){
							Link->HP = 0;
						}
						
						Link->Action = LA_GOTHURTLAND;
						Link->HitDir = -1;
						Link->Invisible = false;
						Link->CollDetection = true;
					}
					else{
						for(i=0; i<16; i++){
							B_TurnHead(vars);
							
							m = 128;
							if(i>=8)
								m = 64;
							
							B_DrawTrident(4, Ghost_X+28, Ghost_Y+44, angle, 24, m, false);
							
							B_Waitframe(this, ghost, vars);
						}
					}
					
					vars[4] = k;
					
					Ghost_Data = combo;
					B_StartFeet(vars);
				}
				attackCooldown = LazyDiffMod(180, 120, 90);
			}
			Ghost_MoveTowardLink(0.2, 0);
			m = AngleDir4(Angle(Ghost_X+16, Ghost_Y+16, Link->X, Link->Y));
			if(!Ghost_CanMove(m, 1, 0)){
				if(m==DIR_LEFT||m==DIR_RIGHT){
					Ghost_MoveXY(0, Sign(80-Ghost_Y+16)*0.2, 0);
				}
				else{
					Ghost_MoveXY(Sign(120-Ghost_X+16)*0.2, 0, 0);
				}
			}
			B_TurnHead(vars);
			B_Waitframe(this, ghost, vars);
		}
	}
	void B_MoveInvisibleLink(int x, int y){
		Link->X = Clamp(x, 8, 232);
		Link->Y = Clamp(y, 8, 152);
	}
	bool B_EraseRay(bool safe, int x, int y, int pos){
		int qx[4];
		int qy[4];
		int px = ComboX(pos)+8;
		int py = ComboY(pos)+8;
		int ang = Angle(x, y, px, py);
		qx[0] = px+VectorX(8, ang+90);
		qy[0] = py+VectorY(8, ang+90);
		
		qx[1] = px+VectorX(-8, ang+90);
		qy[1] = py+VectorY(-8, ang+90);
		
		ang = Angle(x, y, qx[1], qy[1]);
		
		qx[2] = qx[1]+VectorX(256, ang);
		qy[2] = qy[1]+VectorY(256, ang);
		
		ang = Angle(x, y, qx[0], qy[0]);
		
		qx[3] = qx[0]+VectorX(256, ang);
		qy[3] = qy[0]+VectorY(256, ang);
		
		Screen->Quad(0, qx[0], qy[0], qx[1], qy[1], qx[2], qy[2], qx[3], qy[3], 1, 1, 0, 0, 0x00, PT_FLAT);
	
		if(Q7_LineBoxCollision(Link->X+2, Link->Y+2, x, y, px-8, py-8, px+7, py+7, 0)){
			safe = true;
		}
		if(Q7_LineBoxCollision(Link->X+13, Link->Y+2, x, y, px-8, py-8, px+7, py+7, 0)){
			safe = true;
		}
		if(Q7_LineBoxCollision(Link->X+2, Link->Y+13, x, y, px-8, py-8, px+7, py+7, 0)){
			safe = true;
		}
		if(Q7_LineBoxCollision(Link->X+13, Link->Y+13, x, y, px-8, py-8, px+7, py+7, 0)){
			safe = true;
		}
		
		return safe;
	}
	void B_TurnHead(int vars){
		if(Abs(Ghost_X+16-Link->X)<48){
			vars[1] = 0;
			return;
		}
		if(Link->X<Ghost_X+16)
			vars[1] = 1;
		else
			vars[1] = 2;
	}
	void B_HandleArmor(ffc this, npc ghost, int vars){
		int defs = vars[10];
		
		if(vars[5]){
			if(ghost->CollDetection){
				for(int i=Screen->NumLWeapons(); i>0; i--){
					lweapon l = Screen->LoadLWeapon(i);
					if(Collision(l, ghost)){
						if(l->ID==LW_SWORD){
							B_TryArmorDamage(vars, 15, 20);
						}
						else if(l->ID==LW_BOMBBLAST){
							B_TryArmorDamage(vars, 30, 20);
						}
						else if(l->ID==LW_BEAM){
							if(G[G_ALTCHARACTER]){
								if(l->Damage>=32*G[G_HPSCALE])
									B_TryArmorDamage(vars, 100, 100);
								else
									B_TryArmorDamage(vars, 10, 20);
							}
							else
								B_TryArmorDamage(vars, 5, 10);
						}
						else if(l->ID==LW_ARROW){
							B_TryArmorDamage(vars, 5, 40);
						}
						else if(l->ID==LW_MAGIC||l->ID==LW_REFMAGIC||l->ID==LW_FIRE){
							B_TryArmorDamage(vars, 2, 250);
						}
						else if(l->ID==LW_PHASECLOAK_BOMB){
							B_TryArmorDamage(vars, 30, 10);
						}
						else if(l->ID==LW_ACCELERATOR){
							B_TryArmorDamage(vars, 5, 40);
						}
					}
				}
			}
			if(vars[7]){
				vars[7]--;
				vars[9] -= vars[6];
				if(vars[9]<=0){
					vars[8]--;
					vars[9] = 100;
					
					vars[19] += 8;
					Boots_PlayTone(vars[8]);
					if(vars[8]<=0){
						vars[6] = 0;
						vars[7] = 0;
						vars[8] = 0;
						vars[9] = 600;
						if(!IsEasyMode())
							vars[9] = 900;
						else if(!IsHardMode())
							vars[9] = 750;
						vars[13] = 20;
						
						Ghost_SetDefenses(ghost, defs);
						vars[5] = 0;
					}
				}
			}
			else{
				vars[9] += 2;
				if(vars[9]>100){
					if(vars[8]>11)
						vars[9] = 100;
					else{
						vars[8]++;
						vars[9] = 0;
					}
				}
			}
		}
		else{
			if(!Link->Item[I_DIFF_VERYEASY])
				vars[9]--;
			if(vars[9]==0){
				Game->PlaySound(SFX_BANNON_ARMOR_REGROW);
				Ghost_SetAllDefenses(ghost, NPCDT_BLOCK);
				vars[5] = 1;
				vars[13] = 48;
				
				vars[8] = 12;
				vars[9] = 100;
			}
		}
	}
	void B_TryArmorDamage(int vars, int damage, int damageTime){
		if(damage*damageTime>vars[6]*vars[7]||damage>vars[6]){
			vars[6] = damage;
			vars[7] = damageTime;
		}
	}
	void B_TeleportOut(ffc this, npc ghost, int vars, int teleDir){
		ghost->CollDetection = false;
		
		vars[1] = 0;
		vars[12] = 1;
		
		Game->PlaySound(SFX_BANNON_PORTALOUT);
		for(int i=0; i<16; i++){
			B_Teleport_Draw(this, ghost, vars, teleDir, Ghost_X, Ghost_Y, i, 16);
			B_Waitframe(this, ghost, vars);
		}
	}
	void B_TeleportIn(ffc this, npc ghost, int vars, int teleDir, int x, int y){
		// Ghost_X = x;
		// Ghost_Y = y;
		
		vars[1] = 0;
		vars[12] = 1;
		
		Game->PlaySound(SFX_BANNON_PORTALIN);
		for(int i=16; i>0; i--){
			B_Teleport_Draw(this, ghost, vars, teleDir, x, y, i, 16);
			B_Waitframe(this, ghost, vars);
		}
		
		vars[12] = 0;
		
		ghost->CollDetection = true;
	}
	void B_Teleport_Draw(ffc this, npc ghost, int vars, int teleDir, int drawX, int drawY, int i, int frames){
		int teleDist;
		
		teleDist = 48*(i/frames);
		Screen->SetRenderTarget(RT_BANNON_TELEPORT);
		
		Screen->Rectangle(0, 0, 0, 80, 80, 0x00, 1, 0, 0, 0, true, 128);
		
		B_Draw(this, ghost, vars, 0, 16, 16);
		
		if(teleDir==DIR_UP){
			Screen->Rectangle(0, 16, 15, 26+47, 15+teleDist, 0x00, 1, 0, 0, 0, true, 128);
		}
		else if(teleDir==DIR_DOWN){
			Screen->Rectangle(0, 16, 16+48-teleDist, 16+47, 16+48, 0x00, 1, 0, 0, 0, true, 128);
		}
		else if(teleDir==DIR_LEFT){
			Screen->Rectangle(0, 15, 16, 15+teleDist, 16+47, 0x00, 1, 0, 0, 0, true, 128);
		}
		else if(teleDir==DIR_RIGHT){
			Screen->Rectangle(0, 16+48-teleDist, 16, 16+48, 16+47, 0x00, 1, 0, 0, 0, true, 128);
		}
		
		Screen->SetRenderTarget(RT_SCREEN);
		
		if(teleDir==DIR_UP){
			Q7_DrawComboC(2, drawX+24, drawY, CMB_BANNON_TELEPORT, 2, 5, 5, -1, -1, drawX+24, drawY, 90, 0, 0, true, 128);
		
			Screen->DrawBitmap(2, RT_BANNON_TELEPORT, 16, 16, 48, 48, drawX, drawY-teleDist, 48, 48, 0, true);
		
			Q7_DrawComboC(2, drawX+24, drawY, CMB_BANNON_TELEPORT+1, 2, 5, 5, -1, -1, drawX+24, drawY, 90, 0, 0, true, 128);
		}
		else if(teleDir==DIR_DOWN){
			Q7_DrawComboC(2, drawX+24, drawY+47, CMB_BANNON_TELEPORT, 2, 5, 5, -1, -1, drawX+24, drawY+47, 270, 0, 0, true, 128);
		
			Screen->DrawBitmap(2, RT_BANNON_TELEPORT, 16, 16, 48, 48, drawX, drawY+teleDist, 48, 48, 0, true);
		
			Q7_DrawComboC(2, drawX+24, drawY+47, CMB_BANNON_TELEPORT+1, 2, 5, 5, -1, -1, drawX+24, drawY+47, 270, 0, 0, true, 128);
		}
		else if(teleDir==DIR_LEFT){
			Q7_DrawComboC(2, drawX, drawY+24, CMB_BANNON_TELEPORT, 2, 5, 5, -1, -1, drawX, drawY+24, 0, 0, 0, true, 128);
		
			Screen->DrawBitmap(2, RT_BANNON_TELEPORT, 16, 16, 48, 48, drawX-teleDist, drawY, 48, 48, 0, true);
			
			Q7_DrawComboC(2, drawX, drawY+24, CMB_BANNON_TELEPORT+1, 2, 5, 5, -1, -1, drawX, drawY+24, 0, 0, 0, true, 128);
		}
		else if(teleDir==DIR_RIGHT){
			Q7_DrawComboC(2, drawX+47, drawY+24, CMB_BANNON_TELEPORT, 2, 5, 5, -1, -1, drawX+47, drawY+24, 180, 0, 0, true, 128);
		
			Screen->DrawBitmap(2, RT_BANNON_TELEPORT, 16, 16, 48, 48, drawX+teleDist, drawY, 48, 48, 0, true);
		
			Q7_DrawComboC(2, drawX+47, drawY+24, CMB_BANNON_TELEPORT+1, 2, 5, 5, -1, -1, drawX+47, drawY+24, 180, 0, 0, true, 128);
		}
	}
	void B_FliesRing(int x, int y, int count, int dist, int ang, int arr1, eweapon earr){
		int i; int j; int k;
		
		int tmpX; int tmpY;
		int angDist = 360/count;
		for(i=0; i<count; i++){
			if(!earr[i]->isValid())
				earr[i] = FireEWeapon(EW_BANNON_FLIES, x-8, y-8, 0, 0, DAMAGE_BANNON_FLIES, 0, 0, 0);
			arr1[i] += arr1[i+count];
			tmpX = x-8+VectorX(dist, ang+i*angDist);
			tmpY = y-8+VectorY(dist, ang+i*angDist);
			
			tmpX += VectorX(arr1[i+count*2]*Sin(arr1[i]), ang+i*angDist+180);
			tmpY += VectorY(arr1[i+count*2]*Sin(arr1[i]), ang+i*angDist+180);
			
			earr[i]->X = tmpX;
			earr[i]->Y = tmpY;
			earr[i]->CollDetection = false;
			earr[i]->DrawYOffset = -1000;
			earr[i]->Angle = DegtoRad(ang+i*angDist+90+90*Cos(arr1[i]));
			SetEWeaponLifespan(earr[i], EWL_TIMER, 2);
			SetEWeaponDeathEffect(earr[i], EWD_VANISH, 0);
		}
	}
	bool B_DrawTrident(int layer, int cx, int cy, int ang, int dist, int op, bool damage){
		cx += VectorX(dist, ang);
		cy += VectorY(dist, ang);
		Q7_DrawTileC(layer, cx, cy, TIL_BANNON_TRIDENT, 4, 4, 11, -1, -1, cx, cy, ang, 0, true, op);
		if(damage){
			if(Q7_RotRectCollision(cx, cy, 28, 4, ang, Link->X+8, Link->Y+8, 4, 4, 0, false)){
				DamageLink(DAMAGE_BANNON_TRIDENT*Bannon_DamageMods());
				return true;
			}
		}
		return false;
	}
	void B_Draw(ffc this, npc ghost, int vars, int layer, int x, int y){
		int combo = ghost->Attributes[10];
		int cs = this->CSet;
		if(vars[17])
			cs = 3;
		
		int headCMB = combo+1;
		if(vars[1]==1)
			headCMB = combo+2;
		else if(vars[1]==2)
			headCMB = combo+3;
		int bodyCMB = Ghost_Data;
		int headYOff = 9;
		int feetXOff = 8;
		int feetYOff[2] = {34, 34};
		if(Ghost_Data==combo+11){
			headYOff = -1000;
		}
		else if(Ghost_Data>=combo+12||Ghost_Data>=combo+15){
			headYOff = 15;
			feetXOff = 11;
		}
		if(vars[19]){
			if(vars[19]%8>3){
				combo += 32;
				headCMB += 32;
				bodyCMB += 32;
			}
			--vars[19];
		}
		
		if(vars[3]==0||vars[3]==1){
			if(vars[3]==0)
				feetYOff[0] -= 4*Sin((180/vars[4])*vars[2]);
			else if(vars[3]==1)
				feetYOff[1] -= 4*Sin((180/vars[4])*vars[2]);
		}
		else if(vars[3]==2||vars[3]==3){
			if(vars[3]==2)
				feetYOff[0] -= 4*Sin(vars[2]);
			else if(vars[3]==3)
				feetYOff[1] -= 4*Sin(vars[2]);
		}
		
		if(Link->HP>0){
			Screen->FastCombo(layer, x+16-feetXOff, y+feetYOff[0], combo+4, cs, 128);
			Screen->FastCombo(layer, x+16+feetXOff, y+feetYOff[1], combo+5, cs, 128);
		
			Screen->DrawCombo(layer, x, y, bodyCMB, 3, 3, cs, -1, -1, 0, 0, 0, 0, 0, true, 128);
			
			Screen->DrawCombo(layer, x+8, y+headYOff, headCMB, 2, 1, cs, -1, -1, 0, 0, 0, 0, 0, true, 128);
		}
	}
	void B_Draw(ffc this, npc ghost, int vars){
		int combo = ghost->Attributes[10];
		
		int headCMB = combo+1;
		if(vars[1]==1)
			headCMB = combo+2;
		else if(vars[1]==2)
			headCMB = combo+3;
		int bodyCMB = Ghost_Data;
		int headYOff = 9;
		int feetXOff = 8;
		int feetYOff[2] = {34, 34};
		if(Ghost_Data==combo+11){
			headYOff = -1000;
		}
		else if(Ghost_Data>=combo+12||Ghost_Data>=combo+15){
			headYOff = 15;
			feetXOff = 11;
		}
		
		if(vars[3]==0||vars[3]==1){
			if(vars[12]==0){
				vars[2]++;
				if(vars[2]>=vars[4]){
					Game->PlaySound(SFX_BANNON_STOMP);
					int args[8];
					if(vars[3]==0)
						args[1] = Ghost_X+16-feetXOff+8;
					else
						args[1] = Ghost_X+16+feetXOff+8;
					args[2] = Ghost_Y+46;
					RunFFCScript(vars[11], args);
				
					vars[3] = (vars[3]+1)%2;
					vars[2] = 0;
				}
			}
			
			if(vars[3]==0)
				feetYOff[0] -= 4*Sin((180/vars[4])*vars[2]);
			else if(vars[3]==1)
				feetYOff[1] -= 4*Sin((180/vars[4])*vars[2]);
		}
		else if(vars[3]==2||vars[3]==3){
			if(vars[3]==2)
				feetYOff[0] -= 4*Sin(vars[2]);
			else if(vars[3]==3)
				feetYOff[1] -= 4*Sin(vars[2]);
		}
		
		if(vars[12]==1)
			return;
		
		if(Link->HP>0){
			if(Ghost_Z>0)
				Screen->DrawCombo(2, Ghost_X, Ghost_Y+32, combo+6, 3, 1, 7, -1, -1, 0, 0, 0, 0, 0, true, 128);
			if(vars[5]){
				int armorOff[2];
				int range = 5;
				if(vars[13]>0){
					range = (vars[13]/48)*15;
					vars[13]--;
				}
				armorOff[0] = Rand(-range, range);
				armorOff[1] = Rand(-range, range);
				
				Screen->FastCombo(2, armorOff[0]+Ghost_X+16-feetXOff, armorOff[1]+Ghost_Y-Ghost_Z+feetYOff[0], combo+4, this->CSet, 64);
				Screen->FastCombo(2, armorOff[0]+Ghost_X+16+feetXOff, armorOff[1]+Ghost_Y-Ghost_Z+feetYOff[1], combo+5, this->CSet, 64);
			
				Screen->DrawCombo(2, armorOff[0]+Ghost_X, armorOff[1]+Ghost_Y-Ghost_Z, bodyCMB, 3, 3, this->CSet, -1, -1, 0, 0, 0, 0, 0, true, 64);
				
				Screen->DrawCombo(2, armorOff[0]+Ghost_X+8, armorOff[1]+Ghost_Y-Ghost_Z+headYOff, headCMB, 2, 1, this->CSet, -1, -1, 0, 0, 0, 0, 0, true, 64);
			}
			else{
				if(vars[13]>0){
					if(vars[13]%2==0)
						Q7_RunFFCScript(-vars[11], 5, Ghost_X+Rand(48), Ghost_Y+Rand(48), 0, 0, 0, 0, 0);		
					
					vars[13]--;
				}
			}
		}
		
		B_Draw(this, ghost, vars, 2, Ghost_X, Ghost_Y-Ghost_Z);
	}
	void B_DestroyRocksContact(npc ghost){
		int x1 = ghost->X+ghost->HitXOffset-1;
		int x2 = ghost->X+ghost->HitXOffset+ghost->HitWidth+1;
		int y1 = ghost->Y+ghost->HitYOffset-1;
		int y2 = ghost->Y+ghost->HitYOffset+ghost->HitHeight+1;
		for(int x=x1; x<=x2; x=Min(x+16, x2)){
			for(int y=y1; y<=y2; y=Min(y+16, y2)){
				//Screen->PutPixel(6, x, y, 0x01, 0, 0, 0, 128);
				int pos = ComboAt(x, y);
				if(GetLayerComboS(2, pos)){
					SetLayerComboD(2, pos, 0);
					eweapon sbomb = FireEWeapon(EW_SBOMBBLAST, ComboX(pos), ComboY(pos), 0, 0, DAMAGE_BANNON_ROCKFALL*Bannon_DamageMods(), -1, -1, 0);
				}
				if(y==y2)
					break;
			}
			if(x==x2)
				break;
		}
	}
	void B_StopFeet(int vars){
		vars[2] = 0;
		vars[3] = 2;
	}
	void B_StartFeet(int vars){
		vars[2] = 0;
		vars[3] = Rand(2);
	}
	void B_WeaponUpdate(ffc this, npc ghost, int vars){
		
		if(vars[18])
			vars[18]--;
		
		bool canBeDamaged = Link->CollDetection;
		for(int i=Screen->NumEWeapons(); i>=1; i--){
			eweapon e = Screen->LoadEWeapon(i);
			if(e->ID==EW_BANNON_FLIES){
				int flyAng = RadtoDeg(e->Angle);
				if(e->Misc[__EWI_MOVEMENT]==EWM_SINE_WAVE){
					flyAng += 90*Cos(e->Misc[__EWI_WORK]);
				}
				Screen->DrawCombo(4, e->X, e->Y, CMB_BANNON_FLIES, 1, 1, 5, -1, -1, e->X, e->Y, flyAng, 0, 0, true, 128);
				if(RectCollision(e->X+4, e->Y+4, e->X+11, e->Y+11, Link->X, Link->Y, Link->X+15, Link->Y+15)){
					if(!e->Misc[EWM_BANNON_FLIES]){
						e->Misc[EWM_BANNON_FLIES] = 8;
						
						if(canBeDamaged){
							if(vars[18]<=0){
								Game->PlaySound(SFX_OUCH);
								DealDirectDamage(Ceiling(DAMAGE_BANNON_FLIES*DiffMultiplier()/2));
								canBeDamaged = false;
								if(IsEasyMode())
									vars[18] = 8;
								else if(!IsHardMode())
									vars[18] = 4;
							}
						}
					}
				}
				else{
					if(e->Misc[EWM_BANNON_FLIES])
						e->Misc[EWM_BANNON_FLIES]--;
				}
				if(e->X<-80||e->X>256+64||e->Y<-80||e->Y>176+64)
					e->DeadState = 0;
			}
		}
	}
	void B_PhaseChanges(ffc this, npc ghost, int vars){
		//vars[14] - Max HP
		//vars[15] - Current Phase
		//vars[16] - Target Phase
		
		int phaseHP[4];
		if(IsHardMode()){
			phaseHP[0] = Round(vars[14]*0.75);
			phaseHP[1] = Round(vars[14]*0.50);
			phaseHP[2] = Round(vars[14]*0.25);
		}
		else{
			phaseHP[0] = Round(vars[14]*0.6666);
			phaseHP[1] = Round(vars[14]*0.3333);
		}
		
		bool raiseShield;
		
		if(vars[15]==0){
			if(ghost->HP<phaseHP[0]){
				ghost->HP = phaseHP[0];
				Ghost_HP = ghost->HP;
				
				vars[16] = 1;
			}
		}
		else if(vars[15]==1){
			if(ghost->HP<phaseHP[1]){
				ghost->HP = phaseHP[1];
				Ghost_HP = ghost->HP;
				
				vars[16] = 2;
			}
		}
		else if(vars[15]==2&&phaseHP[2]>0){
			if(ghost->HP<phaseHP[2]){
				ghost->HP = phaseHP[2];
				Ghost_HP = ghost->HP;
				
				vars[16] = 3;
			}
		}
		
		if(vars[15]!=vars[16]){
			if(!vars[5]){
				Ghost_SetAllDefenses(ghost, NPCDT_BLOCK);
				vars[5] = 1;
			}
			vars[13] = 48;
			vars[6] = 0;
			vars[7] = 0;
			vars[8] = 12;
			vars[9] = 100;	
		}
	}
	void B_Waitframe(ffc this, npc ghost, int vars){
		// if(Link->PressEx1){
			// if(Link->Item[I_DIFF_NORMAL]){
				// Link->Item[I_DIFF_NORMAL] = false;
				// Link->Item[I_DIFF_HARD] = true;
				// Link->Item[I_DIFF_VERYHARD] = false;
			// }
			// else if(Link->Item[I_DIFF_HARD]){
				// Link->Item[I_DIFF_NORMAL] = false;
				// Link->Item[I_DIFF_HARD] = false;
				// Link->Item[I_DIFF_VERYHARD] = true;
			// }
			// else if(Link->Item[I_DIFF_VERYHARD]){
				// Link->Item[I_DIFF_NORMAL] = true;
				// Link->Item[I_DIFF_HARD] = false;
				// Link->Item[I_DIFF_VERYHARD] = false;
			// }
		// }
		
		B_PhaseChanges(this, ghost, vars);
		B_WeaponUpdate(this, ghost, vars);
		B_HandleArmor(this, ghost, vars);
		B_Draw(this, ghost, vars);
		if(!Q7_Ghost_Waitframe(this, ghost, false, false)){
			B_DeathAnim(this, ghost, vars);
			Quit();
		}
	}
	void B_Waitframe(ffc this, npc ghost, int vars, int frames){
		for(int i=0; i<frames; i++){
			B_Waitframe(this, ghost, vars);
		}
	}
	void B_ClearEffects(){
		int i;
		int effectsScript[] = "Bannon_Effects";
		int slot = Game->GetFFCScript(effectsScript);
		
		for(i=1; i<=32; i++){
			ffc f = Screen->LoadFFC(i);
			if(f->Script==slot)
				f->Script = 0;
		}
		for(i=Screen->NumEWeapons(); i>=1; i--){
			eweapon e = Screen->LoadEWeapon(i);
			e->DeadState = 0;
		}
	}
	void B_DeathAnim(ffc this, npc ghost, int vars){
		int i; int j; int k;
		
		int combo = ghost->Attributes[10];
		
		__DeathAnimStart(this, ghost);
		__DeathAnimSFX(ghost->ID, ghost->X);
		B_ClearEffects();
		
		__Ghost_FlashCounter=0;
		
		Game->PlayMIDI(0);
		Screen->D[7] = 2;
		vars[17] = 1;
		Ghost_Data = combo+8;
		vars[1] = 0;
		for(i=0; i<32; i++){
			if(i%2==0)
				vars[1] = Rand(3);
			B_Draw(this, ghost, vars, 2, Ghost_X, Ghost_Y);
			Ghost_WaitframeLight(this, ghost);
		}
		vars[1] = 0;
		for(i=0; i<16; i++){
			B_Draw(this, ghost, vars, 2, Ghost_X, Ghost_Y);
			Ghost_WaitframeLight(this, ghost);
		}
		Game->PlaySound(SFX_GLASSCRACK);
		for(i=0; i<48; i++){
			B_Draw(this, ghost, vars, 2, Ghost_X, Ghost_Y);
			Screen->DrawTile(2, Ghost_X+8, Ghost_Y+16, TIL_BANNON_CRACK, 2, 2, 11, -1, -1, 0, 0, 0, 0, true, 128);
			Ghost_WaitframeLight(this, ghost);
		}
		Game->PlaySound(SFX_GLASSCRACK);
		for(i=0; i<48; i++){
			B_Draw(this, ghost, vars, 2, Ghost_X, Ghost_Y);
			Screen->DrawTile(2, Ghost_X+8, Ghost_Y+16, TIL_BANNON_CRACK+2, 2, 2, 11, -1, -1, 0, 0, 0, 0, true, 128);
			Ghost_WaitframeLight(this, ghost);
		}
		Game->PlaySound(SFX_GLASSCRACK);
		for(i=0; i<48; i++){
			B_Draw(this, ghost, vars, 2, Ghost_X, Ghost_Y);
			Screen->DrawTile(2, Ghost_X+8, Ghost_Y+16, TIL_BANNON_CRACK+4, 2, 2, 11, -1, -1, 0, 0, 0, 0, true, 128);
			Ghost_WaitframeLight(this, ghost);
		}
		int baseAng = Rand(360);
		int rayA[6];
		int rayW[6];
		int rayMaxW[6];
		for(i=0; i<3; i++){
			rayA[i] = baseAng + i*120 + Rand(-20, 20);
			rayMaxW[i] = Rand(8, 12);
			
			rayA[i+3] = baseAng + 60 + i*120 + Rand(-20, 20);
			rayMaxW[i+3] = Rand(8, 12);
		}
		Game->PlaySound(98);
		Screen->SetRenderTarget(RT_BANNON_SHOCKWAVES);
		Screen->Rectangle(0, 0, 0, 255, 175, 0x00, 1, 0, 0, 0, true, 128);
		Screen->SetRenderTarget(RT_SCREEN);
		for(i=0; i<32; i++){
			B_Draw(this, ghost, vars, 2, Ghost_X, Ghost_Y);
			Screen->DrawTile(2, Ghost_X+8, Ghost_Y+16, TIL_BANNON_CRACK+4, 2, 2, 11, -1, -1, 0, 0, 0, 0, true, 128);
			if(i%8==0&&i<24)
				Game->PlaySound(97);
			for(j=0; j<3; j++){
				if(i>j*8){
					rayW[j] = Min(rayW[j]+1, rayMaxW[j]);
				}
			}
			for(j=0; j<6; j++){
				if(rayW[j]>0){
					FakeArc(4, Ghost_X+24, Ghost_Y+28, 256*(rayMaxW[j]/rayW[j]), rayA[j]-(rayW[j]+Rand(2))/2, rayA[j]+(rayW[j]+Rand(2))/2, 0x01, 1, 0, 0, 0, true, true, 128);
				}
			}
			Ghost_WaitframeLight(this, ghost);
		}
		for(i=0; i<16; i++){
			B_Draw(this, ghost, vars, 2, Ghost_X, Ghost_Y);
			Screen->DrawTile(2, Ghost_X+8, Ghost_Y+16, TIL_BANNON_CRACK+4, 2, 2, 11, -1, -1, 0, 0, 0, 0, true, 128);
			for(j=0; j<6; j++){
				if(rayW[j]>0){
					FakeArc(4, Ghost_X+24, Ghost_Y+28, 256*(rayMaxW[j]/rayW[j]), rayA[j]-(rayW[j]+Rand(2))/2, rayA[j]+(rayW[j]+Rand(2))/2, 0x01, 1, 0, 0, 0, true, true, 128);
				}
			}
			Ghost_WaitframeLight(this, ghost);
		}
		for(i=0; i<32; i++){
			B_Draw(this, ghost, vars, 2, Ghost_X, Ghost_Y);
			Screen->DrawTile(2, Ghost_X+8, Ghost_Y+16, TIL_BANNON_CRACK+4, 2, 2, 11, -1, -1, 0, 0, 0, 0, true, 128);
			if(i%8==0&&i<24)
				Game->PlaySound(97);
			for(j=0; j<3; j++){
				if(i>j*8){
					rayW[j+3] = Min(rayW[j+3]+1, rayMaxW[j+3]);
				}
			}
			for(j=0; j<6; j++){
				if(rayW[j]>0){
					FakeArc(4, Ghost_X+24, Ghost_Y+28, 256*(rayMaxW[j]/rayW[j]), rayA[j]-(rayW[j]+Rand(2))/2, rayA[j]+(rayW[j]+Rand(2))/2, 0x01, 1, 0, 0, 0, true, true, 128);
				}
			}
			Ghost_WaitframeLight(this, ghost);
		}
		Game->PlaySound(99);
		for(i=0; i<64; i++){
			B_Draw(this, ghost, vars, 2, Ghost_X, Ghost_Y);
			Screen->DrawTile(2, Ghost_X+8, Ghost_Y+16, TIL_BANNON_CRACK+4, 2, 2, 11, -1, -1, 0, 0, 0, 0, true, 128);
			for(j=0; j<6; j++){
				if(rayW[j]>0){
					FakeArc(4, Ghost_X+24, Ghost_Y+28, 256*(rayMaxW[j]/rayW[j]), rayA[j]-(rayW[j]+Rand(2))/2, rayA[j]+(rayW[j]+Rand(2))/2, 0x01, 1, 0, 0, 0, true, true, 128);
				}
			}
			Screen->SetRenderTarget(RT_BANNON_SHOCKWAVES);
			Screen->Circle(0, Ghost_X+24, Ghost_Y+28, i*4, 0x01, 1, 0, 0, 0, true, 128);
			Screen->SetRenderTarget(RT_SCREEN);
			Screen->DrawBitmap(7, RT_BANNON_SHOCKWAVES, 0, 0, 256, 176, 0, 0, 256, 176, 0, true);
			
			Ghost_WaitframeLight(this, ghost);
		}
		Bannon_ClearLayer2();
		Screen->D[7] = 3;
		Link->X = 120;
		Link->Y = 128;
		Link->Dir = DIR_UP;
		for(i=0; i<128; i++){
			Screen->SetRenderTarget(RT_BANNON_SHOCKWAVES);
			Screen->Rectangle(0, 0, 0, 255, 175, 0x00, 1, 0, 0, 0, true, 128);
			for(j=0; j<128; j++){
				k = 88+48-(88+48)*(i/96) + 16*Sin(i*6+j*2) - 48*Sin((j/128)*180);
				Screen->Line(0, j*2, k, j*2, k-176, 0x01, 1, 0, 0, 0, 128);
				k = 88+32-(88+48)*(i/96) + 16*Sin(i*8+j*2) - 48*Sin((j/128)*180);
				Screen->Line(0, j*2+1, k, j*2+1, k-176, 0x01, 1, 0, 0, 0, 128);
				
				k = 88-48+(88+48)*(i/96) - 16*Sin(i*6+j*2) + 48*Sin((j/128)*180);
				Screen->Line(0, j*2, k, j*2, k+176, 0x01, 1, 0, 0, 0, 128);
				k = 88-32+(88+48)*(i/96) - 16*Sin(i*8+j*2) + 48*Sin((j/128)*180);
				Screen->Line(0, j*2+1, k, j*2+1, k+176, 0x01, 1, 0, 0, 0, 128);
			}
			Screen->SetRenderTarget(RT_SCREEN);
			
			Screen->DrawBitmap(7, RT_BANNON_SHOCKWAVES, 0, 0, 256, 176, 0, 0, 256, 176, 0, true);
			
			NoAction();
			
			Ghost_WaitframeLight(this, ghost);
		}
		
		for(i=0; i<64; i++){
			NoAction();
			
			Ghost_WaitframeLight(this, ghost);
		}
		int ys[] = "Ys.nsf";
		Game->PlayEnhancedMusic(ys, 12);
		for(i=0; i<32; i++){
			Screen->FastCombo(2, 120, 72, 2918, 6, 64);
			Screen->FastCombo(2, 120, 72, 2918, 6, 64);
			
			NoAction();
			
			Ghost_WaitframeLight(this, ghost);
		}
		for(i=0; i<32; i++){
			Screen->FastCombo(2, 120, 72, 2918, 6, 64);
			
			
			NoAction();
			
			Ghost_WaitframeLight(this, ghost);
		}
		for(i=0; i<32; i++){
			Screen->FastCombo(2, 120, 72, 2918, 6, 128);
			
			
			NoAction();
			
			Ghost_WaitframeLight(this, ghost);
		}
		Screen->Message(167);
		Screen->FastCombo(2, 120, 72, 2918, 6, 128);
		NoAction();
		Ghost_WaitframeLight(this, ghost);
		for(i=86; i<=89; i++){
			Screen->ComboF[i] = 15;
		}
		
		while(true){
			Screen->FastCombo(2, 120, 72, 2918, 6, 128);
			
			Ghost_WaitframeLight(this, ghost);
		}
		
		__DeathAnimEnd(this, ghost);
	}
}

const int DAMAGE_BANNON_STOMP = 12;
const int DAMAGE_BANNON_ROCKFALL = 16;

const int CMB_BANNON_ROCKFALL = 2908;

const int NPC_BANNON = 316;

ffc script Bannon_Effects{
	void run(int type, int x, int y, int d3, int d4, int d5, int d6, int d7){
		int i; int j; int k; int m;
		int x2; int y2;
		int vX; int vY;
		int w; int w2; int segments;
		
		int diffMod[4];
		
		int effectsScript[] = "Bannon_Effects";
		if(type==0){ //Shockwave
			m = 6; //10
			if(d3>0){
				m = d3;
				if(!IsHardMode()){
					m = Floor(m*0.8);
				}
			}
			if(d4==0){
				for(i=-16; i<=16; i=Min(i+16, 16)){
					for(j=-16; j<=16; j=Min(j+16, 16)){
						if(GetLayerComboS(2, ComboAt(x+i, y+j))){
							k = ComboAt(x+i, y+j);
							eweapon sbomb = FireEWeapon(EW_SBOMBBLAST, ComboX(k), ComboY(k), 0, 0, DAMAGE_BANNON_ROCKFALL*Bannon_DamageMods(), -1, -1, 0);
							SetLayerComboD(2, k, 0);
						}
						if(j==16)
							break;
					}
					if(i==16)
						break;
				}
			}
			for(i=0; i<m; i++){
				k = Choose(0xB1, 0xB2, 0xB3);
				for(j=0; j<3; j++){
					if(i<m-2)
						Screen->Ellipse(1, x, y, i*4+j, i*2.5+j, k, 1, 0, 0, 0, false, 128);
					else
						Screen->Ellipse(1, x, y, i*4+j, i*2.5+j, k, 1, 0, 0, 0, false, 64);
				}
				if(EllipsePointCollision(x, y, i*4, i*2.5, Link->X+8, Link->Y+12))
					DamageLink(DAMAGE_BANNON_STOMP*Bannon_DamageMods());
				Waitframe();
			}
		}
		else if(type==1){ //Lightning
			x2 = d3;
			y2 = d4;
			w = d5;
			w2 = d6;
			segments = d7;
			
			int lightning[1024];
			
			Lightning_Init(lightning, x, y, x2, y2, w, w2, segments);
			
			Game->PlaySound(SFX_LIGHTNING_STRIKE);
			for(i=0; i<16; i++){
				Lightning_Update(lightning, 6, 12, 0x0F);
				if(i<4)
					Screen->Rectangle(7, 0, 0, 255, 275, 0x01, 1, 0, 0, 0, true, 64);
				if(i==1||i==2)
					Screen->Rectangle(7, 0, 0, 255, 275, 0x01, 1, 0, 0, 0, true, 128);
				Waitframe();
			}
		}
		else if(type==2){ //Rocks fall
			npc ghost = LoadNPCOf(NPC_BANNON);
			if((x==0&&y==0)||!ComboFI(x+8, y+8, 103)||Screen->isSolid(x+8, y+8)){
				for(i=0; i<176*2; i++){
					if(i<176)
						j = Rand(176);
					else
						j = i-176;
					if(ComboFI(j, 103)&&(i>=176||Distance(ghost->X+16, ghost->Y+24, ComboX(j), ComboY(j))>32)){
						x = ComboX(j);
						y = ComboY(j);
						if(i<176&&Screen->isSolid(x+8, y+8))
							continue;
						break;
					}
				}
			}
			Game->PlaySound(SFX_FALL);
			for(i=176; i>0; i-=4){
				Screen->FastCombo(2, x, y, CMB_BANNON_ROCKFALL+3, 7, 128);
				Screen->FastCombo(6, x, y-i, CMB_BANNON_ROCKFALL, 8, 128);
				Waitframe();
			}
			SetLayerComboD(2, ComboAt(x+8, y+8), CMB_BANNON_ROCKFALL+1);
			Q7_SetLayerComboC(2, ComboAt(x+8, y+8), 8);
			Game->PlaySound(SFX_BOMB);
			Game->PlaySound(SFX_BANNON_SHOCKWAVE);
			Q7_RunFFCScript(effectsScript, 0, x+8, y+8, 10, 1, 0, 0, 0);		
		}
		else if(type==3){ //Charge ball
			if(d4==0)
				d4 = 1;
			vX = VectorX(d4, d3);
			vY = VectorY(d4, d3);
			
			m = 0;
			if(d5)
				m = 2;
			Game->PlaySound(SFX_BANNON_CHARGEBALL);
			while(true){
				x += vX;
				y += vY;
				
				diffMod[0] = LazyDiffMod(2, 3, 3.5); //Top Speed
				diffMod[1] = LazyDiffMod(0.0666, 0.1, 0.1166); //Accel
				
				if(Distance(x, y, Link->X, Link->Y)<48){
					vX = Clamp(vX+Sign(Link->X-x)*diffMod[1], -diffMod[0], diffMod[0]); //*0.2, 4
					vY = Clamp(vY+Sign(Link->Y-y)*diffMod[1], -diffMod[0], diffMod[0]);
				}
				else{
					vX = Clamp(vX+Sign(Link->X-x)*diffMod[1]*0.5, -diffMod[0], diffMod[0]); //*0.1, 4
					vY = Clamp(vY+Sign(Link->Y-y)*diffMod[1]*0.5, -diffMod[0], diffMod[0]);
				}
				
				if(m==0){
					if(!ChargeBall_IsSolid(x+8, y+8))
						m = 1;
				}
				else if(m==1){
					if(ChargeBall_IsSolid(x+8, y+8)){
						m = 2;
						Game->PlaySound(SFX_BANNON_CHARGEBALL_BOUNCE);
						d3 = Angle(x, y, Link->X+8, Link->Y+8);
						vX = VectorX(1, d3);
						vY = VectorY(1, d3);
					}
				}
				else if(m==2){
					if(!ChargeBall_IsSolid(x+8, y+8))
						m = 3;
				}
				else if(m==3){
					if(ChargeBall_IsSolid(x+8, y+8))
						break;
				}
				
				Screen->FastCombo(2, x, y, CMB_BANNON_SMALLBALL, 10, 128);
				MakeHitbox(x, y, 16, 16, DAMAGE_BANNON_SMALLSHOCK*Bannon_DamageMods());
				Waitframe();
			}
			
			Game->PlaySound(SFX_BANNON_SHOCKWAVE);
			Game->PlaySound(SFX_BOMB);
			for(i=0; i<24; i++){
				j = 4+32*(i/16);
				k = Choose(0xA1, 0xA2, 0xA3, 0x0F);
				if(i%4<2)
					k = 0x01;
				m = 4*(i/16);
				vX = Rand(-m, m);
				vY = Rand(-m, m);
				
				Screen->Circle(4, x+8+vX, y+8+vY, j, k, 1, 0, 0, 0, true, 128);
				
				k = Choose(0xA1, 0xA2, 0xA3, 0x0F);
				
				Screen->Circle(4, x+8+vX+Rand(-2, 2), y+8+vY+Rand(-2, 2), j, k, 1, 0, 0, 0, false, 128);
				Screen->Circle(4, x+8+vX+Rand(-2, 2), y+8+vY+Rand(-2, 2), j, k, 1, 0, 0, 0, false, 128);
				Screen->Circle(4, x+8+vX+Rand(-2, 2), y+8+vY+Rand(-2, 2), j, k, 1, 0, 0, 0, false, 128);
				
				if(Distance(Link->X, Link->Y, x, y)<j)
					DamageLink(DAMAGE_BANNON_SMALLSHOCK*Bannon_DamageMods());
				
				Waitframe();
			}
		}
		else if(type==4){ //Wrapping Flies
			eweapon ewrapFly[12];
			int flyA1[12];
			int flyA2[12];
			int flyX[12];
			int flyY[12];
			int flyWraps[12];
			int flyWork[12];
			int flyAng[12];
			int flyStep[12];
			int wrapFly[] = {0, flyA1, flyA2, flyX, flyY, flyWraps, flyWork, flyAng, flyStep};
			
			diffMod[0] = LazyDiffMod(48, 40, 32);
			diffMod[1] = LazyDiffMod(4, 5, 6);
			for(i=0; i<diffMod[1]; i++){
				Game->PlaySound(SFX_BANNON_FLIES);
				flyA1[i] = Rand(12, 16);
				flyA2[i] = Rand(12, 16);
				flyX[i] = x;
				flyY[i] = y;
				flyWraps[i] = d3;
				flyAng[i] = Angle(x, y, Link->X, Link->Y+176);
				flyStep[i] = 3;
				ewrapFly[i] = FireEWeapon(EW_BANNON_FLIES, x, y, DegtoRad(flyAng[i]), 0, DAMAGE_BANNON_FLIES, 0, 0, 0);
				ewrapFly[i]->CollDetection = false;
				ewrapFly[i]->DrawYOffset = -1000;
				for(j=0; j<diffMod[0]; j++){
					WarpFly_Update(ewrapFly, wrapFly);
					Waitframe();
				}
			}
			while(wrapFly[0]>0){
				for(i=0; i<diffMod[1]; i++){
					if(flyStep[i]>1.5)
					flyStep[i] -= 0.1;
				}
				WarpFly_Update(ewrapFly, wrapFly);
				Waitframe();
			}
		}
		else if(type==5){ //Armor Break Particles
			for(i=0; i<8; i++){
				k = 128;
				if(i>=6)
					k = 64;
				for(j=0; j<3; j++){
					Screen->Circle(4, x+Rand(-1, 1), y+Rand(-1, 1), i*2+j*2, 0x0F, 1, 0, 0, 0, false, k);
				}
				Waitframe();
			}
		}
		else if(type==6){ //Triangle Wave
			int lineX[2];
			int lineY[2];
			for(i=0; i<64; i+=2){
				x += VectorX(8, d3);
				y += VectorY(8, d3);
				d4 += 8;
				for(j=0; j<3; j++){
					for(k=0; k<3; k++){
						lineX[0] = x+VectorX(i+k*2, d4+120*j);
						lineY[0] = y+VectorY(i+k*2, d4+120*j);
						lineX[1] = x+VectorX(i+k*2, d4+120*(j+1));
						lineY[1] = y+VectorY(i+k*2, d4+120*(j+1));
						
						Screen->Line(6, lineX[0], lineY[0], lineX[1], lineY[1], 0x0F, 1, 0, 0, 0, 128);
					}
				}
				Waitframe();
			}
		}
	}
	void WarpFly_Update(eweapon ewrapFly, int wrapFly){
		int flyA1 = wrapFly[1];
		int flyA2 = wrapFly[2];
		int flyX = wrapFly[3];
		int flyY = wrapFly[4];
		int flyWraps = wrapFly[5];
		int flyWork = wrapFly[6];
		int flyAng = wrapFly[7];
		int flyStep = wrapFly[8];
		
		wrapFly[0] = 0;
		for(int i=0; i<12; i++){
			if(flyWraps[i]>0){
				int offset = flyA1[i]*Sin(flyWork[i]);
				if(ewrapFly[i]->isValid()){
					ewrapFly[i]->Angle = DegtoRad(flyAng[i]+90*Cos(flyWork[i]));
					ewrapFly[i]->X = flyX[i]+VectorX(offset, flyAng[i]+90);
					ewrapFly[i]->Y = flyY[i]+VectorY(offset, flyAng[i]+90);
				}
				else{
					ewrapFly[i] = FireEWeapon(EW_BANNON_FLIES, flyX[i]+VectorX(offset, flyAng[i]+90), flyY[i]+VectorY(offset, flyAng[i]+90), DegtoRad(flyAng[i]), 0, DAMAGE_BANNON_FLIES, 0, 0, 0);
					ewrapFly[i]->CollDetection = false;
					ewrapFly[i]->DrawYOffset = -1000;
					//SetEWeaponMovement(ewrapFly[i], EWM_SINE_WAVE, flyA1[i], flyA2[i]);
				}
				flyWork[i] += flyA2[i];
				// if(flyStep[i]>1.5)
					// flyStep[i] -= 0.2;
				flyX[i] += VectorX(flyStep[i], flyAng[i]);
				flyY[i] += VectorY(flyStep[i], flyAng[i]);
				if(flyX[i]<-32){
					flyWraps[i]--;
					flyX[i] += 240+64;
				}
				if(flyX[i]>240+32){
					flyWraps[i]--;
					flyX[i] -= 240+64;
				}
				if(flyY[i]<-32){
					flyWraps[i]--;
					flyY[i] += 160+64;
				}
				if(flyY[i]>160+32){
					flyWraps[i]--;
					flyY[i] -= 160+64;
				}
				
				wrapFly[0]++;
			}
			else if(ewrapFly[i]->isValid())
				ewrapFly[i]->DeadState = 0;
		}
	}
	void Lightning_Init(int lightning, int x1, int y1, int x2, int y2, int width, int width2, int segments){
		int ang = Angle(x1, y1, x2, y2);
		int dist = Distance(x1, y1, x2, y2);
		int tmpX; int tmpY; int tmpW; int tmpAng;
		for(int i=0; i<segments+1; i++){
			tmpX = x1+VectorX(dist*(i/segments), ang);
			tmpY = y1+VectorY(dist*(i/segments), ang);
			tmpAng = ang+Rand(-30, 30);
			tmpW = 0;
			if(i>0&&i<segments){
				tmpX += VectorX(Rand(-width/2, width/2), ang+90);
				tmpY += VectorY(Rand(-width/2, width/2), ang+90);
				tmpW = width2;
			}
			lightning[i*4+0] = tmpX;
			lightning[i*4+1] = tmpY;
			lightning[i*4+2] = tmpAng;
			lightning[i*4+3] = tmpW;
		}
	}
	void Lightning_Update(int lightning, int layer, int segments, int color){
		int x[4];
		int y[4];
		int i;
		for(i=0; i<segments; i++){
			x[0] = lightning[i*4+0];
			y[0] = lightning[i*4+1];
			
			x[1] = lightning[i*4+0];
			y[1] = lightning[i*4+1];
			
			if(i>0){
				x[0] += VectorX(-lightning[i*4+3]/2, lightning[i*4+2]);
				y[0] += VectorY(-lightning[i*4+3]/2, lightning[i*4+2]);
				
				x[1] += VectorX(lightning[i*4+3]/2, lightning[i*4+2]);
				y[1] += VectorY(lightning[i*4+3]/2, lightning[i*4+2]);
			}
			
			x[2] = lightning[(i+1)*4+0];
			y[2] = lightning[(i+1)*4+1];
			
			x[3] = lightning[(i+1)*4+0];
			y[3] = lightning[(i+1)*4+1];
			
			if(i<segments){
				x[2] += VectorX(lightning[(i+1)*4+3]/2, lightning[(i+1)*4+2]);
				y[2] += VectorY(lightning[(i+1)*4+3]/2, lightning[(i+1)*4+2]);
				
				x[3] += VectorX(-lightning[(i+1)*4+3]/2, lightning[(i+1)*4+2]);
				y[3] += VectorY(-lightning[(i+1)*4+3]/2, lightning[(i+1)*4+2]);
			}
			
			Screen->Quad(layer, x[0], y[0], x[1], y[1], x[2], y[2], x[3], y[3], 1, 1, 0, 0, color, PT_FLAT);
		}
	}
	bool ChargeBall_IsSolid(int x, int y){
		if(x<0||x>255||y<0||y>167)
			return true;
		return Screen->isSolid(x, y);
	}
}

void Q7_DrawSpeedLines(int startSeed, int layer, int x1, int y1, int x2, int y2, int w, int h, int numLines, int colors){
	int seed[2] = {startSeed[0], startSeed[1]};
	
	int maxColors = SizeOfArray(colors);
	int xOff; int yOff;  int clr;
	for(int i=0; i<numLines; i++){
		xOff = Q7_srand(seed, w);
		yOff = Q7_srand(seed, h);
		clr = Q7_srand(seed, maxColors);
		
		Screen->Line(layer, x1+xOff, y1+yOff, x2+xOff, y2+yOff, colors[clr], 1, 0, 0, 0, 128);
	}
}

void Q7_XORShift_SetSeed(int seed, int x, int y) {
	 seed[0] = x & 0xFFFF;
	 seed[1] = y & 0xFFFF;
}

int Q7_XORShift_Next(int seed) {
	 int t = seed[0] ^ ((seed[0] << 5) & 0xFFFF);
	 seed[0] = seed[1];
	 seed[1] = (seed[1] ^ (seed[1] >> 1));
	 seed[1] ^= t ^ (t >> 3);
	 return seed[1];
}

int Q7_srand(int seed, int max){
	if(seed[0]==-1)
		return Rand(max);
	else
		return Q7_XORShift_Next(seed)%max;
}

int Q7_srand(int seed, int min, int max){
	if(seed[0]==-1)
		return Rand(min, max);
	else
		return min+(Q7_XORShift_Next(seed)%(max-min+1));
}

void DamageLink(int damage){
	eweapon e = FireEWeapon(EW_SCRIPT10, Link->X+InFrontX(Link->Dir, 12), Link->Y+InFrontY(Link->Dir, 12), 0, 0, damage, -1, -1, EWF_UNBLOCKABLE);
	e->Dir = Link->Dir;
	e->DrawYOffset = -1000;
	SetEWeaponLifespan(e, EWL_TIMER, 1);
	SetEWeaponDeathEffect(e, EWD_VANISH, 0);
}

void Q7_RunFFCScript(int name, int d0, int d1, int d2, int d3, int d4, int d5, int d6, int d7){
	int slot;
	if(name<0)
		slot = -name;
	else 
		slot = Game->GetFFCScript(name);
	int args[8] = {d0, d1, d2, d3, d4, d5, d6, d7};
	RunFFCScript(slot, args);
}

bool EllipsePointCollision(int x1, int y1, int rx, int ry, int x2, int y2){
	if(rx==0||ry==0)
		return false;
	int ret = (Pow((x2-x1), 2)/Pow(rx, 2)) + (Pow((y2-y1), 2)/Pow(ry, 2));
	// if(ret<1)
		// Screen->Ellipse(6, x1, y1, rx, ry, 0x81, 1, 0, 0, 0, false, 128);
	// else
		// Screen->Ellipse(6, x1, y1, rx, ry, 0x01, 1, 0, 0, 0, false, 128);
	// Screen->Circle(6, x2, y2, 2, 0x01, 1, 0, 0, 0, true, 128);
	return ret<1;
}

//Function to draw a tile where the scaling, rotation, and position point is the center of the tile
void Q7_DrawTileC(int layer, int x, int y, int tile, int blockw, int blockh, int cset, int xscale, int yscale, int rx, int ry, int rangle, int flip, bool transparency, int opacity){
	int w = xscale;
	if(xscale==-1)
		w = blockw*16;
	int h = yscale;
	if(yscale==-1)
		h = blockh*16;
	Screen->DrawTile(layer, x-w/2, y-h/2, tile, blockw, blockh, cset, xscale, yscale, rx-w/2, ry-h/2, rangle, flip, transparency, opacity);
}

//A shorthand way to set a combo on the current layer.
//Layer 0 is the screen itself.
void Q7_SetLayerComboC(int layer, int pos, int combo) 
{
	if (layer < 0 )
	{
		int err[]="Invalid layer passed to SetLayerComboC";
		TraceError(err,layer);
		return;
	}
	if (layer > 6 )
	{
		int err[]="Invalid layer passed to SetLayerComboC";
		TraceError(err,layer);
		return;
	}
	if (!layer) //layer 0
	{
		if ( SETLAYERCOMBO_ALWAYS_USE_SETCOMBO )
		{
			Game->SetComboCSet(Game->GetCurMap(), Game->GetCurScreen(), pos, combo);
			return;
		}
		else
		{
			Screen->ComboC[pos] = combo;
			return;
		}
	}
	else
	{
		Game->SetComboCSet(Screen->LayerMap(layer), Screen->LayerScreen(layer), pos, combo);
	}
}

//Function to draw a combo where the scaling, rotation, and position point is the center of the tile
void Q7_DrawComboC(int layer, int x, int y, int combo, int blockw, int blockh, int cset, int xscale, int yscale, int rx, int ry, int rangle, int frame, int flip, bool transparency, int opacity){
	int w = xscale;
	if(xscale==-1)
		w = blockw*16;
	int h = yscale;
	if(yscale==-1)
		h = blockh*16;
	Screen->DrawCombo(layer, x-w/2, y-h/2, combo, blockw, blockh, cset, xscale, yscale, rx-w/2, ry-h/2, rangle, frame, flip, transparency, opacity);
}

// Function to see if a box has collided with a line
bool Q7_LineBoxCollision(int lineX1, int lineY1, int lineX2, int lineY2, int boxX1, int boxY1, int boxX2, int boxY2, int boxBorder)
{
	// Shrink down the box for the border
	boxX1 += boxBorder; boxY1 += boxBorder;
	boxX2 -= boxBorder; boxY2 -= boxBorder;
	
	// If the line isn't vertical
	if(lineX2!=lineX1)
	{
		
		float i0 = (boxX1 - lineX1)/(lineX2-lineX1);
		float i1 = (boxX2 - lineX1)/(lineX2-lineX1);
		
		float yA = lineY1 + i0*(lineY2-lineY1);
		float yB = lineY1 + i1*(lineY2-lineY1);
		
		
		if(Max(boxX1, boxX2) >= Min(lineX1, lineX2) && Min(boxX1, boxX2) <= Max(lineX1, lineX2) &&
			Max(boxY1, boxY2) >= Min(lineY1, lineY2) && Min(boxY1, boxY2) <= Max(lineY1, lineY2))
		{
			if(Min(boxY1, boxY2) > Max(yA, yB) || Max(boxY1, boxY2) < Min(yA, yB))
				return false;
			else
				return true;
		}
		else
			return false;
	}
	// If the line is vertical
	else if(lineX1 >= boxX1 && lineX1 <= boxX2)
	{
		// Basically we need to find the top and bottom y values of the line to check for intersection
		float lineYMin = lineY1;
		float lineYMax = lineY2;
		
		if(lineYMin > lineYMax)
		{
			lineYMin = lineY2;
			lineYMax = lineY1;
		}
		
		// If either point intersects
		if((boxY1 >= lineYMin && boxY1 <= lineYMax) || (boxY2 >= lineYMin && boxY2 <= lineYMax))
			return true;
	}
	
	return false;
} //! End of lineBoxCollision

bool Q7_NPCRectCollision(npc n, int x, int y, int w, int h){
	return RectCollision(n->X+n->HitXOffset, n->Y+n->HitYOffset, n->X+n->HitXOffset+n->HitWidth-1, n->Y+n->HitYOffset+n->HitHeight-1, x, y, x+w-1, y+h-1);
}

// Returns true if two rotated hitboxes collide
// float x1c,y1c        - Center point of the first hitbox
// float width1,height1 - Width/Height of the first hitbox
// float rot1           - Rotation of the first hitbox
// float x2c,y2c        - Center point of the second hitbox
// float width2,height2 - Width/Height of the second hitbox
// float rot2           - Rotation of the second hitbox
// bool debug   		- If true, draws both hitboxes to the screen for debugging collisions
bool Q7_RotRectCollision(float x1c, float y1c, float width1, float height1, float rot1, float x2c, float y2c, float width2, float height2, float rot2, bool debug){
	float rad1=Sqrt(height1*height1+width1*width1);
	float rad2=Sqrt(height2*height2+width2*width2);
	
	float angle1=RadtoDeg(ArcSin(height1/rad1));
	float angle2=RadtoDeg(ArcSin(height2/rad2));
	
	float x1[4];
	float y1[4];
	float x2[4];
	float y2[4];
	float axisX[4];
	float axisY[4];
	float proj;
	float minProj1;
	float maxProj1;
	float minProj2;
	float maxProj2;
	x1[0]=x1c+rad1*Cos(rot1-angle1);
	y1[0]=y1c+rad1*Sin(rot1-angle1);
	x1[1]=x1c+rad1*Cos(rot1+angle1);
	y1[1]=y1c+rad1*Sin(rot1+angle1);
	x1[2]=x1c+rad1*Cos(rot1+180-angle1);
	y1[2]=y1c+rad1*Sin(rot1+180-angle1);
	x1[3]=x1c+rad1*Cos(rot1+180+angle1);
	y1[3]=y1c+rad1*Sin(rot1+180+angle1);

	x2[0]=x2c+rad2*Cos(rot2-angle2);
	y2[0]=y2c+rad2*Sin(rot2-angle2);
	x2[1]=x2c+rad2*Cos(rot2+angle2);
	y2[1]=y2c+rad2*Sin(rot2+angle2);
	x2[2]=x2c+rad2*Cos(rot2+180-angle2);
	y2[2]=y2c+rad2*Sin(rot2+180-angle2);
	x2[3]=x2c+rad2*Cos(rot2+180+angle2);
	y2[3]=y2c+rad2*Sin(rot2+180+angle2);
	axisX[0]=x1[0]-x1[1];
	axisY[0]=y1[0]-y1[1];
	axisX[1]=x1[2]-x1[1];
	axisY[1]=y1[2]-y1[1];
	axisX[2]=x2[0]-x2[1];
	axisY[2]=y2[0]-y2[1];
	axisX[3]=x2[2]-x2[1];
	axisY[3]=y2[2]-y2[1];
	if(debug){
		Screen->Rectangle(5, x1c-width1, y1c-height1, x1c+width1, y1c+height1, 1, -1, x1c, y1c, rot1, true, 128);
		Screen->Rectangle(5, x2c-width2, y2c-height2, x2c+width2, y2c+height2, 2, -1, x2c, y2c, rot2, true, 128);
	}
	for(int i=0; i<4; i++){
		proj=x1[0]*axisX[i]+y1[0]*axisY[i];
		minProj1=proj;
		maxProj1=proj;
		for(int j=1; j<4; j++){
			proj=x1[j]*axisX[i]+y1[j]*axisY[i];
			if(proj<minProj1)
				minProj1=proj;
			if(proj>maxProj1)
				maxProj1=proj;
		}
		proj=x2[0]*axisX[i]+y2[0]*axisY[i];
		minProj2=proj;
		maxProj2=proj;
		for(int j=1; j<4; j++){
			proj=x2[j]*axisX[i]+y2[j]*axisY[i];
			if(proj<minProj2)
				minProj2=proj;
			if(proj>maxProj2)
				maxProj2=proj;
		}
		if(maxProj2<minProj1 || maxProj1<minProj2)
			return false;
	}
	return true;
}

int Q7_Interpolate(int start, int end, int frame, int numframes){
	return start + (end-start)*(frame/numframes);
}

int Q7_InterpolateSin(int start, int end, int frame, int numframes){
	return start + (end-start)*Sin(frame/numframes*180);
}

void FakeArc(int layer, int x, int y, int radius, int startangle, int endangle, int color, float scale, int rx, int ry, int rangle, bool closed, bool fill, int opacity){
	int x1 = x+VectorX(radius, startangle);
	int y1 = y+VectorY(radius, startangle);
	
	int x2 = x+VectorX(radius, endangle);
	int y2 = y+VectorY(radius, endangle);
	
	Screen->Triangle(layer, x2, y2, x1, y1, x, y, 1, 1, color, 0, -1, PT_FLAT);
}

void SFXLoop(int sfx, int frate){
	if(G[G_SFXANIM]>=frate){
		G[G_SFXANIM] = 0;
	}
	if(G[G_SFXANIM]==0)
		Game->PlaySound(sfx);
	G[G_SFXANIM]++;
	
}

const int D_NESGANONROOMEVENTFLAG = 6;

ffc script NESGanonRoom{
	void run(){
		int i; int j; int k;
		int sfxTimer;
		int ganonTheme[] = "Zelda - The Legend of Link.nsf";
		if(Screen->D[D_NESGANONROOMEVENTFLAG]<2){
			npc stopper = CreateNPCAt(NPC_TRIGGER, 0, 0);
			
			while(Link->Y>=128){
				Waitframe();
			}
			Game->PlayMIDI(0);
			
			if(Screen->D[D_NESGANONROOMEVENTFLAG]==0){
				sfxTimer = 0;
				for(i=0; i<32; i++){
					if(i==16)
						Screen->Message(174);
					
					Q7_WaitNoAction();
				}
				for(i=-48; i<48; i+=1.5){
					++sfxTimer;
					if(!(sfxTimer%20))
						Game->PlaySound(SFX_ADJEAN_DASH);
					if(!(sfxTimer%4))
						ShadowTrail(112, i, 2, 2, 2837, 10, 20);
					
					Screen->DrawCombo(4, 112, i, 2837, 2, 2, 10, -1, -1, 0, 0, 0, 0, 0, true, 128);
					
					Q7_WaitNoAction();
				}
				for(i=0; i<30; i++){
					if(i==16)
						Screen->Message(175);
					
					Screen->DrawCombo(4, 112, 48, 2837, 2, 2, 10, -1, -1, 0, 0, 0, 0, 0, true, 128);
					
					Q7_WaitNoAction();
				}
				sfxTimer = 0;
				for(i=48; i>-48; i-=1.5){
					++sfxTimer;
					if(!(sfxTimer%20))
						Game->PlaySound(SFX_ADJEAN_DASH);
					if(!(sfxTimer%4))
						ShadowTrail(112, i, 2, 2, 2837, 10, 20);
					
					Screen->DrawCombo(4, 112, i, 2837, 2, 2, 10, -1, -1, 0, 0, 0, 0, 0, true, 128);
					
					Q7_WaitNoAction();
				}
				Screen->D[D_NESGANONROOMEVENTFLAG] = 1;
			}
			for(i=1; i<=32; i++){
				ffc f = Screen->LoadFFC(i);
				f->Flags[FFCF_IGNOREHOLDUP] = true;
			}
			for(i=0; i<48; i++){
				Link->Action = LA_NONE;
				Link->Action = LA_HOLD2LAND;
				Link->HeldItem = I_TRIFORCE;
				Q7_WaitNoAction();
			}
			Game->PlaySound(14);
			for(i=0; i<176; i++){
				Link->Action = LA_NONE;
				Link->Action = LA_HOLD2LAND;
				Link->HeldItem = I_TRIFORCE;
				
				Screen->DrawTile(2, 112, 48, 5100, 2, 2, 9, -1, -1, 0, 0, 0, 0, true, 128);
				
				Q7_WaitNoAction();
			}
			Link->Action = LA_NONE;
			npc gann = CreateNPCAt(NPC_GANON, 112, 48);
			Game->PlayEnhancedMusic(ganonTheme, 14);
			while(gann->isValid()){
				if(stopper->isValid()){
					if(stopper->HP<=0)
						stopper = CreateNPCAt(NPC_TRIGGER, 0, 0);
				}
				else
					stopper = CreateNPCAt(NPC_TRIGGER, 0, 0);
				Waitframe();
			}
			stopper = CreateNPCAt(NPC_TRIGGER, 0, 0);
			sfxTimer = 0;
			for(i=-48; i<48; i+=1.5){
				++sfxTimer;
				if(!(sfxTimer%20))
					Game->PlaySound(SFX_ADJEAN_DASH);
				if(!(sfxTimer%4))
					ShadowTrail(112, i, 2, 2, 2837, 10, 20);
				
				if(Abs(Link->X-120)<24){
					if(Link->Y<i+32){
						Link->Y = i+32;
						Link->Dir = DIR_UP;
					}
				}
				
				Screen->DrawCombo(4, 112, i, 2837, 2, 2, 10, -1, -1, 0, 0, 0, 0, 0, true, 128);
				
				Q7_WaitNoAction();
			}
			for(i=0; i<30; i++){
				if(i==16)
					Screen->Message(180);
				
				Screen->DrawCombo(4, 112, 48, 2837, 2, 2, 10, -1, -1, 0, 0, 0, 0, 0, true, 128);
				
				Q7_WaitNoAction();
			}
			sfxTimer = 0;
			for(i=48; i>-48; i-=1.5){
				++sfxTimer;
				if(!(sfxTimer%20))
					Game->PlaySound(SFX_ADJEAN_DASH);
				if(!(sfxTimer%4))
					ShadowTrail(112, i, 2, 2, 2837, 10, 20);
				
				Screen->DrawCombo(4, 112, i, 2837, 2, 2, 10, -1, -1, 0, 0, 0, 0, 0, true, 128);
				
				Q7_WaitNoAction();
			}
			Screen->D[D_NESGANONROOMEVENTFLAG] = 2;
			if(stopper->isValid()){
				stopper->HP = -1000;
				stopper->ItemSet = 0;
			}
		}
	}
}

void Q7_WaitNoAction(){
	Link->InputStart = false; Link->PressStart = false;
	Link->InputMap = false; Link->PressMap = false;
	WaitNoAction();
}

ffc script DarmLockedDoorLinker{
	void run(int dmap, int scrn, int doorDir, int oppositeDir){
		dmap = Screen->GetSideWarpDMap(0);
		// if(dmap==23&&NumTriforcePieces()>=8)
			// dmap = 24;
		int doorBit = 1<<doorDir;
		int oppositeDoorBit = 1<<oppositeDir;
		while(true){
			int targetD = Game->GetDMapScreenD(dmap, scrn, D_LTTPDOORS);
			if(Screen->D[D_LTTPDOORS]&doorBit)
				targetD = targetD | oppositeDoorBit;
			else
				targetD = targetD & ~oppositeDoorBit;
			Game->SetDMapScreenD(dmap, scrn, D_LTTPDOORS, targetD);
			
			Waitframe();
		}
	}
}

const int PASSWORDMENU_NUMCHARS = 40;
const int PASSWORDMENU_ROWSIZE = 10;

const int SFX_ERROR = 66;

bool Q7_CheatEnabled(int index){
	return G[index]&&!G[G_DISABLE_SPECIALMODES];
}

const int CHEAT_RESETTI					= 1;
const int CHEAT_HYRULEWARRIORS 			= 2;
const int CHEAT_BINLAND 				= 3;
const int CHEAT_DARKNUT 				= 4;
const int CHEAT_ALWAYSHARD 				= 5;
const int CHEAT_SPEEDHACK 				= 6;
const int CHEAT_LOGGINGMEMES 			= 7;
const int CHEAT_GLITCH 					= 8;
const int CHEAT_YOLO					= 9;
const int CHEAT_NOTRIFORCE 				= 10;
const int CHEAT_SLASH 					= 11;
const int CHEAT_SBOMB 					= 12;
const int CHEAT_SAITAMA 				= 13;
const int CHEAT_NJFHP 					= 14;
const int CHEAT_COLORSHIFT 				= 15;
const int CHEAT_RANDOMIZER 				= 16;
const int CHEAT_EASYNAV 				= 17;
const int CHEAT_SPOILENEMYSECRETS 		= 18;
const int CHEAT_STANDARDRANDOMIZER 		= 19;
const int CHEAT_HANDYMAP 				= 20;
const int CHEAT_GARDEVOIR 				= 21;
const int CHEAT_OKBOOMER 				= 22;
const int CHEAT_NOPROGRESSIVE 			= 23;
const int CHEAT_NOLOGIC 				= 24;
const int CHEAT_DEBUGITEMS 				= 25;
const int CHEAT_BSIDES 					= 26;
const int CHEAT_MAXRANDOMIZER 			= 27;
const int CHEAT_FREESIGHT 				= 28;
const int CHEAT_MAPHINTS 				= 29;
const int CHEAT_CHARMENU 				= 30;
const int CHEAT_NONIGHTMARE 			= 31;
const int CHEAT_SAURON		 			= 32;
const int CHEAT_MANGOSTEEN		 		= 33;
const int CHEAT_BLEEDINGHEART 			= 34;
const int CHEAT_BLEEDINGWALLET			= 35;

ffc script PasswordMenu{
	void run(){
		G[G_DISABLE_SPECIALMODES] = 1;
		
		int i;
		
		int characters[] = {'A', 'B', 'C', 'D', 'E', 'F', 'G', 'H', 'I', 'J', 'K', 'L', 'M', 'N', 'O', 'P', 'Q', 'R', 'S', 'T', 'U', 'V', 'W', 'X', 'Y', 'Z', '_', '.', '!', '?', '0', '1', '2', '3', '4', '5', '6', '7', '8', '9'};
		int sel[5];
		//sel[0] - Selection position
		//sel[1] - Selection X
		//sel[2] - Selection Y
		//sel[3] - Selection X2
		//sel[4] - Current character selection
		
		int curPass[17];
		int enabledCheats[64];
		
		int holdDir[4];
		
		for(i=0; i<16; i++){
			Screen->Rectangle(6, 0, 0, 255, 175, 0x0F, 1, 0, 0, 0, true, 64);
			WaitNoAction();
		}
		for(i=0; i<16; i++){
			Screen->Rectangle(6, 0, 0, 255, 175, 0x0F, 1, 0, 0, 0, true, 64);
			Screen->Rectangle(6, 0, 0, 255, 175, 0x0F, 1, 0, 0, 0, true, 64);
			WaitNoAction();
		}
		int holdDirMax = 16;
		while(true){
			bool buttonPressed = false;
			if(Link->InputUp){
				++holdDir[DIR_UP];
				buttonPressed = true;
			}
			else if(Link->InputDown){
				++holdDir[DIR_DOWN];
				buttonPressed = true;
			}
			if(Link->InputLeft){
				++holdDir[DIR_LEFT];
				buttonPressed = true;
			}
			else if(Link->InputRight){
				++holdDir[DIR_RIGHT];
				buttonPressed = true;
			}
			
			if(buttonPressed){
				holdDirMax = Clamp(holdDirMax-0.1, 8, 16);
			}
			else{
				holdDirMax = Clamp(holdDirMax+0.2, 8, 16);
			}
			
			if(Link->PressUp||holdDir[DIR_UP]>holdDirMax){
				holdDir[DIR_UP] = 0;
				holdDir[DIR_DOWN] = 0;
				
				if(sel[0]<PASSWORDMENU_NUMCHARS){
					--sel[2];
					if(sel[2]<0){
						sel[3] = Clamp(Floor(sel[1]/3), 0, 2);
						sel[2] = 4;
						
						sel[0] = PASSWORDMENU_NUMCHARS+sel[3];
					}
					else{
						sel[0] = sel[1]+sel[2]*PASSWORDMENU_ROWSIZE;
					}
				}
				else{
					sel[2] = 3;
					sel[0] = sel[1]+sel[2]*PASSWORDMENU_ROWSIZE;
				}
				
				Game->PlaySound(SFX_SELECT);
			}
			else if(Link->PressDown||holdDir[DIR_DOWN]>holdDirMax){
				holdDir[DIR_UP] = 0;
				holdDir[DIR_DOWN] = 0;
				
				if(sel[0]<PASSWORDMENU_NUMCHARS){
					++sel[2];
					if(sel[2]>3){
						sel[3] = Clamp(Floor(sel[1]/3), 0, 2);
						sel[2] = 4;
						
						sel[0] = PASSWORDMENU_NUMCHARS+sel[3];
					}
					else{
						sel[0] = sel[1]+sel[2]*PASSWORDMENU_ROWSIZE;
					}
				}
				else{
					sel[2] = 0;
					sel[0] = sel[1]+sel[2]*PASSWORDMENU_ROWSIZE;
				}
				
				Game->PlaySound(SFX_SELECT);
			}
			if(Link->PressLeft||holdDir[DIR_LEFT]>holdDirMax){
				holdDir[DIR_LEFT] = 0;
				holdDir[DIR_RIGHT] = 0;
				
				if(sel[0]<PASSWORDMENU_NUMCHARS){
					--sel[1];
					if(sel[1]<0){
						sel[1] = PASSWORDMENU_ROWSIZE-1;
					}
					sel[0] = sel[1]+sel[2]*PASSWORDMENU_ROWSIZE;
				}
				else{
					--sel[3];
					if(sel[3]<0){
						sel[3] = 2;
					}
					sel[0] = PASSWORDMENU_NUMCHARS+sel[3];
					sel[1] = Clamp(Round(Floor(sel[3]/4.5)*4.5), 0, PASSWORDMENU_ROWSIZE-1);
				}
				
				Game->PlaySound(SFX_SELECT);
			}
			else if(Link->PressRight||holdDir[DIR_RIGHT]>holdDirMax){
				holdDir[DIR_LEFT] = 0;
				holdDir[DIR_RIGHT] = 0;
				
				if(sel[0]<PASSWORDMENU_NUMCHARS){
					++sel[1];
					if(sel[1]>PASSWORDMENU_ROWSIZE-1){
						sel[1] = 0;
					}
					sel[0] = sel[1]+sel[2]*PASSWORDMENU_ROWSIZE;
				}
				else{
					++sel[3];
					if(sel[3]>2){
						sel[3] = 0;
					}
					sel[0] = PASSWORDMENU_NUMCHARS+sel[3];
					sel[1] = Clamp(Round(Floor(sel[3]/4.5)*4.5), 0, PASSWORDMENU_ROWSIZE-1);
				}
				
				Game->PlaySound(SFX_SELECT);
			}
			
			if(Link->PressStart){
				sel[1] = 0;
				sel[2] = 4;
				sel[3] = 0;
				
				sel[0] = PASSWORDMENU_NUMCHARS+sel[3];
				
				Link->PressA = true;
			}
			Link->InputStart = false;
			Link->PressStart = false;
			
			if(Link->PressA){
				if(sel[0]<PASSWORDMENU_NUMCHARS){
					if(sel[4]<16){
						Game->PlaySound(SFX_SELECT);
						
						curPass[sel[4]] = characters[sel[0]];
						
						++sel[4];
					}
					else{
						Game->PlaySound(SFX_ERROR);
					}
				}
				else{
					if(sel[3]==0){
						int activePass = CheckPassword(curPass);
						if(activePass==0){
							Game->PlaySound(SFX_ERROR);
						}
						else{
							Game->PlaySound(SFX_CONFIRM);
							if(activePass==CHEAT_RESETTI){
								ToggleCheat(activePass);
								Screen->Message(193);
							}
							else{
								//enabledCheats[activePass-1] = Cond(enabledCheats[activePass-1], 0, 1);
								if(ToggleCheat(activePass)){
									if(activePass==CHEAT_HYRULEWARRIORS)
										Screen->Message(194);
									else if(activePass==CHEAT_BINLAND)
										Screen->Message(195);
									else if(activePass==CHEAT_DARKNUT)
										Screen->Message(196);
									else if(activePass==CHEAT_ALWAYSHARD)
										Screen->Message(197);
									else if(activePass==CHEAT_SPEEDHACK)
										Screen->Message(198);
									else if(activePass==CHEAT_LOGGINGMEMES)
										Screen->Message(199);
									else if(activePass==CHEAT_GLITCH)
										Screen->Message(200);
									else if(activePass==CHEAT_YOLO)
										Screen->Message(201);
									else if(activePass==CHEAT_NOTRIFORCE)
										Screen->Message(202);
									else if(activePass==CHEAT_SLASH)
										Screen->Message(203);
									else if(activePass==CHEAT_SBOMB)
										Screen->Message(204);
									else if(activePass==CHEAT_SAITAMA)
										Screen->Message(205);
									else if(activePass==CHEAT_NJFHP)
										Screen->Message(206);
									else if(activePass==CHEAT_COLORSHIFT)
										Screen->Message(207);
									else if(activePass==CHEAT_RANDOMIZER)
										Screen->Message(209);
									else if(activePass==CHEAT_EASYNAV)
										Screen->Message(210);
									else if(activePass==CHEAT_SPOILENEMYSECRETS)
										Screen->Message(211);
									else if(activePass==CHEAT_STANDARDRANDOMIZER)
										Screen->Message(213);
									else if(activePass==CHEAT_HANDYMAP)
										Screen->Message(214);
									else if(activePass==CHEAT_OKBOOMER)
										Screen->Message(218);
									else if(activePass==CHEAT_NOPROGRESSIVE)
										Screen->Message(219);
									else if(activePass==CHEAT_NOLOGIC)
										Screen->Message(220);
									if(activePass==CHEAT_DEBUGITEMS)
										Screen->Message(230);
									else if(activePass==CHEAT_BSIDES)
										Screen->Message(231);
									else if(activePass==CHEAT_MAXRANDOMIZER)
										Screen->Message(232);
									else if(activePass==CHEAT_FREESIGHT)
										Screen->Message(276);
									else if(activePass==CHEAT_MAPHINTS)
										Screen->Message(277);
									else if(activePass==CHEAT_CHARMENU)
										Screen->Message(280);
									else if(activePass==CHEAT_NONIGHTMARE)
										Screen->Message(281);
									else if(activePass==CHEAT_SAURON)
										Screen->Message(282);
									else if(activePass==CHEAT_MANGOSTEEN)
										Screen->Message(283);
									else if(activePass==CHEAT_BLEEDINGHEART)
										Screen->Message(284);
									else if(activePass==CHEAT_BLEEDINGWALLET)
										Screen->Message(285);
								}
								else{
									Screen->Message(216);
								}
							}
						}
						
						for(i=0; i<16; i++){
							curPass[i] = 0;
							sel[4] = 0;
						}
					}
					else if(sel[3]==1){
						if(sel[4]>0){
							Game->PlaySound(SFX_PLACE);
							
							curPass[sel[4]] = 0;
							
							--sel[4];
							
							curPass[sel[4]] = 0;
						}
						else{
							Game->PlaySound(SFX_ERROR);
						}
					}
					else if(sel[3]==2){
						if(sel[4]>0)
							Game->PlaySound(SFX_ERROR);
						else{
							G[G_DISABLE_SPECIALMODES] = 1;
							Game->PlaySound(SFX_CONFIRM);
							break;
						}
					}
				}
			}
			if(Link->PressB){
				if(sel[4]>0){
					Game->PlaySound(SFX_PLACE);
					
					curPass[sel[4]] = 0;
					
					--sel[4];
					
					curPass[sel[4]] = 0;
				}
				else{
					Game->PlaySound(SFX_ERROR);
				}
			}
			
			Screen->Rectangle(6, 0, 0, 255, 175, 0x0F, 1, 0, 0, 0, true, 64);
			Screen->Rectangle(6, 0, 0, 255, 175, 0x0F, 1, 0, 0, 0, true, 64);
			DrawLetterInputs(48, 256-48, 64, 256-64, 32, 48, characters, sel, curPass, G[G_ANIM]%32<16);
			DrawActiveCheats();
			NoAction();
			Waitframe();
		}
		for(i=0; i<16; i++){
			DrawActiveCheats();
			Screen->Rectangle(6, 0, 0, 255, 175, 0x0F, 1, 0, 0, 0, true, 64);
			Screen->Rectangle(6, 0, 0, 255, 175, 0x0F, 1, 0, 0, 0, true, 64);
			WaitNoAction();
		}
		for(i=0; i<16; i++){
			DrawActiveCheats();
			Screen->Rectangle(6, 0, 0, 255, 175, 0x0F, 1, 0, 0, 0, true, 64);
			WaitNoAction();
		}
	}
	void DrawLetterInputs(int minX, int maxX, int minOptionX, int maxOptionX, int passwordX, int baseY, int characters, int sel, int curPass, bool drawPlace){
		int baseW = maxX-minX;
		int optionW = maxOptionX-minOptionX;
		
		int passwordStr[64] = "PASSWORD: ";
		strcat(passwordStr, curPass);
		if(sel[4]<16&&drawPlace){
			passwordStr[10+sel[4]] = '_';
		}
		Q7_DrawStringOutline(6, passwordX-4, baseY-baseW*(1/(PASSWORDMENU_ROWSIZE-1))-4, FONT_Z1, 0x01, 0x0F, TF_NORMAL, passwordStr, 128); 
		
		for(int i=0; i<PASSWORDMENU_NUMCHARS; i++){
			int x = baseW*(1/(PASSWORDMENU_ROWSIZE-1))*(i%PASSWORDMENU_ROWSIZE);
			int y = baseW*(1/(PASSWORDMENU_ROWSIZE-1))*Floor(i/PASSWORDMENU_ROWSIZE);
			
			if(sel[0]==i){
				Q7_DrawCharacterOutline(6, minX+x-4, baseY+y-4, FONT_Z1, 0x01, 0x0F, -1, -1, characters[i], 128); 
			}
			else{
				Q7_DrawCharacterOutline(6, minX+x-4, baseY+y-4, FONT_Z1, 0x02, 0x0F, -1, -1, characters[i], 128); 
			}
		}
		
		int enter[] = "ENTER";
		int del[] = "DELETE";
		int done[] = "DONE";
		
		int options[3] = {enter, del, done};
		
		for(int i=0; i<3; i++){
			int x = optionW*0.5*i;
			int y = baseW*(1/(PASSWORDMENU_ROWSIZE-1))*4;
			
			if(sel[0]==PASSWORDMENU_NUMCHARS+i){
				Q7_DrawStringOutline(6, minOptionX+x, baseY+y-4, FONT_Z1, 0x01, 0x0F, TF_CENTERED, options[i], 128); 
			}
			else{
				Q7_DrawStringOutline(6, minOptionX+x, baseY+y-4, FONT_Z1, 0x02, 0x0F, TF_CENTERED, options[i], 128); 
			}
		}
	} 
	int CheckPassword(int curPass){
		int resetti[] = "RESETTI";
		int ciathicc[] = "CIA_THICC";
		int binland[] = "BINLAND";
		int darknut[] = "DARKNUT";
		int ragingclue[] = "RAGING_CLUE";
		int g2gfast[] = "G2G_FAST";
		int lagmyshitup[] = "LAG_MY_SHIT_UP";
		int baguwashere[] = "BAGU_WAS_HERE";
		int yoloswolo[] = "YOLO_SWOLO";
		int nay4ce[] = "NAY4CE";
		int slashyjoe[] = "SLASHY_JOE";
		int soupperbomb[] = "SOUP_PER_BOMB";
		int saitama[] = "SAITAMA";
		int lawofslaw[] = "LAW_OF_SLAW";
		int cset16[] = "CSET16";
		int rng[] = "RNG";
		int rngstd[] = "RNGSTD";
		int rngmax[] = "RNGMAX";
		int littlewilly[] = "LITTLE_WILLY";
		int dingdingding[] = "DINGDINGDING";
		int patrahasit[] = "PATRAHASIT";
		int okboomer[] = "OK_BOOMER";
		int altite[] = "ALTITE";
		int impossibleseed[] = "IMPOSSIBLE_SEED";
		int gehennaexpress[] = "GEHENNA_EXPRESS";
		int bsides[] = "$5B";
		int bombwallio[] = "BOMBWALLIO";
		int fi4me[] = "FI4ME";
		int aots4[] = "AOTS4";
		int nonutmare[] = "NO_NUTMARE";
		int sauron[] = "SAURON";
		int mangosteen[] = "MANGOSTEEN";
		int thisisfun[] = "THIS_IS_FUN";
		int findom[] = "FINDOM";
		
		int allPass[256];
		allPass[CHEAT_RESETTI] = resetti;
		allPass[CHEAT_HYRULEWARRIORS] = ciathicc;
		allPass[CHEAT_BINLAND] = binland;
		allPass[CHEAT_DARKNUT] = darknut;
		allPass[CHEAT_ALWAYSHARD] = ragingclue;
		allPass[CHEAT_SPEEDHACK] = g2gfast;
		allPass[CHEAT_LOGGINGMEMES] = lagmyshitup;
		allPass[CHEAT_GLITCH] = baguwashere;
		allPass[CHEAT_YOLO] = yoloswolo;
		allPass[CHEAT_NOTRIFORCE] = nay4ce;
		allPass[CHEAT_SLASH] = slashyjoe;
		allPass[CHEAT_SBOMB] = soupperbomb;
		allPass[CHEAT_SAITAMA] = saitama;
		allPass[CHEAT_NJFHP] = lawofslaw;
		allPass[CHEAT_COLORSHIFT] = cset16;
		allPass[CHEAT_RANDOMIZER] = rng;
		allPass[CHEAT_STANDARDRANDOMIZER] = rngstd;
		allPass[CHEAT_MAXRANDOMIZER] = rngmax;
		allPass[CHEAT_EASYNAV] = littlewilly;
		allPass[CHEAT_SPOILENEMYSECRETS] = dingdingding;
		allPass[CHEAT_HANDYMAP] = patrahasit;
		allPass[CHEAT_OKBOOMER] = okboomer;
		allPass[CHEAT_NOPROGRESSIVE] = altite;
		allPass[CHEAT_NOLOGIC] = impossibleseed;
		allPass[CHEAT_DEBUGITEMS] = gehennaexpress;
		allPass[CHEAT_BSIDES] = bsides;
		allPass[CHEAT_FREESIGHT] = bombwallio;
		allPass[CHEAT_MAPHINTS] = fi4me;
		allPass[CHEAT_CHARMENU] = aots4;
		allPass[CHEAT_NONIGHTMARE] = nonutmare;
		allPass[CHEAT_SAURON] = sauron;
		allPass[CHEAT_MANGOSTEEN] = mangosteen;
		allPass[CHEAT_BLEEDINGHEART] = thisisfun;
		allPass[CHEAT_BLEEDINGWALLET] = findom;
		
		int count = SizeOfArray(allPass);
		
		for(int i=0; i<count; i++){
			if(allPass[i]!=0){
				if(strcmp(curPass, allPass[i])==0)
					return i;
			}
		}
		
		return 0;
	}
	bool ToggleCheat(int which){
		int cheatSet[10];
		if(which==CHEAT_RESETTI){
			G[G_MODE_HYRULEWARRIORS] = 0;
			G[G_MODE_BINLAND] = 0;
			G[G_MODE_DARKNUT] = 0;
			G[G_MODE_ALWAYSHARD] = 0;
			G[G_MODE_SPEEDHACK] = 0;
			G[G_MODE_LOGGINGMEMES] = 0;
			G[G_MODE_GLITCH] = 0;
			G[G_MODE_YOLOREF] = 0;
			G[G_MODE_NOTRIFORCE] = 0;
			G[G_MODE_FORCESLASH] = 0;
			G[G_MODE_SUPERBOMBS] = 0;
			G[G_MODE_SAITAMA] = 0;
			G[G_MODE_NJFHP] = 0;
			G[G_MODE_COLORSHIFT] = 0;
			G[G_MODE_RANDOMIZER] = 0;
			G[G_MODE_EASYNAVIGATION] = 0;
			G[G_MODE_SPOILENEMYSECRETS] = 0;
			G[G_MODE_HANDYMAP] = 0;
			G[G_MODE_OKBOOMER] = 0;
			G[G_MODE_NORANDOMIZERPROGRESSIVE] = 0;
			G[G_MODE_NORANDOMIZERLOGIC] = 0;
			G[G_MODE_DEBUGSTART] = 0;
			G[G_MODE_BSIDES] = 0;
			G[G_MODE_FREESIGHT] = 0;
			G[G_MODE_TRACKERHINTS] = 0;
			G[G_MODE_ALTCHARACTER] = 0;
			G[G_MODE_NORANDOMIZERNIGHTMARE] = 0;
			return false;
		}
		
		if(which==CHEAT_HYRULEWARRIORS)
			cheatSet[0] = G_MODE_HYRULEWARRIORS;
		if(which==CHEAT_BINLAND)
			cheatSet[0] = G_MODE_BINLAND;
		if(which==CHEAT_DARKNUT)
			cheatSet[0] = G_MODE_DARKNUT;
		if(which==CHEAT_ALWAYSHARD)
			cheatSet[0] = G_MODE_ALWAYSHARD;
		if(which==CHEAT_SPEEDHACK)
			cheatSet[0] = G_MODE_SPEEDHACK;
		if(which==CHEAT_LOGGINGMEMES)
			cheatSet[0] = G_MODE_LOGGINGMEMES;
		if(which==CHEAT_GLITCH)
			cheatSet[0] = G_MODE_GLITCH;
		if(which==CHEAT_YOLO)
			cheatSet[0] = G_MODE_YOLOREF;
		if(which==CHEAT_NOTRIFORCE)
			cheatSet[0] = G_MODE_NOTRIFORCE;
		if(which==CHEAT_SLASH)
			cheatSet[0] = G_MODE_FORCESLASH;
		if(which==CHEAT_SBOMB)
			cheatSet[0] = G_MODE_SUPERBOMBS;
		if(which==CHEAT_SAITAMA)
			cheatSet[0] = G_MODE_SAITAMA;
		if(which==CHEAT_NJFHP)
			cheatSet[0] = G_MODE_NJFHP;
		if(which==CHEAT_COLORSHIFT)
			cheatSet[0] = G_MODE_COLORSHIFT;
		if(which==CHEAT_RANDOMIZER)
			cheatSet[0] = G_MODE_RANDOMIZER;
		if(which==CHEAT_EASYNAV)
			cheatSet[0] = G_MODE_EASYNAVIGATION;
		if(which==CHEAT_SPOILENEMYSECRETS)
			cheatSet[0] = G_MODE_SPOILENEMYSECRETS;
		if(which==CHEAT_STANDARDRANDOMIZER){
			cheatSet[0] = G_MODE_RANDOMIZER;
			cheatSet[1] = G_MODE_EASYNAVIGATION;
			cheatSet[2] = G_MODE_SPOILENEMYSECRETS;
			cheatSet[3] = G_MODE_HANDYMAP;
		}
		if(which==CHEAT_HANDYMAP)
			cheatSet[0] = G_MODE_HANDYMAP;
		if(which==CHEAT_OKBOOMER)
			cheatSet[0] = G_MODE_OKBOOMER;
		if(which==CHEAT_NOPROGRESSIVE)
			cheatSet[0] = G_MODE_NORANDOMIZERPROGRESSIVE;
		if(which==CHEAT_NOLOGIC)
			cheatSet[0] = G_MODE_NORANDOMIZERLOGIC;
		if(which==CHEAT_DEBUGITEMS)
			cheatSet[0] = G_MODE_DEBUGSTART;
		if(which==CHEAT_BSIDES)
			cheatSet[0] = G_MODE_BSIDES;
		if(which==CHEAT_MAXRANDOMIZER){
			cheatSet[0] = G_MODE_RANDOMIZER;
			cheatSet[1] = G_MODE_EASYNAVIGATION;
			cheatSet[2] = G_MODE_SPOILENEMYSECRETS;
			cheatSet[3] = G_MODE_HANDYMAP;
			cheatSet[4] = G_MODE_ALWAYSHARD;
			cheatSet[5] = G_MODE_FREESIGHT;
			cheatSet[6] = G_RANDOMIZERAUTOMAXSETTINGS;
			cheatSet[7] = G_MODE_ALTCHARACTER;
		}
		if(which==CHEAT_FREESIGHT)
			cheatSet[0] = G_MODE_FREESIGHT;
		if(which==CHEAT_MAPHINTS){
			cheatSet[0] = G_MODE_TRACKERHINTS;
			cheatSet[1] = G_MODE_HANDYMAP;
		}
		if(which==CHEAT_CHARMENU)
			cheatSet[0] = G_MODE_ALTCHARACTER;
		if(which==CHEAT_NONIGHTMARE)
			cheatSet[0] = G_MODE_NORANDOMIZERNIGHTMARE;
		if(which==CHEAT_SAURON)
			cheatSet[0] = G_MODE_EQUIPALLRINGS;
		if(which==CHEAT_MANGOSTEEN)
			cheatSet[0] = G_MODE_RUPOORGARBAGE;
		if(which==CHEAT_BLEEDINGHEART)
			cheatSet[0] = G_MODE_BLEEDINGHEART;
		if(which==CHEAT_BLEEDINGWALLET)
			cheatSet[0] = G_MODE_BLEEDINGWALLET;
		
		int setVal = Cond(G[cheatSet[0]], 0, 1);
		for(int i=0; i<10; ++i){
			if(cheatSet[i]){
				G[cheatSet[i]] = setVal;
			}
		}
		if(!setVal)
			return false;
		return true;
	}
	void DrawActiveCheats(){
		int x = 4;
		int y = 4;
		
		int cheats[] = {	G_MODE_HYRULEWARRIORS, 5744,
							G_MODE_BINLAND, 5745,
							G_MODE_DARKNUT, 5746,
							G_MODE_ALWAYSHARD, 5747,
							G_MODE_SPEEDHACK, 5748,
							G_MODE_LOGGINGMEMES, 5749,
							G_MODE_GLITCH, 5750,
							G_MODE_YOLOREF, 5751,
							G_MODE_NOTRIFORCE, 5752,
							G_MODE_FORCESLASH, 5753,
							G_MODE_SUPERBOMBS, 5754,
							G_MODE_SAITAMA, 5755,
							G_MODE_NJFHP, 5756,
							G_MODE_COLORSHIFT, 5757,
							G_MODE_RANDOMIZER, 5758,
							G_MODE_EASYNAVIGATION, 5759,
							G_MODE_SPOILENEMYSECRETS, 5764,
							G_MODE_HANDYMAP, 5765,
							G_MODE_OKBOOMER, 5766,
							G_MODE_NORANDOMIZERPROGRESSIVE, 5767,
							G_MODE_NORANDOMIZERLOGIC, 5768,
							G_MODE_DEBUGSTART, 5769,
							G_MODE_BSIDES, 5770,
							G_MODE_FREESIGHT, 5771,
							G_MODE_TRACKERHINTS, 5772,
							G_MODE_ALTCHARACTER, 5773,
							G_MODE_NORANDOMIZERNIGHTMARE, 5774,
							G_MODE_EQUIPALLRINGS, 5775,
							G_MODE_RUPOORGARBAGE, 5776,
							G_MODE_BLEEDINGHEART, 5777,
							G_MODE_BLEEDINGWALLET, 5778
						};
		int size = SizeOfArray(cheats)/2;
		for(int i=0; i<size; ++i){
			if(G[cheats[i*2]]){
				Screen->FastTile(6, x, y, cheats[i*2+1], 0, 128);
				x += 8;
				if(x>240){
					x = 4;
					y += 8;
				}
			}
		}
	}
}

int Q7_NumValidNPCs(){
	int count;
	for(int i=Screen->NumNPCs(); i>=1; i--){
		npc n = Screen->LoadNPC(i);
		if(n->Type!=NPCT_FAIRY&&!(n->MiscFlags&(1<<3))&&n->Type!=NPCT_PROJECTILE&&n->Type!=NPCT_TRAP&&n->Type!=NPCT_ZORA){
			count++;
		}
	}
	return count;
}

ffc script Dimentio_ItemSwap{
	void run(int itemID, int oldID){
		if(Q7_CheatEnabled(G_MODE_DIMENTIO)&&!Q7_CheatEnabled(G_MODE_RANDOMIZER)){
			for(int i=1; i<=32; ++i){
				ffc f = Screen->LoadFFC(i);
				if(f->Script==113){
					f->InitD[1] = itemID;
					f->InitD[7] = 1;
				}
			}
		}
		Quit();
		
		Waitframes(4);
		while(Q7_NumValidNPCs()>0){
			Waitframe();
		}
		if(!Screen->State[ST_ITEM]){
			Game->PlaySound(7);
			if(Q7_CheatEnabled(G_MODE_DIMENTIO)){
				item itm = CreateItemAt(itemID, this->X, this->Y);
				itm->Pickup = IP_ST_ITEM;
			}
			else{
				item itm = CreateItemAt(oldID, this->X, this->Y);
				itm->Pickup = IP_ST_ITEM;
			}
		}
	}
}

//Randomier
//{

const int Q7R_RANDOMIZEHISTORIES = 2;
const int Q7R_RANDOMIZEGARBAGE = 3;
const int Q7R_RINGSANITY = 4;
const int Q7R_KEYSANITY = 5;
const int Q7R_RANDOMIZEMUMPUS = 6;
const int Q7R_CAVESANITY = 7;
const int Q7R_RANDOMIZEFIRSTCAVE = 8;
const int Q7R_ENTRAND = 9;
const int Q7R_DUNGEONCEPTION = 10;
const int Q7R_CHOOSEONE = 11;
const int Q7R_REQTRIFORCES = 12;
const int Q7R_STARTINGACCELERATOR = 13;

ffc script Q7_RandomizerMenu{
	void run(){
		int i;
		
		int lineStart[256];
		int lineEnd[256];
		int lineStartColor[256];
		int strDat[6] = {lineStart, lineEnd, lineStartColor, 0, 12, 1};
	
		int seedDigits[4];
		for(i=0; i<4; i++){
			seedDigits[i] = Rand(16);
		}
		int sel = 1;
		int sel2;
		int options[16] = {seedDigits};
		//0 - Seed Digits Array
		//1 - Seed Digit Selection
		//2 - Randomize Histories
		//3 - Randomize Garbage
		//4 - Ringsanity
		//5 - Keysanity
		//6 - Randomize Mumpus
		//7 - Cavesanity
		//8 - Randomize First Cave
		//9 - Entrance Randomizer
		//10 - Dungeonception
		//11 - Choose One
		//12 - Req Triforces
		//13 - Starting Accelerator
		
		if(G[G_RANDOMIZERAUTOMAXSETTINGS]){
			options[Q7R_RANDOMIZEHISTORIES] = 1;
			options[Q7R_RANDOMIZEGARBAGE] = 1;
			options[Q7R_RINGSANITY] = 1;
			options[Q7R_KEYSANITY] = 1;
			options[Q7R_RANDOMIZEMUMPUS] = 1;
			options[Q7R_CAVESANITY] = 1;
			options[Q7R_RANDOMIZEFIRSTCAVE] = 2;
			options[Q7R_ENTRAND] = 1;
			options[Q7R_DUNGEONCEPTION] = 1;
			options[Q7R_CHOOSEONE] = 3;
			options[Q7R_REQTRIFORCES] = 0;
			options[Q7R_STARTINGACCELERATOR] = 1;
		}
		
		for(i=0; i<30; i++){
			if(i<10)
				Screen->Rectangle(6, 0, 0, 255, 175, 0x0F, 1, 0, 0, 0, true, 128);
			if(i<20)
				Screen->Rectangle(6, 0, 0, 255, 175, 0x0F, 1, 0, 0, 0, true, 64);
			Screen->Rectangle(6, 0, 0, 255, 175, 0x0F, 1, 0, 0, 0, true, 64);
			WaitNoAction();
		}
		while(true){
			if(sel2==1){
				seedDigits[options[1]] += Cond(Link->PressUp, 1, 0) + Cond(Link->PressDown, -1, 0);
				seedDigits[options[1]] += Cond(Link->PressL, -4, 0) + Cond(Link->PressR, 4, 0);
				if(seedDigits[options[1]]<0)
					seedDigits[options[1]] += 16;
				else if(seedDigits[options[1]]>15)
					seedDigits[options[1]] -= 16;
				
				options[1] += Cond(Link->PressLeft, -1, 0) + Cond(Link->PressRight, 1, 0);
				if(options[1]<0)
					options[1] += 4;
				else if(options[1]>3)
					options[1] -= 4;
				
				if(Link->PressUp||Link->PressDown||Link->PressLeft||Link->PressRight||Link->PressL||Link->PressR)
					Game->PlaySound(SFX_SELECT);
				
				if(Link->PressA||Link->PressStart){
					Game->PlaySound(SFX_SELECT);
					sel = 1;
					sel2 = 0;
				}
			}
			else{
				sel += Cond(Link->PressUp, -1, 0) + Cond(Link->PressDown, 1, 0);
				if(Link->PressUp||Link->PressDown)
					Game->PlaySound(SFX_SELECT);
				if(sel<1)
					sel = 14;
				else if(sel>14)
					sel = 1;
				
				if(sel==1){ //Seed
					if(Link->PressA||Link->PressStart){
						Game->PlaySound(SFX_SELECT);
						sel2 = 1;
					}
				}
				else if(sel==Q7R_RANDOMIZEHISTORIES){ //Randomize Triforce
					if(Link->PressLeft||Link->PressRight){
						options[Q7R_RANDOMIZEHISTORIES] = Cond(options[Q7R_RANDOMIZEHISTORIES], 0, 1);
						Game->PlaySound(SFX_SELECT);
					}
				}
				else if(sel==Q7R_RANDOMIZEGARBAGE){ //Randomize Garbage
					if(Link->PressLeft||Link->PressRight){
						options[Q7R_RANDOMIZEGARBAGE] = Cond(options[Q7R_RANDOMIZEGARBAGE], 0, 1);
						options[Q7R_RINGSANITY] = 0;
						if(options[Q7R_CHOOSEONE]==3)
							options[Q7R_CHOOSEONE] = 2;
						Game->PlaySound(SFX_SELECT);
					}
				}
				else if(sel==Q7R_RINGSANITY){ //Ringsanity
					if(Link->PressLeft||Link->PressRight){
						if(options[Q7R_RANDOMIZEGARBAGE])
							options[Q7R_RINGSANITY] = Cond(options[Q7R_RINGSANITY], 0, 1);
						Game->PlaySound(SFX_SELECT);
					}
				}
				else if(sel==Q7R_KEYSANITY){ //Keysanity
					if(Link->PressLeft||Link->PressRight){
						options[Q7R_KEYSANITY] = Cond(options[Q7R_KEYSANITY], 0, 1);
						Game->PlaySound(SFX_SELECT);
					}
				}
				else if(sel==Q7R_RANDOMIZEMUMPUS){ //Map + Compass
					if(Link->PressLeft||Link->PressRight){
						options[Q7R_RANDOMIZEMUMPUS] = Cond(options[Q7R_RANDOMIZEMUMPUS], 0, 1);
						Game->PlaySound(SFX_SELECT);
					}
				}
				else if(sel==Q7R_CAVESANITY){ //Cavesanity
					if(Link->PressLeft||Link->PressRight){
						options[Q7R_CAVESANITY] = Cond(options[Q7R_CAVESANITY], 0, 1);
						Game->PlaySound(SFX_SELECT);
					}
				}
				else if(sel==Q7R_RANDOMIZEFIRSTCAVE){ //Randomize First Cave
					options[Q7R_RANDOMIZEFIRSTCAVE] += Cond(Link->PressLeft, -1, 0) + Cond(Link->PressRight, 1, 0);
					if(Link->PressLeft||Link->PressRight)
						Game->PlaySound(SFX_SELECT);
					if(options[Q7R_RANDOMIZEFIRSTCAVE]<0)
						options[Q7R_RANDOMIZEFIRSTCAVE] += 3;
					else if(options[Q7R_RANDOMIZEFIRSTCAVE]>2)
						options[Q7R_RANDOMIZEFIRSTCAVE] -= 3;
				}
				else if(sel==Q7R_ENTRAND){ //Entrance Randomizer
					if(Link->PressLeft||Link->PressRight){
						options[Q7R_ENTRAND] = Cond(options[Q7R_ENTRAND], 0, 1);
						if(!options[Q7R_ENTRAND])
							options[Q7R_DUNGEONCEPTION] = 0;
						Game->PlaySound(SFX_SELECT);
					}
				}
				else if(sel==Q7R_DUNGEONCEPTION){ //Dungeonception
					if(Link->PressLeft||Link->PressRight){
						options[Q7R_DUNGEONCEPTION] = Cond(options[Q7R_DUNGEONCEPTION]||!options[Q7R_ENTRAND], 0, 1);
						Game->PlaySound(SFX_SELECT);
					}
				}
				else if(sel==Q7R_CHOOSEONE){ //Choose One
					options[Q7R_CHOOSEONE] += Cond(Link->PressLeft, -1, 0) + Cond(Link->PressRight, 1, 0);
					if(Link->PressLeft||Link->PressRight)
						Game->PlaySound(SFX_SELECT);
					if(options[Q7R_RANDOMIZEGARBAGE]==0){
						if(options[Q7R_CHOOSEONE]<0)
							options[Q7R_CHOOSEONE] += 3;
						else if(options[Q7R_CHOOSEONE]>2)
							options[Q7R_CHOOSEONE] -= 3;
					}
					else{
						if(options[Q7R_CHOOSEONE]<0)
							options[Q7R_CHOOSEONE] += 4;
						else if(options[Q7R_CHOOSEONE]>3)
							options[Q7R_CHOOSEONE] -= 4;
					}
				}
				else if(sel==Q7R_REQTRIFORCES){ //Require Histories
					options[Q7R_REQTRIFORCES] += Cond(Link->PressLeft, -1, 0) + Cond(Link->PressRight, 1, 0);
					if(Link->PressLeft||Link->PressRight)
						Game->PlaySound(SFX_SELECT);
					if(options[Q7R_REQTRIFORCES]<0)
						options[Q7R_REQTRIFORCES] += 3;
					else if(options[Q7R_REQTRIFORCES]>2)
						options[Q7R_REQTRIFORCES] -= 3;
				}
				else if(sel==Q7R_STARTINGACCELERATOR){ //Accelerator
					if(Link->PressLeft||Link->PressRight){
						options[Q7R_STARTINGACCELERATOR] = Cond(options[Q7R_STARTINGACCELERATOR], 0, 1);
						Game->PlaySound(SFX_SELECT);
					}
				}
				else if(sel==14){ //Confirm
					if(Link->PressA||Link->PressStart)
						break;
				}
			}
			
			Q7_DrawRandomizerMenu(sel, sel2, options, strDat, true);
			WaitNoAction();
		}
		Game->PlaySound(SFX_CONFIRM);
		G[G_SEEDX] = seedDigits[0]*16+seedDigits[1];
		G[G_SEEDY] = seedDigits[2]*16+seedDigits[3];
		G[G_ISRANDOMIZER] = 1;
		G[G_RANDOMIZETRIFORCE] = options[Q7R_RANDOMIZEHISTORIES];
		G[G_RANDOMIZETRASH] = options[Q7R_RANDOMIZEGARBAGE];
		G[G_MODE_GIMMICKRINGS] = options[Q7R_RINGSANITY];
		G[G_MODE_KEYSANITY] = options[Q7R_KEYSANITY];
		G[G_MODE_RANDOMIZEMUMPUS] = options[Q7R_RANDOMIZEMUMPUS];
		G[G_MODE_CAVESANITY] = options[Q7R_CAVESANITY];
		G[G_RANDOMIZESTARTINGSWORD] = options[Q7R_RANDOMIZEFIRSTCAVE];
		G[G_MODE_ENTRANCE_RANDO] = options[Q7R_ENTRAND];
		G[G_MODE_DUNGEONCEPTION] = options[Q7R_DUNGEONCEPTION];
		G[G_RANDOMIZER_CHOOSEONETYPE] = options[Q7R_CHOOSEONE];
		G[G_RANDOMIZER_REQTRIFORCE] = options[Q7R_REQTRIFORCES];
		G[G_L0ACCEL] = options[Q7R_STARTINGACCELERATOR];
		
		int seed[2];
		seed[0] = G[G_SEEDX];
		seed[1] = G[G_SEEDY];
		if(DEBUG_RANDOMIZER_SEEDS){
			int goodSeeds;
			int badSeeds;
			while(true){
				i = G[G_SEEDX]*256+G[G_SEEDY];
				i = (i+1)%65536;
				G[G_SEEDX] = Floor(i/256);
				G[G_SEEDY] = i%256;
				seed[0] = G[G_SEEDX];
				seed[1] = G[G_SEEDY];
				Trace(i);
				bool success = Randomizer_ApplyRandomization(seed);
				if(success)
					++goodSeeds;
				else
					++badSeeds;
				TraceB(success);
				int s[] = "SEED RATIO - %d-%d\n";
				printf(s, goodSeeds, badSeeds);
				Waitframes(30);
			}
		}
		bool success = Randomizer_ApplyRandomization(seed);
		while(!success){
			i = G[G_SEEDX]*256+G[G_SEEDY];
			i = (i+1)%65536;
			G[G_SEEDX] = Floor(i/256);
			G[G_SEEDY] = i%256;
			seed[0] = G[G_SEEDX];
			seed[1] = G[G_SEEDY];
			success = Randomizer_ApplyRandomization(seed);
		}
		
		for(i=0; i<30; i++){
			if(i%4<2){
				Q7_DrawRandomizerMenu(sel, sel2, options, strDat, true);
			}
			else{
				Q7_DrawRandomizerMenu(sel, sel2, options, strDat, false);
			}
			
			WaitNoAction();
		}
		for(i=0; i<30; i++){
			if(i%4<2){
				Q7_DrawRandomizerMenu(sel, sel2, options, strDat, true);
			}
			else{
				Q7_DrawRandomizerMenu(sel, sel2, options, strDat, false);
			}
			
			if(i>=10)
				Screen->Rectangle(6, 0, 0, 255, 175, 0x0F, 1, 0, 0, 0, true, 64);
			if(i>=20)
				Screen->Rectangle(6, 0, 0, 255, 175, 0x0F, 1, 0, 0, 0, true, 128);
			Screen->Rectangle(6, 0, 0, 255, 175, 0x0F, 1, 0, 0, 0, true, 64);
			
			WaitNoAction();
		}
	}
	void Q7_DrawRandomizerMenu(int sel, int sel2, int options, int strDat, bool drawSelection){
		int i;
		
		int str_randomizerOptions[] = "RANDOMIZER SETTINGS:";
		int str_seed[] = "SEED:";
		int str_randomizeTriforce[] = "RANDOMIZE HISTORIES:";
		int str_randomizeGarbage[] = "RANDOMIZE GARBAGE:";
		int str_ringsanity[] = "SPECIAL RINGS:";
		int str_keysanity[] = "RANDOMIZE KEYS:";
		int str_mumpus[] = "RANDOMIZE MUMPUS:";
		int str_cavesanity[] = "RANDOMIZE CAVES:";
		int str_randomizeFirstCave[] = "RANDOMIZE FIRST CAVE:";
		int str_entrand[] = "RANDOMIZE ENTRANCES:";
		int str_dungeonception[] = "DUNGEONCEPTION";
		int str_chooseOneType[] = "CHOOSE ONE ITEM:";
		int str_reqTriforce[] = "REQUIRE HISTORIES:";
		int str_accel[] = "STARTING ACCELERATOR:";
		
		int str_yes[] = "YES";
		int str_no[] = "NO";
		int str_potions[] = "POTIONS";
		int str_hearts[] = "HEARTS";
		int str_both[] = "BOTH";
		int str_random[] = "RANDOM";
		int str_damage[] = "DAMAGE";
		
		int str_start[] = "START";
		int str_end[] = "END";
		
		int str_confirm[] = "CONFIRM";
		
		int seedDigits = options[0];
		
		Q7_DrawStringOutline(6, 16, 8, FONT_Z1, 0x01, 0x0F, TF_NORMAL, str_randomizerOptions, 128);
	
		int baseY; int scroll;
		int c; int kscroll;
		scroll = Clamp(sel-3, 1, 8);
		for(int k=0; k<6; ++k){
			kscroll = k+scroll;
			
			baseY = 24+12*k;
			
			c = 0x02;
			if(sel==kscroll&&drawSelection)
				c = 0x01;
			
			if(kscroll==1){ //Seed
				c = 0x02;
				if(sel==1&&sel2==0&&drawSelection)
					c = 0x01;
		
				Q7_DrawStringOutline(6, 8, baseY, FONT_Z1, c, 0x0F, TF_NORMAL, str_seed, 128);
			
				if(sel2==1&&drawSelection){
					for(i=0; i<4; i++){
						c = 0x02;
						if(options[1]==i)
							c = 0x01;
						if(seedDigits[i]<10)
							Q7_DrawCharacterOutline(6, 248-32+8*i, baseY, FONT_Z1, c, 0x0F, -1, -1, '0'+seedDigits[i], 128);
						else
							Q7_DrawCharacterOutline(6, 248-32+8*i, baseY, FONT_Z1, c, 0x0F, -1, -1, 'A'+seedDigits[i]-10, 128);
							
					}
				}
				else{
					for(i=0; i<4; i++){
						if(seedDigits[i]<10)
							Q7_DrawCharacterOutline(6, 248-32+8*i, baseY, FONT_Z1, 0x02, 0x0F, -1, -1, '0'+seedDigits[i], 128);
						else
							Q7_DrawCharacterOutline(6, 248-32+8*i, baseY, FONT_Z1, 0x02, 0x0F, -1, -1, 'A'+seedDigits[i]-10, 128);
					}
				}
			}
			else if(kscroll==Q7R_RANDOMIZEHISTORIES){ //Randomize Histories
	
				Q7_DrawStringOutline(6, 8, baseY, FONT_Z1, c, 0x0F, TF_NORMAL, str_randomizeTriforce, 128);
			
				if(options[Q7R_RANDOMIZEHISTORIES]==0)
					Q7_DrawStringOutline(6, 248, baseY, FONT_Z1, c, 0x0F, TF_RIGHT, str_no, 128);
				else
					Q7_DrawStringOutline(6, 248, baseY, FONT_Z1, c, 0x0F, TF_RIGHT, str_yes, 128); 
	
			}
			else if(kscroll==Q7R_RANDOMIZEGARBAGE){ //Randomize Garbage
				Q7_DrawStringOutline(6, 8, baseY, FONT_Z1, c, 0x0F, TF_NORMAL, str_randomizeGarbage, 128);
			
				if(options[Q7R_RANDOMIZEGARBAGE]==0)
					Q7_DrawStringOutline(6, 248, baseY, FONT_Z1, c, 0x0F, TF_RIGHT, str_no, 128);
				else
					Q7_DrawStringOutline(6, 248, baseY, FONT_Z1, c, 0x0F, TF_RIGHT, str_yes, 128); 
			}
			else if(kscroll==Q7R_RINGSANITY){ //Ringsanity
				Q7_DrawStringOutline(6, 8, baseY, FONT_Z1, c, 0x0F, TF_NORMAL, str_ringsanity, 128);
			
				if(options[Q7R_RINGSANITY]==0)
					Q7_DrawStringOutline(6, 248, baseY, FONT_Z1, c, 0x0F, TF_RIGHT, str_no, 128);
				else
					Q7_DrawStringOutline(6, 248, baseY, FONT_Z1, c, 0x0F, TF_RIGHT, str_yes, 128); 
			}
			else if(kscroll==Q7R_KEYSANITY){ //Keysanity
				Q7_DrawStringOutline(6, 8, baseY, FONT_Z1, c, 0x0F, TF_NORMAL, str_keysanity, 128);
			
				if(options[Q7R_KEYSANITY]==0)
					Q7_DrawStringOutline(6, 248, baseY, FONT_Z1, c, 0x0F, TF_RIGHT, str_no, 128);
				else
					Q7_DrawStringOutline(6, 248, baseY, FONT_Z1, c, 0x0F, TF_RIGHT, str_yes, 128); 
			}
			else if(kscroll==Q7R_RANDOMIZEMUMPUS){ //Mumpus
				Q7_DrawStringOutline(6, 8, baseY, FONT_Z1, c, 0x0F, TF_NORMAL, str_mumpus, 128);
			
				if(options[Q7R_RANDOMIZEMUMPUS]==0)
					Q7_DrawStringOutline(6, 248, baseY, FONT_Z1, c, 0x0F, TF_RIGHT, str_no, 128);
				else
					Q7_DrawStringOutline(6, 248, baseY, FONT_Z1, c, 0x0F, TF_RIGHT, str_yes, 128); 
			}
			else if(kscroll==Q7R_CAVESANITY){ //Cavesanity
				Q7_DrawStringOutline(6, 8, baseY, FONT_Z1, c, 0x0F, TF_NORMAL, str_cavesanity, 128);
			
				if(options[Q7R_CAVESANITY]==0)
					Q7_DrawStringOutline(6, 248, baseY, FONT_Z1, c, 0x0F, TF_RIGHT, str_no, 128);
				else
					Q7_DrawStringOutline(6, 248, baseY, FONT_Z1, c, 0x0F, TF_RIGHT, str_yes, 128); 
			}
			else if(kscroll==Q7R_RANDOMIZEFIRSTCAVE){ //Randomize First Cave
				Q7_DrawStringOutline(6, 8, baseY, FONT_Z1, c, 0x0F, TF_NORMAL, str_randomizeFirstCave, 128);
			
				if(options[Q7R_RANDOMIZEFIRSTCAVE]==0)
					Q7_DrawStringOutline(6, 248, baseY, FONT_Z1, c, 0x0F, TF_RIGHT, str_no, 128);
				else if(options[Q7R_RANDOMIZEFIRSTCAVE]==1)
					Q7_DrawStringOutline(6, 248, baseY, FONT_Z1, c, 0x0F, TF_RIGHT, str_yes, 128); 
				else if(options[Q7R_RANDOMIZEFIRSTCAVE]==2)
					Q7_DrawStringOutline(6, 248, baseY, FONT_Z1, c, 0x0F, TF_RIGHT, str_damage, 128); 
			}
			else if(kscroll==Q7R_ENTRAND){ //Entrance Randomizer
				Q7_DrawStringOutline(6, 8, baseY, FONT_Z1, c, 0x0F, TF_NORMAL, str_entrand, 128);
			
				if(options[Q7R_ENTRAND]==0)
					Q7_DrawStringOutline(6, 248, baseY, FONT_Z1, c, 0x0F, TF_RIGHT, str_no, 128);
				else
					Q7_DrawStringOutline(6, 248, baseY, FONT_Z1, c, 0x0F, TF_RIGHT, str_yes, 128); 
			}
			else if(kscroll==Q7R_DUNGEONCEPTION){ //Dungeonception
				Q7_DrawStringOutline(6, 8, baseY, FONT_Z1, c, 0x0F, TF_NORMAL, str_dungeonception, 128);
			
				if(options[Q7R_DUNGEONCEPTION]==0)
					Q7_DrawStringOutline(6, 248, baseY, FONT_Z1, c, 0x0F, TF_RIGHT, str_no, 128);
				else
					Q7_DrawStringOutline(6, 248, baseY, FONT_Z1, c, 0x0F, TF_RIGHT, str_yes, 128); 
			}
			else if(kscroll==Q7R_CHOOSEONE){ //Choose One
				Q7_DrawStringOutline(6, 8, baseY, FONT_Z1, c, 0x0F, TF_NORMAL, str_chooseOneType, 128);
			
				if(options[Q7R_CHOOSEONE]==0)
					Q7_DrawStringOutline(6, 248, baseY, FONT_Z1, c, 0x0F, TF_RIGHT, str_potions, 128);
				else if(options[Q7R_CHOOSEONE]==1)
					Q7_DrawStringOutline(6, 248, baseY, FONT_Z1, c, 0x0F, TF_RIGHT, str_hearts, 128); 
				else if(options[Q7R_CHOOSEONE]==2)
					Q7_DrawStringOutline(6, 248, baseY, FONT_Z1, c, 0x0F, TF_RIGHT, str_random, 128); 
				else if(options[Q7R_CHOOSEONE]==3)
					Q7_DrawStringOutline(6, 248, baseY, FONT_Z1, c, 0x0F, TF_RIGHT, str_both, 128); 
			}
			else if(kscroll==Q7R_REQTRIFORCES){ //Require Histories
				Q7_DrawStringOutline(6, 8, baseY, FONT_Z1, c, 0x0F, TF_NORMAL, str_reqTriforce, 128);
				
				if(options[Q7R_REQTRIFORCES]==0)
					Q7_DrawStringOutline(6, 248, baseY, FONT_Z1, c, 0x0F, TF_RIGHT, str_start, 128);
				else if(options[Q7R_REQTRIFORCES]==1)
					Q7_DrawStringOutline(6, 248, baseY, FONT_Z1, c, 0x0F, TF_RIGHT, str_end, 128); 
				else if(options[Q7R_REQTRIFORCES]==2)
					Q7_DrawStringOutline(6, 248, baseY, FONT_Z1, c, 0x0F, TF_RIGHT, str_no, 128); 
			}
			else if(kscroll==Q7R_STARTINGACCELERATOR){ //Starting Accelerator
				Q7_DrawStringOutline(6, 8, baseY, FONT_Z1, c, 0x0F, TF_NORMAL, str_accel, 128);
			
				if(options[Q7R_STARTINGACCELERATOR]==0)
					Q7_DrawStringOutline(6, 248, baseY, FONT_Z1, c, 0x0F, TF_RIGHT, str_no, 128);
				else
					Q7_DrawStringOutline(6, 248, baseY, FONT_Z1, c, 0x0F, TF_RIGHT, str_yes, 128); 
			}
		}
		
		c = 0x02;
		if(sel==14&&drawSelection)
			c = 0x01;
		Q7_DrawStringOutline(6, 8, 112, FONT_Z1, c, 0x0F, TF_NORMAL, str_confirm, 128);
		
		int desc_seed[] = "THE CURRENT SEED FOR THE RUN. TWO RUNS WITH THE SAME SEED WILL BE IDENTICAL.";
		int desc_randomizeTriforce[] = "WHETHER OR NOT TO PUT HISTORIES IN THE ITEM POOL.";
		int desc_randomizeGarbage[] = "WHETHER OR NOT TO PUT LESSER ITEMS (RUPEE AND BOMB DROPS) IN THE ITEM POOL.";
		int desc_ringsanity[] = "WHETHER OR NOT TO INCLUDE NEW RING ITEMS. REQUIRES GARBAGE IN THE POOL.";
		int desc_keysanity[] = "WHETHER OR NOT TO PUT DUNGEON KEYS IN THE ITEM POOL.";
		int desc_mumpus[] = "WHETHER OR NOT TO RANDOMIZE MAP AND COMPASS SPOTS.";
		int desc_cavesanity[] = "WHETHER OR NOT TO RANDOMIZE CAVES.";
		int desc_randomizeFirstCave[] = "WHETHER TO PUT A RANDOM ITEM IN THE FIRST CAVE. OTHERWISE IT WILL ALWAYS BE THE SWORD.";
		int desc_entrand[] = "WHETHER OR NOT TO RANDOMIZE DUNGEON AND CAVE ENTRANCES.";
		int desc_dungeonception[] = "ADD EXTRA DOORS IN DUNGEONS THAT CAN POTENTIALLY LEAD TO OTHER DUNGEONS.";
		int desc_chooseOneType[] = "WHICH TYPE OF ITEM THE CHOOSE ONE ITEM ROOM ITEMS BECOME.";
		int desc_reqTriforce[] = "WHETHER OR NOT LEVEL 9 REQUIRES THE HISTORIES AT THE START, END, OR NOT AT ALL.";
		int desc_accel[] = "WHETHER OR NOT TO START WITH THE ABILITY TO RUN. (NO HITBOX WITHOUT THE ITEM)";
		int descString[] = {0, desc_seed, desc_randomizeTriforce, desc_randomizeGarbage, desc_ringsanity, desc_keysanity, desc_mumpus, desc_cavesanity, desc_randomizeFirstCave, desc_entrand, desc_dungeonception, desc_chooseOneType, desc_reqTriforce, desc_accel};
		if(sel>0&&sel<14){
			Q7_DrawStringSP_Prep(strDat, 240, descString[sel]);
			Q7_DrawStringSP(strDat, 6, 128, 128, 224, TF_CENTERED, descString[sel]);
		}
	}
}

item script FakeTriforce{
	void run(){
		for(int i=0; i<8; i++){
			if(!(Game->LItems[1+i]&LI_TRIFORCE)){
				Game->LItems[1+i] |= LI_TRIFORCE;
				int fakeTriforceFFC[] = "FakeTriforceFFC";
				int i = RunFFCScript(Game->GetFFCScript(fakeTriforceFFC), 0);
				ffc f = Screen->LoadFFC(i);
				f->Flags[FFCF_IGNOREHOLDUP] = true;
				Quit();
			}
		}
	}
}

ffc script FakeTriforceFFC{
	void run(){
		this->Flags[FFCF_IGNOREHOLDUP] = true;
		Game->PlaySound(25);
		Game->PlaySound(22);
		Link->Action = LA_HOLD2LAND;
		Link->HeldItem = I_FAKETRIFORCE;
		for(int i=0; i<96; i++){
			SpriteAnim(Rand(240), Rand(160), 117, 1, 1);
			if(i%8<4){
				Screen->Rectangle(6, 0, 0, 255, 175, 0x01, 1, 0, 0, 0, true, 128);
			}
			if(i%8>=2&&i%8<6)
				Screen->Rectangle(6, 0, 0, 255, 175, 0x01, 1, 0, 0, 0, true, 64);
			Waitframe();
		}
	}
}

//Overworld Secrets

//8:77 Sword 1
//8:6D Sword 2
//8:01 Sword 3
//3:0B Sword 4
//8:0B HC
//8:1F Letter
//8:1A Candle
//8:10 Secrets Ring
//8:21 HC
//8:22 Bracelet
//8:45 Blue Ring
//8:4B HC
//8:5F HC
//8:62 HC

//Level 1

//2:11 Bomb
//2:12 HC
//2:20 Triforce
//2:24 Rupee
//2:25 Boomerang
//2:35 Rupee
//2:62 Bomb
//2:64 Bomb
//2:73 Whistle

//Level 2

//2:09 Rupee
//2:18 Rupee
//2:1A Bomb
//2:29 Bow
//2:2D Bomb
//2:3A Rupee
//2:3B Arrow
//2:4B Rupee
//2:58 Triforce
//2:59 HC

//Level 3

//3:25 Bomb
//3:30 Magic Brang
//3:44 Rupee
//3:51 Bomb
//3:53 HC
//3:55 Bait
//3:62 Rupee
//3:63 Triforce
//3:73 Rupee
//3:74 Wand

//Level 4

//3:18 Rupee
//3:1D Flippers
//3:1E Bomb
//3:2B Rupee
//3:58 Rupee
//3:6A Rupee
//3:6C HC
//3:6E Bomb
//3:7C Triforce

//Level 5

//4:03 Triforce
//4:13 HC
//4:20 Rupee
//4:21 Bomb
//4:26 Red Candle
//4:42 Bomb
//4:51 Bomb
//4:61 Rupee
//4:64 Rupee

//Level 6

//4:1B Rupee
//4:29 Rupee
//4:2B Triforce
//4:2D Phase Cloak
//4:39 Bomb
//4:3B HC
//4:3C Bait
//4:5A Rupee
//4:5D Bomb
//4:7B Rupee

//Level 7

//5:04 Rupee
//5:06 Mirror Shield
//5:12 Rupee
//5:22 Bomb
//5:34 Rupee
//5:44 HC
//5:45 Triforce
//5:53 Rupee
//5:63 Bomb
//5:73 Book

//Level 8

//5:0B Red Ring
//5:1C Boots
//5:2C Rupee
//5:2E Triforce
//5:3B Rupee
//5:3E HC
//5:4A Bomb
//5:4E Rupee
//5:5C Rupee
//5:6C Bomb

//Level 9

//13:05 Double Phaser
//13:21 Jesus Statue
//13:33 Ultraviolet Candle
//13:53 Potion
//13:63 Rupee
//13:08 Trimirror Shield
//13:2D Hyper Wand
//14:43 Accelerator
//14:36 Silver Arrow
//14:1A Fire Boomerang

const int I_FAKETRIFORCE = 189;
const int I_BOMBUPGRADE = 190;

bool IsRandomizer(){
	return G[G_ISRANDOMIZER];
}

ffc script NESShop{
	void run(int item1, int price1, int item2, int price2, int item3, int price3, int guy, int msg){
		this->Flags[FFCF_IGNOREHOLDUP] = true;
		
		int i; int j;
		
		WaitNoAction(8);
		item shopItems[3];
		int shopPrices[3];
		bool specialItem[3];
		bool itemWasValid[3];
		npc roomGuys[3];
		item rupeeIcon;
		bool skipIntro;
		
		roomGuys[0] = CreateNPCAt(5, 72, 64);
		roomGuys[0]->DrawYOffset = 0;
		roomGuys[1] = CreateNPCAt(guy, 120, 64);
		roomGuys[1]->DrawYOffset = 0;
		roomGuys[2] = CreateNPCAt(5, 168, 64);
		roomGuys[2]->DrawYOffset = 0;
		
		if(item1==-1){ //Blue candle shop
			item1 = I_SHIELD2;
			price1 = 160;
			if(Link->Item[I_SHIELD4STOLEN]){
				item1 = I_SHIELD4;
				price1 = 100;
			}
			else if(Link->Item[I_SHIELD3STOLEN]){
				item1 = I_SHIELD3;
				price1 = 100;
			}
			
			item2 = I_KEY;
			price2 = 100;
			
			item3 = I_CANDLE1;
			if(Randomizer_GetItemReplacement(Game->GetCurMap(), Game->GetCurScreen()))
				item3 = Randomizer_GetItemReplacement(Game->GetCurMap(), Game->GetCurScreen());
			Randomizer_FlagItemVisited(Game->GetCurMap(), Game->GetCurScreen());
			price3 = 40;
			if(IsRandomizer()){
				if(Screen->State[ST_SPECIALITEM])
					item3 = 0;
				else
					specialItem[2] = true;
			}
		}
		else if(item1==-2){ //Bracelet shop
			item1 = I_CANDLE1;
			price1 = 120;
			if(IsRandomizer()){
				item1 = I_SHIELD2;
				price1 = 60;
			}
			
			item2 = I_BRACELET2;
			if(Randomizer_GetItemReplacement(Game->GetCurMap(), Game->GetCurScreen()))
				item2 = Randomizer_GetItemReplacement(Game->GetCurMap(), Game->GetCurScreen());
			Randomizer_FlagItemVisited(Game->GetCurMap(), Game->GetCurScreen());
			price2 = 140;
			if(IsRandomizer()){
				if(Screen->State[ST_SPECIALITEM])
					item2 = 0;
				else
					specialItem[1] = true;
			}
			
			item3 = I_BOMB;
			price3 = 40;
		}
		else if(item1==-3){ //Secrets ring shop
			item1 = I_BOMB;
			price1 = 10;
			
			item2 = I_SECRETRING;
			if(Randomizer_GetItemReplacement(Game->GetCurMap(), Game->GetCurScreen()))
				item2 = Randomizer_GetItemReplacement(Game->GetCurMap(), Game->GetCurScreen());
			Randomizer_FlagItemVisited(Game->GetCurMap(), Game->GetCurScreen());
			price2 = 180;
			if(IsRandomizer()){
				if(Screen->State[ST_SPECIALITEM])
					item2 = 0;
				else
					specialItem[1] = true;
			}
			
			item3 = I_KEY;
			price3 = 80;
		}
		else if(item1==-4){ //Blue ring shop
			item1 = I_KEY;
			price1 = 80;
			
			item2 = I_RING1;
			if(Randomizer_GetItemReplacement(Game->GetCurMap(), Game->GetCurScreen()))
				item2 = Randomizer_GetItemReplacement(Game->GetCurMap(), Game->GetCurScreen());
			Randomizer_FlagItemVisited(Game->GetCurMap(), Game->GetCurScreen());
			price2 = 250;
			if(IsRandomizer()){
				if(Screen->State[ST_SPECIALITEM])
					item2 = 0;
				else
					specialItem[1] = true;
			}
			else if(Link->Item[I_RING2STOLEN]){
				item2 = I_RING2;
				price2 = 100;
			}
			
			item3 = I_BAIT;
			price3 = 60;
		}
		else if(item1==-5){ //Bomb Upgrade
			item1 = 0;
			price1 = 0;
			
			item2 = I_BOMBUPGRADE;
			if(Randomizer_GetItemReplacement(Game->GetCurMap(), Game->GetCurScreen()))
				item2 = Randomizer_GetItemReplacement(Game->GetCurMap(), Game->GetCurScreen());
			Randomizer_FlagItemVisited(Game->GetCurMap(), Game->GetCurScreen());
			if(Screen->State[ST_SPECIALITEM])
				item2 = 0;
			else
				specialItem[1] = true;
			
			if(item2==0){
				roomGuys[1]->Y -= 1000;
				Quit();
			}
			
			item3 = 0;
			price3 = 0;
		}
		
		WaitNoAction(16);
		
		rupeeIcon = CreateItemAt(I_RUPEE1, 48, 107);
		rupeeIcon->Pickup = IP_DUMMY;
		
		if(item1>0)
			shopItems[0] = CreateItemAt(item1, 88, 88);
		shopPrices[0] = price1;

		if(item2>0)
			shopItems[1] = CreateItemAt(item2, 120, 88);
		shopPrices[1] = price2;
		
		if(item3>0)
			shopItems[2] = CreateItemAt(item3, 152, 88);
		shopPrices[2] = price3;
		Screen->DrawCharacter(6, 64, 112, FONT_Z1, 0x01, -1, -1, -1, 'X', 128);
		WaitNoAction();
		
		int maxItemCount;
		for(i=0; i<3; ++i){
			if(shopItems[i]->isValid()){
				itemWasValid[i] = true;
				++maxItemCount;
			}
		}
		
		int itemCount = maxItemCount;
		int itemBought;
		Screen->Message(msg);
		int freezeLink = 1;
		while(itemCount==maxItemCount){
			if(freezeLink){
				--freezeLink;
				NoAction();
			}
			Screen->DrawCharacter(6, 64, 112, FONT_Z1, 0x01, -1, -1, -1, 'X', 128);
		
			itemCount = 0;
			for(i=0; i<3; ++i){
				if(shopItems[i]->isValid()){
					if(Game->Counter[CR_RUPEES]+Game->DCounter[CR_RUPEES]>=shopPrices[i]){
						if(shopItems[i]->ID==I_BOMB)
							shopItems[i]->Pickup = 0;
						else
							shopItems[i]->Pickup = IP_HOLDUP;
						if(specialItem[i])
							shopItems[i]->Pickup |= IP_ST_SPECIALITEM;
					}
					else
						shopItems[i]->Pickup = IP_DUMMY;
					
					if(shopPrices[i]>0){
						j = 0;
						if(shopPrices[i]>99)
							j = -16;
						else if(shopPrices[i]>9)
							j = -8;
						Screen->DrawInteger(2, shopItems[i]->X+8+j, shopItems[i]->Y+24, FONT_Z1, 0x01, -1, -1, -1, shopPrices[i], 0, 128);
					}
						
					++itemCount;
				}
				else{
					if(itemWasValid[i])
						itemBought = i;
				}
			}
		
			Waitframe();
		}
		rupeeIcon->Y -= 1000;
		Game->DCounter[CR_RUPEES] -= shopPrices[itemBought];
		for(j=0; j<64; ++j){
			itemCount = 0;
			if(j%2==0)
				roomGuys[1]->Y = -32;
			else
				roomGuys[1]->Y = 64;
			for(i=0; i<3; ++i){
				if(shopItems[i]->isValid()){
					if(j%2==0)
						shopItems[i]->DrawYOffset = -1000;
					else
						shopItems[i]->DrawYOffset = 0;
					shopItems[i]->Pickup = IP_DUMMY;
				}
			}
		
			Waitframe();
		}
		roomGuys[1]->Y -= 1000;
		for(i=0; i<3; ++i){
			if(shopItems[i]->isValid()){
				shopItems[i]->Y -= 1000;
			}
		}
	}
}

ffc script NESItemRoom{
	void run(int itemID, int guy, int msg){
		this->Flags[FFCF_IGNOREHOLDUP] = true;
		
		if(Randomizer_GetItemReplacement(Game->GetCurMap(), Game->GetCurScreen()))
			itemID = Randomizer_GetItemReplacement(Game->GetCurMap(), Game->GetCurScreen());
			
		int i; int j;
		
		WaitNoAction(8);
		item specialItem;
		npc roomGuys[3];
		
		roomGuys[0] = CreateNPCAt(5, 72, 64);
		roomGuys[0]->DrawYOffset = 0;
		roomGuys[2] = CreateNPCAt(5, 168, 64);
		roomGuys[2]->DrawYOffset = 0;
		
		if(!Screen->State[ST_SPECIALITEM]){
			roomGuys[1] = CreateNPCAt(guy, 120, 64);
			roomGuys[1]->DrawYOffset = 0;
			WaitNoAction(16);
			
			specialItem = CreateItemAt(itemID, 120, 88);
			specialItem->Pickup = IP_HOLDUP|IP_ST_SPECIALITEM;
			Randomizer_FlagItemVisited(Game->GetCurMap(), Game->GetCurScreen());
			WaitNoAction();
			Screen->Message(msg);
			int freezeLink = 1;
			while(specialItem->isValid()){
				if(freezeLink){
					--freezeLink;
					NoAction();
				}
			
				Waitframe();
			}
			for(j=0; j<64; ++j){
				if(j%2==0)
					roomGuys[1]->Y = -32;
				else
					roomGuys[1]->Y = 64;
			
				Waitframe();
			}
			roomGuys[1]->Y -= 1000;
		}
	}
}

ffc script NESChooseItem{
	void run(int item1, int item2, int guy, int msg){
		this->Flags[FFCF_IGNOREHOLDUP] = true;
		
		int i; int j;
		
		WaitNoAction(8);
		item shopItems[2];
		npc roomGuys[3];
		
		roomGuys[0] = CreateNPCAt(5, 72, 64);
		roomGuys[0]->DrawYOffset = 0;
		roomGuys[2] = CreateNPCAt(5, 168, 64);
		roomGuys[2]->DrawYOffset = 0;
		if(Screen->State[ST_SPECIALITEM])
			Quit();
		roomGuys[1] = CreateNPCAt(guy, 120, 64);
		roomGuys[1]->DrawYOffset = 0;
		
		WaitNoAction(16);
		
		if(IsRandomizer()){
			if(Randomizer_GetItemReplacement(Game->GetCurMap(), Game->GetCurScreen()))
				item1 = Randomizer_GetItemReplacement(Game->GetCurMap(), Game->GetCurScreen());
			Randomizer_FlagItemVisited(Game->GetCurMap(), Game->GetCurScreen());
		
			msg = 208;
			shopItems[0] = CreateItemAt(item1, 120, 88);
			shopItems[0]->Pickup = IP_HOLDUP|IP_ST_SPECIALITEM;
			
			WaitNoAction();
			
			Screen->Message(msg);
			int freezeLink = 1;
			while(shopItems[0]->isValid()){
				if(freezeLink){
					--freezeLink;
					NoAction();
				}
				
				Waitframe();
			}
			for(j=0; j<64; ++j){
				if(j%2==0)
					roomGuys[1]->Y = -32;
				else
					roomGuys[1]->Y = 64;
				if(j%2==0)
					shopItems[0]->DrawYOffset = -1000;
				else
					shopItems[0]->DrawYOffset = 0;
			
				Waitframe();
			}
			roomGuys[1]->Y -= 1000;
			shopItems[0]->Y -= 1000;
		}
		else{
			shopItems[0] = CreateItemAt(item1, 88, 88);
			shopItems[0]->Pickup = IP_HOLDUP|IP_ST_SPECIALITEM;
			shopItems[1] = CreateItemAt(item2, 152, 88);
			shopItems[1]->Pickup = IP_HOLDUP|IP_ST_SPECIALITEM;
			
			WaitNoAction();
			
			Screen->Message(msg);
			int freezeLink = 1;
			while(shopItems[0]->isValid()&&shopItems[1]->isValid()){
				if(freezeLink){
					--freezeLink;
					NoAction();
				}
				
				Waitframe();
			}
			for(j=0; j<64; ++j){
				if(j%2==0)
					roomGuys[1]->Y = -32;
				else
					roomGuys[1]->Y = 64;
				for(i=0; i<2; ++i){
					if(shopItems[i]->isValid()){
						if(j%2==0)
							shopItems[i]->DrawYOffset = -1000;
						else
							shopItems[i]->DrawYOffset = 0;
						shopItems[i]->Pickup = IP_DUMMY;
					}
				}
			
				Waitframe();
			}
			roomGuys[1]->Y -= 1000;
			for(i=0; i<2; ++i){
				if(shopItems[i]->isValid()){
					shopItems[i]->Y -= 1000;
				}
			}
		}
	}
}

//D0: SpawnType
//		0 - Instant
//		1 - Enemy->Item
//		2 - Enemy Carried
ffc script NESSpawnItem{
	void run(int spawnType, int itemID){
		if(this->InitD[7]==1){
			itemID = this->InitD[1];
		}
		if(IsRandomizer()){
			if(Randomizer_GetItemReplacement(Game->GetCurMap(), Game->GetCurScreen()))
				itemID = Randomizer_GetItemReplacement(Game->GetCurMap(), Game->GetCurScreen());
		}
		
		if(!Screen->State[ST_ITEM]){
			if(spawnType==0){
				item itm = CreateItemAt(itemID, this->X, this->Y);
				itm->Pickup = IP_ST_ITEM;
				Randomizer_FlagItemVisited(Game->GetCurMap(), Game->GetCurScreen());
			}
			else if(spawnType==1){
				Waitframes(4);
				if(Q7_CheatEnabled(G_MODE_SPOILENEMYSECRETS))
					Game->PlaySound(SFX_COMPASSBEEP);
				while(Q7_NumValidNPCs()>0){
					Waitframe();
				}
				Game->PlaySound(7);
				item itm = CreateItemAt(itemID, this->X, this->Y);
				itm->Pickup = IP_ST_ITEM;
				Randomizer_FlagItemVisited(Game->GetCurMap(), Game->GetCurScreen());
			}
			else if(spawnType==2){
				Waitframes(4);
				npc n = HoldItem_FindFirstNPC();
				if(n->isValid()){
					item itm = CreateItemAt(itemID, this->X, this->Y);
					itm->Pickup = IP_ST_ITEM;
					Randomizer_FlagItemVisited(Game->GetCurMap(), Game->GetCurScreen());
					while(n->isValid()){
						itm->X = n->X;
						itm->Y = n->Y;
						if(itm->X==0&&itm->Y==0)
							itm->X = -16;
						Waitframe();
					}
				}
				else{
					item itm = CreateItemAt(itemID, this->X, this->Y);
					itm->Pickup = IP_ST_ITEM;
					Randomizer_FlagItemVisited(Game->GetCurMap(), Game->GetCurScreen());
				}
			}
		}
	}
	npc HoldItem_FindFirstNPC(){
		int max = Screen->NumNPCs();
		for(int i=1; i<=max; i++){
			npc n = Screen->LoadNPC(i);
			if(n->Type!=NPCT_PROJECTILE&&n->Type!=NPCT_FAIRY&&n->Type!=NPCT_TRAP&&n->Type!=NPCT_ZORA){
				return n;
			}
		}
		npc NULLNPC;
		return NULLNPC;
	}
}

int RandomizerLocs[32768];
int RandomizerLocsFlags[32768];
int RandomizerLocsKeys[32768];
int EntranceRandomizerLocs[32768];

void Randomizer_SetLoc(int index, int itemID, int level, int metalevel, int flags, int keys){
	RandomizerLocs[index] = itemID|(level<<8)|(metalevel<<12);
	RandomizerLocsFlags[index] = flags;
	RandomizerLocsKeys[index] = keys;
}

int Randomizer_GetLocID(int index){
	return (RandomizerLocs[index]&0xFF);
}

int Randomizer_GetLocLevel(int index){
	return ((RandomizerLocs[index]>>8)&0xF);
}

int Randomizer_GetLocMetaLevel(int index){
	return ((RandomizerLocs[index]>>12)&0xF);
}

int Randomizer_SetLocVisited(int index){
	RandomizerLocs[index] |= (1<<16);
}

int Randomizer_GetLocVisited(int index){
	return (RandomizerLocs[index]>>16)&0x1;
}


void Randomizer_SetLocAccessible(int index){
	RandomizerLocsKeys[index] |= (1<<16);
}

int Randomizer_GetLocAccessible(int index){
	return (RandomizerLocsKeys[index]>>16)&0x1;
}

void EntranceRandomizer_SetLoc(int index, int dmap, int scrn, int isEntrance){
	// int str[] = "Loc:%d DMap:%d Screen:%X\n";
	// printf(str, index, dmap, scrn);
	EntranceRandomizerLocs[index] = dmap|(scrn<<9)|(isEntrance<<16);
}

int EntranceRandomizer_GetLocDMap(int index){
	return EntranceRandomizerLocs[index]&0x1FF;
}

int EntranceRandomizer_GetLocScreen(int index){
	return (EntranceRandomizerLocs[index]>>9)&0x7F;
}

bool EntranceRandomizer_IsLocEntrance(int index){
	return ((EntranceRandomizerLocs[index]>>16)&1)==1;
}

//Randomizer requirement flags
const int RRF_DAMAGE		= 0000000000000001b;
const int RRF_WHISTLE		= 0000000000000010b;
const int RRF_ARROW1		= 0000000000001000b;
const int RRF_ARROW2		= 0000000000000100b;
const int RRF_ARROW			= 0000000000001100b;
const int RRF_CANDLE		= 0000000000010000b;
const int RRF_CANDLE2		= 0000000000100000b;
const int RRF_CANDLE3		= 0000000001000000b;
const int RRF_FLIPPERS		= 0000000010000000b;
const int RRF_BRACELET		= 0000000100000000b;
const int RRF_PHASECLOAK	= 0000001000000000b;
const int RRF_PHASECLOAK2	= 0000010000000000b;
const int RRF_TRIFORCES		= 0000100000000000b;
const int RRF_BOOTS			= 0001000000000000b;
const int RRF_WAND			= 0010000000000000b;

//Randomizer count[] index
const int RI_NUMROOMS				= 0;
const int RI_NUMITEMS				= 1;
const int RI_NUMDAMAGEITEMS			= 2;
const int RI_NUMSPECIALITEMS		= 3;
const int RI_NUMTRIFORCEITEMS 		= 4;
const int RI_NUMGARBAGEITEMS 		= 5;
const int RI_NUMMISCITEMS 			= 6;
const int RI_NUMAVAILABLEROOMS		= 7;
const int RI_NUMNEWROOMS			= 8;
const int RI_TOTALREMAININGITEMS	= 9;
const int RI_NUMAVAILABLETRIFORCES 	= 10;
const int RI_PLACEMENTERROR 		= 14;
const int RI_DEBUG 					= 15;
const int RI_NUMKEYITEMS			= 16;
const int RI_NUMENTRANCES			= 17;
const int RI_NUMRUPEEENTRANCES 		= 18;

bool Randomizer_ApplyRandomization(int seed){
	int roomMaps[512];
	int roomScreens[512];
	int roomReqFlags[512];
	int roomLevels[512];
	int roomReqKeys[512];
	int roomPlaced[512];
	int roomMetaLevels[512];
	
	int generalItems[512];
	int itemFlags[512];
	int damageItems[512];
	int specialItems[512];
	int triforceItems[512];
	int garbageItems[512];
	int miscItems[512];
	int keyItems[512];
	int levelKeys[11];
	int oldLevelKeys[12];
	if(!G[G_MODE_KEYSANITY]){
		for(int i=0; i<11; ++i){
			levelKeys[i] = 99;
			oldLevelKeys[i] = 99;
		}
	}
	
	int availableRooms[512];
	int newRooms[512];
	int entFlags[512];
	
	int erItemRooms[128];
	int erItemRoomFlags[128];
	int erIDs[128];
	int erStartIDs[128];
	int erCavesanityIDs[128];
	
	int roomTriforceReq[512];
	
	int itemGroups[256];
	
	int triforcesFound[8];
	
	int counts[32];
	
	int randVars[48];
	randVars[0] = counts;
	randVars[1] = roomMaps;
	randVars[2] = roomScreens;
	randVars[3] = roomReqFlags;
	randVars[4] = roomLevels;
	randVars[5] = roomReqKeys;
	randVars[6] = roomPlaced;
	randVars[7] = generalItems;
	randVars[8] = itemFlags;
	randVars[9] = damageItems;
	randVars[10] = specialItems;
	randVars[11] = triforceItems;
	randVars[12] = garbageItems;
	randVars[13] = miscItems;
	randVars[14] = availableRooms;
	randVars[15] = newRooms;
	randVars[16] = roomTriforceReq;
	randVars[17] = triforcesFound;
	randVars[18] = itemGroups;
	randVars[19] = roomMetaLevels;
	randVars[20] = keyItems;
	randVars[21] = levelKeys;
	randVars[22] = oldLevelKeys;
	randVars[23] = 0; //Keycount Changed
	randVars[24] = entFlags;
	randVars[25] = 0; //Unused
	randVars[26] = erItemRooms;
	randVars[27] = erItemRoomFlags;
	randVars[28] = erIDs;
	randVars[29] = erStartIDs;
	randVars[30] = erCavesanityIDs;
	
	if(!Randomizer_SetUpEntranceData(randVars, seed)){
		return false;
	}
	
	Randomizer_SetUpRoomData(randVars);
	Randomizer_SetUpItemData(randVars, seed);
	
	return Randomizer_DoTheThing(randVars, seed);
	
	//ImGonnaCoooooom(true);
}

const int ENT_SWORD1 = 0;
const int ENT_SWORD2 = 1;
const int ENT_SWORD3 = 2;
const int ENT_SWORD4 = 3;
const int ENT_LEVEL1 = 4;
const int ENT_LEVEL2 = 5;
const int ENT_LEVEL3 = 6;
const int ENT_LEVEL4A = 7;
const int ENT_LEVEL4B = 8;
const int ENT_LEVEL5 = 9;
const int ENT_LEVEL6 = 10;
const int ENT_LEVEL7 = 11;
const int ENT_LEVEL8 = 12;
const int ENT_LEVEL9 = 13;
const int ENT_HEARTx0B = 14;
const int ENT_HEARTx21 = 15;
const int ENT_HEARTx4B = 16;
const int ENT_HEARTx62 = 17;
const int ENT_LETTER = 18;
const int ENT_SHOPCANDLE = 19;
const int ENT_SHOPBRACELET = 20;
const int ENT_SHOPSECRETS = 21;
const int ENT_SHOPRING = 22;
const int ENT_GEN03 = 23;
const int ENT_GEN05 = 24;
const int ENT_GEN07 = 25;
const int ENT_GEN0A = 26;
const int ENT_GEN0C = 27;
const int ENT_GEN0D = 28;
const int ENT_GEN12 = 29;
const int ENT_GEN14 = 30;
const int ENT_GEN16 = 31;
const int ENT_GEN1C = 32;
const int ENT_GEN1D = 33;
const int ENT_GEN1E = 34; 
const int ENT_GEN23 = 35;
const int ENT_GEN25 = 36;
const int ENT_GEN26 = 37;
const int ENT_GEN27 = 38;
const int ENT_GEN28 = 39;
const int ENT_GEN2D = 40;
const int ENT_GEN3C = 41;
const int ENT_GEN3D = 42;
const int ENT_GEN42 = 43;
const int ENT_GEN43 = 44;
const int ENT_GEN44 = 45;
const int ENT_GEN46 = 46;
const int ENT_GEN47 = 47;
const int ENT_GEN48 = 48;
const int ENT_GEN49 = 49;
const int ENT_GEN4D = 50;
const int ENT_GEN51 = 51;
const int ENT_GEN56 = 52;
const int ENT_GEN5B = 53;
const int ENT_GEN5E = 54;
const int ENT_GEN63 = 55;
const int ENT_GEN64 = 56;
const int ENT_GEN66 = 57;
const int ENT_GEN67 = 58;
const int ENT_GEN68 = 59;
const int ENT_GEN6A = 60;
const int ENT_GEN6B = 61;
const int ENT_GEN6F = 62;
const int ENT_GEN76 = 63;
const int ENT_GEN78 = 64;
const int ENT_GEN79 = 65;
const int ENT_GEN7B = 66;
const int ENT_GEN7C = 67;
const int ENT_GEN7D = 68;
const int ENT_EXTRAGEN1 = 69;
const int ENT_EXTRAGEN2 = 70;
const int ENT_EXTRAGEN3 = 71;
const int ENT_EXTRAGEN4 = 72;
const int ENT_EXTRAGEN5 = 73;
const int ENT_EXTRAGEN6 = 74;
const int ENT_EXTRAGEN7 = 75;
const int ENT_EXTRAGEN8 = 76;
const int ENT_EXTRAGEN9 = 77;

void Randomizer_DebugEntranceData(int randVars, int entVars, int entFlags, int i){
	int erEntDMaps = entVars[1];
	int erEntScreens = entVars[2];
	int erExitDMaps = entVars[3];
	int erExitScreens = entVars[4];
	int erIDs = randVars[28];
	int erStartIDs = randVars[29];
	
	int flags = entFlags[erIDs[i]];//entFlags[erStartIDs[i]];
	int strBinary[17];
	BinaryToString(strBinary, flags, 16);
	int strFlags[17];
	int j;
	int flagChars[16] = {'D', 'W', 'A', 0, 'C', 0, 0, 'F', 'B', 'P', '2', 'T', 0, 0, 0, 0};
	for(int i=0; i<16; ++i){
		if(flagChars[i]){
			if(flags&(1<<i)){
				strFlags[j] = flagChars[i];
				++j;
			}
		}
	}
	int str[] = "Entrance %d(%d), %d:%X -> %d:%X - %s - %s \n";
	printf(str, erIDs[i], erStartIDs[i], erEntDMaps[i], erEntScreens[i], erExitDMaps[i], erExitScreens[i], strBinary, strFlags);
}

bool Randomizer_SetUpEntranceData(int randVars, int seed){
	int entFlags = randVars[24];
	int onlyFirstCave = 0;
	if(G[G_RANDOMIZESTARTINGSWORD]==2)
		onlyFirstCave = RRF_DAMAGE;
	int l9ReqTriforce = Cond(G[G_RANDOMIZER_REQTRIFORCE]==0, RRF_TRIFORCES, 0);
	
	if(G[G_MODE_ENTRANCE_RANDO]){
		int counts = randVars[0];
		
		//more of these declared up in Randomizer_ApplyRandomization()
		int erEntDMaps[128];
		int erEntScreens[128];
		int erExitDMaps[128];
		int erExitScreens[128];
		int erIDs = randVars[28];
		int erStartIDs = randVars[29];
		int entVars[] = {0, erEntDMaps, erEntScreens, erExitDMaps, erExitScreens};

		if(G[G_RANDOMIZESTARTINGSWORD]==1)
			Randomizer_AddEntrance(randVars, entVars, 0, 0x77, 20, 0x11, ENT_SWORD1, 0);
		Randomizer_AddEntrance(randVars, entVars, 0, 0x6D, 20, 0x00, ENT_SWORD2, RRF_CANDLE);
		Randomizer_AddEntrance(randVars, entVars, 0, 0x01, 20, 0x01, ENT_SWORD3, RRF_DAMAGE);
		Randomizer_AddEntrance(randVars, entVars, 4, 0x03, 20, 0x10, ENT_SWORD4, RRF_DAMAGE|RRF_FLIPPERS|RRF_BOOTS|RRF_PHASECLOAK);
		if(G[G_MODE_DUNGEONCEPTION]){
			Randomizer_AddEntrance(randVars, entVars, 1, 0x34, 20, 0x19, ENT_EXTRAGEN1, RRF_DAMAGE);
			Randomizer_AddEntrance(randVars, entVars, 2, 0x54, 20, 0x19, ENT_EXTRAGEN2, RRF_DAMAGE);
			Randomizer_AddEntrance(randVars, entVars, 3, 0x26, 20, 0x19, ENT_EXTRAGEN3, RRF_DAMAGE);
			Randomizer_AddEntrance(randVars, entVars, 4, 0x25, 20, 0x19, ENT_EXTRAGEN4, RRF_DAMAGE);
			Randomizer_AddEntrance(randVars, entVars, 5, 0x25, 20, 0x19, ENT_EXTRAGEN5, RRF_DAMAGE|RRF_CANDLE);
			Randomizer_AddEntrance(randVars, entVars, 6, 0x41, 20, 0x19, ENT_EXTRAGEN6, RRF_DAMAGE);
			Randomizer_AddEntrance(randVars, entVars, 7, 0x24, 20, 0x19, ENT_EXTRAGEN7, RRF_DAMAGE|RRF_PHASECLOAK);
			Randomizer_AddEntrance(randVars, entVars, 8, 0x72, 20, 0x19, ENT_EXTRAGEN8, RRF_DAMAGE|RRF_BRACELET|RRF_FLIPPERS|RRF_PHASECLOAK);
			Randomizer_AddEntrance(randVars, entVars, 10, 0x14, 20, 0x19, ENT_EXTRAGEN9, RRF_DAMAGE|RRF_PHASECLOAK|l9ReqTriforce);
		}
		
		Randomizer_AddEntrance(randVars, entVars, 0, 0x0B, 20, 0x0C, ENT_HEARTx0B, onlyFirstCave);
		Randomizer_AddEntrance(randVars, entVars, 0, 0x21, 20, 0x0D, ENT_HEARTx21, onlyFirstCave);
		Randomizer_AddEntrance(randVars, entVars, 0, 0x4B, 20, 0x0B, ENT_HEARTx4B, RRF_CANDLE);
		Randomizer_AddEntrance(randVars, entVars, 0, 0x62, 20, 0x0A, ENT_HEARTx62, RRF_CANDLE);
		
		Randomizer_AddEntrance(randVars, entVars, 0, 0x1F, 20, 0x12, ENT_LETTER, RRF_DAMAGE);
		Randomizer_AddEntrance(randVars, entVars, 0, 0x1A, 20, 0x06, ENT_SHOPCANDLE, RRF_DAMAGE);
		Randomizer_AddEntrance(randVars, entVars, 0, 0x22, 20, 0x07, ENT_SHOPBRACELET, RRF_DAMAGE);
		Randomizer_AddEntrance(randVars, entVars, 0, 0x10, 20, 0x08, ENT_SHOPSECRETS, RRF_DAMAGE|RRF_BRACELET);
		Randomizer_AddEntrance(randVars, entVars, 0, 0x45, 20, 0x09, ENT_SHOPRING, RRF_DAMAGE|RRF_FLIPPERS);
		
		Randomizer_AddEntrance(randVars, entVars, 0, 0x34, 1, 0x72, ENT_LEVEL1, 0);
		Randomizer_AddEntrance(randVars, entVars, 0, 0x39, 2, 0x73, ENT_LEVEL2, 0);
		Randomizer_AddEntrance(randVars, entVars, 0, 0x29, 3, 0x12, ENT_LEVEL3, RRF_WHISTLE);
		Randomizer_AddEntrance(randVars, entVars, 0, 0x0F, 4, 0x22, ENT_LEVEL4A, RRF_DAMAGE);
		Randomizer_AddEntrance(randVars, entVars, 0, 0x2F, 4, 0x57, ENT_LEVEL4B, RRF_FLIPPERS);
		Randomizer_AddEntrance(randVars, entVars, 0, 0x33, 5, 0x53, ENT_LEVEL5, RRF_DAMAGE);
		Randomizer_AddEntrance(randVars, entVars, 0, 0x70, 6, 0x73, ENT_LEVEL6, RRF_DAMAGE);
		Randomizer_AddEntrance(randVars, entVars, 0, 0x04, 7, 0x15, ENT_LEVEL7, 0);
		Randomizer_AddEntrance(randVars, entVars, 0, 0x37, 8, 0x51, ENT_LEVEL8, 0);
		Randomizer_AddEntrance(randVars, entVars, 0, 0x0E, 9, 0x73, ENT_LEVEL9, RRF_DAMAGE);
		
		if(G[G_MODE_CAVESANITY]){
			Randomizer_AddEntrance(randVars, entVars, 0, 0x03, 20, 0x4B, ENT_GEN03, RRF_DAMAGE); //Potion 60
			Randomizer_AddEntrance(randVars, entVars, 0, 0x05, 20, 0x4B, ENT_GEN05, RRF_DAMAGE); //Potion 60
			Randomizer_AddEntrance(randVars, entVars, 0, 0x07, 20, 0x19, ENT_GEN07, RRF_DAMAGE); //Money 30
			Randomizer_AddEntrance(randVars, entVars, 0, 0x0A, 20, 0x3A, ENT_GEN0A, 0); //Info Swords
			Randomizer_AddEntrance(randVars, entVars, 0, 0x0C, 20, 0x4E, ENT_GEN0C, RRF_DAMAGE); //Shield 60
			Randomizer_AddEntrance(randVars, entVars, 0, 0x0D, 20, 0x04, ENT_GEN0D, RRF_DAMAGE); //Gamble 100
			if(AllowSomeJokes())
				Randomizer_AddEntrance(randVars, entVars, 0, 0x12, 20, 0x1A, ENT_GEN12, RRF_DAMAGE); //Roulette
			else
				Randomizer_AddEntrance(randVars, entVars, 0, 0x12, 20, 0x05, ENT_GEN12, RRF_DAMAGE); //Gamble 60
			Randomizer_AddEntrance(randVars, entVars, 0, 0x14, 20, 0x4D, ENT_GEN14, RRF_DAMAGE); //Shield 90
			Randomizer_AddEntrance(randVars, entVars, 0, 0x16, 20, 0x19, ENT_GEN16, RRF_DAMAGE); //Money 30
			Randomizer_AddEntrance(randVars, entVars, 0, 0x1C, 20, 0x4E, ENT_GEN1C, RRF_DAMAGE); //Shield 60
			Randomizer_AddEntrance(randVars, entVars, 0, 0x1D, 20, 0x19, ENT_GEN1D, RRF_DAMAGE|RRF_BRACELET); //Money 30
			Randomizer_AddEntrance(randVars, entVars, 0, 0x1E, 20, 0x4B, ENT_GEN1E, RRF_DAMAGE); //Potion 60
			Randomizer_AddEntrance(randVars, entVars, 0, 0x23, 20, 0x3E, ENT_GEN23, RRF_BRACELET); //Info Adjean
			Randomizer_AddEntrance(randVars, entVars, 0, 0x25, 20, 0x02, ENT_GEN25, 0); //Gamble 40
			Randomizer_AddEntrance(randVars, entVars, 0, 0x26, 20, 0x19, ENT_GEN26, RRF_DAMAGE); //Money 20
			Randomizer_AddEntrance(randVars, entVars, 0, 0x27, 20, 0x4B, ENT_GEN27, RRF_FLIPPERS); //Potion 60
			Randomizer_AddEntrance(randVars, entVars, 0, 0x28, 20, 0x19, ENT_GEN28, RRF_CANDLE); //Money 30
			Randomizer_AddEntrance(randVars, entVars, 0, 0x2D, 20, 0x19, ENT_GEN2D, RRF_DAMAGE); //Money 30
			Randomizer_AddEntrance(randVars, entVars, 0, 0x3C, 20, 0x4D, ENT_GEN3C, 0); //Shield 90
			Randomizer_AddEntrance(randVars, entVars, 0, 0x3D, 20, 0x19, ENT_GEN3D, 0); //Rupoor 50
			Randomizer_AddEntrance(randVars, entVars, 0, 0x42, 20, 0x4C, ENT_GEN42, 0); //Potion 100
			Randomizer_AddEntrance(randVars, entVars, 0, 0x43, 20, 0x19, ENT_GEN43, RRF_DAMAGE); //Money 100
			Randomizer_AddEntrance(randVars, entVars, 0, 0x44, 20, 0x4E, ENT_GEN44, 0); //Shield 60
			Randomizer_AddEntrance(randVars, entVars, 0, 0x46, 20, 0x19, ENT_GEN46, RRF_CANDLE); //Money 10
			Randomizer_AddEntrance(randVars, entVars, 0, 0x47, 20, 0x19, ENT_GEN47, RRF_CANDLE); //Money 20
			Randomizer_AddEntrance(randVars, entVars, 0, 0x48, 20, 0x19, ENT_GEN48, RRF_CANDLE); //Money 10
			Randomizer_AddEntrance(randVars, entVars, 0, 0x49, 20, 0x4D, ENT_GEN49, RRF_BRACELET); //Shield 90
			Randomizer_AddEntrance(randVars, entVars, 0, 0x4D, 20, 0x4E, ENT_GEN4D, RRF_CANDLE); //Shield 60
			Randomizer_AddEntrance(randVars, entVars, 0, 0x51, 20, 0x19, ENT_GEN51, RRF_CANDLE); //Rupoor 10
			Randomizer_AddEntrance(randVars, entVars, 0, 0x56, 20, 0x4D, ENT_GEN56, RRF_CANDLE); //Shield 90
			Randomizer_AddEntrance(randVars, entVars, 0, 0x5B, 20, 0x03, ENT_GEN5B, RRF_CANDLE); //Gamble 60
			Randomizer_AddEntrance(randVars, entVars, 0, 0x5E, 20, 0x3B, ENT_GEN5E, 0); //Info Paths
			Randomizer_AddEntrance(randVars, entVars, 0, 0x63, 20, 0x19, ENT_GEN63, RRF_CANDLE); //Rupoor 20
			Randomizer_AddEntrance(randVars, entVars, 0, 0x64, 20, 0x3C, ENT_GEN64, 0); //Info Waterfall
			Randomizer_AddEntrance(randVars, entVars, 0, 0x66, 20, 0x4E, ENT_GEN66, 0); //Shield 60
			Randomizer_AddEntrance(randVars, entVars, 0, 0x67, 20, 0x02, ENT_GEN67, RRF_DAMAGE); //Gamble 40
			Randomizer_AddEntrance(randVars, entVars, 0, 0x68, 20, 0x19, ENT_GEN68, RRF_CANDLE); //Money 5
			Randomizer_AddEntrance(randVars, entVars, 0, 0x6A, 20, 0x19, ENT_GEN6A, RRF_CANDLE); //Money 30
			Randomizer_AddEntrance(randVars, entVars, 0, 0x6B, 20, 0x19, ENT_GEN6B, RRF_CANDLE); //Money 10
			Randomizer_AddEntrance(randVars, entVars, 0, 0x6F, 20, 0x3D, ENT_GEN6F, 0); //Info Cascade
			Randomizer_AddEntrance(randVars, entVars, 0, 0x76, 20, 0x19, ENT_GEN76, RRF_DAMAGE); //Money 20
			Randomizer_AddEntrance(randVars, entVars, 0, 0x78, 20, 0x19, ENT_GEN78, RRF_CANDLE); //Money 10
			Randomizer_AddEntrance(randVars, entVars, 0, 0x79, 20, 0x19, ENT_GEN79, RRF_DAMAGE); //Money 30
			Randomizer_AddEntrance(randVars, entVars, 0, 0x7B, 20, 0x19, ENT_GEN7B, RRF_DAMAGE); //Rupoor 10
			Randomizer_AddEntrance(randVars, entVars, 0, 0x7C, 20, 0x4A, ENT_GEN7C, RRF_DAMAGE); //Potion 20
			Randomizer_AddEntrance(randVars, entVars, 0, 0x7D, 20, 0x19, ENT_GEN7D, RRF_DAMAGE); //Rupoor 30
		}
		
		int first;
		int second;
		int i;
		for(i=0; i<counts[RI_NUMENTRANCES]*2; ++i){
			first  = Q7_srand(seed, counts[RI_NUMENTRANCES]);
			second = Q7_srand(seed, counts[RI_NUMENTRANCES]);
			Randomizer_SwapEntrance(randVars, entVars, first, second);
		}
		
		int entranceFlags;
		for(i=0; i<counts[RI_NUMENTRANCES]; ++i){
			entranceFlags = 0;
			entranceFlags = Randomizer_EntranceSetFlags(randVars, entVars, entFlags, i, entranceFlags);
			if(G[G_MODE_DUNGEONCEPTION]){
				if(erIDs[i]==ENT_LEVEL1)
					Randomizer_EntranceSetFlags(randVars, entVars, entFlags, -ENT_EXTRAGEN1, entranceFlags);
				if(erIDs[i]==ENT_LEVEL2)
					Randomizer_EntranceSetFlags(randVars, entVars, entFlags, -ENT_EXTRAGEN2, entranceFlags);
				if(erIDs[i]==ENT_LEVEL3)
					Randomizer_EntranceSetFlags(randVars, entVars, entFlags, -ENT_EXTRAGEN3, entranceFlags);
				if(erIDs[i]==ENT_LEVEL4A)
					Randomizer_EntranceSetFlags(randVars, entVars, entFlags, -ENT_EXTRAGEN4, entranceFlags);
				if(erIDs[i]==ENT_LEVEL5)
					Randomizer_EntranceSetFlags(randVars, entVars, entFlags, -ENT_EXTRAGEN5, entranceFlags);
				if(erIDs[i]==ENT_LEVEL6)
					Randomizer_EntranceSetFlags(randVars, entVars, entFlags, -ENT_EXTRAGEN6, entranceFlags);
				if(erIDs[i]==ENT_LEVEL7)
					Randomizer_EntranceSetFlags(randVars, entVars, entFlags, -ENT_EXTRAGEN7, entranceFlags);
				if(erIDs[i]==ENT_LEVEL8)
					Randomizer_EntranceSetFlags(randVars, entVars, entFlags, -ENT_EXTRAGEN8, entranceFlags);
				if(erIDs[i]==ENT_LEVEL9)
					Randomizer_EntranceSetFlags(randVars, entVars, entFlags, -ENT_EXTRAGEN9, entranceFlags);
			}
			if(erIDs[i]==ENT_LEVEL4B)
				Randomizer_EntranceSetFlags(randVars, entVars, entFlags, -ENT_SWORD4, entranceFlags);
		}
		
		Randomizer_GetSignificantEntrances(randVars, entVars);
		
		if(DEBUG_ENTRANCES){
			for(i=0; i<counts[RI_NUMENTRANCES]; ++i){
				Randomizer_DebugEntranceData(randVars, entVars, entFlags, i);
			}
		}
		
		G[G_ENTRANCERANDOMIZER_NUMENTRANCES] = counts[RI_NUMENTRANCES];
		if(!Randomizer_ValidateEntranceData(randVars, entVars))
			return false;
	}
	else{
		entFlags[ENT_SWORD2] = RRF_CANDLE;
		entFlags[ENT_SWORD3] = RRF_DAMAGE;
		entFlags[ENT_SWORD4] = RRF_DAMAGE|RRF_FLIPPERS|RRF_BOOTS|RRF_PHASECLOAK;
		
		entFlags[ENT_HEARTx0B] = onlyFirstCave;
		entFlags[ENT_HEARTx21] = onlyFirstCave;
		entFlags[ENT_HEARTx4B] = RRF_CANDLE;
		entFlags[ENT_HEARTx62] = RRF_CANDLE;
		
		entFlags[ENT_LETTER] = RRF_DAMAGE;
		
		entFlags[ENT_SHOPCANDLE] = RRF_DAMAGE;
		entFlags[ENT_SHOPBRACELET] = RRF_DAMAGE;
		entFlags[ENT_SHOPSECRETS] = RRF_BRACELET|RRF_DAMAGE;
		entFlags[ENT_SHOPRING] = RRF_DAMAGE|RRF_FLIPPERS;
		
		entFlags[ENT_LEVEL3] = RRF_WHISTLE;
		entFlags[ENT_LEVEL4A] = RRF_DAMAGE;
		entFlags[ENT_LEVEL4B] = RRF_FLIPPERS;
		entFlags[ENT_LEVEL5] = RRF_DAMAGE;
		entFlags[ENT_LEVEL6] = RRF_DAMAGE;
		entFlags[ENT_LEVEL9] = RRF_DAMAGE;
		
		entFlags[ENT_GEN03] = RRF_DAMAGE; //Potion 60
		entFlags[ENT_GEN05] = RRF_DAMAGE; //Potion 60
		entFlags[ENT_GEN07] = RRF_DAMAGE; //Money 30
		entFlags[ENT_GEN0A] = 0; //Info Swords
		entFlags[ENT_GEN0C] = RRF_DAMAGE; //Shield 60
		entFlags[ENT_GEN0D] = RRF_DAMAGE; //Gamble 100
		entFlags[ENT_GEN12] = RRF_DAMAGE; //Gamble 60
		entFlags[ENT_GEN14] = RRF_DAMAGE; //Shield 90
		entFlags[ENT_GEN16] = RRF_DAMAGE; //Money 30
		entFlags[ENT_GEN1C] = RRF_DAMAGE; //Shield 60
		entFlags[ENT_GEN1D] = RRF_DAMAGE|RRF_BRACELET; //Money 30
		entFlags[ENT_GEN1E] = RRF_DAMAGE; //Potion 60
		entFlags[ENT_GEN23] = RRF_BRACELET; //Info Adjean
		entFlags[ENT_GEN25] = 0; //Gamble 40
		entFlags[ENT_GEN26] = RRF_DAMAGE; //Money 20
		entFlags[ENT_GEN27] = RRF_FLIPPERS; //Potion 60
		entFlags[ENT_GEN28] = RRF_CANDLE; //Money 30
		entFlags[ENT_GEN2D] = RRF_DAMAGE; //Money 30
		entFlags[ENT_GEN3C] = 0; //Shield 90
		entFlags[ENT_GEN3D] = 0; //Rupoor 50
		entFlags[ENT_GEN42] = 0; //Potion 100
		entFlags[ENT_GEN43] = RRF_DAMAGE; //Money 100
		entFlags[ENT_GEN44] = 0; //Shield 60
		entFlags[ENT_GEN46] = RRF_CANDLE; //Money 10
		entFlags[ENT_GEN47] = RRF_CANDLE; //Money 20
		entFlags[ENT_GEN48] = RRF_CANDLE; //Money 10
		entFlags[ENT_GEN49] = RRF_BRACELET; //Shield 90
		entFlags[ENT_GEN4D] = RRF_CANDLE; //Shield 60
		entFlags[ENT_GEN51] = RRF_CANDLE; //Rupoor 10
		entFlags[ENT_GEN56] = RRF_CANDLE; //Shield 90
		entFlags[ENT_GEN5B] = RRF_CANDLE; //Gamble 60
		entFlags[ENT_GEN5E] = 0; //Info Paths
		entFlags[ENT_GEN63] = RRF_CANDLE; //Rupoor 20
		entFlags[ENT_GEN64] = 0; //Info Waterfall
		entFlags[ENT_GEN66] = 0; //Shield 60
		entFlags[ENT_GEN67] = RRF_DAMAGE; //Gamble 40
		entFlags[ENT_GEN68] = RRF_CANDLE; //Money 5
		entFlags[ENT_GEN6A] = RRF_CANDLE; //Money 30
		entFlags[ENT_GEN6B] = RRF_CANDLE; //Money 10
		entFlags[ENT_GEN6F] = 0; //Info Cascade
		entFlags[ENT_GEN76] = RRF_DAMAGE; //Money 20
		entFlags[ENT_GEN78] = RRF_CANDLE; //Money 10
		entFlags[ENT_GEN79] = RRF_DAMAGE; //Money 30
		entFlags[ENT_GEN7B] = RRF_DAMAGE; //Rupoor 10
		entFlags[ENT_GEN7C] = RRF_DAMAGE; //Potion 20
		entFlags[ENT_GEN7D] = RRF_DAMAGE; //Rupoor 30
		
		entFlags[ENT_EXTRAGEN1] = RRF_DAMAGE; 
		entFlags[ENT_EXTRAGEN2] = RRF_DAMAGE; 
		entFlags[ENT_EXTRAGEN3] = RRF_DAMAGE; 
		entFlags[ENT_EXTRAGEN4] = RRF_DAMAGE; 
		entFlags[ENT_EXTRAGEN5] = RRF_DAMAGE|RRF_CANDLE; 
		entFlags[ENT_EXTRAGEN5] = RRF_DAMAGE; 
		entFlags[ENT_EXTRAGEN6] = RRF_DAMAGE; 
		entFlags[ENT_EXTRAGEN7] = RRF_DAMAGE|RRF_PHASECLOAK; 
		entFlags[ENT_EXTRAGEN8] = RRF_DAMAGE|RRF_BRACELET|RRF_PHASECLOAK|RRF_FLIPPERS|RRF_WHISTLE; 
		entFlags[ENT_EXTRAGEN8] = l9ReqTriforce|RRF_DAMAGE|RRF_PHASECLOAK; 
	}
	return true;
}

int Randomizer_EntranceSetFlags(int randVars, int entVars, int entFlags, int id, int curFlags){
	int i;
	
	int counts = randVars[0];
	
	int erEntDMaps = entVars[1];
	int erEntScreens = entVars[2];
	int erExitDMaps = entVars[3];
	int erExitScreens = entVars[4];
	int erIDs = randVars[28];
	int erStartIDs = randVars[29];
	
	if(id<0){
		for(int i=0; i<counts[RI_NUMENTRANCES]; ++i){
			if(erStartIDs[i]==Abs(id)){
				id = i;
				break;
			}
		}
	}
	
	int entranceDMap = erEntDMaps[id];
	int entranceMap = Game->DMapMap[entranceDMap];
	int entranceScreen = erEntScreens[id]+Game->DMapOffset[entranceDMap];
	int exitDMap = erExitDMaps[id];
	int exitMap = Game->DMapMap[exitDMap];
	int exitScreen = erExitScreens[id]+Game->DMapOffset[exitDMap];
	
	EntranceRandomizer_SetLoc(entranceMap*128+entranceScreen, exitDMap, erExitScreens[id], 1);
	EntranceRandomizer_SetLoc(exitMap*128+exitScreen, entranceDMap, erEntScreens[id], 0);
	
	curFlags |= Randomizer_GetEntranceFlags(randVars, erStartIDs[id]);
	entFlags[erIDs[id]] = curFlags;
	
	return curFlags;
}

int Randomizer_GetEntranceFlags(int randVars, int id){
	int l9ReqTriforce = Cond(G[G_RANDOMIZER_REQTRIFORCE]==0, RRF_TRIFORCES, 0);
	
	if(id==ENT_SWORD2) return RRF_CANDLE;
	if(id==ENT_SWORD3) return RRF_DAMAGE;
	if(id==ENT_SWORD4) return RRF_DAMAGE|RRF_FLIPPERS|RRF_BOOTS|RRF_PHASECLOAK;
	
	// if(id==ENT_HEARTx0B) return RRF_DAMAGE;
	// if(id==ENT_HEARTx21) return RRF_DAMAGE;
	if(id==ENT_HEARTx4B) return RRF_CANDLE;
	if(id==ENT_HEARTx62) return RRF_CANDLE;
	
	if(id==ENT_LEVEL3) return RRF_WHISTLE;
	
	if(id==ENT_LEVEL4A) return RRF_DAMAGE;
	if(id==ENT_LEVEL4B) return RRF_FLIPPERS;
	if(id==ENT_LEVEL5) return RRF_DAMAGE;
	if(id==ENT_LEVEL6) return RRF_DAMAGE;
	
	if(id==ENT_LETTER) return RRF_DAMAGE;
	
	// if(id==ENT_SHOPCANDLE) return RRF_DAMAGE;
	// if(id==ENT_SHOPBRACELET) return RRF_DAMAGE;
	if(id==ENT_SHOPSECRETS) return RRF_BRACELET;
	if(id==ENT_SHOPRING) return RRF_FLIPPERS;
	
	if(id==ENT_EXTRAGEN1) return RRF_DAMAGE;
	if(id==ENT_EXTRAGEN2) return RRF_DAMAGE;
	if(id==ENT_EXTRAGEN3) return RRF_DAMAGE;
	if(id==ENT_EXTRAGEN4) return RRF_DAMAGE;
	if(id==ENT_EXTRAGEN5) return RRF_DAMAGE|RRF_CANDLE;
	if(id==ENT_EXTRAGEN6) return RRF_DAMAGE;
	if(id==ENT_EXTRAGEN7) return RRF_DAMAGE|RRF_PHASECLOAK; 
	if(id==ENT_EXTRAGEN8) return RRF_DAMAGE|RRF_BRACELET|RRF_PHASECLOAK|RRF_FLIPPERS|RRF_WHISTLE; 
	if(id==ENT_EXTRAGEN9) return l9ReqTriforce|RRF_DAMAGE|RRF_PHASECLOAK; 
	
	int erItemRoomFlags = randVars[27];
	return erItemRoomFlags[id];
}

void Randomizer_AddEntrance(int randVars, int entVars, int dmapA, int screenA, int dmapB, int screenB, int id, int flags){
	int counts = randVars[0];
	
	int erEntDMaps = entVars[1];
	int erEntScreens = entVars[2];
	int erExitDMaps = entVars[3];
	int erExitScreens = entVars[4];
	int erItemRoomFlags = randVars[27];
	int erIDs = randVars[28];
	int erStartIDs = randVars[29];
	
	int index = counts[RI_NUMENTRANCES];
	
	erEntDMaps[index] = dmapA;
	erEntScreens[index] = screenA;
	erExitDMaps[index] = dmapB;
	erExitScreens[index] = screenB;
	erIDs[index] = id;
	erItemRoomFlags[id] = flags;
	erStartIDs[index] = id;
	
	++counts[RI_NUMENTRANCES];
}

bool Randomizer_ValidateEntranceData(int randVars, int entVars){
	int erEntDMaps = entVars[1];
	int erExitDMaps = entVars[3];
	
	bool foundLevels[16];
	foundLevels[0] = true;
	int totalLevels;
	for(int i=0; i<10&&totalLevels<9; ++i){
		for(int j=0; j<128; ++j){
			int lvl = Game->DMapLevel[erEntDMaps[j]];
			int exitlvl = Game->DMapLevel[erExitDMaps[j]];
			if(foundLevels[lvl]&&!foundLevels[exitlvl]){
				// int s[] = "Found level %d!\n";
				// printf(s, exitlvl);
				foundLevels[exitlvl] = true;
				++totalLevels;
			}
		}
	}
	// int s[] = "Done!\nLevels found: %d\n";
	// printf(s, totalLevels);
	if(totalLevels<9)
		return false;
	return true;
}

void Randomizer_GetSignificantEntrances(int randVars, int entVars){
	int counts = randVars[0];
	
	int erEntDMaps = entVars[1];
	int erEntScreens = entVars[2];
	int erExitDMaps = entVars[3];
	int erExitScreens = entVars[4];
	int erItemRooms = randVars[26];
	int erItemRoomFlags = randVars[27];
	int erIDs = randVars[28];
	int erStartIDs = randVars[29];
	int erCavesanityIDs = randVars[30];
	for(int i=0; i<counts[RI_NUMENTRANCES]; ++i){
		if(erExitDMaps[i]==20&&erExitScreens[i]==0x19){
			int scrn = erEntScreens[i]+Game->DMapOffset[erEntDMaps[i]];
			erItemRooms[counts[RI_NUMRUPEEENTRANCES]] = (scrn<<9)|erEntDMaps[i];
			erCavesanityIDs[counts[RI_NUMRUPEEENTRANCES]] = erIDs[i];
			++counts[RI_NUMRUPEEENTRANCES];
		}
	}
}

void Randomizer_SwapEntrance(int randVars, int entVars, int first, int second){
	int erEntDMaps = entVars[1];
	int erEntScreens = entVars[2];
	int erExitDMaps = entVars[3];
	int erExitScreens = entVars[4];
	int erIDs = randVars[28];
	int erStartIDs = randVars[29];
	
	//A DMap shouldn't link to itself
	if(erEntDMaps[first]==erExitDMaps[second]||erEntDMaps[second]==erExitDMaps[first])
		return;
	
	if(first!=second){
		int backup[] = {erExitDMaps[first], erExitScreens[first], erIDs[first]};
		erExitDMaps[first] = erExitDMaps[second];
		erExitScreens[first] = erExitScreens[second];
		erIDs[first] = erIDs[second];
		
		erExitDMaps[second] = backup[0];
		erExitScreens[second] = backup[1];
		erIDs[second] = backup[2];
	}
	
}

void Randomizer_SetUpRoomData(int randVars){
	int i;
	int l9ReqTriforce = Cond(G[G_RANDOMIZER_REQTRIFORCE]==0, RRF_TRIFORCES, 0);
	int l8Disabled = Cond(G[G_MODE_NORANDOMIZERNIGHTMARE], RRF_TRIFORCES|RRF_ARROW|RRF_PHASECLOAK2|RRF_BRACELET|RRF_CANDLE3|RRF_WHISTLE|RRF_WAND|RRF_FLIPPERS, 0);
	int onlyFirstCave = 0;
	if(G[G_RANDOMIZESTARTINGSWORD]==2)
		onlyFirstCave = RRF_DAMAGE;
	
	int counts = randVars[0];
	
	int roomTriforceReq = randVars[16];
	int roomMetaLevels = randVars[19];
	int entFlags = randVars[24];
	
	if(G[G_RANDOMIZESTARTINGSWORD]){
		//Sword 1
		Randomizer_AddRoom(randVars, 6, 0x11, entFlags[ENT_SWORD1], 0, 0);
	}
	
	//Overworld

	//--Swords
	i = Randomizer_AddRoom(randVars, 6, 0x00, entFlags[ENT_SWORD2], 0, 0);
	roomTriforceReq[i] = 2;
	i = Randomizer_AddRoom(randVars, 6, 0x01, entFlags[ENT_SWORD3], 0, 0);
	roomTriforceReq[i] = 5;
	i = Randomizer_AddRoom(randVars, 6, 0x10, entFlags[ENT_SWORD4], 4, 6);
	roomTriforceReq[i] = 8;	
	
	//--HCs
	Randomizer_AddRoom(randVars, 6, 0x0A, entFlags[ENT_HEARTx62], 0, 0);
	Randomizer_AddRoom(randVars, 6, 0x0B, entFlags[ENT_HEARTx4B], 0, 0);
	Randomizer_AddRoom(randVars, 6, 0x0C, entFlags[ENT_HEARTx0B], 0, 0);
	Randomizer_AddRoom(randVars, 6, 0x0D, entFlags[ENT_HEARTx21], 0, 0);
	Randomizer_AddRoom(randVars, 8, 0x5F, RRF_FLIPPERS|RRF_PHASECLOAK, 0, 0);
	
	//--Items
	Randomizer_AddRoom(randVars, 6, 0x12, entFlags[ENT_LETTER], 0, 0);
	Randomizer_AddRoom(randVars, 6, 0x06, entFlags[ENT_SHOPCANDLE]|RRF_DAMAGE, 0, 0);
	Randomizer_AddRoom(randVars, 6, 0x07, entFlags[ENT_SHOPBRACELET]|RRF_DAMAGE, 0, 0);
	Randomizer_AddRoom(randVars, 6, 0x08, entFlags[ENT_SHOPSECRETS]|RRF_DAMAGE, 0, 0);
	Randomizer_AddRoom(randVars, 6, 0x09, entFlags[ENT_SHOPRING]|RRF_DAMAGE, 0, 0);
	
	//Dungeons
	
	//--Level 1 - 5 Locks
	Randomizer_AddRoom(randVars, 2, 0x73, entFlags[ENT_LEVEL1]|RRF_DAMAGE, 1, 1);
	Randomizer_AddRoom(randVars, 2, 0x25, entFlags[ENT_LEVEL1]|RRF_DAMAGE, 1, 3);
	Randomizer_AddRoom(randVars, 2, 0x12, entFlags[ENT_LEVEL1]|RRF_WHISTLE|RRF_DAMAGE, 1, 5);
	
	//--Level 2 - 4 Locks
	Randomizer_AddRoom(randVars, 2, 0x3B, entFlags[ENT_LEVEL2]|RRF_DAMAGE, 2, 0);
	Randomizer_AddRoom(randVars, 2, 0x29, entFlags[ENT_LEVEL2]|RRF_DAMAGE, 2, 3);
	Randomizer_AddRoom(randVars, 2, 0x59, entFlags[ENT_LEVEL2]|RRF_ARROW|RRF_DAMAGE, 2, 4);
	
	//--Level 3 - 5 Locks
	Randomizer_AddRoom(randVars, 3, 0x74, entFlags[ENT_LEVEL3]|RRF_DAMAGE, 3, 5);
	Randomizer_AddRoom(randVars, 3, 0x55, entFlags[ENT_LEVEL3]|RRF_DAMAGE, 3, 0);
	Randomizer_AddRoom(randVars, 3, 0x30, entFlags[ENT_LEVEL3]|RRF_DAMAGE, 3, 1);
	Randomizer_AddRoom(randVars, 3, 0x53, entFlags[ENT_LEVEL3]|RRF_DAMAGE, 3, 5);
	
	//--Level 4 - 7 Locks
	Randomizer_AddRoom(randVars, 3, 0x1D, entFlags[ENT_LEVEL4A]|RRF_DAMAGE, 4, 3);
	Randomizer_AddRoom(randVars, 3, 0x6C, entFlags[ENT_LEVEL4B]|RRF_FLIPPERS|RRF_DAMAGE, 4, 7);
	
	//--Level 5 - 5 Locks
	Randomizer_AddRoom(randVars, 4, 0x26, entFlags[ENT_LEVEL5]|RRF_DAMAGE, 5, 4);
	Randomizer_AddRoom(randVars, 4, 0x13, entFlags[ENT_LEVEL5]|RRF_DAMAGE, 5, 5);
	
	//--Level 6- 3 Locks
	Randomizer_AddRoom(randVars, 4, 0x2D, entFlags[ENT_LEVEL6]|RRF_FLIPPERS|RRF_DAMAGE, 6, 2);
	Randomizer_AddRoom(randVars, 4, 0x5A, entFlags[ENT_LEVEL6]|RRF_DAMAGE, 6, 1);
	Randomizer_AddRoom(randVars, 4, 0x3B, entFlags[ENT_LEVEL6]|RRF_FLIPPERS|RRF_PHASECLOAK|RRF_DAMAGE, 6, 3);
	
	//--Level 7 - 7 Locks
	Randomizer_AddRoom(randVars, 5, 0x06, entFlags[ENT_LEVEL7]|RRF_PHASECLOAK|RRF_DAMAGE, 7, 0);
	Randomizer_AddRoom(randVars, 5, 0x73, entFlags[ENT_LEVEL7]|RRF_PHASECLOAK|RRF_DAMAGE, 7, 5);
	Randomizer_AddRoom(randVars, 5, 0x44, entFlags[ENT_LEVEL7]|RRF_WAND|RRF_PHASECLOAK|RRF_DAMAGE, 7, 6);
	
	//--Level 8 - 5 Locks
	Randomizer_AddRoom(randVars, 5, 0x0B, entFlags[ENT_LEVEL8]|l8Disabled|RRF_BRACELET|RRF_FLIPPERS|RRF_DAMAGE, 8, 4);
	Randomizer_AddRoom(randVars, 5, 0x1C, entFlags[ENT_LEVEL8]|l8Disabled|RRF_WHISTLE|RRF_BRACELET|RRF_FLIPPERS|RRF_ARROW|RRF_DAMAGE, 8, 5);
	Randomizer_AddRoom(randVars, 5, 0x3E, entFlags[ENT_LEVEL8]|l8Disabled|RRF_WHISTLE|RRF_BRACELET|RRF_FLIPPERS|RRF_ARROW|RRF_DAMAGE, 8, 5);
	
	//--Level 9 - 13 Locks
	//Floor 1 - 4 Locks
	i = Randomizer_AddRoom(randVars, 13, 0x43, entFlags[ENT_LEVEL9]|l9ReqTriforce|RRF_FLIPPERS|RRF_DAMAGE, 9, 0);
	roomMetaLevels[i] = 9;
	i = Randomizer_AddRoom(randVars, 13, 0x21, entFlags[ENT_LEVEL9]|l9ReqTriforce|RRF_FLIPPERS|RRF_DAMAGE, 9, 1);
	roomMetaLevels[i] = 9;
	i = Randomizer_AddRoom(randVars, 13, 0x33, entFlags[ENT_LEVEL9]|l9ReqTriforce|RRF_FLIPPERS|RRF_WHISTLE|RRF_DAMAGE, 9, 8);
	roomMetaLevels[i] = 9;
	i = Randomizer_AddRoom(randVars, 13, 0x05, entFlags[ENT_LEVEL9]|l9ReqTriforce|RRF_FLIPPERS|RRF_DAMAGE, 9, 1);
	roomMetaLevels[i] = 9;
	//Floor 2 - 3 Locks
	i = Randomizer_AddRoom(randVars, 13, 0x08, entFlags[ENT_LEVEL9]|l9ReqTriforce|RRF_FLIPPERS|RRF_DAMAGE, 9, 12);
	roomMetaLevels[i] = 10;
	//Floor 3 - 1 Lock
	i = Randomizer_AddRoom(randVars, 13, 0x2D, entFlags[ENT_LEVEL9]|l9ReqTriforce|RRF_PHASECLOAK2|RRF_FLIPPERS|RRF_DAMAGE, 9, 12);
	roomMetaLevels[i] = 11;
	//Floor 4 - 1 Lock
	i = Randomizer_AddRoom(randVars, 14, 0x14, entFlags[ENT_LEVEL9]|l9ReqTriforce|RRF_CANDLE3|RRF_PHASECLOAK2|RRF_FLIPPERS|RRF_DAMAGE, 9, 8);
	roomMetaLevels[i] = 12;
	i = Randomizer_AddRoom(randVars, 14, 0x43, entFlags[ENT_LEVEL9]|l9ReqTriforce|RRF_PHASECLOAK2|RRF_FLIPPERS|RRF_DAMAGE, 9, 12);
	roomMetaLevels[i] = 12;
	//Floor 5 - 3 Locks
	i = Randomizer_AddRoom(randVars, 14, 0x36, entFlags[ENT_LEVEL9]|l9ReqTriforce|RRF_PHASECLOAK2|RRF_FLIPPERS|RRF_DAMAGE, 9, 9);
	roomMetaLevels[i] = 13;
	//Floor 6 - 1 Lock
	i = Randomizer_AddRoom(randVars, 14, 0x1A, entFlags[ENT_LEVEL9]|l9ReqTriforce|RRF_PHASECLOAK2|RRF_FLIPPERS|RRF_DAMAGE, 9, 12);
	roomMetaLevels[i] = 14;
	
	//Bomb Upgrades
	Randomizer_AddRoom(randVars, 3, 0x1A, entFlags[ENT_LEVEL4A]|RRF_DAMAGE, 4, 0);
	Randomizer_AddRoom(randVars, 4, 0x14, entFlags[ENT_LEVEL5]|RRF_CANDLE2|RRF_DAMAGE, 5, 4);
	Randomizer_AddRoom(randVars, 5, 0x6D, entFlags[ENT_LEVEL8]|RRF_BRACELET|RRF_FLIPPERS|RRF_DAMAGE, 8, 4);
	
	if(G[G_RANDOMIZETRASH]){
		//Dungeons
	
		//--Level 1
		Randomizer_AddRoom(randVars, 2, 0x11, entFlags[ENT_LEVEL1]|RRF_WHISTLE|RRF_DAMAGE, 1, 5);
		Randomizer_AddRoom(randVars, 2, 0x24, entFlags[ENT_LEVEL1]|RRF_DAMAGE, 1, 4);
		Randomizer_AddRoom(randVars, 2, 0x35, entFlags[ENT_LEVEL1]|RRF_DAMAGE, 1, 2);
		Randomizer_AddRoom(randVars, 2, 0x62, entFlags[ENT_LEVEL1]|onlyFirstCave, 1, 0);
		Randomizer_AddRoom(randVars, 2, 0x64, entFlags[ENT_LEVEL1]|RRF_DAMAGE, 1, 1);
		
		//--Level 2
		Randomizer_AddRoom(randVars, 2, 0x09, entFlags[ENT_LEVEL2]|RRF_DAMAGE, 2, 0);
		Randomizer_AddRoom(randVars, 2, 0x18, entFlags[ENT_LEVEL2]|RRF_DAMAGE, 2, 0);
		Randomizer_AddRoom(randVars, 2, 0x1A, entFlags[ENT_LEVEL2]|RRF_DAMAGE, 2, 0);
		Randomizer_AddRoom(randVars, 2, 0x2D, entFlags[ENT_LEVEL2]|RRF_DAMAGE, 2, 0);
		Randomizer_AddRoom(randVars, 2, 0x3A, entFlags[ENT_LEVEL2]|RRF_DAMAGE, 2, 0);
		Randomizer_AddRoom(randVars, 2, 0x4B, entFlags[ENT_LEVEL2]|RRF_DAMAGE, 2, 0);
		
		//--Level 3
		Randomizer_AddRoom(randVars, 3, 0x25, entFlags[ENT_LEVEL3]|RRF_DAMAGE, 3, 1);
		Randomizer_AddRoom(randVars, 3, 0x44, entFlags[ENT_LEVEL3]|RRF_DAMAGE, 3, 4);
		Randomizer_AddRoom(randVars, 3, 0x51, entFlags[ENT_LEVEL3]|RRF_DAMAGE, 3, 1);
		Randomizer_AddRoom(randVars, 3, 0x62, entFlags[ENT_LEVEL3]|RRF_DAMAGE, 3, 1);
		Randomizer_AddRoom(randVars, 3, 0x73, entFlags[ENT_LEVEL3]|RRF_DAMAGE, 3, 5);
		
		//--Level 4
		Randomizer_AddRoom(randVars, 3, 0x18, entFlags[ENT_LEVEL4A]|RRF_DAMAGE, 4, 0);
		Randomizer_AddRoom(randVars, 3, 0x1E, entFlags[ENT_LEVEL4A]|RRF_DAMAGE, 4, 3);
		Randomizer_AddRoom(randVars, 3, 0x2B, entFlags[ENT_LEVEL4A]|RRF_DAMAGE, 4, 2);
		Randomizer_AddRoom(randVars, 3, 0x58, entFlags[ENT_LEVEL4B]|RRF_FLIPPERS|RRF_DAMAGE, 4, 3);
		Randomizer_AddRoom(randVars, 3, 0x6A, entFlags[ENT_LEVEL4B]|RRF_FLIPPERS|RRF_WHISTLE|RRF_DAMAGE, 4, 4);
		Randomizer_AddRoom(randVars, 3, 0x6E, entFlags[ENT_LEVEL4B]|RRF_FLIPPERS|RRF_DAMAGE, 4, 3);
		
		//--Level 5
		Randomizer_AddRoom(randVars, 4, 0x20, entFlags[ENT_LEVEL5]|RRF_CANDLE2|RRF_DAMAGE, 5, 2);
		Randomizer_AddRoom(randVars, 4, 0x21, entFlags[ENT_LEVEL5]|RRF_CANDLE2|RRF_DAMAGE, 5, 4);
		Randomizer_AddRoom(randVars, 4, 0x42, entFlags[ENT_LEVEL5]|RRF_CANDLE2|RRF_DAMAGE, 5, 1);
		Randomizer_AddRoom(randVars, 4, 0x51, entFlags[ENT_LEVEL5]|RRF_CANDLE2|RRF_DAMAGE, 5, 2);
		Randomizer_AddRoom(randVars, 4, 0x61, entFlags[ENT_LEVEL5]|RRF_CANDLE2|RRF_DAMAGE, 5, 2);
		Randomizer_AddRoom(randVars, 4, 0x64, entFlags[ENT_LEVEL5]|RRF_DAMAGE, 5, 0);
		
		//--Level 6
		Randomizer_AddRoom(randVars, 4, 0x1B, entFlags[ENT_LEVEL6]|RRF_FLIPPERS|RRF_DAMAGE, 6, 1);
		Randomizer_AddRoom(randVars, 4, 0x29, entFlags[ENT_LEVEL6]|RRF_FLIPPERS|RRF_DAMAGE, 6, 1);
		Randomizer_AddRoom(randVars, 4, 0x39, entFlags[ENT_LEVEL6]|RRF_FLIPPERS|RRF_DAMAGE, 6, 1);
		Randomizer_AddRoom(randVars, 4, 0x3C, entFlags[ENT_LEVEL6]|RRF_FLIPPERS|RRF_DAMAGE, 6, 2);
		Randomizer_AddRoom(randVars, 4, 0x5D, entFlags[ENT_LEVEL6]|RRF_DAMAGE, 6, 0);
		Randomizer_AddRoom(randVars, 4, 0x7B, entFlags[ENT_LEVEL6], 6, 0);
		
		//--Level 7
		Randomizer_AddRoom(randVars, 5, 0x05, entFlags[ENT_LEVEL7]|onlyFirstCave, 7, 0);
		Randomizer_AddRoom(randVars, 5, 0x12, entFlags[ENT_LEVEL7]|RRF_PHASECLOAK|RRF_DAMAGE, 7, 1);
		Randomizer_AddRoom(randVars, 5, 0x22, entFlags[ENT_LEVEL7]|RRF_PHASECLOAK|RRF_DAMAGE, 7, 1);
		Randomizer_AddRoom(randVars, 5, 0x34, entFlags[ENT_LEVEL7]|RRF_PHASECLOAK|RRF_DAMAGE, 7, 1);
		Randomizer_AddRoom(randVars, 5, 0x53, entFlags[ENT_LEVEL7]|RRF_PHASECLOAK|RRF_DAMAGE, 7, 4);
		Randomizer_AddRoom(randVars, 5, 0x63, entFlags[ENT_LEVEL7]|RRF_PHASECLOAK|RRF_DAMAGE, 7, 4);
		
		//--Level 8
		Randomizer_AddRoom(randVars, 5, 0x2C, entFlags[ENT_LEVEL8]|l8Disabled|RRF_BRACELET|RRF_DAMAGE, 8, 5);
		Randomizer_AddRoom(randVars, 5, 0x3B, entFlags[ENT_LEVEL8]|l8Disabled|RRF_BRACELET|RRF_DAMAGE, 8, 2);
		Randomizer_AddRoom(randVars, 5, 0x4A, entFlags[ENT_LEVEL8]|l8Disabled|RRF_BRACELET|RRF_DAMAGE, 8, 1);
		Randomizer_AddRoom(randVars, 5, 0x4E, entFlags[ENT_LEVEL8]|l8Disabled|RRF_BRACELET|RRF_FLIPPERS|RRF_DAMAGE, 8, 5);
		Randomizer_AddRoom(randVars, 5, 0x5C, entFlags[ENT_LEVEL8]|l8Disabled|RRF_BRACELET|RRF_FLIPPERS|RRF_DAMAGE, 8, 2);
		Randomizer_AddRoom(randVars, 5, 0x6C, entFlags[ENT_LEVEL8]|l8Disabled|RRF_BRACELET|RRF_FLIPPERS|RRF_DAMAGE, 8, 2);
		
		//--Level 9
		i = Randomizer_AddRoom(randVars, 13, 0x63, entFlags[ENT_LEVEL9]|RRF_DAMAGE, 9, 0);
		roomMetaLevels[i] = 9;
	}
	
	if(G[G_RANDOMIZETRIFORCE]){
		Randomizer_AddRoom(randVars, 2, 0x20, entFlags[ENT_LEVEL1]|RRF_WHISTLE|RRF_DAMAGE, 1, 5);
		Randomizer_AddRoom(randVars, 2, 0x58, entFlags[ENT_LEVEL2]|RRF_ARROW|RRF_DAMAGE, 2, 4);
		Randomizer_AddRoom(randVars, 3, 0x63, entFlags[ENT_LEVEL3]|RRF_DAMAGE, 3, 5);
		Randomizer_AddRoom(randVars, 3, 0x7C, entFlags[ENT_LEVEL4B]|RRF_FLIPPERS|RRF_DAMAGE, 4, 7);
		Randomizer_AddRoom(randVars, 4, 0x03, entFlags[ENT_LEVEL5]|RRF_CANDLE2|RRF_DAMAGE, 5, 5);
		Randomizer_AddRoom(randVars, 4, 0x2B, entFlags[ENT_LEVEL6]|RRF_PHASECLOAK|RRF_DAMAGE, 6, 3);
		Randomizer_AddRoom(randVars, 5, 0x45, entFlags[ENT_LEVEL7]|RRF_WAND|RRF_PHASECLOAK|RRF_DAMAGE, 7, 6);
		Randomizer_AddRoom(randVars, 5, 0x2E, entFlags[ENT_LEVEL8]|l8Disabled|RRF_WHISTLE|RRF_ARROW|RRF_BRACELET|RRF_FLIPPERS|RRF_DAMAGE, 8, 5);
	}
	
	if(G[G_MODE_KEYSANITY]){
		//--Level 1 - 5 Locks
		Randomizer_AddRoom(randVars, 2, 0x02, entFlags[ENT_LEVEL1]|RRF_DAMAGE, 1, 2);
		Randomizer_AddRoom(randVars, 2, 0x23, entFlags[ENT_LEVEL1]|RRF_DAMAGE, 1, 2);
		Randomizer_AddRoom(randVars, 2, 0x44, entFlags[ENT_LEVEL1]|RRF_DAMAGE, 1, 1);
		Randomizer_AddRoom(randVars, 2, 0x50, entFlags[ENT_LEVEL1]|RRF_DAMAGE, 1, 0);
		Randomizer_AddRoom(randVars, 2, 0x61, entFlags[ENT_LEVEL1]|RRF_DAMAGE, 1, 0);
		//--Level 2 - 4 Locks
		Randomizer_AddRoom(randVars, 2, 0x19, entFlags[ENT_LEVEL2]|RRF_DAMAGE, 2, 0);
		Randomizer_AddRoom(randVars, 2, 0x49, entFlags[ENT_LEVEL2]|RRF_ARROW|RRF_DAMAGE, 2, 3);
		Randomizer_AddRoom(randVars, 2, 0x4C, entFlags[ENT_LEVEL2]|RRF_DAMAGE, 2, 0);
		Randomizer_AddRoom(randVars, 2, 0x5B, entFlags[ENT_LEVEL2]|RRF_ARROW|RRF_DAMAGE, 2, 0);
		//--Level 3 - 5 Locks
		Randomizer_AddRoom(randVars, 3, 0x20, entFlags[ENT_LEVEL3]|RRF_DAMAGE, 3, 0);
		Randomizer_AddRoom(randVars, 3, 0x40, entFlags[ENT_LEVEL3]|RRF_DAMAGE, 3, 1);
		Randomizer_AddRoom(randVars, 3, 0x46, entFlags[ENT_LEVEL3]|RRF_DAMAGE, 3, 1);
		Randomizer_AddRoom(randVars, 3, 0x56, entFlags[ENT_LEVEL3]|RRF_DAMAGE, 3, 0);
		Randomizer_AddRoom(randVars, 3, 0x61, entFlags[ENT_LEVEL3]|RRF_DAMAGE, 3, 1);
		//--Level 4 - 6 Locks
		Randomizer_AddRoom(randVars, 3, 0x08, entFlags[ENT_LEVEL4A]|RRF_DAMAGE, 4, 0);
		Randomizer_AddRoom(randVars, 3, 0x1F, entFlags[ENT_LEVEL4A]|RRF_DAMAGE, 4, 0);
		Randomizer_AddRoom(randVars, 3, 0x2E, entFlags[ENT_LEVEL4A]|RRF_DAMAGE|RRF_PHASECLOAK, 4, 2);
		Randomizer_AddRoom(randVars, 3, 0x3B, entFlags[ENT_LEVEL4A]|RRF_DAMAGE, 4, 2);
		Randomizer_AddRoom(randVars, 3, 0x3C, entFlags[ENT_LEVEL4A]|RRF_DAMAGE, 4, 2);
		Randomizer_AddRoom(randVars, 3, 0x48, entFlags[ENT_LEVEL4B]|RRF_FLIPPERS|RRF_DAMAGE, 4, 3);
		Randomizer_AddRoom(randVars, 3, 0x5E, entFlags[ENT_LEVEL4B]|RRF_DAMAGE, 4, 3);
		//--Level 5 - 5 Locks
		Randomizer_AddRoom(randVars, 4, 0x12, entFlags[ENT_LEVEL5]|RRF_CANDLE2|RRF_DAMAGE, 5, 4);
		Randomizer_AddRoom(randVars, 4, 0x24, entFlags[ENT_LEVEL5]|RRF_CANDLE2|RRF_DAMAGE, 5, 4);
		Randomizer_AddRoom(randVars, 4, 0x34, entFlags[ENT_LEVEL5]|RRF_DAMAGE, 5, 0);
		Randomizer_AddRoom(randVars, 4, 0x54, entFlags[ENT_LEVEL5]|RRF_DAMAGE, 5, 0);
		Randomizer_AddRoom(randVars, 4, 0x65, entFlags[ENT_LEVEL5]|RRF_CANDLE2|RRF_DAMAGE, 5, 1);
		//--Level 6- 3 Locks
		Randomizer_AddRoom(randVars, 4, 0x3D, entFlags[ENT_LEVEL6]|RRF_DAMAGE, 6, 0);
		Randomizer_AddRoom(randVars, 4, 0x4B, entFlags[ENT_LEVEL6]|RRF_DAMAGE, 6, 1);
		Randomizer_AddRoom(randVars, 4, 0x4D, entFlags[ENT_LEVEL6]|RRF_PHASECLOAK|RRF_DAMAGE, 6, 0);
		//--Level 7 - 7 Locks
		Randomizer_AddRoom(randVars, 5, 0x02, entFlags[ENT_LEVEL7]|RRF_PHASECLOAK|RRF_DAMAGE, 7, 0);
		Randomizer_AddRoom(randVars, 5, 0x20, entFlags[ENT_LEVEL7]|RRF_DAMAGE, 7, 1);
		Randomizer_AddRoom(randVars, 5, 0x21, entFlags[ENT_LEVEL7]|RRF_WAND|RRF_DAMAGE, 7, 1);
		Randomizer_AddRoom(randVars, 5, 0x32, entFlags[ENT_LEVEL7]|RRF_WAND|RRF_DAMAGE, 7, 1);
		Randomizer_AddRoom(randVars, 5, 0x33, entFlags[ENT_LEVEL7]|RRF_DAMAGE, 7, 1);
		Randomizer_AddRoom(randVars, 5, 0x51, entFlags[ENT_LEVEL7]|RRF_DAMAGE, 7, 5);
		Randomizer_AddRoom(randVars, 5, 0x62, entFlags[ENT_LEVEL7]|RRF_DAMAGE, 7, 5);
		//--Level 8 - 5 Locks
		Randomizer_AddRoom(randVars, 5, 0x2A, entFlags[ENT_LEVEL8]|l8Disabled|RRF_BRACELET|RRF_DAMAGE, 8, 1);
		Randomizer_AddRoom(randVars, 5, 0x39, entFlags[ENT_LEVEL8]|l8Disabled|RRF_BRACELET|RRF_DAMAGE, 8, 0);
		Randomizer_AddRoom(randVars, 5, 0x3D, entFlags[ENT_LEVEL8]|l8Disabled|RRF_BRACELET|RRF_DAMAGE, 8, 2);
		Randomizer_AddRoom(randVars, 5, 0x5B, entFlags[ENT_LEVEL8]|l8Disabled|RRF_BRACELET|RRF_DAMAGE|RRF_FLIPPERS, 8, 4);
		Randomizer_AddRoom(randVars, 5, 0x7C, entFlags[ENT_LEVEL8]|l8Disabled|RRF_BRACELET|RRF_DAMAGE|RRF_FLIPPERS, 8, 5);
		//--Level 9 - 13 Locks
		//Floor 1 - 4 Locks
		i = Randomizer_AddRoom(randVars, 13, 0x04, entFlags[ENT_LEVEL9]|l9ReqTriforce|RRF_DAMAGE, 9, 1);
		roomMetaLevels[i] = 9;
		i = Randomizer_AddRoom(randVars, 13, 0x14, entFlags[ENT_LEVEL9]|l9ReqTriforce|RRF_FLIPPERS|RRF_CANDLE2|RRF_PHASECLOAK|RRF_DAMAGE, 9, 13);
		roomMetaLevels[i] = 9;
		i = Randomizer_AddRoom(randVars, 13, 0x22, entFlags[ENT_LEVEL9]|l9ReqTriforce|RRF_DAMAGE, 9, 0);
		roomMetaLevels[i] = 9;
		i = Randomizer_AddRoom(randVars, 13, 0x35, entFlags[ENT_LEVEL9]|l9ReqTriforce|RRF_WHISTLE|RRF_DAMAGE, 9, 12);
		roomMetaLevels[i] = 9;
		//Floor 2 - 3 Locks
		i = Randomizer_AddRoom(randVars, 13, 0x37, entFlags[ENT_LEVEL9]|l9ReqTriforce|RRF_DAMAGE, 9, 1);
		roomMetaLevels[i] = 10;
		i = Randomizer_AddRoom(randVars, 13, 0x39, entFlags[ENT_LEVEL9]|l9ReqTriforce|RRF_FLIPPERS|RRF_DAMAGE, 9, 0);
		roomMetaLevels[i] = 10;
		//Floor 3 - 1 Lock
		i = Randomizer_AddRoom(randVars, 13, 0x1C, entFlags[ENT_LEVEL9]|l9ReqTriforce|RRF_WHISTLE|RRF_DAMAGE, 9, 3);
		roomMetaLevels[i] = 11;
		i = Randomizer_AddRoom(randVars, 13, 0x3C, entFlags[ENT_LEVEL9]|l9ReqTriforce|RRF_WHISTLE|RRF_DAMAGE, 9, 7);
		roomMetaLevels[i] = 11;
		//Floor 4 - 1 Lock
		i = Randomizer_AddRoom(randVars, 14, 0x01, entFlags[ENT_LEVEL9]|l9ReqTriforce|RRF_WHISTLE|RRF_DAMAGE, 9, 7);
		roomMetaLevels[i] = 12;
		i = Randomizer_AddRoom(randVars, 14, 0x21, entFlags[ENT_LEVEL9]|l9ReqTriforce|RRF_WHISTLE|RRF_DAMAGE, 9, 7);
		roomMetaLevels[i] = 12;
		//Floor 5 - 3 Locks
		i = Randomizer_AddRoom(randVars, 14, 0x16, entFlags[ENT_LEVEL9]|l9ReqTriforce|RRF_WHISTLE|RRF_DAMAGE, 9, 12);
		roomMetaLevels[i] = 13;
		i = Randomizer_AddRoom(randVars, 14, 0x37, entFlags[ENT_LEVEL9]|l9ReqTriforce|RRF_PHASECLOAK2|RRF_WHISTLE|RRF_DAMAGE, 9, 7);
		roomMetaLevels[i] = 13;
		//Floor 6 - 1 Lock
		i = Randomizer_AddRoom(randVars, 14, 0x2A, entFlags[ENT_LEVEL9]|l9ReqTriforce|RRF_PHASECLOAK2|RRF_WHISTLE|RRF_DAMAGE, 9, 12);
		roomMetaLevels[i] = 14;
		i = Randomizer_AddRoom(randVars, 15, 0x6A, entFlags[ENT_LEVEL9]|l9ReqTriforce|RRF_PHASECLOAK2|RRF_WHISTLE|RRF_DAMAGE, 9, 12);
		roomMetaLevels[i] = 14;
	}
	
	if(G[G_MODE_RANDOMIZEMUMPUS]){
		Randomizer_AddRoom(randVars, 2, 0x54, entFlags[ENT_LEVEL1]|RRF_DAMAGE, 1, 1);
		Randomizer_AddRoom(randVars, 2, 0x55, entFlags[ENT_LEVEL1]|RRF_DAMAGE, 1, 1);
		
		Randomizer_AddRoom(randVars, 2, 0x2A, entFlags[ENT_LEVEL2]|RRF_DAMAGE, 2, 0);
		Randomizer_AddRoom(randVars, 2, 0x2C, entFlags[ENT_LEVEL2]|RRF_DAMAGE, 2, 0);
	
		Randomizer_AddRoom(randVars, 3, 0x45, entFlags[ENT_LEVEL3]|RRF_DAMAGE, 3, 3);
		Randomizer_AddRoom(randVars, 3, 0x64, entFlags[ENT_LEVEL3]|RRF_DAMAGE, 3, 0);
		
		Randomizer_AddRoom(randVars, 3, 0x0F, entFlags[ENT_LEVEL4A]|RRF_DAMAGE, 4, 6);
		Randomizer_AddRoom(randVars, 3, 0x4F, entFlags[ENT_LEVEL4B]|RRF_DAMAGE, 4, 0);
		
		Randomizer_AddRoom(randVars, 4, 0x55, entFlags[ENT_LEVEL5]|RRF_DAMAGE, 5, 0);
		Randomizer_AddRoom(randVars, 4, 0x62, entFlags[ENT_LEVEL5]|RRF_DAMAGE|RRF_CANDLE2, 5, 1);
		
		Randomizer_AddRoom(randVars, 4, 0x4C, entFlags[ENT_LEVEL6]|RRF_DAMAGE, 6, 0);
		Randomizer_AddRoom(randVars, 4, 0x59, entFlags[ENT_LEVEL6]|RRF_DAMAGE, 6, 1);
		
		Randomizer_AddRoom(randVars, 5, 0x11, entFlags[ENT_LEVEL7]|RRF_WAND|RRF_DAMAGE, 7, 1);
		Randomizer_AddRoom(randVars, 5, 0x43, entFlags[ENT_LEVEL7]|RRF_DAMAGE, 7, 6);
		
		Randomizer_AddRoom(randVars, 5, 0x4C, entFlags[ENT_LEVEL8]|l8Disabled|RRF_DAMAGE, 8, 4);
		Randomizer_AddRoom(randVars, 5, 0x5A, entFlags[ENT_LEVEL8]|l8Disabled, 8, 0);
		
		i = Randomizer_AddRoom(randVars, 13, 0x17, entFlags[ENT_LEVEL9]|l9ReqTriforce|RRF_DAMAGE, 9, 1);
		roomMetaLevels[i] = 10;
		i = Randomizer_AddRoom(randVars, 13, 0x45, entFlags[ENT_LEVEL9]|l9ReqTriforce|RRF_DAMAGE, 9, 7);
		roomMetaLevels[i] = 9;
	}

	bool entrandRupeeCaves;
	if(G[G_MODE_DUNGEONCEPTION]){
		if(G[G_MODE_ENTRANCE_RANDO]){
			entrandRupeeCaves = true;
		}
		else{
			Randomizer_AddRoom(randVars, 2, 0x34, entFlags[ENT_LEVEL1]|RRF_DAMAGE, 1, 2);
			Randomizer_AddRoom(randVars, 2, 0x5C, entFlags[ENT_LEVEL2]|RRF_DAMAGE, 2, 0);
			Randomizer_AddRoom(randVars, 3, 0x04, entFlags[ENT_LEVEL3]|RRF_DAMAGE, 3, 1);
			Randomizer_AddRoom(randVars, 3, 0x2D, entFlags[ENT_LEVEL4A]|RRF_DAMAGE, 4, 3);
			Randomizer_AddRoom(randVars, 4, 0x25, entFlags[ENT_LEVEL5]|RRF_DAMAGE|RRF_CANDLE, 5, 0);
			Randomizer_AddRoom(randVars, 4, 0x49, entFlags[ENT_LEVEL6]|RRF_DAMAGE|RRF_FLIPPERS, 6, 1);
			Randomizer_AddRoom(randVars, 5, 0x24, entFlags[ENT_LEVEL7]|RRF_DAMAGE|RRF_PHASECLOAK, 7, 1);
			Randomizer_AddRoom(randVars, 5, 0x7A, entFlags[ENT_LEVEL8]|RRF_DAMAGE|RRF_BRACELET|RRF_FLIPPERS|RRF_PHASECLOAK, 8, 2);
			Randomizer_AddRoom(randVars, 13, 0x19, entFlags[ENT_LEVEL9]|RRF_DAMAGE|RRF_PHASECLOAK|l9ReqTriforce, 9, 1);
		}
	}
	if(G[G_MODE_CAVESANITY]){
		if(G[G_MODE_ENTRANCE_RANDO]){
			entrandRupeeCaves = true;
		}
		else{
			Randomizer_AddRoom(randVars, 8, 0x07, RRF_DAMAGE, 0, 0);
			Randomizer_AddRoom(randVars, 8, 0x16, RRF_DAMAGE, 0, 0);
			Randomizer_AddRoom(randVars, 8, 0x1D, RRF_BRACELET, 0, 0);
			Randomizer_AddRoom(randVars, 8, 0x26, RRF_DAMAGE, 0, 0);
			Randomizer_AddRoom(randVars, 8, 0x28, RRF_CANDLE, 0, 0);
			Randomizer_AddRoom(randVars, 8, 0x2D, RRF_DAMAGE, 0, 0);
			Randomizer_AddRoom(randVars, 8, 0x3D, 0, 0, 0);
			Randomizer_AddRoom(randVars, 8, 0x43, RRF_DAMAGE, 0, 0);
			Randomizer_AddRoom(randVars, 8, 0x46, RRF_CANDLE, 0, 0);
			Randomizer_AddRoom(randVars, 8, 0x47, RRF_CANDLE, 0, 0);
			Randomizer_AddRoom(randVars, 8, 0x48, RRF_CANDLE, 0, 0);
			Randomizer_AddRoom(randVars, 8, 0x51, RRF_CANDLE, 0, 0);
			Randomizer_AddRoom(randVars, 8, 0x63, RRF_CANDLE, 0, 0);
			Randomizer_AddRoom(randVars, 8, 0x68, RRF_CANDLE, 0, 0);
			Randomizer_AddRoom(randVars, 8, 0x6A, RRF_CANDLE, 0, 0);
			Randomizer_AddRoom(randVars, 8, 0x6B, RRF_CANDLE, 0, 0);
			Randomizer_AddRoom(randVars, 8, 0x76, RRF_DAMAGE, 0, 0);
			Randomizer_AddRoom(randVars, 8, 0x78, RRF_CANDLE, 0, 0);
			Randomizer_AddRoom(randVars, 8, 0x79, RRF_DAMAGE, 0, 0);
			Randomizer_AddRoom(randVars, 8, 0x7B, RRF_DAMAGE, 0, 0);
			Randomizer_AddRoom(randVars, 8, 0x7D, RRF_DAMAGE, 0, 0);
		}
	}
	if(entrandRupeeCaves){
		int erItemRooms = randVars[26];
		int erItemRoomFlags = randVars[27];
		int erCavesanityIDs = randVars[30];
		for(i=0; i<counts[RI_NUMRUPEEENTRANCES]; ++i){
			int dmap = (erItemRooms[i])&0x1FF;
			int map = Game->DMapMap[dmap];
			int scrn = (erItemRooms[i]>>9)&0xFF;
			Randomizer_AddRoom(randVars, map, scrn, entFlags[erCavesanityIDs[i]], Game->DMapLevel[dmap], Randomizer_EntRandKeyReqs(dmap, scrn));
		}
	}
}

//Returns the required number of keys for entrances within dungeons
int Randomizer_EntRandKeyReqs(int dmap, int scrn){
	if(dmap==1)
		return 1;
	else if(dmap==2)
		return 0;
	else if(dmap==3)
		return 1;
	else if(dmap==4){
		if(scrn==0x0B)
			return 5;
		else
			return 3;
	}
	else if(dmap==5)
		return 0;
	else if(dmap==6)
		return 1;
	else if(dmap==7)
		return 1;
	else if(dmap==8)
		return 2;
	else if(dmap==9)
		return 1;
	return 0;
}

const int I_KEY_L1 = 180;
const int I_KEY_L2 = 181;
const int I_KEY_L3 = 182;
const int I_KEY_L4 = 183;
const int I_KEY_L5 = 184;
const int I_KEY_L6 = 185;
const int I_KEY_L7 = 186;
const int I_KEY_L8 = 187;
const int I_KEY_L9 = 188;

int Randomizer_SetKey(int id){
	if(Link->Item[I_SETTING_TRUEKEYS])
		return id;
	return I_KEY;
}

void Randomizer_SetUpItemData(int randVars, int seed){
	
	for(int i=0; i<32768; i++){
		RandomizerLocs[i] = 0;
	}
	
	int swordGroup = RI_NUMDAMAGEITEMS;
	int damagingRingGroup = 0;
	int damagingRingFlags = 0;
	if(G[G_RANDOMIZESTARTINGSWORD]==2){ 
		//Remove 3/4 swords from the pool
		swordGroup = 0;
		damagingRingGroup = RI_NUMDAMAGEITEMS;
		damagingRingFlags = RRF_DAMAGE;
	}
	
	if(G[G_RANDOMIZESTARTINGSWORD]){
		//Sword 1
		Randomizer_AddItem(randVars, I_SWORD1, RRF_DAMAGE, RI_NUMDAMAGEITEMS);
	}
	
	//Swords
	Randomizer_AddItem(randVars, I_SWORD2, RRF_DAMAGE, swordGroup);
	Randomizer_AddItem(randVars, I_SWORD3, RRF_DAMAGE, swordGroup);
	Randomizer_AddItem(randVars, I_SWORD4, RRF_DAMAGE, swordGroup);

	//HCs
	if(G[G_RANDOMIZER_CHOOSEONETYPE]==0||G[G_RANDOMIZER_CHOOSEONETYPE]==3){
		Randomizer_AddItem(randVars, I_CRITPOTION, 0, 0);
		Randomizer_AddItem(randVars, I_CRITPOTION, 0, 0);
		Randomizer_AddItem(randVars, I_CRITPOTION, 0, 0);
		Randomizer_AddItem(randVars, I_CRITPOTION, 0, 0);
	}
	if(G[G_RANDOMIZER_CHOOSEONETYPE]==1){
		Randomizer_AddItem(randVars, I_HEARTCONTAINER, 0, 0);
		Randomizer_AddItem(randVars, I_HEARTCONTAINER, 0, 0);
		Randomizer_AddItem(randVars, I_HEARTCONTAINER, 0, 0);
		Randomizer_AddItem(randVars, I_HEARTCONTAINER, 0, 0);
	}
	if(G[G_RANDOMIZER_CHOOSEONETYPE]==2){
		
		Randomizer_AddItem(randVars, Cond(Q7_srand(seed, 2)==0, I_HEARTCONTAINER, I_CRITPOTION), 0, 0);
		Randomizer_AddItem(randVars, Cond(Q7_srand(seed, 2)==0, I_HEARTCONTAINER, I_CRITPOTION), 0, 0);
		Randomizer_AddItem(randVars, Cond(Q7_srand(seed, 2)==0, I_HEARTCONTAINER, I_CRITPOTION), 0, 0);
		Randomizer_AddItem(randVars, Cond(Q7_srand(seed, 2)==0, I_HEARTCONTAINER, I_CRITPOTION), 0, 0);
	}
	Randomizer_AddItem(randVars, I_HEARTCONTAINER, 0, 0);
	Randomizer_AddItem(randVars, I_HEARTCONTAINER, 0, 0);
	Randomizer_AddItem(randVars, I_HEARTCONTAINER, 0, 0);
	Randomizer_AddItem(randVars, I_HEARTCONTAINER, 0, 0);
	Randomizer_AddItem(randVars, I_HEARTCONTAINER, 0, 0);
	Randomizer_AddItem(randVars, I_HEARTCONTAINER, 0, 0);
	Randomizer_AddItem(randVars, I_HEARTCONTAINER, 0, 0);
	Randomizer_AddItem(randVars, I_HEARTCONTAINER, 0, 0);
	Randomizer_AddItem(randVars, I_HEARTCONTAINER, 0, 0);
	
	//Overworld Items
	Randomizer_AddItem(randVars, I_LETTER, 0, 0);
	Randomizer_AddItem(randVars, I_BRACELET2, RRF_BRACELET, RI_NUMSPECIALITEMS);
	Randomizer_AddItem(randVars, I_CANDLE1, RRF_CANDLE|RRF_DAMAGE, RI_NUMDAMAGEITEMS);
	Randomizer_AddItem(randVars, Cond(G[G_MODE_GIMMICKRINGS], I_RINGBOX, I_SECRETRING), 0, 0);
	Randomizer_AddItem(randVars, I_RING1, 0, 0);
	
	//Dungeon Items
	Randomizer_AddItem(randVars, I_WHISTLE, RRF_WHISTLE, RI_NUMSPECIALITEMS);
	Randomizer_AddItem(randVars, I_BRANG1, 0, 0);
	Randomizer_AddItem(randVars, I_BOW1, RRF_ARROW1, RI_NUMSPECIALITEMS);
	Randomizer_AddItem(randVars, I_ARROW1, RRF_ARROW2, RI_NUMSPECIALITEMS);
	Randomizer_AddItem(randVars, I_BRANG2, 0, 0);
	Randomizer_AddItem(randVars, I_WAND, RRF_DAMAGE|RRF_WAND, RI_NUMDAMAGEITEMS);
	Randomizer_AddItem(randVars, I_BAIT, 0, 0);
	Randomizer_AddItem(randVars, I_FLIPPERS, RRF_FLIPPERS, RI_NUMSPECIALITEMS);
	Randomizer_AddItem(randVars, I_CANDLE2, RRF_CANDLE2|RRF_CANDLE|RRF_DAMAGE, RI_NUMDAMAGEITEMS);
	Randomizer_AddItem(randVars, I_PHASECLOAK, RRF_PHASECLOAK, RI_NUMSPECIALITEMS);
	Randomizer_AddItem(randVars, I_BAIT, 0, 0);
	Randomizer_AddItem(randVars, I_SHIELD3, 0, 0);
	Randomizer_AddItem(randVars, I_REFWANDBOOK, 0, 0);
	Randomizer_AddItem(randVars, I_RING2, 0, 0);
	Randomizer_AddItem(randVars, I_SCRIPTBOOTS, RRF_BOOTS, RI_NUMSPECIALITEMS);
	Randomizer_AddItem(randVars, I_FLIPPERS2, RRF_FLIPPERS, RI_NUMSPECIALITEMS);
	Randomizer_AddItem(randVars, I_CANDLE3, RRF_CANDLE3|RRF_CANDLE2|RRF_CANDLE|RRF_DAMAGE, RI_NUMDAMAGEITEMS);
	Randomizer_AddItem(randVars, I_PHASECLOAK2, RRF_PHASECLOAK|RRF_PHASECLOAK2, RI_NUMSPECIALITEMS);
	Randomizer_AddItem(randVars, I_SHIELD4, 0, 0);
	Randomizer_AddItem(randVars, I_WAND2, RRF_DAMAGE|RRF_WAND, RI_NUMDAMAGEITEMS);
	Randomizer_AddItem(randVars, I_ACCELERATOR, RRF_DAMAGE, RI_NUMDAMAGEITEMS);
	Randomizer_AddItem(randVars, I_BOW2, 0, 0);
	Randomizer_AddItem(randVars, I_ARROW2, RRF_ARROW2, RI_NUMSPECIALITEMS);
	Randomizer_AddItem(randVars, I_BRANG3, 0, 0);
	Randomizer_AddItem(randVars, I_POTION1, 0, 0);
	
	//Bomb Upgrades
	Randomizer_AddItem(randVars, I_BOMBUPGRADE, 0, 0);
	Randomizer_AddItem(randVars, I_BOMBUPGRADE, 0, 0);
	Randomizer_AddItem(randVars, I_BOMBUPGRADE, 0, 0);
	
	if(G[G_RANDOMIZETRIFORCE]){
		Randomizer_AddItem(randVars, I_FAKETRIFORCE, 0, RI_NUMTRIFORCEITEMS);
		Randomizer_AddItem(randVars, I_FAKETRIFORCE, 0, RI_NUMTRIFORCEITEMS);
		Randomizer_AddItem(randVars, I_FAKETRIFORCE, 0, RI_NUMTRIFORCEITEMS);
		Randomizer_AddItem(randVars, I_FAKETRIFORCE, 0, RI_NUMTRIFORCEITEMS);
		Randomizer_AddItem(randVars, I_FAKETRIFORCE, 0, RI_NUMTRIFORCEITEMS);
		Randomizer_AddItem(randVars, I_FAKETRIFORCE, 0, RI_NUMTRIFORCEITEMS);
		Randomizer_AddItem(randVars, I_FAKETRIFORCE, 0, RI_NUMTRIFORCEITEMS);
		Randomizer_AddItem(randVars, I_FAKETRIFORCE, 0, RI_NUMTRIFORCEITEMS);
	}
	
	if(G[G_RANDOMIZETRASH]){
		//--Level 1
		if(G[G_RANDOMIZER_CHOOSEONETYPE]==3){
			Randomizer_AddItem(randVars, I_HEARTCONTAINER, 0, 0);
			Randomizer_AddItem(randVars, I_HEARTCONTAINER, 0, 0);
			Randomizer_AddItem(randVars, I_HEARTCONTAINER, 0, 0);
			Randomizer_AddItem(randVars, I_HEARTCONTAINER, 0, 0);
		}
		else{
			Randomizer_AddItem(randVars, I_BOMB, 0, 0);
			Randomizer_AddItem(randVars, I_RUPEE5, 0, 0);
			Randomizer_AddItem(randVars, I_RUPEE5, 0, 0);
			Randomizer_AddItem(randVars, I_BOMB, 0, 0);
		}
		if(G[G_MODE_GIMMICKRINGS])
			Randomizer_AddItem(randVars, I_SPRING1_HITO, 0, 0);
		else
			Randomizer_AddItem(randVars, I_BOMB, 0, 0);
		
		//--Level 2
		if(G[G_MODE_GIMMICKRINGS])
			Randomizer_AddItem(randVars, I_SPRING2_JACK, 0, 0);
		else
			Randomizer_AddItem(randVars, I_RUPEE5, 0, 0);
		if(G[G_MODE_GIMMICKRINGS])
			Randomizer_AddItem(randVars, I_SPRING3_WILL, 0, 0);
		else
			Randomizer_AddItem(randVars, I_RUPEE5, 0, 0);
		if(G[G_MODE_GIMMICKRINGS])
			Randomizer_AddItem(randVars, I_SPRING4_RHONE, 0, 0);
		else
			Randomizer_AddItem(randVars, I_BOMB, 0, 0);
		if(G[G_MODE_GIMMICKRINGS])
			Randomizer_AddItem(randVars, I_SPRING5_SEINE, 0, 0);
		else
			Randomizer_AddItem(randVars, I_BOMB, 0, 0);
		if(G[G_MODE_GIMMICKRINGS])
			Randomizer_AddItem(randVars, I_SPRING6_LOIRE, 0, 0);
		else
			Randomizer_AddItem(randVars, I_RUPEE5, 0, 0);
		if(G[G_MODE_GIMMICKRINGS])
			Randomizer_AddItem(randVars, I_SPRING7_NAIYA, 0, 0);
		else
			Randomizer_AddItem(randVars, I_RUPEE5, 0, 0);
		
		//--Level 3
		if(G[G_MODE_GIMMICKRINGS])
			Randomizer_AddItem(randVars, I_SPRING8_TYRE, 0, 0);
		else
			Randomizer_AddItem(randVars, I_BOMB, 0, 0);
		if(G[G_MODE_GIMMICKRINGS])
			Randomizer_AddItem(randVars, I_SPRING9_JANDRA, 0, 0);
		else
			Randomizer_AddItem(randVars, I_RUPEE5, 0, 0);
		if(G[G_MODE_GIMMICKRINGS])
			Randomizer_AddItem(randVars, I_SPRING10_HOLM, 0, 0);
		else
			Randomizer_AddItem(randVars, I_BOMB, 0, 0);
		if(G[G_MODE_GIMMICKRINGS])
			Randomizer_AddItem(randVars, I_SPRING11_MIRR, 0, 0);
		else
			Randomizer_AddItem(randVars, I_RUPEE5, 0, 0);
		if(G[G_MODE_GIMMICKRINGS])
			Randomizer_AddItem(randVars, I_SPRING12_HART, 0, 0);
		else
			Randomizer_AddItem(randVars, I_RUPEE5, 0, 0);
		
		//--Level 4
		if(G[G_MODE_GIMMICKRINGS])
			Randomizer_AddItem(randVars, I_SPRING13_FLECT, 0, 0);
		else
			Randomizer_AddItem(randVars, I_RUPEE5, 0, 0);
		if(G[G_MODE_GIMMICKRINGS])
			Randomizer_AddItem(randVars, I_SPRING14_VANICE, damagingRingFlags, damagingRingGroup);
		else
			Randomizer_AddItem(randVars, I_BOMB, 0, 0);
		if(G[G_MODE_GIMMICKRINGS])
			Randomizer_AddItem(randVars, I_SPRING15_ZARATH, 0, 0);
		else
			Randomizer_AddItem(randVars, I_RUPEE5, 0, 0);
		if(G[G_MODE_GIMMICKRINGS])
			Randomizer_AddItem(randVars, I_SPRING16_AUTIMECIA, 0, 0);
		else
			Randomizer_AddItem(randVars, I_RUPEE5, 0, 0);
		if(G[G_MODE_GIMMICKRINGS])
			Randomizer_AddItem(randVars, I_SPRING17_REDTEAR, 0, 0);
		else
			Randomizer_AddItem(randVars, I_RUPEE5, 0, 0);
		if(G[G_MODE_GIMMICKRINGS])
			Randomizer_AddItem(randVars, I_SPRING18_BLUETEAR, 0, 0);
		else
			Randomizer_AddItem(randVars, I_BOMB, 0, 0);
		
		//--Level 5
		if(G[G_MODE_GIMMICKRINGS])
			Randomizer_AddItem(randVars, I_SPRING19_WALLMASTER, 0, 0);
		else
			Randomizer_AddItem(randVars, I_RUPEE5, 0, 0);
		if(G[G_MODE_GIMMICKRINGS])
			Randomizer_AddItem(randVars, I_SPRING20_GAMBLE, 0, 0);
		else
			Randomizer_AddItem(randVars, I_BOMB, 0, 0);
		if(G[G_MODE_GIMMICKRINGS])
			Randomizer_AddItem(randVars, I_SPRING21_STARVATION, 0, 0);
		else
			Randomizer_AddItem(randVars, I_BOMB, 0, 0);
		if(G[G_MODE_GIMMICKRINGS])
			Randomizer_AddItem(randVars, I_SPRING22_SOARING, 0, 0);
		else
			Randomizer_AddItem(randVars, I_BOMB, 0, 0);
		if(G[G_MODE_GIMMICKRINGS])
			Randomizer_AddItem(randVars, I_SPRING23_HEART, 0, 0);
		else
			Randomizer_AddItem(randVars, I_RUPEE5, 0, 0);
		if(G[G_MODE_GIMMICKRINGS])
			Randomizer_AddItem(randVars, I_SPRING24_BOMB, 0, 0);
		else
			Randomizer_AddItem(randVars, I_RUPEE5, 0, 0);
		
		//--Level 6
		if(G[G_MODE_GIMMICKRINGS])
			Randomizer_AddItem(randVars, I_SPRING25_WILLARD, 0, 0);
		else
			Randomizer_AddItem(randVars, I_RUPEE5, 0, 0);
		if(G[G_MODE_GIMMICKRINGS])
			Randomizer_AddItem(randVars, I_SPRING26_RAINY, 0, 0);
		else
			Randomizer_AddItem(randVars, I_RUPEE5, 0, 0);
		if(G[G_MODE_GIMMICKRINGS])
			Randomizer_AddItem(randVars, I_SPRING27_POTION, 0, 0);
		else
			Randomizer_AddItem(randVars, I_BOMB, 0, 0);
		if(G[G_MODE_GIMMICKRINGS])
			Randomizer_AddItem(randVars, I_SPRING28_ACCEL, 0, 0);
		else
			Randomizer_AddItem(randVars, I_RUPEE5, 0, 0);
		if(G[G_MODE_GIMMICKRINGS])
			Randomizer_AddItem(randVars, I_SPRING29_BRANG, 0, 0);
		else
			Randomizer_AddItem(randVars, I_BOMB, 0, 0);
		if(G[G_MODE_GIMMICKRINGS])
			Randomizer_AddItem(randVars, I_SPRING30_CALAMITY, 0, 0);
		else
			Randomizer_AddItem(randVars, I_RUPEE5, 0, 0);
		
		//--Level 7
		Randomizer_AddItem(randVars, I_RUPEE5, 0, 0);
		Randomizer_AddItem(randVars, I_RUPEE5, 0, 0);
		Randomizer_AddItem(randVars, I_BOMB, 0, 0);
		Randomizer_AddItem(randVars, I_RUPEE5, 0, 0);
		Randomizer_AddItem(randVars, I_RUPEE5, 0, 0);
		Randomizer_AddItem(randVars, I_BOMB, 0, 0);
		
		//--Level 8
		Randomizer_AddItem(randVars, I_RUPEE5, 0, 0);
		Randomizer_AddItem(randVars, I_RUPEE5, 0, 0);
		Randomizer_AddItem(randVars, I_BOMB, 0, 0);
		Randomizer_AddItem(randVars, I_RUPEE5, 0, 0);
		Randomizer_AddItem(randVars, I_RUPEE5, 0, 0);
		Randomizer_AddItem(randVars, I_BOMB, 0, 0);
		
		//--Level 9
		Randomizer_AddItem(randVars, I_RUPEE5, 0, 0);
	}

	if(G[G_MODE_KEYSANITY]){
		//--Level 1 - 5 Locks
		Randomizer_AddItem(randVars, I_KEY_L1, 0, RI_NUMKEYITEMS);
		Randomizer_AddItem(randVars, I_KEY_L1, 0, RI_NUMKEYITEMS);
		Randomizer_AddItem(randVars, I_KEY_L1, 0, RI_NUMKEYITEMS);
		Randomizer_AddItem(randVars, I_KEY_L1, 0, RI_NUMKEYITEMS);
		Randomizer_AddItem(randVars, I_KEY_L1, 0, RI_NUMKEYITEMS);
		//--Level 2 - 4 Locks
		Randomizer_AddItem(randVars, I_KEY_L2, 0, RI_NUMKEYITEMS);
		Randomizer_AddItem(randVars, I_KEY_L2, 0, RI_NUMKEYITEMS);
		Randomizer_AddItem(randVars, I_KEY_L2, 0, RI_NUMKEYITEMS);
		Randomizer_AddItem(randVars, I_KEY_L2, 0, RI_NUMKEYITEMS);
		//--Level 3 - 5 Locks
		Randomizer_AddItem(randVars, I_KEY_L3, 0, RI_NUMKEYITEMS);
		Randomizer_AddItem(randVars, I_KEY_L3, 0, RI_NUMKEYITEMS);
		Randomizer_AddItem(randVars, I_KEY_L3, 0, RI_NUMKEYITEMS);
		Randomizer_AddItem(randVars, I_KEY_L3, 0, RI_NUMKEYITEMS);
		Randomizer_AddItem(randVars, I_KEY_L3, 0, RI_NUMKEYITEMS);
		//--Level 4 - 6 Locks
		Randomizer_AddItem(randVars, I_KEY_L4, 0, RI_NUMKEYITEMS);
		Randomizer_AddItem(randVars, I_KEY_L4, 0, RI_NUMKEYITEMS);
		Randomizer_AddItem(randVars, I_KEY_L4, 0, RI_NUMKEYITEMS);
		Randomizer_AddItem(randVars, I_KEY_L4, 0, RI_NUMKEYITEMS);
		Randomizer_AddItem(randVars, I_KEY_L4, 0, RI_NUMKEYITEMS);
		Randomizer_AddItem(randVars, I_KEY_L4, 0, RI_NUMKEYITEMS);
		Randomizer_AddItem(randVars, I_KEY_L4, 0, RI_NUMKEYITEMS);
		//--Level 5 - 5 Locks
		Randomizer_AddItem(randVars, I_KEY_L5, 0, RI_NUMKEYITEMS);
		Randomizer_AddItem(randVars, I_KEY_L5, 0, RI_NUMKEYITEMS);
		Randomizer_AddItem(randVars, I_KEY_L5, 0, RI_NUMKEYITEMS);
		Randomizer_AddItem(randVars, I_KEY_L5, 0, RI_NUMKEYITEMS);
		Randomizer_AddItem(randVars, I_KEY_L5, 0, RI_NUMKEYITEMS);
		//--Level 6- 3 Locks
		Randomizer_AddItem(randVars, I_KEY_L6, 0, RI_NUMKEYITEMS);
		Randomizer_AddItem(randVars, I_KEY_L6, 0, RI_NUMKEYITEMS);
		Randomizer_AddItem(randVars, I_KEY_L6, 0, RI_NUMKEYITEMS);
		//--Level 7 - 7 Locks
		Randomizer_AddItem(randVars, I_KEY_L7, 0, RI_NUMKEYITEMS);
		Randomizer_AddItem(randVars, I_KEY_L7, 0, RI_NUMKEYITEMS);
		Randomizer_AddItem(randVars, I_KEY_L7, 0, RI_NUMKEYITEMS);
		Randomizer_AddItem(randVars, I_KEY_L7, 0, RI_NUMKEYITEMS);
		Randomizer_AddItem(randVars, I_KEY_L7, 0, RI_NUMKEYITEMS);
		Randomizer_AddItem(randVars, I_KEY_L7, 0, RI_NUMKEYITEMS);
		Randomizer_AddItem(randVars, I_KEY_L7, 0, RI_NUMKEYITEMS);
		//--Level 8 - 5 Locks
		Randomizer_AddItem(randVars, I_KEY_L8, 0, RI_NUMKEYITEMS);
		Randomizer_AddItem(randVars, I_KEY_L8, 0, RI_NUMKEYITEMS);
		Randomizer_AddItem(randVars, I_KEY_L8, 0, RI_NUMKEYITEMS);
		Randomizer_AddItem(randVars, I_KEY_L8, 0, RI_NUMKEYITEMS);
		Randomizer_AddItem(randVars, I_KEY_L8, 0, RI_NUMKEYITEMS);
		//--Level 9 - 13 Locks
		//Floor 1 - 4 Locks
		Randomizer_AddItem(randVars, I_KEY_L9, 0, RI_NUMKEYITEMS);
		Randomizer_AddItem(randVars, I_KEY_L9, 0, RI_NUMKEYITEMS);
		Randomizer_AddItem(randVars, I_KEY_L9, 0, RI_NUMKEYITEMS);
		Randomizer_AddItem(randVars, I_KEY_L9, 0, RI_NUMKEYITEMS);
		//Floor 2 - 3 Locks
		Randomizer_AddItem(randVars, I_KEY_L9, 0, RI_NUMKEYITEMS);
		Randomizer_AddItem(randVars, I_KEY_L9, 0, RI_NUMKEYITEMS);
		//Floor 3 - 1 Lock
		Randomizer_AddItem(randVars, I_KEY_L9, 0, RI_NUMKEYITEMS);
		Randomizer_AddItem(randVars, I_KEY_L9, 0, RI_NUMKEYITEMS);
		//Floor 4 - 1 Lock
		Randomizer_AddItem(randVars, I_KEY_L9, 0, RI_NUMKEYITEMS);
		Randomizer_AddItem(randVars, I_KEY_L9, 0, RI_NUMKEYITEMS);
		//Floor 5 - 3 Locks
		Randomizer_AddItem(randVars, I_KEY_L9, 0, RI_NUMKEYITEMS);
		Randomizer_AddItem(randVars, I_KEY_L9, 0, RI_NUMKEYITEMS);
		//Floor 6 - 1 Lock
		Randomizer_AddItem(randVars, I_KEY_L9, 0, RI_NUMKEYITEMS);
		Randomizer_AddItem(randVars, I_KEY_L9, 0, RI_NUMKEYITEMS);
	}

	if(G[G_MODE_RANDOMIZEMUMPUS]){
		Randomizer_AddItem(randVars, I_RUPEE5, 0, RI_NUMGARBAGEITEMS);
		Randomizer_AddItem(randVars, I_BOMB, 0, RI_NUMGARBAGEITEMS);
		Randomizer_AddItem(randVars, I_RUPEE5, 0, RI_NUMGARBAGEITEMS);
		Randomizer_AddItem(randVars, I_BOMB, 0, RI_NUMGARBAGEITEMS);
		Randomizer_AddItem(randVars, I_RUPEE5, 0, RI_NUMGARBAGEITEMS);
		Randomizer_AddItem(randVars, I_BOMB, 0, RI_NUMGARBAGEITEMS);
		Randomizer_AddItem(randVars, I_RUPEE5, 0, RI_NUMGARBAGEITEMS);
		Randomizer_AddItem(randVars, I_BOMB, 0, RI_NUMGARBAGEITEMS);
		Randomizer_AddItem(randVars, I_RUPEE5, 0, RI_NUMGARBAGEITEMS);
		Randomizer_AddItem(randVars, I_BOMB, 0, RI_NUMGARBAGEITEMS);
		Randomizer_AddItem(randVars, I_RUPEE5, 0, RI_NUMGARBAGEITEMS);
		Randomizer_AddItem(randVars, I_BOMB, 0, RI_NUMGARBAGEITEMS);
		Randomizer_AddItem(randVars, I_RUPEE5, 0, RI_NUMGARBAGEITEMS);
		Randomizer_AddItem(randVars, I_BOMB, 0, RI_NUMGARBAGEITEMS);
		Randomizer_AddItem(randVars, I_RUPEE5, 0, RI_NUMGARBAGEITEMS);
		Randomizer_AddItem(randVars, I_BOMB, 0, RI_NUMGARBAGEITEMS);
		Randomizer_AddItem(randVars, I_RUPEE5, 0, RI_NUMGARBAGEITEMS);
		Randomizer_AddItem(randVars, I_BOMB, 0, RI_NUMGARBAGEITEMS);
	}
	
	if(G[G_MODE_DUNGEONCEPTION]){
		Randomizer_AddItem(randVars, I_RUPEE5, 0, RI_NUMGARBAGEITEMS);
		Randomizer_AddItem(randVars, I_RUPEE5, 0, RI_NUMGARBAGEITEMS);
		Randomizer_AddItem(randVars, I_RUPEE5, 0, RI_NUMGARBAGEITEMS);
		Randomizer_AddItem(randVars, I_RUPEE5, 0, RI_NUMGARBAGEITEMS);
		Randomizer_AddItem(randVars, I_RUPEE5, 0, RI_NUMGARBAGEITEMS);
		Randomizer_AddItem(randVars, I_RUPEE5, 0, RI_NUMGARBAGEITEMS);
		Randomizer_AddItem(randVars, I_RUPEE5, 0, RI_NUMGARBAGEITEMS);
		Randomizer_AddItem(randVars, I_RUPEE5, 0, RI_NUMGARBAGEITEMS);
		Randomizer_AddItem(randVars, I_RUPEE5, 0, RI_NUMGARBAGEITEMS);
	}
	
	if(G[G_MODE_CAVESANITY]){
		Randomizer_AddItem(randVars, I_SECRETMONEY30, 0, RI_NUMGARBAGEITEMS); //0x07
		Randomizer_AddItem(randVars, I_SECRETMONEY30, 0, RI_NUMGARBAGEITEMS); //0x16
		Randomizer_AddItem(randVars, I_SECRETMONEY30, 0, RI_NUMGARBAGEITEMS); //0x1D
		Randomizer_AddItem(randVars, I_SECRETMONEY20, 0, RI_NUMGARBAGEITEMS); //0x26
		Randomizer_AddItem(randVars, I_SECRETMONEY30, 0, RI_NUMGARBAGEITEMS); //0x28
		Randomizer_AddItem(randVars, I_SECRETMONEY30, 0, RI_NUMGARBAGEITEMS); //0x2D
		Randomizer_AddItem(randVars, I_SECRETMONEY100, 0, RI_NUMGARBAGEITEMS); //0x43
		Randomizer_AddItem(randVars, I_SECRETMONEY10, 0, RI_NUMGARBAGEITEMS); //0x46
		Randomizer_AddItem(randVars, I_SECRETMONEY20, 0, RI_NUMGARBAGEITEMS); //0x47
		Randomizer_AddItem(randVars, I_SECRETMONEY10, 0, RI_NUMGARBAGEITEMS); //0x48
		Randomizer_AddItem(randVars, I_RUPEE5, 0, RI_NUMGARBAGEITEMS); //0x68
		Randomizer_AddItem(randVars, I_SECRETMONEY30, 0, RI_NUMGARBAGEITEMS); //0x6A
		Randomizer_AddItem(randVars, I_SECRETMONEY10, 0, RI_NUMGARBAGEITEMS); //0x6B
		Randomizer_AddItem(randVars, I_SECRETMONEY20, 0, RI_NUMGARBAGEITEMS); //0x76
		Randomizer_AddItem(randVars, I_SECRETMONEY10, 0, RI_NUMGARBAGEITEMS); //0x78
		Randomizer_AddItem(randVars, I_SECRETMONEY30, 0, RI_NUMGARBAGEITEMS); //0x79
		
		Randomizer_AddItem(randVars, I_RUPOOR50, 0, RI_NUMGARBAGEITEMS); //0x3D
		Randomizer_AddItem(randVars, I_RUPOOR10, 0, RI_NUMGARBAGEITEMS); //0x51
		Randomizer_AddItem(randVars, I_RUPOOR20, 0, RI_NUMGARBAGEITEMS); //0x63
		Randomizer_AddItem(randVars, I_RUPOOR10, 0, RI_NUMGARBAGEITEMS); //0x7B
		Randomizer_AddItem(randVars, I_RUPOOR30, 0, RI_NUMGARBAGEITEMS); //0x7D
	}
}

void Randomizer_SetUpItemGroups(int itemGroups){
	itemGroups[I_CRITPOTION] = RI_NUMMISCITEMS;
	itemGroups[I_HEARTCONTAINER] = RI_NUMMISCITEMS;
	itemGroups[I_LETTER] = RI_NUMMISCITEMS;
	itemGroups[I_HEARTCONTAINER] = RI_NUMMISCITEMS;
}

int Randomizer_AddRoom(int randVars, int map, int scrn, int reqflags, int level, int reqKeys){
	int counts = randVars[0];
	int roomMaps = randVars[1];
	int roomScreens = randVars[2];
	int roomReqFlags = randVars[3];
	int roomLevels = randVars[4];
	int roomReqKeys = randVars[5];
	int roomMetaLevels = randVars[19];
	
	if(G[G_MODE_NORANDOMIZERLOGIC]){
		reqflags = 0;
	}
	
	roomMaps[counts[RI_NUMROOMS]] = map;
	roomScreens[counts[RI_NUMROOMS]] = scrn;
	roomReqFlags[counts[RI_NUMROOMS]] = reqflags;
	roomLevels[counts[RI_NUMROOMS]] = level;
	roomReqKeys[counts[RI_NUMROOMS]] = reqKeys;
	roomMetaLevels[counts[RI_NUMROOMS]] = level;
	++counts[RI_NUMROOMS];
	return counts[RI_NUMROOMS]-1;
}

void Randomizer_AddItem(int randVars, int itemID, int itemFlagset, int itemGroup){
	int counts = randVars[0];
	int generalItems = randVars[7];
	int itemFlags = randVars[8];
	int damageItems = randVars[9];
	int specialItems = randVars[10];
	int triforceItems = randVars[11];
	int garbageItems = randVars[12];
	int miscItems = randVars[13];
	int itemGroups = randVars[18];
	int keyItems = randVars[20];
	
	if(G[G_MODE_RUPOORGARBAGE]){
		if(itemID==I_RUPEE5)
			itemID = I_RUPOOR10;
		if(itemID==I_BOMB)
			itemID = I_RUPOOR10;
	}
	// for(int i=0; i<32768; i++){
		// RandomizerLocs[i] = 0;
	// }
	
	generalItems[counts[RI_NUMITEMS]] = itemID;
	itemFlags[counts[RI_NUMITEMS]] = itemFlagset;
	
	if(itemGroup==RI_NUMDAMAGEITEMS){
		itemGroups[itemID] = RI_NUMDAMAGEITEMS;
		damageItems[counts[RI_NUMDAMAGEITEMS]] = counts[RI_NUMITEMS];
		++counts[RI_NUMDAMAGEITEMS];
	}
	else if(itemGroup==RI_NUMSPECIALITEMS){
		itemGroups[itemID] = RI_NUMSPECIALITEMS;
		specialItems[counts[RI_NUMSPECIALITEMS]] = counts[RI_NUMITEMS];
		++counts[RI_NUMSPECIALITEMS];
	}
	else if(itemGroup==RI_NUMTRIFORCEITEMS){
		itemGroups[itemID] = RI_NUMTRIFORCEITEMS;
		triforceItems[counts[RI_NUMTRIFORCEITEMS]] = counts[RI_NUMITEMS];
		++counts[RI_NUMTRIFORCEITEMS];
	}
	else if(itemGroup==RI_NUMGARBAGEITEMS){
		itemGroups[itemID] = RI_NUMGARBAGEITEMS;
		garbageItems[counts[RI_NUMGARBAGEITEMS]] = counts[RI_NUMITEMS];
		++counts[RI_NUMGARBAGEITEMS];
	}
	else if(itemGroup==RI_NUMKEYITEMS){
		itemGroups[itemID] = RI_NUMKEYITEMS;
		keyItems[counts[RI_NUMKEYITEMS]] = counts[RI_NUMITEMS];
		++counts[RI_NUMKEYITEMS];
	}
	else{
		itemGroups[itemID] = RI_NUMMISCITEMS;
		miscItems[counts[RI_NUMMISCITEMS]] = counts[RI_NUMITEMS];
		++counts[RI_NUMMISCITEMS];
	}
	
	++counts[RI_NUMITEMS];
	++counts[RI_TOTALREMAININGITEMS];
}

void Randomizer_ScrambleDamageItems(int randVars, int seed){
	int counts = randVars[0];
	int damageItems = randVars[9];
	
	int pos1;
	int pos2;
	int saved;
	for(int i=0; i<counts[RI_NUMDAMAGEITEMS]*2; i++){
		if(i==0)
			pos1 = 0;
		else
			pos1 = Q7_srand(seed, counts[RI_NUMDAMAGEITEMS]);
		
		pos2 = Q7_srand(seed, counts[RI_NUMDAMAGEITEMS]);
		
		saved = damageItems[pos2];
		damageItems[pos2] = damageItems[pos1];
		damageItems[pos1] = saved;
	}
}

void Randomizer_ScrambleSpecialItems(int randVars, int seed){
	int counts = randVars[0];
	int specialItems = randVars[10];
	
	int pos1;
	int pos2;
	int saved;
	for(int i=0; i<counts[RI_NUMSPECIALITEMS]*2; i++){
		if(i==0)
			pos1 = 0;
		else
			pos1 = Q7_srand(seed, counts[RI_NUMSPECIALITEMS]);
		pos2 = Q7_srand(seed, counts[RI_NUMSPECIALITEMS]);
		
		saved = specialItems[pos2];
		specialItems[pos2] = specialItems[pos1];
		specialItems[pos1] = saved;
	}
}

void Randomizer_ScrambleKeyItems(int randVars, int seed){
	int counts = randVars[0];
	int keyItems = randVars[20];
	
	int pos1;
	int pos2;
	int saved;
	for(int i=0; i<counts[RI_NUMKEYITEMS]*2; i++){
		if(i==0)
			pos1 = 0;
		else
			pos1 = Q7_srand(seed, counts[RI_NUMKEYITEMS]);
		pos2 = Q7_srand(seed, counts[RI_NUMKEYITEMS]);
		
		saved = keyItems[pos2];
		keyItems[pos2] = keyItems[pos1];
		keyItems[pos1] = saved;
	}
}

void Randomizer_ScrambleGarbageItems(int randVars, int seed){
	int counts = randVars[0];
	int garbageItems = randVars[12];
	
	int pos1;
	int pos2;
	int saved;
	for(int i=0; i<counts[RI_NUMGARBAGEITEMS]*2; i++){
		if(i==0)
			pos1 = 0;
		else
			pos1 = Q7_srand(seed, counts[RI_NUMGARBAGEITEMS]);
		pos2 = Q7_srand(seed, counts[RI_NUMGARBAGEITEMS]);
		
		saved = garbageItems[pos2];
		garbageItems[pos2] = garbageItems[pos1];
		garbageItems[pos1] = saved;
	}
}

bool Randomizer_DoTheThing(int randVars, int seed){
	int currentItemFlags;
	int prevItemFlags;
	
	int counts = randVars[0];
	int generalItems = randVars[7];
	int itemFlags = randVars[8];
	int damageItems = randVars[9];
	int specialItems = randVars[10];
	int triforceItems = randVars[11];
	int garbageItems = randVars[12];
	int miscItems = randVars[13];
	int keyItems = randVars[20];
	
	Randomizer_ScrambleDamageItems(randVars, seed);
	Randomizer_ScrambleSpecialItems(randVars, seed);
	Randomizer_ScrambleGarbageItems(randVars, seed);
	Randomizer_ScrambleKeyItems(randVars, seed);
	
	int damageItemsPlaced;
	int specialItemsPlaced;
	int triforceItemsPlaced;
	int garbageItemsPlaced;
	int keyItemsPlaced;
	int miscItemsPlaced;
	int placementCycle;
	
	Randomizer_DebugTheThingStart(randVars);
	
	if(G[G_RANDOMIZESTARTINGSWORD]==0)
		currentItemFlags |= RRF_DAMAGE;
	
	//If starting cave is randomized to be a damage item, place one there
	if(G[G_RANDOMIZESTARTINGSWORD]==2){
		Randomizer_GetAvailableRooms(randVars, currentItemFlags, prevItemFlags);
		prevItemFlags = currentItemFlags;
		int theRoom = Randomizer_FindRoom(randVars, 6, 0x11);
		currentItemFlags = Randomizer_SetRoomPart2(randVars, seed, currentItemFlags, damageItems[damageItemsPlaced], theRoom);
		
		if(!counts[RI_PLACEMENTERROR])
			++damageItemsPlaced;
	}
	
	while(counts[RI_TOTALREMAININGITEMS]){
		bool skipMisc;
		if(G[G_RANDOMIZETRIFORCE]&&!G[G_RANDOMIZETRASH]&&triforceItemsPlaced<8)
			skipMisc = true;
		
		if(placementCycle==0){
			if(damageItemsPlaced<counts[RI_NUMDAMAGEITEMS]){
				Randomizer_GetAvailableRooms(randVars, currentItemFlags, prevItemFlags);
				prevItemFlags = currentItemFlags;
				currentItemFlags = Randomizer_SetRoom(randVars, seed, currentItemFlags, damageItems[damageItemsPlaced]);
				
				if(!counts[RI_PLACEMENTERROR])
					++damageItemsPlaced;
			}
		}
		else if(placementCycle==1){
			if(specialItemsPlaced<counts[RI_NUMSPECIALITEMS]){
				Randomizer_GetAvailableRooms(randVars, currentItemFlags, prevItemFlags);
				prevItemFlags = currentItemFlags;
				currentItemFlags = Randomizer_SetRoom(randVars, seed, currentItemFlags, specialItems[specialItemsPlaced]);
				
				if(!counts[RI_PLACEMENTERROR])
					++specialItemsPlaced;
			}
			else{
				if(triforceItemsPlaced<counts[RI_NUMTRIFORCEITEMS]){
					Randomizer_GetAvailableRooms(randVars, currentItemFlags, prevItemFlags);
					prevItemFlags = currentItemFlags;
					currentItemFlags = Randomizer_SetRoom(randVars, seed, currentItemFlags, triforceItems[triforceItemsPlaced]);
					
					if(!counts[RI_PLACEMENTERROR])
						++triforceItemsPlaced;
				}
			}
		}
		else if(placementCycle==2){
			if(garbageItemsPlaced<counts[RI_NUMGARBAGEITEMS]){
				Randomizer_GetAvailableRooms(randVars, currentItemFlags, prevItemFlags);
				prevItemFlags = currentItemFlags;
				currentItemFlags = Randomizer_SetRoom(randVars, seed, currentItemFlags, garbageItems[garbageItemsPlaced]);

				if(!counts[RI_PLACEMENTERROR])
					++garbageItemsPlaced;
			}
		}
		else if(placementCycle==3){
			if(keyItemsPlaced<counts[RI_NUMKEYITEMS]){
				Randomizer_GetAvailableRooms(randVars, currentItemFlags, prevItemFlags);
				prevItemFlags = currentItemFlags;
				currentItemFlags = Randomizer_SetRoom(randVars, seed, currentItemFlags, keyItems[keyItemsPlaced]);

				if(!counts[RI_PLACEMENTERROR])
					++keyItemsPlaced;
			}
		}
		else if(placementCycle==4&&!skipMisc){
			if(miscItemsPlaced<counts[RI_NUMMISCITEMS]){
				Randomizer_GetAvailableRooms(randVars, currentItemFlags, prevItemFlags);
				prevItemFlags = currentItemFlags;
				currentItemFlags = Randomizer_SetRoom(randVars, seed, currentItemFlags, miscItems[miscItemsPlaced]);

				if(!counts[RI_PLACEMENTERROR])
					++miscItemsPlaced;
			}
		}
		
		if(counts[RI_PLACEMENTERROR])
			return false;
		
		++placementCycle;
		placementCycle %= 5;
	}

	G[G_AUTIMECIARING] = Q7_srand(seed, 30);
	if(G[G_AUTIMECIARING]==15)
		G[G_AUTIMECIARING] = 14;
	G[G_AUTIMECIARINGID] = Q7_SPRingToID(G[G_AUTIMECIARING]);
	
	G[G_REVOLVERCHAMBER] = 0;
	G[G_REVOLVERDEATHCHAMBER] = Q7_srand(seed, 6);
	
	// int levelKeys = randVars[21];
	// for(int i=1; i<=9; ++i){
		// int str[] = "L%d: %d\n";
		// printf(str, i, levelKeys[i]);
	// }
	
	return true;
}

const int DEBUG_ENTRANCES = 0;
const int DEBUG_RANDOMIZER = 0;
//0 - Off
//1 - Show locations as they unlock
//2 - Show total locations

const int DEBUG_RANDOMIZER_SEEDS = 0;

void Randomizer_DebugTheThingStart(int randVars){
	if(!DEBUG_RANDOMIZER)
		return;
	
	int counts = randVars[0];
	
	int label[] = "\n\n========================== \n=  RANDOMIZER DEBUG LOG  = \n========================== \n\n";
	printf(label);
	int totalItems[] = "Total Items: %i\nTotal Rooms: %i\n\n";
	printf(totalItems, counts[RI_TOTALREMAININGITEMS], counts[RI_NUMROOMS]);
}

void Randomizer_DebugTheThing(int randVars, int itemID, int map, int scrn, int currentFlags, int prevFlags){
	if(!DEBUG_RANDOMIZER)
		return;
	
	int traceNameScreen[] = "Placed Item %s at %s\n";
	itemdata id = Game->LoadItemData(itemID);
	int itemName[2048];
	id->GetName(itemName);
	int screenStr[16];
	GetScreenStr(screenStr, map, scrn);
	printf(traceNameScreen, itemName, screenStr);
	
	int counts = randVars[0];
	int roomMaps = randVars[1];
	int roomScreens = randVars[2];
	int roomReqFlags = randVars[3];
	
	if(currentFlags!=prevFlags){
		if(DEBUG_RANDOMIZER==1){
			int traceScreensAdded[65536] = "Screens Opened: ";
			TraceS(traceScreensAdded);
			TraceNL();
			int scrBuf[512];
			int screensTraced;
			for(int i=0; i<counts[RI_NUMITEMS]; ++i){
				if((roomReqFlags[i]&currentFlags)==roomReqFlags[i]){
					if((roomReqFlags[i]&prevFlags)!=(roomReqFlags[i]&currentFlags)){
						int screenStr[16];
						GetScreenStr(screenStr, roomMaps[i], roomScreens[i]);
						Q7_AppendCharToString(screenStr, ' ');
						Q7_AppendCharToString(screenStr, ' ');
						if(screensTraced<8){
							strcat(scrBuf, screenStr);
							++screensTraced;
						}
						else{
							TraceS(scrBuf);
							TraceNL();
							for(int k=0; k<512; ++k){
								scrBuf[k] = 0;
							}
							screensTraced = 0;
						}
					}
				}
			}
			if(screensTraced){
				TraceS(scrBuf);
			}
			TraceNL();
		}
		else{
			int traceScreensAvailable[65536] = "Available Screens: ";
			TraceS(traceScreensAvailable);
			TraceNL();
			int scrBuf[512];
			int screensTraced;
			for(int i=0; i<counts[RI_NUMITEMS]; ++i){
				if((roomReqFlags[i]&currentFlags)==roomReqFlags[i]){
					if(true){//(roomReqFlags[i]&prevFlags)!=(roomReqFlags[i]&currentFlags)){
						int screenStr[16];
						GetScreenStr(screenStr, roomMaps[i], roomScreens[i]);
						Q7_AppendCharToString(screenStr, ' ');
						Q7_AppendCharToString(screenStr, ' ');
						if(screensTraced<8){
							strcat(scrBuf, screenStr);
							++screensTraced;
						}
						else{
							TraceS(scrBuf);
							TraceNL();
							for(int k=0; k<512; ++k){
								scrBuf[k] = 0;
							}
							screensTraced = 0;
						}
					}
				}
			}
			if(screensTraced){
				TraceS(scrBuf);
			}
			TraceNL();
		}
	}
}

void Randomizer_DebugTriggerFlags(int randVars, int i, int currentFlags){
	if(!DEBUG_RANDOMIZER)
		return;
	
	int roomScreens = randVars[2];
	int roomReqFlags = randVars[3];
	
	int strBin1[17];
	int strBin2[17];
	int strBin3[17];
	BinaryToString(strBin1, currentFlags, 16);
	BinaryToString(strBin2, roomReqFlags[i], 16);
	BinaryToString(strBin3, currentFlags&roomReqFlags[i], 16);
	int traceNameScreen[] = "Flags: %s & %s = %s\n";
	printf(traceNameScreen, strBin1, strBin2, strBin3);
}

void GetScreenStr(int str, int map, int scrn){
	itoa(str, 0, map);
	Q7_AppendCharToString(str, ':');
	int i;
	i = Floor(scrn/16);
	Q7_AppendCharToString(str, Cond(i<10, '0'+i, 'A'+i-10));
	i = scrn%16;
	Q7_AppendCharToString(str, Cond(i<10, '0'+i, 'A'+i-10));
}

void Q7_AppendCharToString(int str, int chr){
	int len = SizeOfArray(str);
	for(int i=0; i<len; ++i){
		if(str[i]==0){
			str[i] = chr;
			return;
		}
	}
}

int Randomizer_FindRoom(int randVars, int theMap, int theScreen){
	int counts = randVars[0];
	int roomMaps = randVars[1];
	int roomScreens = randVars[2];
	for(int i=0; i<counts[RI_NUMROOMS]; i++){
		if(roomMaps[i]==theMap&&roomScreens[i]==theScreen)
			return i;
	}
	return 0;
}

int Randomizer_SetRoom(int randVars, int seed, int currentItemFlags, int whichItem){
	int counts = randVars[0];
	
	if(!counts[RI_NUMAVAILABLEROOMS]){
		int strSeed[] = "0000";
		int i;
		i = Floor(G[G_SEEDX]/16);
		if(i<10)
			strSeed[0] = '0'+i;
		else
			strSeed[0] = 'A'+i-10;
		i = G[G_SEEDX]%16;
		if(i<10)
			strSeed[1] = '0'+i;
		else
			strSeed[1] = 'A'+i-10;
		i = Floor(G[G_SEEDY]/16);
		if(i<10)
			strSeed[2] = '0'+i;
		else
			strSeed[2] = 'A'+i-10;
		i = G[G_SEEDY]%16;
		if(i<10)
			strSeed[3] = '0'+i;
		else
			strSeed[3] = 'A'+i-10;
		int str[] = "Error placing room.\nNum Items:%d\nNum Rooms:%d\nSkipping seed. (%s)\n"; 
		printf(str, counts[RI_NUMITEMS], counts[RI_NUMROOMS], strSeed);
	
		counts[RI_PLACEMENTERROR] = 1;
		return currentItemFlags;
	}
	int availableRooms = randVars[14];
	int newRooms = randVars[15];
	
	int roomPlaced = randVars[6];
	
	int whichRoom;
	if(counts[RI_NUMNEWROOMS]>0&&Q7_srand(seed, 4)==0){
		whichRoom = newRooms[Q7_srand(seed, counts[RI_NUMNEWROOMS])];
		if(roomPlaced[whichRoom])
			whichRoom = availableRooms[Q7_srand(seed, counts[RI_NUMAVAILABLEROOMS])];
	}
	else{
		whichRoom = availableRooms[Q7_srand(seed, counts[RI_NUMAVAILABLEROOMS])];
	}
	return Randomizer_SetRoomPart2(randVars, seed, currentItemFlags, whichItem, whichRoom);
	Trace(9999);
}
int Randomizer_SetRoomPart2(int randVars, int seed, int currentItemFlags, int whichItem, int whichRoom){
	int counts = randVars[0];
	int roomPlaced = randVars[6];
	
	int roomMaps = randVars[1];
	int roomScreens = randVars[2];
	int roomReqFlags = randVars[3];
	int roomLevels = randVars[4];
	int roomReqKeys = randVars[5]; //find me
	int generalItems = randVars[7];
	int itemFlags = randVars[8];
	int roomMetaLevels = randVars[19];
	int levelKeys = randVars[21];
	int oldLevelKeys = randVars[22];
	int prevFlags = currentItemFlags;
	
	Randomizer_DebugTriggerFlags(randVars, whichRoom, currentItemFlags);
	
	currentItemFlags |= itemFlags[whichItem];
	
	int itemID = generalItems[whichItem];
	
	Randomizer_UpdateTriforceCounter(randVars, currentItemFlags, generalItems[whichItem]);
	if(counts[RI_NUMAVAILABLETRIFORCES]>=8)
		currentItemFlags |= RRF_TRIFORCES;
	
	randVars[23] = 0;
	if(itemID>=I_KEY_L1&&itemID<=I_KEY_L9){
		for(int i=1; i<=9; ++i){
			if(levelKeys[i]>oldLevelKeys[i])
				randVars[23] = 1;
			oldLevelKeys[i] = levelKeys[i];
		}
		++levelKeys[itemID-I_KEY_L1+1];
		if(!Link->Item[I_SETTING_TRUEKEYS])
			itemID = I_KEY;
	}
	// if(roomReqKeys[whichRoom]>0){ //find me
		// int str[] = "LOCKED ITEM %d:%X - %d / %d\n";
		// printf(str, roomMaps[whichRoom], roomScreens[whichRoom], roomReqKeys[whichRoom], levelKeys[roomLevels[whichRoom]]);
	// }
	
	Randomizer_SetLoc(roomMaps[whichRoom]*128+roomScreens[whichRoom], itemID, roomLevels[whichRoom], roomMetaLevels[whichRoom], roomReqFlags[whichRoom], roomReqKeys[whichRoom]);
	roomPlaced[whichRoom] = 1;
	
	Randomizer_DebugTheThing(randVars, generalItems[whichItem], roomMaps[whichRoom], roomScreens[whichRoom], currentItemFlags, prevFlags);
	
	--counts[RI_TOTALREMAININGITEMS];
	
	return currentItemFlags;
}

void Randomizer_UpdateTriforceCounter(int randVars, int currentItemFlags, int itemID){
	int counts = randVars[0];
	if(G[G_RANDOMIZETRIFORCE]){
		if(itemID==I_FAKETRIFORCE){
			++counts[RI_NUMAVAILABLETRIFORCES];
		}
	}
	else{
		int triforcesFound = randVars[17];
		int targetFlags;
		
		targetFlags = RRF_DAMAGE|RRF_WHISTLE;
		if(!triforcesFound[0]&&(currentItemFlags&targetFlags)==targetFlags){
			++counts[RI_NUMAVAILABLETRIFORCES];
			triforcesFound[0] = 1;
		}
		
		targetFlags = RRF_DAMAGE|RRF_ARROW;
		if(!triforcesFound[1]&&(currentItemFlags&targetFlags)==targetFlags){
			++counts[RI_NUMAVAILABLETRIFORCES];
			triforcesFound[1] = 1;
		}
		
		targetFlags = RRF_DAMAGE|RRF_WHISTLE;
		if(!triforcesFound[2]&&(currentItemFlags&targetFlags)==targetFlags){
			++counts[RI_NUMAVAILABLETRIFORCES];
			triforcesFound[2] = 1;
		}
		
		targetFlags = RRF_DAMAGE|RRF_FLIPPERS;
		if(!triforcesFound[3]&&(currentItemFlags&targetFlags)==targetFlags){
			++counts[RI_NUMAVAILABLETRIFORCES];
			triforcesFound[3] = 1;
		}
		
		targetFlags = RRF_DAMAGE|RRF_CANDLE2;
		if(!triforcesFound[4]&&(currentItemFlags&targetFlags)==targetFlags){
			++counts[RI_NUMAVAILABLETRIFORCES];
			triforcesFound[4] = 1;
		}
		
		targetFlags = RRF_DAMAGE|RRF_FLIPPERS|RRF_PHASECLOAK;
		if(!triforcesFound[5]&&(currentItemFlags&targetFlags)==targetFlags){
			++counts[RI_NUMAVAILABLETRIFORCES];
			triforcesFound[5] = 1;
		}
		
		targetFlags = RRF_DAMAGE|RRF_PHASECLOAK|RRF_WAND;
		if(!triforcesFound[6]&&(currentItemFlags&targetFlags)==targetFlags){
			++counts[RI_NUMAVAILABLETRIFORCES];
			triforcesFound[6] = 1;
		}
		
		targetFlags = RRF_DAMAGE|RRF_ARROW|RRF_WHISTLE|RRF_FLIPPERS|RRF_BRACELET;
		if(!triforcesFound[7]&&(currentItemFlags&targetFlags)==targetFlags){
			++counts[RI_NUMAVAILABLETRIFORCES];
			triforcesFound[7] = 1;
		}
	}
}

void Randomizer_GetAvailableRooms(int randVars, int currentItemFlags, int prevItemFlags){
	int counts = randVars[0];
	int roomMaps = randVars[1];
	int roomScreens = randVars[2];
	int roomReqFlags = randVars[3];
	int roomLevels = randVars[4];
	int roomReqKeys = randVars[5];
	int roomPlaced = randVars[6];
	int availableRooms = randVars[14];
	int newRooms = randVars[15];
	int roomTriforceReq = randVars[16];
	int levelKeys = randVars[21];
	int oldLevelKeys = randVars[22];
	
	bool keysChanged;
	if(randVars[23]){
		keysChanged = true;
	}
	
	counts[RI_NUMAVAILABLEROOMS] = 0;
	if(currentItemFlags!=prevItemFlags||keysChanged){
		counts[RI_NUMNEWROOMS] = 0;
		for(int i=0; i<counts[RI_NUMROOMS]; i++){
			// Trace(i);
			// TraceBinary(currentItemFlags, 16);
			// TraceBinary(roomReqFlags[i], 16);
			if(!roomPlaced[i]&&(roomReqFlags[i]&currentItemFlags)==roomReqFlags[i]&&counts[RI_NUMAVAILABLETRIFORCES]>=roomTriforceReq[i]&&roomReqKeys[i]<=levelKeys[roomLevels[i]]){
				if((roomReqFlags[i]&prevItemFlags)!=roomReqFlags[i]){
					newRooms[counts[RI_NUMNEWROOMS]] = i;
					++counts[RI_NUMNEWROOMS];
				}
				else if(roomReqKeys[i]<=levelKeys[roomLevels[i]]&&roomReqKeys[i]>oldLevelKeys[roomLevels[i]]){
					newRooms[counts[RI_NUMNEWROOMS]] = i;
					++counts[RI_NUMNEWROOMS];
				}
					
				availableRooms[counts[RI_NUMAVAILABLEROOMS]] = i;
				++counts[RI_NUMAVAILABLEROOMS];
			}
		}	
	}
	else{
		for(int i=0; i<counts[RI_NUMROOMS]; i++){
			// Trace(i);
			// TraceBinary(currentItemFlags, 16);
			// TraceBinary(roomReqFlags[i], 16);
			if(!roomPlaced[i]&&(roomReqFlags[i]&currentItemFlags)==roomReqFlags[i]&&counts[RI_NUMAVAILABLETRIFORCES]>=roomTriforceReq[i]&&roomReqKeys[i]<=levelKeys[roomLevels[i]]){
				availableRooms[counts[RI_NUMAVAILABLEROOMS]] = i;
				++counts[RI_NUMAVAILABLEROOMS];
			}
		}	
	}
}

int Randomizer_GetItemReplacement(int map, int scrn){
	int i = map*128+scrn;
	
	int itemID = Randomizer_GetLocID(i); //RandomizerLocs[i];
	
	if(Q7_CheatEnabled(G_MODE_NORANDOMIZERPROGRESSIVE))
		return itemID;
	
	if(itemID==I_SWORD1||itemID==I_SWORD2||itemID==I_SWORD3||itemID==I_SWORD4){
		if(Link->Item[I_SWORD3])
			return I_SWORD4;
		else if(Link->Item[I_SWORD2])
			return I_SWORD3;
		else if(Link->Item[I_SWORD1])
			return I_SWORD2;
		return I_SWORD1;
	}
	if(itemID==I_FLIPPERS||itemID==I_FLIPPERS2){
		if(Link->Item[I_FLIPPERS])
			return I_FLIPPERS2;
		return I_FLIPPERS;
	}
	if(itemID==I_SHIELD3||itemID==I_SHIELD4){
		if(Link->Item[I_SHIELD3])
			return I_SHIELD4;
		return I_SHIELD3;
	}
	if(itemID==I_RING1||itemID==I_RING2){
		if(Link->Item[I_RING1])
			return I_RING2;
		return I_RING1;
	}
	if(itemID==I_PHASECLOAK||itemID==I_PHASECLOAK2){
		if(Link->Item[I_PHASECLOAK])
			return I_PHASECLOAK2;
		return I_PHASECLOAK;
	}
	if(itemID==I_CANDLE1||itemID==I_CANDLE2||itemID==I_CANDLE3){
		if(Link->Item[I_CANDLE2])
			return I_CANDLE3;
		else if(Link->Item[I_CANDLE1])
			return I_CANDLE2;
		return I_CANDLE1;
	}
	if(itemID==I_ARROW1||itemID==I_ARROW2){
		if(Link->Item[I_ARROW1])
			return I_ARROW2;
		return I_ARROW1;
	}
	if(itemID==I_BRANG1||itemID==I_BRANG2||itemID==I_BRANG3){
		if(Link->Item[I_BRANG2])
			return I_BRANG3;
		else if(Link->Item[I_BRANG1])
			return I_BRANG2;
		return I_BRANG1;
	}
	if(itemID==I_WAND||itemID==I_WAND2){
		if(Link->Item[I_WAND])
			return I_WAND2;
		return I_WAND;
	}
	if(itemID==I_BOW1||itemID==I_BOW2){
		if(Link->Item[I_BOW1])
			return I_BOW2;
		return I_BOW1;
	}
	
	return itemID;
}

int Randomizer_FlagItemVisited(int map, int scrn){
	int i = map*128+scrn;
	Randomizer_SetLocVisited(i);
	
}

//Traces a log of all the 
void ImGonnaCoooooom(bool logitems){
	int strCurSeed[] = "CURRENT SEED: %s \n";
	int strSeed[] = "0000";
	int i;
	i = Floor(G[G_SEEDX]/16);
	if(i<10)
		strSeed[0] = '0'+i;
	else
		strSeed[0] = 'A'+i-10;
	i = G[G_SEEDX]%16;
	if(i<10)
		strSeed[1] = '0'+i;
	else
		strSeed[1] = 'A'+i-10;
	i = Floor(G[G_SEEDY]/16);
	if(i<10)
		strSeed[2] = '0'+i;
	else
		strSeed[2] = 'A'+i-10;
	i = G[G_SEEDY]%16;
	if(i<10)
		strSeed[3] = '0'+i;
	else
		strSeed[3] = 'A'+i-10;
	printf(strCurSeed, strSeed);
	TraceSettings();
	TraceNL();
	if(logitems){
		int itemCount = 0;
		for(int i=0; i<32768; i++){
			if(RandomizerLocs[i]>0){
				itemCount++;
				TraceCoomlet(i, RandomizerLocs[i]&0xFF);
			}
		}
		int totalItems[] = "\nTOTAL ITEMS: %i \n\n";
		printf(totalItems, itemCount);
	}
}

void TraceSettings(){
	int str_randomizeTriforce[512] = "RANDOMIZE HISTORIES: ";
	int str_randomizeGarbage[512] = "RANDOMIZE GARBAGE: ";
	int str_specialRings[512] = "SPECIAL RINGS: ";
	int str_randomizeKeys[512] = "RANDOMIZE KEYS: ";
	int str_randomizeMumpus[512] = "RANDOMIZE MUMPUS: ";
	int str_randomizeCaves[512] = "RANDOMIZE CAVES: ";
	int str_randomizeFirstCave[512] = "RANDOMIZE FIRST CAVE: ";
	int str_randomizeEntrances[512] = "RANDOMIZE ENTRNACES: ";
	int str_chooseOneType[512] = "CHOOSE ONE ITEM: ";
	int str_reqTriforce[512] = "REQUIRE HISTORIES: ";
	int str_startingAccelerator[512] = "STARTING ACCELERATOR: ";
	
	int str_yes[] = "YES";
	int str_no[] = "NO";
	int str_potions[] = "POTIONS";
	int str_hearts[] = "HEARTS";
	int str_both[] = "BOTH";
	int str_random[] = "RANDOM";
	int str_damage[] = "DAMAGE";
	
	int str_start[] = "START";
	int str_end[] = "END";
	
	if(G[G_RANDOMIZETRIFORCE]){
		strcat(str_randomizeTriforce, str_yes);
	}
	else{
		strcat(str_randomizeTriforce, str_no);
	}
	
	if(G[G_RANDOMIZETRASH]){
		strcat(str_randomizeGarbage, str_yes);
	}
	else{
		strcat(str_randomizeGarbage, str_no);
	}
	
	if(G[G_MODE_GIMMICKRINGS]){
		strcat(str_specialRings, str_yes);
	}
	else{
		strcat(str_specialRings, str_no);
	}
	
	if(G[G_MODE_KEYSANITY]){
		strcat(str_randomizeKeys, str_yes);
	}
	else{
		strcat(str_randomizeKeys, str_no);
	}
	
	if(G[G_MODE_RANDOMIZEMUMPUS]){
		strcat(str_randomizeMumpus, str_yes);
	}
	else{
		strcat(str_randomizeMumpus, str_no);
	}
	
	if(G[G_MODE_CAVESANITY]){
		strcat(str_randomizeCaves, str_yes);
	}
	else{
		strcat(str_randomizeCaves, str_no);
	}
	
	if(G[G_RANDOMIZESTARTINGSWORD]==1){
		strcat(str_randomizeFirstCave, str_yes);
	}
	else if(G[G_RANDOMIZESTARTINGSWORD]==2){
		strcat(str_randomizeFirstCave, str_damage);
	}
	else{
		strcat(str_randomizeFirstCave, str_no);
	}
	
	if(G[G_RANDOMIZER_CHOOSEONETYPE]==0){
		strcat(str_chooseOneType, str_hearts);
	}
	else if(G[G_RANDOMIZER_CHOOSEONETYPE]==1){
		strcat(str_chooseOneType, str_potions);
	}
	else if(G[G_RANDOMIZER_CHOOSEONETYPE]==2){
		strcat(str_chooseOneType, str_random);
	}
	else{
		strcat(str_chooseOneType, str_both);
	}
	
	if(G[G_RANDOMIZER_REQTRIFORCE]==0){
		strcat(str_reqTriforce, str_start);
	}
	else if(G[G_RANDOMIZER_CHOOSEONETYPE]==1){
		strcat(str_reqTriforce, str_end);
	}
	else if(G[G_RANDOMIZER_CHOOSEONETYPE]==2){
		strcat(str_reqTriforce, str_no);
	}
	
	if(G[G_L0ACCEL]){
		strcat(str_startingAccelerator, str_yes);
	}
	else{
		strcat(str_startingAccelerator, str_no);
	}
	
	TraceS(str_randomizeTriforce);
	TraceNL();
	TraceS(str_randomizeGarbage);
	TraceNL();
	TraceS(str_specialRings);
	TraceNL();
	TraceS(str_randomizeKeys);
	TraceNL();
	TraceS(str_randomizeKeys);
	TraceNL();
	TraceS(str_randomizeMumpus);
	TraceNL();
	TraceS(str_randomizeCaves);
	TraceNL();
	TraceS(str_randomizeFirstCave);
	TraceNL();
	TraceS(str_randomizeEntrances);
	TraceNL();
	TraceS(str_chooseOneType);
	TraceNL();
	TraceS(str_reqTriforce);
	TraceNL();
}

void TraceCoomlet(int pos, int itemID){
	itemdata id = Game->LoadItemData(itemID);
	int buf[512];
	int scrnstr[] = "00";
	int screenXY[2];
	screenXY[0] = Floor((pos%128)/16);
	screenXY[1] = (pos%128)%16;
	if(screenXY[0]<10)
		scrnstr[0] = '0' + screenXY[0];
	else
		scrnstr[0] = 'A' + screenXY[0]-10;
	if(screenXY[1]<10)
		scrnstr[1] = '0' + screenXY[1];
	else
		scrnstr[1] = 'A' + screenXY[1]-10;
	id->GetName(buf);
	int strItem[512] = "%i:%s - %s\n";
	printf(strItem, Floor(pos/128), scrnstr, buf);
}

//}

ffc script ObnoxiousWallmaster{
	void run(){
		while(true){
			int wallmasterCount;
			for(int i=Screen->NumNPCs(); i>0; i--){
				npc n = Screen->LoadNPC(i);
				if(n->ID==NPC_WALLMASTER){
					wallmasterCount++;
				}
			}
			if(wallmasterCount==0){
				CreateNPCAt(NPC_WALLMASTER, 0, 0);
				CreateNPCAt(NPC_WALLMASTER, 0, 0);
			}
			if(wallmasterCount==1){
				CreateNPCAt(NPC_WALLMASTER, 0, 0);
			}
			Waitframe();
		}
	}
}

ffc script ContextCave{
	void run(){
		while(true){
			Screen->SetSideWarp(0, G[G_SCRIPTPASSAGE_OLDSCREEN], G[G_SCRIPTPASSAGE_OLDDMAP], WT_IWARPBLACKOUT);
			if(Screen->ComboF[0]!=98){
				int oldMap = Game->DMapMap[G[G_SCRIPTPASSAGE_OLDDMAP]];
				int oldScreen = G[G_SCRIPTPASSAGE_OLDSCREEN]+Game->DMapOffset[G[G_SCRIPTPASSAGE_OLDDMAP]];
				Randomizer_FlagItemVisited(oldMap, oldScreen);
			}
			Waitframe();
		}
		//Screen->SetSideWarp(0, G[G_LASTOVERWORLDSCREEN], G[G_LASTOVERWORLDDMAP], WT_IWARPBLACKOUT);
	}
}

ffc script CandleAdventure{
	void run(){
		int i; int j; int k;
		for(i=0; i<176; i++){
			if(Screen->ComboD[i]==300&&Screen->ComboF[i]!=CF_NOENEMY){
				j = Rand(8);
				if(j==DIR_UP)
					j = i-16;
				else if(j==DIR_DOWN)
					j = i+16;
				else if(j==DIR_LEFT)
					j = i-1;
				else if(j==DIR_RIGHT)
					j = i+1;
				else if(j==DIR_LEFTUP)
					j = i-17;
				else if(j==DIR_LEFTDOWN)
					j = i+15;
				else if(j==DIR_RIGHTUP)
					j = i-15;
				else if(j==DIR_RIGHTDOWN)
					j = i+17;
				
				if(Screen->ComboD[j]!=300&&Screen->ComboF[j]!=CF_NOENEMY){
					Screen->ComboD[j] = 300;
					Screen->ComboD[i] = 5;
					Screen->ComboF[i] = 0;
					Screen->ComboF[j] = CF_NOENEMY;
				}
			}
		}
		Waitframe();
		
		if(!Screen->State[ST_ITEM]){
			item candle = CreateItemAt(I_CANDLE1, this->X, this->Y);
			candle->Pickup = IP_ST_ITEM;
			
			for(i=0; i<60; i++){
				WaitNoAction();
			}
			if(!Q7_HasRing(I_SPRING11_MIRR))
				Screen->Lit = false;
			
			this->Flags[FFCF_ETHEREAL] = true;
			
			int Z = 0;
			int jump = 1.6;
			
			while(candle->isValid()){
				this->Vx = VectorX(0.5, Angle(Link->X, Link->Y, this->X, this->Y));
				this->Vy = VectorY(0.5, Angle(Link->X, Link->Y, this->X, this->Y));
				
				this->X = Clamp(this->X, 32, 208);
				this->Y = Clamp(this->Y, 32, 128);
				
				if(this->Vx>this->Vy&&((this->Vx<0&&!CanWalk(this->X, this->Y, DIR_LEFT, 1, true))||(this->Vx>0&&!CanWalk(this->X, this->Y, DIR_RIGHT, 1, true)))){
					this->Vy = Sign(this->Y-Link->Y)*0.5;
				}
				else if(this->Vy>this->Vx&&((this->Vy<0&&!CanWalk(this->X, this->Y, DIR_UP, 1, true))||(this->Vy>0&&!CanWalk(this->X, this->Y, DIR_DOWN, 1, true)))){
					this->Vx = Sign(this->X-Link->X)*0.5;
				}
				
				
				if(Z<=0)
					jump = 1.6;
				Z = Max(Z+jump, 0);
				
				jump -= 0.16;
				
				candle->X = this->X;
				candle->Y = this->Y-Z;
				
				Waitframe();
			}
			Screen->Lit = true;
		}
	}
}

const int SFX_HEALTILE = 22; //SFX when stepping on a scripted healing tile

//Place this script on a screen with flags 7, 92, or 93 and it will make them instant
//D0: If 1, the healing tile will heal Link again if you step off and back on, else it's one time use only
//D1: If 1, the healing tile will reset the guy count of every room in the dungeon when stepped on
ffc script FairyTile{
	void run(int multipleTimes, int resetGuyCount){
		int i;
		int healFlags[176];
		int pos;
		for(i=0; i<176; ++i){
			if(Screen->ComboF[i]==7){
				healFlags[i] = 1;
				Screen->ComboF[i] = 0;
			}
			else if(Screen->ComboF[i]==92){
				healFlags[i] = 2;
				Screen->ComboF[i] = 0;
			}
			else if(Screen->ComboF[i]==93){
				healFlags[i] = 3;
				Screen->ComboF[i] = 0;
			}
		}
		while(true){
			pos = ComboAt(Link->X+8, Link->Y+12);
			if(healFlags[pos]){
				Game->PlaySound(SFX_HEALTILE);
				if(healFlags[pos]==1){
					Link->HP = Link->MaxHP;
				}
				else if(healFlags[pos]==2){
					Link->MP = Link->MaxMP;
				}
				else if(healFlags[pos]==3){
					Link->HP = Link->MaxHP;
					Link->MP = Link->MaxMP;
				}
				if(resetGuyCount){
					for(i=0; i<128; ++i){
						Game->GuyCount[i] = 10;
					}
				}
				if(multipleTimes){
					while(healFlags[pos]){
						pos = ComboAt(Link->X+8, Link->Y+12);
						Waitframe();
					}
				}
				else
					Quit();
			}
			Waitframe();
		}
	}
}

//D0: First of the combos to cycle between
//D1: Last of the combos to cycle between
//D2: Frames between each combo in the cycle
//D3: Set to 1 if the last combo in the cycle should cycle back to the first
//D4: SFX to play when cycling
ffc script LessDumbComboCycling{
	void run(int cmb, int frames, int frate, int loop, int sfx){
		int cmbFrames[176];
		for(int i=0; i<176; i++){
			cmbFrames[i] = -1;
		}
		while(true){
			for(int i=0; i<176; i++){
				int cd = Screen->ComboD[i];
				if(cd>=cmb&&cd<=cmb+frames-1){
					if(cmbFrames[i]==-1){
						cmbFrames[i] = frate;
					}
					else if(cmbFrames[i]>0){
						cmbFrames[i]--;
					}
					else{
						if(cd<cmb+frames-1){
							Screen->ComboD[i]++;
							cmbFrames[i] = frate;
							if(sfx>0)
								Game->PlaySound(sfx);
						}
						else{
							if(loop){
								Screen->ComboD[i] = cmb;
								cmbFrames[i] = frate;
								if(sfx>0)
									Game->PlaySound(sfx);
							}
						}
					}
				}
				else{
					cmbFrames[i] = -1;
				}
			}
			Waitframe();
		}
	}
}

ffc script OneWayPassageExit{
	void run(int cmb, int frames, int frate){
		int pos = ComboAt(this->X+8, this->Y+8);
		int oldcmb = Screen->ComboD[pos];
		if(Abs(Link->X-this->X)<8&&Abs(Link->Y-this->Y)<8){
			Screen->ComboD[pos] = cmb;
			while(Abs(Link->X-this->X)<8&&Abs(Link->Y-this->Y)<8){
				Waitframe();
			}
			for(int i=1; i<frames; ++i){
				Waitframes(frate);
				Screen->ComboD[pos] = cmb+i;
			}
			Waitframes(frate);
			Screen->ComboD[pos] = oldcmb;
		}
	}
}

void Permadeath_Update(){
	G[G_F6HP] = Link->HP;
	if(Link->HP<=0){
		if(Link->Item[I_SETTING_3HEARTCONTINUE]&&G[G_CONTINUEHP]==5){
			Link->HP = 1;
			G[G_PERMADEATHCOUNTER] = 1;
			Game->LastEntranceDMap = 34;
			Game->LastEntranceScreen = 0x31;
			Game->ContinueDMap = 34;
			Game->ContinueScreen = 0x31;
			Link->Item[I_RING3] = true;
			Game->Save();
		}
	}
	if(G[G_PERMADEATHCOUNTER]){
		if(G[G_PERMADEATHCOUNTER]==1){
			Screen->SetRenderTarget(RT_DOOMPAUL);
			Screen->Rectangle(0, 0, 0, 511, 511, 0x00, 1, 0, 0, 0, true, 128);
			Screen->DrawScreen(0, Game->GetCurMap(), Game->GetCurScreen(), 0, 0, 0);
			Screen->DrawTile(0, Link->X+Link->DrawXOffset, Link->Y+Link->DrawYOffset, Link->Tile, 1, 1, 6, -1, -1, 0, 0, 0, Cond(Link->Dir==DIR_LEFT, 1, 0), true, 128);
			Screen->SetRenderTarget(RT_SCREEN);
			G[G_PERMADEATHCOUNTER] = 2;
			Game->PlayMIDI(0);
			RunFFCScript(FFCS_DOOMPAUL, 0);
		}
		else if(G[G_PERMADEATHCOUNTER]==3){
			G[G_PERMADEATHCOUNTER] = 0;
			Link->Warp(DMAP_DOOMPAUL, SCREEN_DOOMPAUL);
		}
	}
}

const int DMAP_DOOMPAUL = 34;
const int SCREEN_DOOMPAUL = 0x30;

const int RT_DOOMPAUL = 5;

const int FFCS_DOOMPAUL = 122;

ffc script DoomPaul{
	void run(int sp){
		int i; int j; int k;
		int op;
		int x; int y;
		
		int doom1[] = "WHY DIDN'T YOU STOP IT?";
		int doom2[] = "YOU COULD HAVE PREVENTED THIS.";
		int doom3[] = "IT'S TOO LATE TO TURN BACK NOW.";
		int doom4[] = "YOU'RE DEAD. IT'S OVER.";
		int doom5[] = "AS IS YOUR GAME.";
		int dooms[] = {doom1, doom2, doom3, doom4, doom5};
		
		int scanY[256];
		int scanStep[256];
		int scanH[256];
		int scanDelay[256];
		int numLeft = 1;
		
		if(sp==0)
			Game->PlaySound(130);
		else
			Game->PlaySound(131);
		for(i=0; i<256; ++i){
			scanStep[i] = Rand(100, 150)/100;
			scanH[i] = 176;
			scanDelay[i] = Rand(16);
		}
		i = Rand(256);
		scanStep[i] = 1;
		scanDelay[i] = 15;
		while(numLeft){
			numLeft = 0;
			if(sp==0){
				for(i=Screen->NumNPCs(); i>0; --i){
					npc n = Screen->LoadNPC(i);
					n->Stun = 10;
				}
				Link->CollDetection = false;
				Screen->ClearSprites(SL_EWPNS);
				Screen->ClearSprites(SL_LWPNS);
				Screen->ClearSprites(SL_ITEMS);
				Screen->Rectangle(6, 0, 0, 255, 175, 0x0F, 1, 0, 0, 0, true, 128);
			}
			for(i=0; i<256; ++i){
				if(scanY[i]<176){
					if(scanDelay[i]>0)
						--scanDelay[i];
					else{
						scanY[i] += scanStep[i];
						scanH[i] += scanStep[i]*5;
					}
					Screen->DrawBitmap(6, RT_DOOMPAUL, i, 0, 1, 176, i, scanY[i], 1, scanH[i], 0, false);
					++numLeft;
				}
			}
			WaitNoAction();
		}
		if(sp==0){
			Screen->SetRenderTarget(RT_DOOMPAUL);
			Screen->Rectangle(0, 0, 0, 511, 511, 0x0F, 1, 0, 0, 0, true, 128);
			Screen->SetRenderTarget(RT_SCREEN);
			Screen->Rectangle(6, 0, 0, 255, 175, 0x0F, 1, 0, 0, 0, true, 128);
			WaitNoAction();
			G[G_PERMADEATHCOUNTER] = 3;
			Quit();
		}
		else{
			Link->Item[I_RING3] = true;
			for(k=0; k<5; ++k){
				for(i=0; i<48; ++i){
					op = 128;
					if(i<32)
						op = 64;
					for(j=0; j<5; ++j){
						x = 8+8*j;
						y = 8+24*j;
						if(j<k){
							Q7_DrawStringOutline(6, x, y, FONT_Z3, 0x81, 0x0F, TF_NORMAL, dooms[j], 128);
						}
						else if(j==k){
							Q7_DrawStringOutline(6, x, y+16-(i/3), FONT_Z3, 0x81, 0x0F, TF_NORMAL, dooms[j], op);
						}
					}
					WaitNoAction();
				}
				for(i=0; i<64; ++i){
					for(j=0; j<5; ++j){
						x = 8+8*j;
						y = 8+24*j;
						if(j<=k){
							Q7_DrawStringOutline(6, x, y, FONT_Z3, 0x81, 0x0F, TF_NORMAL, dooms[j], 128);
						}
					}
					WaitNoAction();
				}
			}
			for(i=0; i<128; ++i){
				for(j=0; j<5; ++j){
					x = 8+8*j;
					y = 8+24*j;
					Q7_DrawStringOutline(6, x, y, FONT_Z3, 0x81, 0x0F, TF_NORMAL, dooms[j], 128);
				}
				WaitNoAction();
			}
			Game->Save();
			for(j=0; j<5; ++j){
				x = 8+8*j;
				y = 8+24*j;
				Q7_DrawStringOutline(6, x, y, FONT_Z3, 0x81, 0x0F, TF_NORMAL, dooms[j], 128);
			}
			Game->End();
		}
	}
}

const int FFCS_BUBBLESHIELD = 124;
const int TIL_BUBBLSHIELD = 8960;
const int SFX_BUBBLEPOP = 55;

ffc script BubbleShield{
	void run(){
		int LinkHP = Link->HP;
		int aCounter;
		while(true){
			if(Link->HP<LinkHP){
				Game->PlaySound(SFX_BUBBLEPOP);
				Link->HP = LinkHP;
				Quit();
			}
			++aCounter;
			aCounter%=360;
			int w = 28+4*Sin(aCounter*4);
			int h = 28+4*Cos(aCounter*4);
			Screen->DrawTile(4, Link->X+8-w*0.5, Link->Y+8-h*0.5, TIL_BUBBLSHIELD, 2, 2, 10, w, h, 0, 0, 0, 0, true, 64);
			Waitframe();
		}
	}
}

const int FFCS_SHOCKWAVES = 125;

ffc script Shockwaves{
	void run(int x, int y, int chainMax){
		int i; int j;
		int tmpx; int tmpy;
		for(i=0; i<56; i+=8){
			for(j=0; j<8; ++j){
				Screen->Circle(6, x+8, y+8, i+j*2, Rand(0x81, 0x83), 1, 0, 0, 0, false, 128);
			}
			for(j=Screen->NumNPCs(); j>0; --j){
				npc n = Screen->LoadNPC(j);
				if(n->CollDetection){
					tmpx = CenterX(n);
					tmpy = CenterY(n);
					if(tmpx>0&&tmpx<240&&tmpy>0&&tmpy<160){
						if(n->Defense[NPCD_BOMB]==NPCDT_NONE||n->Defense[NPCD_BOMB]==NPCDT_HALFDAMAGE||n->Defense[NPCD_BOMB]==NPCDT_QUARTERDAMAGE||n->Defense[NPCD_BOMB]==NPCDT_ONEHITKILL){
							int dist = Distance(x, y, tmpx, tmpy);
							if(dist>=i&&dist<i+8){
								lweapon boom = CreateLWeaponAt(LW_BOMBBLAST, tmpx-8, tmpy-8);
								boom->Damage = 8*G[G_HPSCALE];
								boom->Dir = -1;
								boom->Misc[LWM_RINGMODS] = chainMax-1;
							}
						}
					}
				}
			}
			Waitframe();
		}
	}
}

const int FFCS_GASBALL = 126;

const int CMB_GASBALL = 700;

const int SFX_GASBALL = 114;

ffc script GasBall{
	void run(int x, int y){
		Game->PlaySound(SFX_GASBALL);
		int w; int wHit;
		int op;
		for(int i=0; i<16; ++i){
			w = 80*(i/16);
			wHit = 32*(i/16);
			for(int j=Screen->NumNPCs(); j>0; --j){
				npc n = Screen->LoadNPC(j);
				if(n->CollDetection){
					if(!n->Misc[NPCM_STATUSCOUNTER]&&RectCollision(n->X+n->HitXOffset, n->Y+n->HitYOffset, n->X+n->HitXOffset+n->HitWidth-1, n->Y+n->HitYOffset+n->HitHeight-1, x-wHit, y-wHit, x+wHit, y+wHit)){
						if(GasBall_CanHit(n)){
							if(!n->Misc[NPCM_STATUSCOUNTER]){
								n->Misc[NPCM_STATUSTYPE] = 4;
								n->Misc[NPCM_STATUSCOUNTER] = 60;
							}
						}
					}
				}
			}
			Screen->DrawCombo(4, x-w/2, y-w/2, CMB_GASBALL, 5, 5, 10, w, w, 0, 0, 0, -1, 0, true, 128);
			Waitframe();
		}
		for(int i=0; i<8; ++i){
			Screen->DrawCombo(4, x-40, y-40-0.05*i, CMB_GASBALL, 5, 5, 10, -1, -1, 0, 0, 0, -1, 0, true, 64);
			Waitframe();
		}
	}
	bool GasBall_CanHit(npc n){
		if(n->Defense[NPCD_SWORD]==NPCDT_BLOCK||n->Defense[NPCD_SWORD]==NPCDT_IGNORE)
			return false;
		return true;
	}
}

ffc script AliyaIntroduction{
	void run(){
		Waitframe();
		
		int i;
		int rainEffect[] = "RainEffect";
		int rainEffectSlot = Game->GetFFCScript(rainEffect);
		
		ffc aliya = Screen->LoadFFC(2);
		
		while(Link->Y>136){
			NoAction();
			Link->InputUp = true;
			Waitframe();
		}
		if(!Screen->State[ST_BOSSLOCKBLOCK]){
			Screen->TriggerSecrets();
			
			if(!Screen->State[ST_LOCKBLOCK]){
				WaitNoAction(20);
				
				Screen->Message(222);
				WaitNoAction();
				
				WaitNoAction(20);
				
				aliya->X = 128;
				aliya->Y = 56;
				aliya->CSet = 9;
				
				for(i=0; i<40; ++i){
					if(i%4<2)
						aliya->Data = 2973;
					else
						aliya->Data = 1;
					WaitNoAction();
				}
				
				aliya->Data = 2973;
				
				WaitNoAction(20);
				Screen->Message(223);
				WaitNoAction(20);
				
				aliya->Data = 2972;
				
				for(i=0; i<96; ++i){
					if(i%2==0)
						++aliya->Y;
					WaitNoAction();
				}
				
				aliya->Data = 2973;
				
				WaitNoAction(20);
				
				aliya->Data = 2974;
				WaitNoAction(60);
				aliya->Data = 2975;
				WaitNoAction(60);
				aliya->Data = 2976;
				for(i=0; i<40; ++i){
					if(i<20||i%4<2)
						Screen->FastCombo(4, aliya->X+8+VectorX(i*2, -30), aliya->Y+VectorY(i*2, -30), 2977, 9, 128);
					WaitNoAction();
				}
				aliya->Data = 2978;
				
				WaitNoAction(20);
				
				Screen->Message(228);
				WaitNoAction();
			}
			else{
				aliya->X = 128;
				aliya->Y = 56;
				aliya->CSet = 9;
				aliya->Data = 2978;
			}
			
			this->Flags[FFCF_CARRYOVER] = true;
			aliya->Flags[FFCF_CARRYOVER] = true;
			i = RunFFCScript(rainEffectSlot, 0);
			ffc rain = Screen->LoadFFC(i);
			rain->Flags[FFCF_CARRYOVER] = true;
			rain->Flags[FFCF_PRELOAD] = true;
			
			int bestgirl[] = "BestGirl.nsf";
			Game->PlayEnhancedMusic(bestgirl, 0);
			AssignAliyaMusic(bestgirl, 0);
			
			for(i=0; i<4; ++i){
				Link->PitWarp(39+i, Game->GetCurDMapScreen());
				WaitNoAction();
				Screen->TriggerSecrets();
				WaitNoAction(7);
			}
			
			this->Flags[FFCF_CARRYOVER] = false;
			aliya->Flags[FFCF_CARRYOVER] = false;
			rain->Flags[FFCF_CARRYOVER] = false;
			
			if(!Screen->State[ST_LOCKBLOCK]){
				aliya->Data = 2979;
				WaitNoAction(20);
				aliya->Data = 2976;
				for(i=0; i<24; ++i){
					aliya->Y -= 2;
					WaitNoAction();
				}
			}
			
			Screen->State[ST_LOCKBLOCK] = true;
		}
	}
	void AssignAliyaMusic(int ptr, int track){
		Game->SetDMapEnhancedMusic(38, ptr, track);
		Game->SetDMapEnhancedMusic(39, ptr, track);
		Game->SetDMapEnhancedMusic(40, ptr, track);
		Game->SetDMapEnhancedMusic(41, ptr, track);
		Game->SetDMapEnhancedMusic(42, ptr, track);
	}
}

const int CSM_NUM_CHARS = 18;

ffc script Q7_CharacterSelectMenu{
	void run(){
		int i;
		
		int selectedChar;
		
		int z3small[] = {
			// Character widths, including any trailing space
			// ASCII characters 32 to 126
			
			// sp !  "  #  $  %  &  '  (  )  *  +  ,  -  .  /
			   4, 2, 4, 6, 6, 4, 5, 2, 3, 3, 4, 4, 3, 4, 2, 4,
			
			// 0  1  2  3  4  5  6  7  8  9
			   4, 3, 4, 4, 4, 4, 4, 4, 4, 4,
			
			// :  ;  <  =  >  ?  @
			   2, 2, 4, 4, 4, 4, 6,
			
			// A  B  C  D  E  F  G  H  I  J  K  L  M  N  O  P  Q  R  S  T  U  V  W  X  Y  Z
			   5, 5, 4, 5, 4, 4, 5, 4, 2, 4, 5, 4, 6, 5, 5, 5, 6, 5, 4, 4, 5, 6, 6, 4, 4, 4,
			
			// [  \  ]  ^  _  `
			   4, 4, 4, 4, 4, 4,
			
			// Note: This font's capital and lowercase letters are identical, but
			// ZC spaces some of them differently. This appears to be unintentional,
			// so it is not duplicated here.
			// a  b  c  d  e  f  g  h  i  j  k  l  m  n  o  p  q  r  s  t  u  v  w  x  y  z
			   5, 5, 4, 5, 4, 4, 5, 4, 2, 4, 5, 4, 6, 5, 5, 5, 6, 5, 4, 4, 5, 6, 6, 4, 4, 4,
			
			// {  |  }  ~
			   4, 2, 4, 5,
			
			// Additional characters
			   6, 10, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6,
			   6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6,
			   6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6,
			   6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6,
			   6, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
			   4, 4, 4, 4, 4, 4, 4, 4, 4
		};
		int firstPressDelay = 0;
		bool pressedLeft;
		bool pressedRight;
		
		int charOrder[] = {CHAR_LINK, CHAR_ZELDA, CHAR_ADJEAN, CHAR_BANNON, CHAR_ZARATH, CHAR_KELL, CHAR_RIGGS, CHAR_ALIYA, CHAR_HOLM, CHAR_FROGGER, CHAR_DIMI, CHAR_SILVIO, CHAR_NORA, CHAR_GARDEA, CHAR_ARIA, CHAR_SPURDO, CHAR_MANI, CHAR_ARCANA};
		//int charOrder[] = {CHAR_LINK, CHAR_ZELDA, CHAR_ADJEAN, CHAR_BANNON, CHAR_ZARATH, CHAR_KELL, CHAR_RIGGS, CHAR_ALIYA, CHAR_HOLM, CHAR_SILVIO, CHAR_NORA, CHAR_GARDEA, CHAR_ARIA};
		
		for(i=0; i<30; ++i){
			Screen->Rectangle(7, 0, -56, 255, 175, 0x0F, 1, 0, 0, 0, true, 128);
			Screen->DrawScreen(7, Game->GetCurMap(), Game->GetCurScreen(), 0, -28, 0);
			if(i<10)
				Screen->Rectangle(7, 0, -56, 255, 175, 0x0F, 1, 0, 0, 0, true, 128);
			if(i<20)
				Screen->Rectangle(7, 0, -56, 255, 175, 0x0F, 1, 0, 0, 0, true, 64);
			Screen->Rectangle(7, 0, -56, 255, 175, 0x0F, 1, 0, 0, 0, true, 64);
			NoPause();
			WaitNoAction();
		}
		for(i=0; i<28; ++i){
			Screen->Rectangle(7, 0, -56, 255, 175, 0x0F, 1, 0, 0, 0, true, 128);
			Screen->DrawScreen(7, Game->GetCurMap(), Game->GetCurScreen(), 0, -28+i, 0);
			Screen->DrawScreen(7, 1, 0x12, 0, -28+i-176, 0);
			Screen->Rectangle(7, 0, -56, 255, -28-i, 0x0F, 1, 0, 0, 0, true, 128);
			Screen->Rectangle(7, 0, 176-28+i, 255, 175, 0x0F, 1, 0, 0, 0, true, 128);
			NoPause();
			WaitNoAction();
		}
		while(!Link->PressA&&!Link->PressStart){
			if(Link->InputLeft){
				if(firstPressDelay>0&&pressedLeft){
					--firstPressDelay;
					if(firstPressDelay==0)
						firstPressDelay = -1;
				}
				else{
					if(firstPressDelay==0)
						firstPressDelay = 8;
					for(i=0; i<8; ++i){
						DrawBackground();
						DrawCharWheel(selectedChar, charOrder, 48, 72-8, -(i/8)*45); //Char_Draw(selectedChar, 48, 72, 100);
						Char_DrawStrings(selectedChar, charOrder, z3small);
						NoPause();
						NoAction();
						Waitframe();
					}
					Game->PlaySound(SFX_SELECT);
					--selectedChar;
					if(selectedChar<0)
						selectedChar = CSM_NUM_CHARS-1;
				}
				pressedLeft = true;
			}
			else if(Link->InputRight){
				if(firstPressDelay>0&&pressedRight){
					--firstPressDelay;
					if(firstPressDelay==0)
						firstPressDelay = -1;
				}
				else{
					if(firstPressDelay==0)
						firstPressDelay = 8;
					for(i=0; i<8; ++i){
						DrawBackground();
						DrawCharWheel(selectedChar, charOrder, 48, 72-8, (i/8)*45); //Char_Draw(selectedChar, 48, 72, 100);
						Char_DrawStrings(selectedChar, charOrder, z3small);
						NoPause();
						NoAction();
						Waitframe();
					}
					Game->PlaySound(SFX_SELECT);
					++selectedChar;
					if(selectedChar>CSM_NUM_CHARS-1)
						selectedChar = 0;
				}
				pressedRight = true;
			}
			else{
				if(firstPressDelay<0)
					firstPressDelay = 0;
				pressedLeft = false;
				pressedRight = false;
			}
			
			DrawBackground();
			DrawCharWheel(selectedChar, charOrder, 48, 72-8, 0); //Char_Draw(selectedChar, 48, 72, 100);
			Char_DrawStrings(selectedChar, charOrder, z3small);
			NoPause();
			NoAction();
			Waitframe();
		}
		Game->PlaySound(SFX_CONFIRM);
		for(i=0; i<30; i++){
			DrawBackground();
			DrawCharWheel(selectedChar, charOrder, 48, 72-8, 0); //Char_Draw(selectedChar, 48, 72, 100);
			Char_DrawStrings(selectedChar, charOrder, z3small);
			NoPause();
			WaitNoAction();
		}
		for(i=0; i<30; i++){
			DrawBackground();
			DrawCharWheel(selectedChar, charOrder, 48, 72-8, 0); //Char_Draw(selectedChar, 48, 72, 100);
			Char_DrawStrings(selectedChar, charOrder, z3small);
			
			if(i>=10)
				Screen->Rectangle(6, 0, -56, 255, 175, 0x0F, 1, 0, 0, 0, true, 64);
			if(i>=20)
				Screen->Rectangle(6, 0, -56, 255, 175, 0x0F, 1, 0, 0, 0, true, 128);
			Screen->Rectangle(6, 0, -56, 255, 175, 0x0F, 1, 0, 0, 0, true, 64);
			
			NoPause();
			WaitNoAction();
		}
		G[G_ALTCHARACTER] = charOrder[selectedChar];
		AltCharacter_Init();
		G[G_MANISTARFALLCHARGE] = -1;
		Q7_StartGame(this);
	}
	void DrawBackground(){
		Screen->DrawScreen(7, Game->GetCurMap(), Game->GetCurScreen(), 0, 0, 0);
		Screen->DrawScreen(7, 1, 0x12, 0, -176, 0);
	}
	void DrawCharWheel(int whichChar, int charOrder, int x, int y, int ang){
		y -= 28;
		int i; int j;
		int chars[7];
		int c = whichChar;
		chars[3] = charOrder[c];
		for(i=0; i<3; ++i){
			--c;
			if(c<0)
				c = CSM_NUM_CHARS-1;
			chars[2-i] = charOrder[c];
		}
		c = whichChar;
		for(i=0; i<3; ++i){
			++c;
			if(c>CSM_NUM_CHARS-1)
				c = 0;
			chars[4+i] = charOrder[c];
		}
		
		int cx[7];
		int cy[7];
		int cang[7];
		for(i=0; i<7; ++i){
			cang[i] = 90+(3-i)*45+ang;
			cx[i] = VectorX(24, cang[i]);
			cy[i] = VectorY(8, cang[i]);
		}
		int order[9];
		SortLowestToHighestAndReturnOrder(cy, order);
		for(i=0; i<9; ++i){
			j = order[i];
			if(cy[j]>=0){
				Char_Draw(chars[j], x+cx[j], y+cy[j], Clamp((1-(Abs(cang[j]-90)/90))*100, 0, 100));
			}
		}
	}
	void Char_Draw(int whichChar, int x, int y, int lit){
		int til = 12480;
		if(whichChar==CHAR_ZELDA)
			til = 12481;
		else if(whichChar==CHAR_ADJEAN)
			til = 12482;
		else if(whichChar==CHAR_BANNON){
			if(AllowAllJokes())
				til = 12485;
			else
				til = 12483;
		}
		else if(whichChar==CHAR_ZARATH)
			til = 12484;
		else if(whichChar==CHAR_KELL)
			til = 12486;
		else if(whichChar==CHAR_RIGGS)
			til = 12487;
		else if(whichChar==CHAR_ALIYA)
			til = 12488;
		else if(whichChar==CHAR_HOLM)
			til = 12489;
		else if(whichChar==CHAR_GARDEA)
			til = 12490;
		else if(whichChar==CHAR_SILVIO)
			til = 12491;
		else if(whichChar==CHAR_NORA)
			til = 12492;
		else if(whichChar==CHAR_ARIA)
			til = 12493;
		else if(whichChar==CHAR_SPURDO)
			til = 12494;
		else if(whichChar==CHAR_MANI)
			til = 12495;
		else if(whichChar==CHAR_ARCANA)
			til = 12496;
		else if(whichChar==CHAR_FROGGER)
			til = 12497;
		else if(whichChar==CHAR_DIMI)
			til = 12498;
		Screen->FastTile(7, x-1, y, til+20, 0, 128);
		Screen->FastTile(7, x+1, y, til+20, 0, 128);
		Screen->FastTile(7, x, y-1, til+20, 0, 128);
		Screen->FastTile(7, x, y+1, til+20, 0, 128);
		
		Screen->FastTile(7, x, y, til, 0, 128);
		if(lit==0)
			Screen->FastTile(7, x, y, til+20, 0, 128);
		else if(lit<33)
		{
			Screen->FastTile(7, x, y, til+20, 0, 64);
			Screen->FastTile(7, x, y, til+20, 0, 64);
		}
		else if(lit<66){
			Screen->FastTile(7, x, y, til+20, 0, 64);
		}
	}
	void Char_DrawStrings(int whichChar, int charOrder, int z3small){
		whichChar = charOrder[whichChar];
		Char_DrawName(whichChar, z3small);
		int textY = 16+8-56;
		textY += 4;
		textY = Char_DrawAuthor(textY, whichChar, z3small);
		textY = Char_DrawSource(textY, whichChar, z3small);
		textY = Char_DrawDescription(textY, whichChar, z3small);
		textY += 4;
		textY = Char_DrawSignature(textY, whichChar, z3small);
		textY += 4;
		textY = Char_DrawUtility(textY, whichChar, z3small);
	}
	void Char_DrawName(int whichChar, int z3small){
		int x = 112;
		int y = 16-56;
		
		int name[] = "NAME: ";
		
		int cLink[] = "LINK";
		int cZelda[] = "ZELDA";
		int cAdjean[] = "ADJEAN";
		int cBannon[] = "BANNON";
		int cZarath[] = "ZARATH";
		int cKell[] = "KELL";
		int cRiggs[] = "RIGGS";
		int cAliya[] = "ALIYA";
		int cHolm[] = "HOLM";
		int cGarea[] = "GARDEA";
		int cSilvio[] = "SILVIO";
		int cNora[] = "NORA";
		int cAria[] = "ARIA";
		int cSpurdo[] = "SPURDO";
		int cMani[] = "MANI";
		int cArcana[] = "ARCANA";
		int cFrogger[] = "FROGGER X";
		int cDimi[] = "DIMI";
		
		
		int charNames[] = {cLink, cZelda, cAdjean, cBannon, cZarath, cKell, cRiggs, cAliya, cHolm, cGarea, cSilvio, cNora, cAria, cSpurdo, cMani, cArcana, cFrogger, cDimi};
	
		Q7_DrawStringOutline(7, x, y, FONT_Z3SMALL, 0x02, 0x0F, TF_NORMAL, name, 128);
		Q7_DrawStringOutline(7, x+Q7_StringLength(name, z3small), y, FONT_Z3SMALL, 0x01, 0x0F, TF_NORMAL, charNames[whichChar], 128);
	}
	int Char_DrawAuthor(int y, int whichChar, int z3small){
		int x = 112;
		
		int createdBy[] = "CREATED BY: ";
		
		int cMoosh[] = "MOOSH";
		int cRuss[] = "RUSS";
		int cAevin[] = "AEVIN";
		int cZax[] = "ZAXARONE";
		int cOrithan[] = "ORITHAN";
		int cPrince[] = "TWILIGHT PRINCE";
		int cSC[] = "SURREAL CANINE";
		int cEvan[] = "EVAN20K";
		int cMani[] = "MANI KANINA";
		int cHOF[] = "HERO OF FIRE";
		
		int creators[] = {0, 0, 0, 0, cMoosh, cRuss, cRuss, cRuss, cAevin, cZax, cOrithan, cPrince, cSC, cEvan, cMani, cHOF, cEvan, 0};
	
		if(creators[whichChar]){
			Q7_DrawStringOutline(7, x, y, FONT_Z3SMALL, 0x02, 0x0F, TF_NORMAL, createdBy, 128);
			Q7_DrawStringOutline(7, x+Q7_StringLength(createdBy, z3small), y, FONT_Z3SMALL, 0x01, 0x0F, TF_NORMAL, creators[whichChar], 128);
		
			y += 12;
		}
		return y;
	}
	int Char_DrawSource(int y, int whichChar, int z3small){
		int x = 112;
		
		int from[] = "FROM: ";
		
		int sDoM[] = "DEPTHS OF MALICE";
		int sReikon[] = "REIKON";
		int sSirknight[] = "THE LEGEND OF SIRKNIGHT";
		int sSilverSolstice[] = "SILVER SOLSTICE";
		int sDreamsOfBrotherhood[] = "DREAMS OF BROTHERHOOD";
		int sSpurdlunky[] = "SPURDLUNKY";
		int sUmbralCloud[] = "UMBRAL CLOUD";
		int sGollab[] = "GO GOLLAB";
		
		int sources[] = {0, 0, 0, 0, 0, sDoM, sDoM, sDoM, sReikon, sSirknight, sSilverSolstice, 0, sDreamsOfBrotherhood, sSpurdlunky, 0, 0, sUmbralCloud, sGollab};
	
		if(sources[whichChar]){
			Q7_DrawStringOutline(7, x, y, FONT_Z3SMALL, 0x02, 0x0F, TF_NORMAL, from, 128);
			Q7_DrawStringOutline(7, x+Q7_StringLength(from, z3small), y, FONT_Z3SMALL, 0x01, 0x0F, TF_NORMAL, sources[whichChar], 128);
		
			y += 12;
		}
		return y;
	}
	int Char_DrawDescription(int y, int whichChar, int z3small){
		int x = 112;
		
		int description[] = "DESCRIPTION:";
		
		int dLink[] = "THE TRUE CHOICE.";
		int dZelda[] = "A PRINCESS ONCE TRAPPED IN ADJEAN'S NIGHTMARE, NOW DOOMED TO REPEAT IT.";
		int dAdjean[] = "LORD OF THE NIGHTMARE. WHY DOES HE FIGHT HIMSELF?";
		int dBannon[] = "A FEARSOME ENEMY COMPOSED OF BANISHED MEMORIES. HE'S MOSTLY JUST MISUNDERSTOOD.";
		int dZarath[] = "A CHARACTER DENIED HIS GAME. WILL MOOSH EVER GET UNLAZY? WILL ZARATH BE FREED FROM THE CIRCLE OF SUFFERING?";
		int dKell[] = "A YOUNG PRINCE TRYING TO FILL HIS LATE MOTHER'S SHOES. KINDHEARTED, THOUGH A BIT STUFFY AND FORMAL.";
		int dRiggs[] = "A YOUNG PRINCE FROM AN OPPRESSED RACE. PLAYFUL AND OPTIMISTIC, HE SEEKS AN END TO THE PERSECUTION.";
		int dAliya[] = "THE HEIR TO TWO THRONES. HER ATTEMPTED ASSASSINATION AND OPPRESSION OF HER PEOPLE HAVE LED HER DOWN A DARK PATH.";
		int dHolm[] = "A SOMBER, SERIOUS, AND SELF-SACRIFICING YOUNG GHOST WHO WISHES TO PROTECT EVERYONE, NO MATTER THE COST TO HIMSELF.";
		int dGardea[] = "GARDEA IS ONLY HERE AT THE INSISTENCE OF ZAX. HE SAID TO SAY THAT TOO. BLAME ZAX.";
		int dSilvio[] = "A FORMER ASSASSIN WITH A TASTE FOR EDGE WHO REFUSED TO GIVE A DAMN. SUDDEN TWISTS IN HIS LIFE HAVE SWORN HIM AWAY FROM HIS MURDERHOBO PAST, BUT IT IS ALWAYS THERE TO HAUNT HIM.";
		int dNora[] = "A YOUNG SUMMONER WHO VENTURES OUT IN SEARCH OF COMPANIONS. BRIGHT, CHEERFUL, AND ALWAYS LOOKING FORWARD!";
		int dAria[] = "SUBCOMMANDER OF THE GUILD OF HEROES. TOURS THE COSMOS, SEARCHING FOR WORLDS IN NEED OF HELP.";
		int dSpurdo[] = "AN ENIGMATIC CREATURE HAILING FROM THE MYTHICAL LAND OF FINLAND. HAS A LOT TO SAY, BUT FEW TRULY UNDERSTAND HIM. FUG :D";
		int dMani[] = ":V";
		int dArcana[] = "WHENEVER THE MISTRESS OF CHAOS APPEARS, SHE IS SEEKING SOMETHING. BUT WHAT COULD SHE POSSIBLY WANT HERE?";
		int dFrogger[] = "HE'S THE LEADER OF THE BUNCH, YOU KNOW HIM WELL. HE'S FINALLY BACK TO BLOW YOU TO HELL.";
		int dDimi[] = "AN INCURABLE PRANKSTER AND SELF PROCLAIMED \"MASTER RUSEPERSON, GRADE THREE\". OWNS A COMPANY THAT MAKES ESOTERIC PUZZLES AND HAS A FONDNESS FOR SMASHING UP BOATS.";
		
		int charDescs[] = {dLink, dZelda, dAdjean, dBannon, dZarath, dKell, dRiggs, dAliya, dHolm, dGardea, dSilvio, dNora, dAria, dSpurdo, dMani, dArcana, dFrogger, dDimi};
		
		Q7_DrawStringOutline(7, x, y, FONT_Z3SMALL, 0x02, 0x0F, TF_NORMAL, description, 128);
		y += 12;
		y += 8*Q7_DrawStringsOutline(7, x+4, y, FONT_Z3SMALL, 0x01, 0x0F, TF_NORMAL, 128, 8, charDescs[whichChar], 128, z3small);
		return y;
	}
	int Char_DrawSignature(int y, int whichChar, int z3small){
		int x = 112;
		
		int sig[] = "SIGNATURE: ";
		
		int spLink[] = "NONE";
		int spZelda[] = "MAGIC STREAM";
		int spAdjean[] = "CANE OF FACT";
		int spBannon[] = "THE BANHAMMER";
		int spZarath[] = "LIGHT OF DARKNESS";
		int spKell[] = "LIGHTSCALE TRIDENT";
		int spRiggs[] = "CHAINS OF FREEDOM";
		int spAliya[] = "ELEMENTAL STAFF";
		int spHolm[] = "MIRROR SHOT";
		int spGardea[] = "SIRKNIGHT SCYTHE";
		int spSilvio[] = "SPEAR";
		int spNora[] = "SUMMONING STAFF";
		int spAria[] = "DASH";
		int spSpurdo[] = "EGGPLANT";
		int spMani[] = "LIGHT ORB";
		int spArcana[] = "ENERGY SPEAR";
		int spFrogger[] = "HIS GOOSH GOOSH GUN";
		int spDimi[] = "PROCESS OF ELIMINATION";
		
		int spellNames[] = {spLink, spZelda, spAdjean, spBannon, spZarath, spKell, spRiggs, spAliya, spHolm, spGardea, spSilvio, spNora, spAria, spSpurdo, spMani, spArcana, spFrogger, spDimi};
		
		int spdLink[] = " ";
		int spdZelda[] = "A STREAM OF BULLETS THAT FOLLOWS THE USER'S DIRECTION.";
		int spdAdjean[] = "FIRES A TRIPLE SHOT SPREAD OF FIREBALLS.";
		int spdBannon[] = "A SLOW THRUST ATTACK WITH A MIGHTY HAMMER. MAKE THEM FEAR THE \"BIG POKEY\"!";
		int spdZarath[] = "SHOOTS OUT CHAINS TO PULL ENEMIES TO YOU OR YOU TO THEM.";
		int spdKell[] = "THRUST WITH A POWERFUL TRIDENT THAT HITS ENEMIES FROM AFAR.";
		int spdRiggs[] = "SWIPE WITH A WIDE ARC THAT LEAVES ENEMIES BURNED.";
		int spdAliya[] = "CHARGE A MAGIC STAFF WHICH GAINS ELEMENTAL POWERS FROM SWORD UPGRADES.";
		int spdHolm[] = "FIRE A LOW DAMAGE MAGIC SHOT THAT REFLECTS ENEMY PROJECTILES.";
		int spdGardea[] = "PERFORM A SLASHING ATTACK WITH YOUR SCYTHE.";
		int spdSilvio[] = "WIND UP AND THROW A SPEAR. EFFECTS IMPROVE WITH UPGRADED WEAPONS.";
		int spdNora[] = "A STAFF THAT SUMMONS MONSTERS TO FIGHT FOR YOU.";
		int spdAria[] = "LUNGE FORWARD TO ATTACK YOUR ENEMIES.";
		int spdSpurdo[] = "STAB WITH AN EGGPLANT, BECOMES JUICIER AT HIGHER LEVELS.";
		int spdMani[] = "TAP TO STAB WITH A SPEAR, HOLD TO CHARGE A LIGHT ARROW.";
		int spdArcana[] = "FIRES SPEAR-SHAPED ENERGY. RANGE AND AIM IMPROVE WITH UPGRADES.";
		int spdFrogger[] = "CAN FIRE IN SPURTS. IF HE SHOOTS YA, IT'S GONNA HURT!";
		int spdDimi[] = "WHY DEFEAT ENEMIES WHEN YOU CAN ELIMINATE THEM? HAS DIFFERENT EFFECTS WHEN TRANSFORMED.";
		
		int spellDescs[] = {spdLink, spdZelda, spdAdjean, spdBannon, spdZarath, spdKell, spdRiggs, spdAliya, spdHolm, spdGardea, spdSilvio, spdNora, spdAria, spdSpurdo, spdMani, spdArcana, spdFrogger, spdDimi};
		
		Q7_DrawStringOutline(7, x, y, FONT_Z3SMALL, 0x02, 0x0F, TF_NORMAL, sig, 128);
		Q7_DrawStringOutline(7, x+Q7_StringLength(sig, z3small), y, FONT_Z3SMALL, 0x01, 0x0F, TF_NORMAL, spellNames[whichChar], 128);
		y += 12;
		y += 8*Q7_DrawStringsOutline(7, x+4, y, FONT_Z3SMALL, 0x01, 0x0F, TF_NORMAL, 128, 8, spellDescs[whichChar], 128, z3small);
		return y;
	}
	int Char_DrawUtility(int y, int whichChar, int z3small){
		int x = 112;
		
		int sig[] = "UTILITY: ";
		
		int spLink[] = "NONE";
		int spZelda[] = "SPELLBLOSSOM";
		int spAdjean[] = "WIZARD'S WORMHOLE";
		int spBannon[] = "LOCUST SWARM";
		int spZarath[] = "SOUL SEVERANCE";
		int spKell[] = "FISH ORB";
		int spRiggs[] = "LADDER";
		int spAliya[] = "CHAINS OF HATRED";
		int spHolm[] = "TRI SHIELD";
		int spGardea[] = "POWER GEM";
		int spSilvio[] = "CAPE OF VAQUITA";
		int spNora[] = "FROST HYDRA";
		int spAria[] = "POWER SLASH";
		int spSpurdo[] = "SHOTGUN";
		int spMani[] = "STARFALL";
		int spArcana[] = "CHAOTIC MAGIC";
		int spFrogger[] = "HE'S BIGGER";
		int spDimi[] = "FACE OFF";
		
		int spellNames[] = {spLink, spZelda, spAdjean, spBannon, spZarath, spKell, spRiggs, spAliya, spHolm, spGardea, spSilvio, spNora, spAria, spSpurdo, spMani, spArcana, spFrogger, spDimi};
		
		int spdLink[] = " ";
		int spdZelda[] = "A CONCENTRATED BLAST OF SLOW MOVING MAGIC ENERGY.";
		int spdAdjean[] = "USE ONCE TO LAY DOWN A WORMHOLE, AGAIN TO TELEPORT TO IT.";
		int spdBannon[] = "SET A SWARM OF LOCUSTS UPON YOUR ENEMIES. WE'RE STILL WORKING OUT THE BUGS IN THE CODE...";
		int spdZarath[] = "PLACE DOWN YOUR LANTERN AND INCREASE YOUR DAMAGE POTENTIAl. IF IT GETS HIT, YOU DIE INSTANTLY.";
		int spdKell[] = "THROW DOWN AN ORB THAT SUMMONS FISH TO SWARM AROUND IT. THEY'LL ATTACK INDISCRIMINATELY, SO WATCH OUT!";
		int spdRiggs[] = "PLACE DOWN LADDERS TO MAKE PERMANENT SHORTCUTS. THEY HAVE LIMITED USE, SO CHOOSE CAREFULLY.";
		int spdAliya[] = "TOSS OUT A CHAIN THAT CAN BE PULLED BACK TOWARDS YOU.";
		int spdHolm[] = "CHARGE UP TO CAST FLAKE, PETAL, OR SKULL SHIELD.";
		int spdGardea[] = "FIRE A STREAM OF HOMING PROJECTILES AT THE COST OF 5 RUPEES.";
		int spdSilvio[] = "USE TO BRIEFLY BECOME INVISIBLE.";
		int spdNora[] = "SUMMON A FROST HYDRA TO PELT YOUR ENEMIES WITH BALLS OF ICE.";
		int spdAria[] = "CREATE A GIANT SLASH IN FRONT OF YOU WITH A CHANCE TO DEAL CRITICAL DAMAGE.";
		int spdSpurdo[] = "SHOOT A SPREAD OF PELLETS WITH HIGH DAMAGE, HIGH RECOIL, AND HIGH SHITPOSTS.";
		int spdMani[] = "IT'S BASICALLY A SCREEN NUKE. GROWS STRONGER WHEN NOT USED.";
		int spdArcana[] = "RANDOMLY CASTS ONE OF MANY SPELLS. POWER AND EFFECTS CAN VARY.";
		int spdFrogger[] = "FASTER, AND STRONGER TOO. ONCE HE FULLY ASCENDS, HE'LL ANNIHILATE YOU.";
		int spdDimi[] = "ASSUME THE FORM OF A NEARBY ENEMY. BREAKS WHEN YOU GET HIT.";
		
		int spellDescs[] = {spdLink, spdZelda, spdAdjean, spdBannon, spdZarath, spdKell, spdRiggs, spdAliya, spdHolm, spdGardea, spdSilvio, spdNora, spdAria, spdSpurdo, spdMani, spdArcana, spdFrogger, spdDimi};
		
		Q7_DrawStringOutline(7, x, y, FONT_Z3SMALL, 0x02, 0x0F, TF_NORMAL, sig, 128);
		Q7_DrawStringOutline(7, x+Q7_StringLength(sig, z3small), y, FONT_Z3SMALL, 0x01, 0x0F, TF_NORMAL, spellNames[whichChar], 128);
		y += 12;
		y += 8*Q7_DrawStringsOutline(7, x+4, y, FONT_Z3SMALL, 0x01, 0x0F, TF_NORMAL, 128, 8, spellDescs[whichChar], 128, z3small);
		return y;
	}
}

void Timers_Update(){
	if(G[G_INVISTIMER]){
		Link->Invisible = true;
		--G[G_INVISTIMER];
		if(!G[G_INVISTIMER])
			Link->Invisible = false;
	}
	if(G[G_NOCOLLTIMER]){
		Link->CollDetection = false;
		--G[G_NOCOLLTIMER];
		if(!G[G_NOCOLLTIMER])
			Link->CollDetection = true;
	}
}

void SetInvisible(){
	Link->Invisible = true;
	G[G_INVISTIMER] = 2;
}

void SetNoColl(){
	Link->CollDetection = true;
	G[G_NOCOLLTIMER] = 2;
}

const int CHAR_LINK = 0;
const int CHAR_ZELDA = 1;
const int CHAR_ADJEAN = 2;
const int CHAR_BANNON = 3;
const int CHAR_ZARATH = 4;
const int CHAR_KELL = 5;
const int CHAR_RIGGS = 6;
const int CHAR_ALIYA = 7;
const int CHAR_HOLM = 8;
const int CHAR_GARDEA = 9;
const int CHAR_SILVIO = 10;
const int CHAR_NORA = 11;
const int CHAR_ARIA = 12;
const int CHAR_SPURDO = 13;
const int CHAR_MANI = 14;
const int CHAR_ARCANA = 15;
const int CHAR_FROGGER = 16;
const int CHAR_DIMI = 17;

const int I_UTILITYSPELL = 81;

const int I_SPPAL1_PURPLE = 225;
const int I_SPPAL2_BANNON = 226;
const int I_SPPAL3_WHITE = 227;
const int I_SPPAL4_DOM = 228;
const int I_SPPAL5_BROWN = 229;
const int I_SPPAL6_GOLD = 230;

void AltCharacter_Init(){
	G[G_ALTCHARACTERPAL] = 0;
	
	if(G[G_ALTCHARACTER]==CHAR_LINK){
		AltCharacter_CopyTile(13160, 13000);
	}
	else{
		Link->Item[I_UTILITYSPELL] = true;
		if(G[G_ALTCHARACTER]==CHAR_ZELDA){
			AltCharacter_CopyTile(13200, 13000);
			AltCharacter_SetSigTiles(12740, 12840);
		}
		else if(G[G_ALTCHARACTER]==CHAR_ADJEAN){
			AltCharacter_CopyTile(13260, 13000);
			AltCharacter_UsePalette(I_SPPAL1_PURPLE);
			AltCharacter_SetSigTiles(12741, 12841);
		}
		else if(G[G_ALTCHARACTER]==CHAR_BANNON){
			if(AllowAllJokes())
				AltCharacter_CopyTile(13380, 13000);
			else
				AltCharacter_CopyTile(13300, 13000);
			AltCharacter_UsePalette(I_SPPAL2_BANNON);
			AltCharacter_SetSigTiles(12742, 12842);
		}
		else if(G[G_ALTCHARACTER]==CHAR_ZARATH){
			AltCharacter_CopyTile(13340, 13000);
			AltCharacter_UsePalette(I_SPPAL3_WHITE);
			AltCharacter_SetSigTiles(12743, 12843);
		}
		else if(G[G_ALTCHARACTER]==CHAR_KELL){
			AltCharacter_CopyTile(13420, 13000);
			AltCharacter_UsePalette(I_SPPAL4_DOM);
			AltCharacter_SetSigTiles(12744, 12744, 12745, 12745, 12844);
		}
		else if(G[G_ALTCHARACTER]==CHAR_RIGGS){
			AltCharacter_CopyTile(13460, 13000);
			AltCharacter_UsePalette(I_SPPAL4_DOM);
			AltCharacter_SetSigTiles(12746, 12746, 12747, 12747, 12845);
		}
		else if(G[G_ALTCHARACTER]==CHAR_ALIYA){
			AltCharacter_CopyTile(13520, 13000);
			AltCharacter_UsePalette(I_SPPAL4_DOM);
			AltCharacter_SetSigTiles(12748, 12749, 12750, 12751, 12846);
		}
		else if(G[G_ALTCHARACTER]==CHAR_HOLM){
			AltCharacter_CopyTile(13560, 13000);
			AltCharacter_UsePalette(I_SPPAL3_WHITE);
			AltCharacter_SetSigTiles(12752, 12847);
		}
		else if(G[G_ALTCHARACTER]==CHAR_GARDEA){
			AltCharacter_CopyTile(13600, 13000);
			AltCharacter_UsePalette(I_SPPAL3_WHITE);
			AltCharacter_SetSigTiles(12753, 12848);
		}
		else if(G[G_ALTCHARACTER]==CHAR_SILVIO){
			AltCharacter_CopyTile(13640, 13000);
			AltCharacter_UsePalette(I_SPPAL3_WHITE);
			AltCharacter_SetSigTiles(12754, 12755, 12756, 12757, 12849);
		}
		else if(G[G_ALTCHARACTER]==CHAR_NORA){
			AltCharacter_CopyTile(13680, 13000);
			AltCharacter_UsePalette(I_SPPAL4_DOM);
			AltCharacter_SetSigTiles(12758, 12850);
		}
		else if(G[G_ALTCHARACTER]==CHAR_ARIA){
			AltCharacter_CopyTile(13720, 13000);
			AltCharacter_UsePalette(I_SPPAL3_WHITE);
			AltCharacter_SetSigTiles(12759, 12851);
		}
		else if(G[G_ALTCHARACTER]==CHAR_SPURDO){
			AltCharacter_CopyTile(13780, 13000);
			AltCharacter_UsePalette(I_SPPAL5_BROWN);
			AltCharacter_SetSigTiles(12760, 12852);
		}
		else if(G[G_ALTCHARACTER]==CHAR_MANI){
			AltCharacter_CopyTile(13820, 13000);
			AltCharacter_UsePalette(I_SPPAL1_PURPLE);
			AltCharacter_SetSigTiles(12761, 12853);
		}
		else if(G[G_ALTCHARACTER]==CHAR_ARCANA){
			AltCharacter_CopyTile(13860, 13000);
			AltCharacter_UsePalette(I_SPPAL6_GOLD);
			AltCharacter_SetSigTiles(12762, 12763, 12764, 12765, 12854);
		}
		else if(G[G_ALTCHARACTER]==CHAR_FROGGER){
			AltCharacter_CopyTile(13900, 13000);
			AltCharacter_UsePalette(I_SPPAL3_WHITE);
			AltCharacter_SetSigTiles(12766, 12855);
		}
		else if(G[G_ALTCHARACTER]==CHAR_DIMI){
			AltCharacter_CopyTile(13940, 13000);
			AltCharacter_UsePalette(I_SPPAL1_PURPLE);
			AltCharacter_SetSigTiles(12767, 12856);
		}
		CopyTile(13003, 28);
		CopyTile(13017, 29);
	}
}

const int I_SHIELD2NOLTM = 222;
const int I_SHIELD3NOLTM = 223;
const int I_SHIELD4NOLTM = 224;

void AltCharacter_Update(){
	G[G_REALDAMAGEMULTIPLIER] = G[G_TEMPDAMAGEMULTIPLIER];
	G[G_TEMPDAMAGEMULTIPLIER] = 1;
	if(G[G_ALTCHARACTER]>0){
		if(G[G_ALTCHARACTERPAL]){
			itemdata pal = Game->LoadItemData(G[G_ALTCHARACTERPAL]);
			if(Link->Item[I_RING2]){
				pal->Power = 4;
				CopyTile(12966, 12984);
			}
			else if(Link->Item[I_RING1]){
				pal->Power = 2;
				CopyTile(12965, 12984);
			}
			else{
				pal->Power = 1;
				CopyTile(12964, 12984);
			}
		}
		
		Link->Item[I_SHIELD4NOLTM] = Link->Item[I_SHIELD4];
		Link->Item[I_SHIELD3NOLTM] = Link->Item[I_SHIELD3];
		Link->Item[I_SHIELD2NOLTM] = Link->Item[I_SHIELD2];
	
		if(G[G_ALTCHARACTER]==CHAR_NORA){
			if(G[G_NORAATTACKCOMMAND])
				--G[G_NORAATTACKCOMMAND];
		}
	
		if(!(Game->GetCurMap()==14&&Game->GetCurScreen()==0x1C)){
			if(G[G_SIGCOOLDOWN]){
				DrawItemCooldown(GetSwordItemTile(), 148, 24, G[G_SIGCOOLDOWN], G[G_SIGCOOLDOWNMAX]);
				--G[G_SIGCOOLDOWN];
			}
			if(Link->PressA&&Link->SwordJinx==0&&(!G[G_SIGCOOLDOWN]||G[G_IGNORESIGCOOLDOWN])&&!OnScreenEdge()&&GetSwordLevel()&&(Link->Action==LA_NONE||Link->Action==LA_WALKING)){
				if(G[G_ALTCHARACTER] != CHAR_ZARATH){
					int sigScript = FFCS_SIGNATURE;
					if(G[G_ALTCHARACTER]==CHAR_KELL||G[G_ALTCHARACTER]==CHAR_RIGGS)
						sigScript = FFCS_ZELDASWORD;
					if(CountFFCsRunning(sigScript)==0){
						RunFFCScript(sigScript, 0);
					}
				}
			}
			
			if(G[G_ALTCHARACTER]==CHAR_ZARATH&&GetSwordLevel()){
				if(CountFFCsRunning(FFCS_LIGHTOFDARKNESS)==0){
					RunFFCScript(FFCS_LIGHTOFDARKNESS, 0);
				}
			}
			
			if(G[G_ALTCHARACTER]==CHAR_FROGGER){
				if(CountFFCsRunning(FFCS_LONGDONGREGALIA)==0){
					RunFFCScript(FFCS_LONGDONGREGALIA, 0);
				}
			}
			
			if(G[G_ALTCHARACTER]==CHAR_DIMI){
				if(CountFFCsRunning(FFCS_DIMITRANSFORMATION)==0){
					RunFFCScript(FFCS_DIMITRANSFORMATION, 0);
				}
			}
			
			if(Link->Action!=LA_SWIMMING){
				Link->InputA = false;
				Link->PressA = false;
			}
		}
		
		if(G[G_UTILITYCOOLDOWN]){
			if(GetEquipmentB()==I_UTILITYSPELL)
				DrawItemCooldown(12985, 124, 24, G[G_UTILITYCOOLDOWN], G[G_UTILITYCOOLDOWNMAX]);
			--G[G_UTILITYCOOLDOWN];
		}
		DrawUtilityExtras(124, 24);
		if(InputButtonItem(I_UTILITYSPELL)){
			if(Link->PressB&&Link->ItemJinx==0&&!OnScreenEdge()&&(Link->Action==LA_NONE||Link->Action==LA_WALKING)){
				if(!G[G_UTILITYCOOLDOWN]||G[G_ALTCHARACTER]==CHAR_FROGGER){
					if(CountFFCsRunning(FFCS_UTILITY)==0){
						RunFFCScript(FFCS_UTILITY, 0);
					}
				}
			}
			Link->InputB = false;
			Link->PressB = false;
		}
		if(G[G_SWORDSHOOTERFLAG])
			--G[G_SWORDSHOOTERFLAG];
	}
}

void AltCharacter_ScreenChange(){
	//Change which script to run based on character and circumstances
	int count = 1;
	if(G[G_ALTCHARACTER]==CHAR_NORA)
		count = 4;
	
	for(int i=0; i<count; ++i){
		int args[8];
		int runOnScreenChange;
		if(G[G_ALTCHARACTER]==CHAR_ZELDA){
			if(G[G_PRESERVEDCHARGEA])
				runOnScreenChange = FFCS_SIGNATURE;
		}
		if(G[G_ALTCHARACTER]==CHAR_RIGGS){
			runOnScreenChange = FFCS_UTILITY;
		}
		if(G[G_ALTCHARACTER]==CHAR_ALIYA){
			if(G[G_PRESERVEDCHARGEA])
				runOnScreenChange = FFCS_SIGNATURE;
		}
		if(G[G_ALTCHARACTER]==CHAR_HOLM){
			if(G[G_PRESERVEDCHARGEB])
				runOnScreenChange = FFCS_UTILITY;
		}
		if(G[G_ALTCHARACTER]==CHAR_SILVIO){
			if(G[G_PRESERVEDCHARGEB])
				runOnScreenChange = FFCS_UTILITY;
		}
		if(G[G_ALTCHARACTER]==CHAR_NORA){
			if(G[G_PRESERVEDCHARGEA]){
				int id = NoraSummons.getSummonFlag(i);
				if(id){
					runOnScreenChange = FFCS_NORASUMMON;
					args[0] = Link->X;
					args[1] = Link->Y;
					args[2] = id-1;
				}
			}
		}
		
		if(runOnScreenChange){
			if(CountFFCsRunning(runOnScreenChange)<count)
				RunFFCScript(runOnScreenChange, args);
		}
	}
}

int GetSwordLevel(){
	if(Link->Item[I_SWORD4])
		return 4;
	if(Link->Item[I_SWORD3])
		return 3;
	if(Link->Item[I_SWORD2])
		return 2;
	if(Link->Item[I_SWORD1])
		return 1;
	return 0;
}

int GetSwordItemTile(){
	if(Link->Item[I_SWORD4])
		return 12983;
	if(Link->Item[I_SWORD3])
		return 12982;
	if(Link->Item[I_SWORD2])
		return 12981;
	if(Link->Item[I_SWORD1])
		return 12980;
}

int SwordDamageLevel(int l1, int l2, int l3, int l4){
	if(Link->Item[I_SWORD4])
		return l4;
	if(Link->Item[I_SWORD3])
		return l3;
	if(Link->Item[I_SWORD2])
		return l2;
	return l1;
}

void DrawItemCooldown(int til, int x, int y, int frames, int maxFrames){
	if(G[G_NODRAWSUBSCREEN])
		return;
	
	y -= 56;
	// Screen->SetRenderTarget(RT_COOLDOWNS);
	// Screen->FastTile(0, bmpx, bmpy, til, 0, 128);
	// Screen->Rectangle(0, bmpx, bmpy, bmpx+15, bmpy+15, 0x0F, 1, 0, 0, 0, true, 64);
	// Screen->SetRenderTarget(RT_SCREEN);
	
	int size = Round((frames/maxFrames)*15);
	//Screen->DrawBitmap(7, RT_COOLDOWNS, bmpx, bmpy, 16, size, x, y, 16, size, 0, true);
	Screen->Rectangle(7, x+1, y, x+14, y+15, 0x0F, 1, 0, 0, 0, true, 64);
	Screen->Rectangle(7, x+1, y, x+14, y+size, 0x0F, 1, 0, 0, 0, true, 64);
	//Screen->FastTile(7, x, y, til, 0, 128);
}

void DrawUtilityExtras(int x, int y){
	if(G[G_NODRAWSUBSCREEN])
		return;
	
	y -= 56;
	if(G[G_ALTCHARACTER]==CHAR_RIGGS&&GetEquipmentB()==I_UTILITYSPELL){
		Q7_DrawIntegerOutline(7, x, y+12, FONT_Z3SMALL, 0x01, 0x0F, -1, -1, G[G_REMAININGLADDERS], 0, 128);
	}
}

void AltCharacter_CopyTile(int src, int dest){
	for(int i=0; i<40; ++i){
		CopyTile(src+i, dest+i);
	}
}

void AltCharacter_SetSigTiles(int l1, int l2, int l3, int l4, int utility){
	CopyTile(l1, 12980);
	CopyTile(l2, 12981);
	CopyTile(l3, 12982);
	CopyTile(l4, 12983);
	
	CopyTile(utility, 12985);
}

void AltCharacter_SetSigTiles(int l1, int utility){
	CopyTile(l1, 12980);
	CopyTile(l1, 12981);
	CopyTile(l1, 12982);
	CopyTile(l1, 12983);
	
	CopyTile(utility, 12985);
}

void AltCharacter_UsePalette(int itemid){
	Link->Item[itemid] = true;
	G[G_ALTCHARACTERPAL] = itemid;
}

void AltCharacter_UpdateSwordLevels(int id){
	if(G[G_ALTCHARACTER]){
		if(Link->Item[I_SWORD4]||id==I_SWORD4)
			CopyTile(12963, 12986);
		else if(Link->Item[I_SWORD3]||id==I_SWORD3)
			CopyTile(12962, 12986);
		else if(Link->Item[I_SWORD2]||id==I_SWORD2)
			CopyTile(12961, 12986);
		else if(Link->Item[I_SWORD1]||id==I_SWORD1)
			CopyTile(12960, 12986);
	}
}

const int FFCS_SIGNATURE = 130;
const int FFCS_UTILITY = 131;

lweapon FireLWeapon(int type, int x, int y, int angle, int step, int damage, int sprite, int sfx){
	lweapon l = CreateLWeaponAt(type, x, y);
	l->Dir = AngleDir4(WrapDegrees(RadtoDeg(angle)));
	l->Angle = angle;
	l->Angular = true;
	l->Step = step;
	l->Damage = damage;
	l->UseSprite(sprite);
	Game->PlaySound(sfx);
	return l;
}

lweapon MakeHitbox(int id, int x, int y, int w, int h, int dir, int damage){
	lweapon l = CreateLWeaponAt(id, 120, 80);
	l->Tile = GH_BLANK_TILE;
	l->OriginalTile = GH_BLANK_TILE;
	l->HitXOffset = x-120;
	l->HitYOffset = y-80;
	l->HitWidth = w;
	l->HitHeight = h;
	l->DrawYOffset = -1000;
	l->Dir = dir;
	l->Step = 0;
	l->Damage = damage;
	l->Misc[LWM_DEATHTIMER] = 2;
	return l;
}

bool OnScreenEdge(){
	if(Game->GetCurLevel()>0&&Game->GetCurLevel()<9){
		return Link->X<24||Link->X>216||Link->Y<24||Link->Y>136;
	}
}

void NoButton(){
	Link->InputR = false; Link->PressR = false;
	Link->InputL = false; Link->PressL = false;
	Link->InputA = false; Link->PressA = false;
	Link->InputB = false; Link->PressB = false;
	Link->InputEx1 = false; Link->PressEx1 = false;
	Link->InputEx2 = false; Link->PressEx2 = false;
	Link->InputEx3 = false; Link->PressEx3 = false;
	Link->InputEx4 = false; Link->PressEx4 = false;
}
void NoWalk(){
	Link->InputUp = false; Link->PressUp = false;
	Link->InputDown = false; Link->PressDown = false;
	Link->InputLeft = false; Link->PressLeft = false;
	Link->InputRight = false; Link->PressRight = false;
}
void NoPause(){
	Link->InputStart = false; Link->PressStart = false;
	Link->InputMap = false; Link->PressMap = false;
}


const int TIL_CANEOFFACT = 5496;
const int TIL_ELEMENTALSTAFF = 5656;
const int TIL_SUMMONSTAFF = 16680;
const int TIL_EGGPLANT = 16616;

const int SPR_INVISIBLE = 125;

bool LinkBusy(){
	if(Link->Invisible)
		return true;
	return Link->Action!=LA_NONE&&Link->Action!=LA_WALKING;
}

const int SFX_HOLM_REFLECTOR = 126;
const int SFX_HOLM_REFLECT = 6;

ffc script SignatureWeapons{
	void run(){
		if(G[G_ALTCHARACTER]==CHAR_ZELDA)
			runMagicStream();
		if(G[G_ALTCHARACTER]==CHAR_ADJEAN)
			runCaneOfFact();
		if(G[G_ALTCHARACTER]==CHAR_BANNON)
			runBanhammer();
		if(G[G_ALTCHARACTER]==CHAR_ALIYA)
			runElementalStaff();
		if(G[G_ALTCHARACTER]==CHAR_HOLM)
			runReflector();
		if(G[G_ALTCHARACTER]==CHAR_GARDEA)
			runSirknightScythe();
		if(G[G_ALTCHARACTER]==CHAR_SILVIO)
			runSpearBow();
		if(G[G_ALTCHARACTER]==CHAR_NORA)
			runSummonStaff(this);
		if(G[G_ALTCHARACTER]==CHAR_ARIA)
			runBite();
		if(G[G_ALTCHARACTER]==CHAR_SPURDO)
			runEggplant();
		if(G[G_ALTCHARACTER]==CHAR_MANI)
			runLightOrb();
		if(G[G_ALTCHARACTER]==CHAR_ARCANA)
			runEnergySpear();
		if(G[G_ALTCHARACTER]==CHAR_FROGGER)
			runGooshGooshGun();
		if(G[G_ALTCHARACTER]==CHAR_DIMI)
			runProcessOfElimination();
	}
	void runMagicStream(){
		int damage = SwordDamageLevel(2, 4, 8, 10)*G[G_HPSCALE];
		int length = SwordDamageLevel(12, 16, 24, 32);
		if(!G[G_PRESERVEDCHARGEA])
			G[G_SIGCOOLDOWN] = 40;
		G[G_SIGCOOLDOWNMAX] = 180;
		int angle = DirAngle(Link->Dir);
		int shotTimer = 0;
		int turnAng = 1;
		while(Link->InputA&&!Link->SwordJinx&&G[G_SIGCOOLDOWN]<=G[G_SIGCOOLDOWNMAX]&&!OnScreenEdge()){
			G[G_SWORDSHOOTERFLAG] = 2;
			++G[G_SIGCOOLDOWN];
			G[G_PRESERVEDCHARGEA] = 1;
			int targetAngle = DirAngle(Link->Dir);
			if(Abs(AngDiff(angle, targetAngle))>=180)
				angle = WrapDegrees(angle-turnAng*3);
			else{
				if(angle!=targetAngle)
					turnAng = Sign(AngDiff(angle, targetAngle));
				angle = TurnToAngle(angle, targetAngle, 3);
			}
			++shotTimer;
			if(shotTimer>4){
				lweapon l = FireLWeapon(LW_BEAM, Link->X, Link->Y, DegtoRad(angle), 400, damage, 122, SFX_WAND);
				l->Misc[LWM_DEATHTIMER] = length;
				G[G_SIGCOOLDOWN] += 2;
				shotTimer = 0;
			}
			Waitframe();
		}
		G[G_PRESERVEDCHARGEA] = 0;
	}
	void runCaneOfFact(){
		if(Link->Invisible)
			Quit();
		int damage = SwordDamageLevel(2, 4, 8, 12)*G[G_HPSCALE];
		int hpPercentage = SwordDamageLevel(1, 0.8, 0.6, 0.5);
		int step = SwordDamageLevel(200, 250, 300, 350);
		int dir = Link->Dir;
		int i;
		int x; int y;
		Game->PlaySound(SFX_SWORD);
		G[G_SWORDSHOOTERFLAG] = 2;
		for(i=0; i<12; ++i){
			x = Link->X+DirX(dir, 14);
			y = Link->Y+DirY(dir, 14);
			if(dir==DIR_UP)
				Screen->DrawTile(2, x, y, TIL_CANEOFFACT, 1, 1, 10, -1, -1, 0, 0, 0, 0, true, 128);
			else if(dir==DIR_DOWN)
				Screen->DrawTile(2, x, y, TIL_CANEOFFACT, 1, 1, 10, -1, -1, 0, 0, 0, 2, true, 128);
			else if(dir==DIR_LEFT)
				Screen->DrawTile(2, x, y, TIL_CANEOFFACT+1, 1, 1, 10, -1, -1, 0, 0, 0, 1, true, 128);
			else if(dir==DIR_RIGHT)
				Screen->DrawTile(2, x, y, TIL_CANEOFFACT+1, 1, 1, 10, -1, -1, 0, 0, 0, 0, true, 128);
			Link->Action = LA_NONE;
			Link->Action = LA_ATTACKING;
			MakeHitbox(LW_BEAM, x, y, 16, 16, dir, damage);
			WaitNoAction();
		}
		if(Link->HP>=Floor(Link->MaxHP*hpPercentage)){
			if(NumLWeaponsOf(LW_REFFIREBALL)<3){
				for(i=-1; i<=1; ++i){
					lweapon fireball = FireLWeapon(LW_REFFIREBALL, x, y, DegtoRad(DirAngle(dir)+i*30), step, damage, 17, SFX_FIREBALL);
					if(i!=0)
						fireball->Step = step*(Sin(90)/Sin(60));
					fireball->Misc[LWM_REFLINKCOLLISION] = 2;
					fireball->Misc[LWM_REFHASMULTIPLIED] = 1;
					fireball->Misc[LWM_ARTIFICIALPUSHTIME] = 16;
				}
			}
		}
		for(i=0; i<4; ++i){
			x = Link->X+DirX(dir, 14-(i/4)*14);
			y = Link->Y+DirY(dir, 14-(i/4)*14);
			if(dir==DIR_UP)
				Screen->DrawTile(2, x, y, TIL_CANEOFFACT, 1, 1, 10, -1, -1, 0, 0, 0, 0, true, 128);
			else if(dir==DIR_DOWN)
				Screen->DrawTile(2, x, y, TIL_CANEOFFACT, 1, 1, 10, -1, -1, 0, 0, 0, 2, true, 128);
			else if(dir==DIR_LEFT)
				Screen->DrawTile(2, x, y, TIL_CANEOFFACT+1, 1, 1, 10, -1, -1, 0, 0, 0, 1, true, 128);
			else if(dir==DIR_RIGHT)
				Screen->DrawTile(2, x, y, TIL_CANEOFFACT+1, 1, 1, 10, -1, -1, 0, 0, 0, 0, true, 128);
			Link->Action = LA_NONE;
			Link->Action = LA_ATTACKING;
			MakeHitbox(LW_BEAM, x, y, 16, 16, dir, damage);
			WaitNoAction();
		}
		Link->Action = LA_NONE;
	}
	void runBanhammer(){
		int i;
		int angle;
		int damage = SwordDamageLevel(4, 8, 12, 16)*G[G_HPSCALE];
		int level = SwordDamageLevel(1, 2, 3, 3);
		for(i=0; i<8; ++i){
			Link->Action = LA_NONE;
			Link->Action = LA_ATTACKING;
			WaitNoAction();
		}
		G[G_SWORDSHOOTERFLAG] = 2;
		Game->PlaySound(SFX_SPINATTACK);
		for(i=0; i<16; ++i){
			angle = WrapDegrees(DirAngle(Link->Dir)+(i/16)*360);
			drawBanhammer(Link->X, Link->Y, angle, 0, level, AngleDir4(angle), damage);
			Link->Action = LA_NONE;
			Link->Action = LA_ATTACKING;
			WaitNoAction();
		}
		if(Link->InputA){
			Game->PlaySound(SFX_SWORD);
			for(i=0; i<8; ++i){
				angle = DirAngle(Link->Dir);
				drawBanhammer(Link->X, Link->Y, angle, i/8, level, Link->Dir, damage);
				Link->Action = LA_NONE;
				Link->Action = LA_ATTACKING;
				WaitNoAction();
			}
			Game->PlaySound(SFX_BOMB);
			Screen->Quake = 10;
			for(i=0; i<8; ++i){
				angle = DirAngle(Link->Dir);
				drawBanhammer(Link->X, Link->Y, angle, 1, level, -1, damage);
				Link->Action = LA_NONE;
				Link->Action = LA_ATTACKING;
				WaitNoAction();
			}
			for(i=0; i<4; ++i){
				angle = DirAngle(Link->Dir);
				drawBanhammer(Link->X, Link->Y, angle, 1-(i/4), level, -1, damage);
				WaitNoAction();
			}
		}
	}
	void drawBanhammer(int cx, int cy, int angle, int extend, int level, int dir, int damage){
		int x; int y;
		if(level==3){
			x = cx-24+VectorX(extend*32, angle);
			y = cy-8+VectorY(extend*32, angle);
			Screen->DrawTile(4, x, y, 5536, 4, 2, 11, -1, -1, x, y, angle, 0, true, 128);
			x = cx+VectorX(24+extend*32, angle);
			y = cy+VectorY(24+extend*32, angle);
			MakeHitbox(LW_BEAM, x, y, 16, 16, dir, damage);
		}
		else if(level==2){
			x = cx-16+VectorX(extend*24, angle);
			y = cy-8+VectorY(extend*24, angle);
			Screen->DrawTile(4, x, y, 5576, 3, 2, 11, -1, -1, x, y, angle, 0, true, 128);
			x = cx+VectorX(16+extend*24, angle);
			y = cy+VectorY(16+extend*24, angle);
			MakeHitbox(LW_BEAM, x, y, 16, 16, dir, damage);
		}
		else if(level==1){
			x = cx-8+VectorX(extend*16, angle);
			y = cy-8+VectorY(extend*16, angle);
			Screen->DrawTile(4, x, y, 5616, 2, 2, 11, -1, -1, x, y, angle, 0, true, 128);
			x = cx+VectorX(8+extend*16, angle);
			y = cy+VectorY(8+extend*16, angle);
			MakeHitbox(LW_BEAM, x, y, 16, 16, dir, damage);
		}
	}
	void runElementalStaff(){
		G[G_IGNORESIGCOOLDOWN] = 1;
		
		if(Link->Invisible)
			Quit();
		int damage = SwordDamageLevel(2, 4, 6, 8)*G[G_HPSCALE];
		int maxCharge = SwordDamageLevel(0, 1, 2, 3);
		int damageFire = SwordDamageLevel(4, 4, 8, 12)*G[G_HPSCALE];
		int damageIce = SwordDamageLevel(12, 12, 12, 16)*G[G_HPSCALE];
		int damageThunder = 24*G[G_HPSCALE];
		int dir = Link->Dir;
		int i;
		int x; int y;
		
		lweapon lwLightning[128];
		int lightningBuffer[8192];
		int lightningX[128];
		int lightningY[128];
		int lightningState[128];
		int lightningMaxDist[128];
		int lightningCurDist[128];
		int lightningSplit[128];
		int lightning[] = {0, lightningBuffer, lightningX, lightningY, lightningState, lightningMaxDist, lightningCurDist, lightningSplit};
		if(!G[G_PRESERVEDCHARGEA]){
			G[G_SWORDSHOOTERFLAG] = 2;
			Game->PlaySound(SFX_SWORD);
			for(i=0; i<12; ++i){
				x = Link->X+DirX(dir, 14);
				y = Link->Y+DirY(dir, 14);
				if(dir==DIR_UP)
					Screen->DrawTile(2, x, y, TIL_ELEMENTALSTAFF, 1, 1, 10, -1, -1, 0, 0, 0, 0, true, 128);
				else if(dir==DIR_DOWN)
					Screen->DrawTile(2, x, y, TIL_ELEMENTALSTAFF, 1, 1, 10, -1, -1, 0, 0, 0, 2, true, 128);
				else if(dir==DIR_LEFT)
					Screen->DrawTile(2, x, y, TIL_ELEMENTALSTAFF+1, 1, 1, 10, -1, -1, 0, 0, 0, 1, true, 128);
				else if(dir==DIR_RIGHT)
					Screen->DrawTile(2, x, y, TIL_ELEMENTALSTAFF+1, 1, 1, 10, -1, -1, 0, 0, 0, 0, true, 128);
				Link->Action = LA_NONE;
				Link->Action = LA_ATTACKING;
				MakeHitbox(LW_BEAM, x, y, 16, 16, dir, damage);
				WaitNoAction();
			}
			for(i=0; i<4; ++i){
				x = Link->X+DirX(dir, 14-(i/4)*14);
				y = Link->Y+DirY(dir, 14-(i/4)*14);
				if(dir==DIR_UP)
					Screen->DrawTile(2, x, y, TIL_ELEMENTALSTAFF, 1, 1, 10, -1, -1, 0, 0, 0, 0, true, 128);
				else if(dir==DIR_DOWN)
					Screen->DrawTile(2, x, y, TIL_ELEMENTALSTAFF, 1, 1, 10, -1, -1, 0, 0, 0, 2, true, 128);
				else if(dir==DIR_LEFT)
					Screen->DrawTile(2, x, y, TIL_ELEMENTALSTAFF+1, 1, 1, 10, -1, -1, 0, 0, 0, 1, true, 128);
				else if(dir==DIR_RIGHT)
					Screen->DrawTile(2, x, y, TIL_ELEMENTALSTAFF+1, 1, 1, 10, -1, -1, 0, 0, 0, 0, true, 128);
				Link->Action = LA_NONE;
				Link->Action = LA_ATTACKING;
				MakeHitbox(LW_BEAM, x, y, 16, 16, dir, damage);
				WaitNoAction();
			}
			Link->Action = LA_NONE;
		}
		
		if(Link->InputA){
			int chargeAnim;
			int chargeTier;
			int maxChargeTime = 90;
			int chargeTime = 90;
			if(G[G_PRESERVEDCHARGEA]){
				chargeTime = G[G_PRESERVEDCHARGEA]&1111111111b;
				chargeTier = G[G_PRESERVEDCHARGEA]>>10;
			}
			while(Link->InputA){
				G[G_PRESERVEDCHARGEA] = chargeTime|(chargeTier<<10);
				if(chargeTime){
					--chargeTime;
					if(chargeTime==0&&chargeTier<maxCharge){
						++chargeTier;
						if(chargeTier==1){
							Game->PlaySound(35);
							maxChargeTime = 120;
							chargeTime = 120;
						}
						else if(chargeTier==2){
							Game->PlaySound(35);
							maxChargeTime = 180;
							chargeTime = 180;
						}
						else if(chargeTier==3){
							Game->PlaySound(36);
						}
					}
				}
				G[G_SIGCOOLDOWN] = chargeTime;
				G[G_SIGCOOLDOWNMAX] = maxChargeTime;
				
				if(chargeTier)
					chargeAnim = drawElementalStaffCharge(chargeAnim, chargeTier);
				
				Waitframe();
			}
			G[G_PRESERVEDCHARGEA] = 0;
			if(chargeTier==1){
				for(i=0; i<6; ++i){
					lweapon l = FireLWeapon(LW_FIRE, Link->X+DirX(Link->Dir, 8), Link->Y+DirY(Link->Dir, 8), DegtoRad(DirAngle(Link->Dir)+Rand(-5, 5)), 400+i*10, damageFire, 12, SFX_FIRE);
				}
			}
			else if(chargeTier==2){
				lweapon iceShot = FireLWeapon(LW_SCRIPT10, Link->X+DirX(Link->Dir, 8), Link->Y+DirY(Link->Dir, 8), DegtoRad(DirAngle(Link->Dir)), 400, damageIce, 124, SFX_ICE);
				if(iceShot->Dir>1){
					++iceShot->Tile;
					if(iceShot->Dir==DIR_LEFT)
						iceShot->Flip = 1;
				}
				if(iceShot->Dir==DIR_DOWN)
						iceShot->Flip = 2;
				int iceX; int iceY;
				while(iceShot->isValid()){
					iceX = iceShot->X;
					iceY = iceShot->Y;
					
					SparkleSpriteAnim(iceX+DirX(iceShot->Dir, -4)+Rand(-4, 4), iceY+DirY(iceShot->Dir, -4)+Rand(-4, 4), 126, 1, 1);
					
					Waitframe();
				}
				npc target;
				for(i=Screen->NumNPCs(); i>0; --i){
					npc n = Screen->LoadNPC(i);
					if(GetEnemyProperty(n, ENPROP_HP)<=0){
						if(RectCollision(iceX, iceY, iceX+15, iceY+15, n->X+n->HitXOffset, n->Y+n->HitYOffset, n->X+n->HitXOffset+n->HitWidth-1, n->Y+n->HitYOffset+n->HitHeight-1)){
							target = n;
							break;
						}
					}
				}
				if(target->isValid()){
					int args[8] = {target->X, target->Y, damageIce*G[G_HPSCALE]};
					target->ItemSet = 0;
					RunFFCScript(FFCS_ICEBLOCK, args);
					SetEnemyProperty(target, ENPROP_HP, -1000);
					SetEnemyProperty(target, ENPROP_Y, -1000);
				}
			}
			else if(chargeTier==3){
				addLightning(lwLightning, lightning, Link->X+8+DirX(Link->Dir, 8), Link->Y+8+DirY(Link->Dir, 8), DirAngle(Link->Dir), damageThunder, 0);
				lightning[0] = 1;
				while(lightning[0]){
					updateLightning(lwLightning, lightning);
					Waitframe();
				}
			}
		}
		G[G_SIGCOOLDOWN] = 0;
		G[G_PRESERVEDCHARGEA] = 0;
	}
	int drawElementalStaffCharge(int counter, int chargeTier){
		++counter;
		counter %= 360;
		
		if(counter%4==0){
			for(int i=0; i<3; ++i){
				int x = Link->X+VectorX(12*Sin(counter*4), counter*6+i*120);
				int y = Link->Y+VectorY(12*Sin(counter*4), counter*6+i*120);
				lweapon l = SpriteAnim(x, y, 123, 1, 1);
				if(chargeTier==2)
					l->CSet = 7;
				else if(chargeTier==3)
					l->CSet = 1;
			}
		}
		return counter;
	}
	void addLightning(lweapon lwLightning, int lightning, int x, int y, int angle, int damage, int split){
		int lightningBuffer = lightning[1];
		int lightningX = lightning[2];
		int lightningY = lightning[3];
		int lightningState = lightning[4];
		int lightningMaxDist = lightning[5];
		int lightningCurDist = lightning[6];
		int lightningSplit = lightning[7];
		
		for(int i=0; i<128; ++i){
			if(lightningState[i]==0){
				lwLightning[i] = FireLWeapon(LW_BEAM, x-8, y-8, DegtoRad(angle), 800, damage, SPR_INVISIBLE, SFX_LIGHTNING_STRIKE);
				lwLightning[i]->Dir = -1;
				lightningX[i] = x;
				lightningY[i] = y;
				lightningState[i] = 1;
				lightningMaxDist[i] = 0;
				lightningCurDist[i] = 0;
				lightningSplit[i] = split;
				
				LWLightningInit(lightningBuffer, i*64, x, y, 32, angle, 0, 24);
				return;
			}
		}
	}
	void updateLightning(lweapon lwLightning, int lightning){
		int lightningBuffer = lightning[1];
		int lightningX = lightning[2];
		int lightningY = lightning[3];
		int lightningState = lightning[4];
		int lightningMaxDist = lightning[5];
		int lightningCurDist = lightning[6];
		int lightningSplit = lightning[7];
		
		lightning[0] = 0;
		for(int i=0; i<128; ++i){
			if(lightningState[i]){
				++lightning[0];
				int c[2];
				if(Rand(2)==0){
					c[0] = 0x13;
					c[1] = 0x13;
				}
				else{
					c[0] = 0x12;
					c[1] = 0x13;
				}
				if(lightningState[i]==1){
					bool alive;
					if(lwLightning[i]->isValid()){
						if(Q7_InScreen(lwLightning[i]->X, lwLightning[i]->Y)){
							if(lwLightning[i]->DeadState==WDS_ALIVE||lwLightning[i]->Misc[LWM_MISCFLAGS]&LWMF_PIERCING)
								alive = true;
						}
						else{
							lwLightning[i]->Misc[LWM_MISCFLAGS]&=~LWMF_PIERCING;
						}
					}
					if(alive&&lwLightning[i]->isValid()){
						lightningX[i] = lwLightning[i]->X+8;
						lightningY[i] = lwLightning[i]->Y+8;
						lightningMaxDist[i] = Distance(lightningX[i], lightningY[i], lightningBuffer[i*64], lightningBuffer[i*64+1]);
					}
					else{
						if(lightningSplit[i]==0){
							if(lightningX[i]>16&&lightningX[i]<240&&lightningY[i]>16&&lightningY[i]<160)
								splitLightning(lwLightning, lightning, lightningX[i], lightningY[i], 24*G[G_HPSCALE]);
						}
						else if(lightningSplit[i]==1){
							int ang = Rand(360);
							for(int j=0; j<3; ++j){
								addLightning(lwLightning, lightning, lightningX[i], lightningY[i], ang+120*j, 24*G[G_HPSCALE], 2);
							}
						}
						lightningState[i] = 2;
					}
					LWLightningUpdate(lightningBuffer, i*64, 32, 0, lightningMaxDist[i], 320, c[0], c[1], 0);
				}
				else if(lightningState[i]==2){
					if(Abs(lightningCurDist[i]-lightningMaxDist[i])>8){
						lightningCurDist[i] += 8;
					}
					else{
						lightningState[i] = 0;
					}
					LWLightningUpdate(lightningBuffer, i*64, 32, lightningCurDist[i], lightningMaxDist[i], 320, c[0], c[1], 0);
				}
			}
		}
	}
	void splitLightning(lweapon lwLightning, int lightning, int x, int y, int damage){
		int i;
		npc allTargets[256];
		int numTargets;
		for(i=Screen->NumNPCs(); i>0; --i){
			npc n = Screen->LoadNPC(i);
			if(n->Type!=NPCT_FAIRY&&n->Type!=NPCT_PROJECTILE&&n->CollDetection){
				allTargets[numTargets] = n;
				++numTargets;
			}
		}
		for(i=0; i<numTargets*2; ++i){
			int r1 = Rand(numTargets);
			int r2 = Rand(numTargets);
			npc old = allTargets[r2];
			allTargets[r2] = allTargets[r1];
			allTargets[r1] = old;
		}
		int maxTarget = Min(numTargets, 10);
		for(i=0; i<maxTarget; ++i){
			int angle = Angle(x, y, CenterX(allTargets[i]), CenterY(allTargets[i]));
			addLightning(lwLightning, lightning, x, y, angle, damage, 1);
		}
	}
	void runReflector(){
		Game->PlaySound(SFX_HOLM_REFLECTOR);
		int i; int j; int k;
		int x; int y;
		int dist; int ang;
		
		int reflectorContactDamage = SwordDamageLevel(1, 2, 3, 4)*G[G_HPSCALE]; 
		int reflectorDamage = SwordDamageLevel(4, 8, 12, 16)*G[G_HPSCALE];
		// int trailX[128];
		// int trailY[128];
		
		int oX[32];
		int oY[32];
		int oA[32];
		
		int endPoint[4];
		int shieldX[4];
		int shieldY[4];
		
		bool reflected[2];
		
		int til;
		
		int fireAngle = DirAngle(Link->Dir);
		int fireDir = Link->Dir;
		
		int timeExtend = 24;
		int timeRetract = 12;
		int sinSpeed = 720/timeExtend;
		int sinScale = 16;
		
		for(i=0; i<16; ++i){
			oX[i] = Link->X+8;
			oY[i] = Link->Y+8;
			
			oX[i+16] = Link->X+8;
			oY[i+16] = Link->Y+8;
		}
		G[G_SWORDSHOOTERFLAG] = 2;
		for(i=0; i<timeExtend+timeRetract; ++i){
			if(i<timeExtend){
				shieldX[0] = Link->X+VectorX((i/(timeExtend))*32, fireAngle)+VectorX((i/timeExtend)*sinScale*Sin(i*sinSpeed), fireAngle+90);
				shieldY[0] = Link->Y+VectorY((i/(timeExtend))*32, fireAngle)+VectorY((i/timeExtend)*sinScale*Sin(i*sinSpeed), fireAngle+90);
				
				shieldX[2] = shieldX[0];
				shieldY[2] = shieldY[0];
				
				shieldX[1] = Link->X+VectorX((i/(timeExtend))*32, fireAngle)+VectorX(-(i/timeExtend)*sinScale*Sin(i*sinSpeed), fireAngle+90);
				shieldY[1] = Link->Y+VectorY((i/(timeExtend))*32, fireAngle)+VectorY(-(i/timeExtend)*sinScale*Sin(i*sinSpeed), fireAngle+90);
				
				shieldX[3] = shieldX[1];
				shieldY[3] = shieldY[1];
			}
			else{
				x = (shieldX[2]+shieldX[3])/2;
				y = (shieldY[2]+shieldY[3])/2;
				dist = Distance(x, y, Link->X, Link->Y);
				ang = Angle(x, y, Link->X, Link->Y);
				
				j = i-timeExtend;
				
				shieldX[0] = x+VectorX(dist*(j/timeRetract), ang)+VectorX(((timeExtend-j)/timeExtend)*sinScale*Sin(i*sinSpeed), ang-90);
				shieldY[0] = y+VectorY(dist*(j/timeRetract), ang)+VectorY(((timeExtend-j)/timeExtend)*sinScale*Sin(i*sinSpeed), ang-90);
				
				shieldX[1] = x+VectorX(dist*(j/timeRetract), ang)+VectorX(-((timeExtend-j)/timeExtend)*sinScale*Sin(i*sinSpeed), ang-90);
				shieldY[1] = y+VectorY(dist*(j/timeRetract), ang)+VectorY(-((timeExtend-j)/timeExtend)*sinScale*Sin(i*sinSpeed), ang-90);
			}
			
			x = shieldX[0];
			y = shieldY[0];
			
			for(j=0; j<=15; ++j){
				if(j==15){
					if(Distance(oX[j], oY[j], x+8, y+8)<1)
						oA[j] = oA[j-1];
					else
						oA[j] = Angle(oX[j], oY[j], x+8, y+8);
					oX[j] = x+8;
					oY[j] = y+8;
				}
				else{
					oA[j] = oA[j+1];
					oX[j] = oX[j+1];
					oY[j] = oY[j+1];
				}
			}
			
			DrawQuadTrail(2, oX, oY, oA, 0, Min(i, 15), 12, 0x02);
			
			x = shieldX[1];
			y = shieldY[1];
			
			for(j=0; j<=15; ++j){
				if(j==15){
					if(Distance(oX[j+16], oY[j+16], x+8, y+8)<1)
						oA[j+16] = oA[j+16-1];
					else
						oA[j+16] = Angle(oX[j+16], oY[j+16], x+8, y+8);
					oX[j+16] = x+8;
					oY[j+16] = y+8;
				}
				else{
					oA[j+16] = oA[j+16+1];
					oX[j+16] = oX[j+16+1];
					oY[j+16] = oY[j+16+1];
				}
			}
			
			DrawQuadTrail(2, oX, oY, oA, 16, 16+Min(i, 15), 12, 0x01);
			
			x = shieldX[0];
			y = shieldY[0];
			
			til = 5676;
			if(i>=32)
				til = 5677;
			
			Screen->FastTile(2, x, y, til, 11, 128);
			
			lweapon hitbox = MakeHitbox(LW_BEAM, x+2, y+2, 12, 12, fireDir, reflectorContactDamage);
			if(i<timeExtend){
				hitbox->Misc[LWM_CHARMODS] = CHAR_HOLM;
				LWeaponPickup(hitbox);
				reflectorDoReflections(hitbox, x, y, reflectorDamage, reflected, 0);
			}
			
			x = shieldX[1];
			y = shieldY[1];
			
			Screen->FastTile(2, x, y, til, 11, 128);
			
			hitbox = MakeHitbox(LW_BEAM, x+2, y+2, 12, 12, fireDir, reflectorContactDamage);
			if(i<timeExtend){
				hitbox->Misc[LWM_CHARMODS] = CHAR_HOLM;
				LWeaponPickup(hitbox);
				reflectorDoReflections(hitbox, x, y, reflectorDamage, reflected, 1);
			}
			
			Waitframe();
		}
		for(i=0; i<16; i+=2){
			DrawQuadTrail(2, oX, oY, oA, 0+Min(i, 15), 15, 12*(16-i)/16, 0x02);
			
			DrawQuadTrail(2, oX, oY, oA, 16+Min(i, 15), 16+15, 12*(16-i)/16, 0x01);
			
			Waitframe();
		}
	}
	void reflectorDoReflections(lweapon l, int lwX, int lwY, int damageReflection, bool reflected, int which){
		lweapon copy;
		for(int i=Screen->NumEWeapons(); i>0; --i){
			eweapon e = Screen->LoadEWeapon(i);
			
			bool collDetection = e->CollDetection;
			if(collDetection&&e->TileWidth<=1&&e->TileHeight<=1&&e->Damage>0&&e->DeadState!=WDS_DEAD){
				int x = e->X+e->HitXOffset;
				int y = e->Y+e->HitYOffset;
				if(RectCollision(lwX+2, lwY+2, lwX+13, lwY+13, x, y, x+e->HitWidth-1, y+e->HitHeight-1)){
					int refAngle = Angle(Link->X, Link->Y, CenterHitX(e)-8, CenterHitY(e)-8);
					npc target = Generic_FindTarget(NPCD_SCRIPT, CenterHitX(e)-8, CenterHitY(e)-8, refAngle);
					//FireEWeapon(EW_BOMBBLAST, CenterX(target)-8, CenterY(target)-8, 0, 0, 0, 0, 0, 0);
					if(target->isValid())
						refAngle = Angle(CenterHitX(e)-8, CenterHitY(e)-8, CenterX(target)-8, CenterY(target)-8);
					if(e->ID==EW_BOMBBLAST||e->ID==EW_SBOMBBLAST||e->Misc[__EWI_ON_DEATH]==EWD_VANISH&&e->Misc[__EWI_LIFESPAN]==EWL_TIMER&&e->Misc[__EWI_LIFESPAN_ARG]<2){
						if(!reflected[which]){
							for(int j=0; j<5; ++j){
								copy = FireLWeapon(LW_SCRIPT10, e->X+e->HitXOffset+e->HitWidth/2-8, e->Y+e->HitYOffset+e->HitHeight/2-8, DegtoRad(refAngle), 300+50*j, damageReflection, 17, SFX_HOLM_REFLECT);
								copy->CSet = 11;
								if(Q7_HasRing(I_SPRING10_HOLM))
									copy->Damage += 4*G[G_HPSCALE];
							}
							e->DeadState = 0;
							reflected[which] = true;
						}
					}
					else{
						int type = LW_SCRIPT10;
						if(e->ID==EW_FIRE)
							type = LW_FIRE;
						copy = FireLWeapon(type, e->X, e->Y, DegtoRad(refAngle), 150+e->Step, damageReflection, 17, SFX_HOLM_REFLECT);
						if(Q7_HasRing(I_SPRING10_HOLM))
							copy->Damage += 4*G[G_HPSCALE];
						reflectorTransferGFX(e, copy, refAngle);
						e->DeadState = 0;
						reflected[which] = true;
					}
				}
			}
		}
	}
	void reflectorTransferGFX(eweapon old, lweapon new, int angNew){
		new->OriginalTile = old->OriginalTile;
		new->Tile = old->Tile;
		new->CSet = old->CSet;
		new->NumFrames = old->NumFrames;
		new->ASpeed = old->ASpeed;
	}
	void runSirknightScythe(){
		int i; int j; int k;
		int angle; int dist;
		
		int dir = Link->Dir;
		int baseAng = DirAngle(dir);
		
		int damage = SwordDamageLevel(2, 4, 6, 12)*G[G_HPSCALE];
		int comboLevel = SwordDamageLevel(1, 2, 3, 3);
		
		int tipX; int tipY;
		int handleX; int handleY;
		
		int startAngT; int endAngT;
		int startAngH; int endAngH;
		int minDistT; int maxDistT;
		int minDistH; int maxDistH;
		int frames;
		
		//So this shit is way more complicated than it needs to be
		//I was going to play with disjointed angles to try and make the animation look more natural, but it ended up being the opposite.
		
		startAngT = -120;
		endAngT = 90;
		startAngH = -120;
		endAngH = 90;
		
		minDistT = 16;
		maxDistT = 24;
		minDistH = 0;
		maxDistH = 0;
		
		int trailX[48];
		int trailY[48];
		int trailA[48];
		
		frames = 12;
		Game->PlaySound(SFX_ZARATHSLASH);
		int bufferedInput;
		
		trailX[16*0] = 1;
		trailX[16*0+1] = 0;
		
		G[G_SWORDSHOOTERFLAG] = 2;
		for(i=0; i<frames; ++i){
			angle = Q7_Interpolate(startAngT, endAngT, i, frames);
			dist = Q7_InterpolateSin(minDistT, maxDistT, i, frames);
			
			tipX = Link->X+8+VectorX(dist, baseAng+angle);
			tipY = Link->Y+8+VectorY(dist, baseAng+angle);
			
			// Screen->PutPixel(6, tipX, tipY, 0x81, 0, 0, 0, 128);
			
			angle = Q7_Interpolate(startAngH, endAngH, i, frames);
			dist = Q7_InterpolateSin(minDistH, maxDistH, i, frames);
			
			handleX = Link->X+8+VectorX(dist, baseAng+angle);
			handleY = Link->Y+8+VectorY(dist, baseAng+angle);
			
			// Screen->PutPixel(6, handleX, handleY, 0x81, 0, 0, 0, 128);
			
			sirknightUpdateTrails(tipX, tipY, 0, i==0, trailX, trailY, trailA);
			sirknightScytheDraw(tipX, tipY, handleX, handleY, false, dir, damage);
			
			if(i!=0&&Link->PressA){
				bufferedInput = 1;
			}
			
			Link->Action = LA_NONE;
			if(i<6)
				Link->Action = LA_ATTACKING;
			
			WaitNoAction();
		}
		
		trailX[16*0] = 2;
		
		if(bufferedInput>=1&&comboLevel>=2){
			startAngT = 120;
			endAngT = -90;
			startAngH = 120;
			endAngH = -90;
			
			minDistT = 16;
			maxDistT = 32;
			minDistH = 0;
			maxDistH = 0;
			
			frames = 12;
			Game->PlaySound(SFX_ZARATHSLASH);
			
			trailX[16*1] = 1;
			trailX[16*1+1] = 0;
			
			G[G_SWORDSHOOTERFLAG] = 2;
			for(i=0; i<frames; ++i){
				angle = Q7_Interpolate(startAngT, endAngT, i, frames);
				dist = Q7_InterpolateSin(minDistT, maxDistT, i, frames);
				
				tipX = Link->X+8+VectorX(dist, baseAng+angle);
				tipY = Link->Y+8+VectorY(dist, baseAng+angle);
				
				// Screen->PutPixel(6, tipX, tipY, 0x81, 0, 0, 0, 128);
				
				angle = Q7_Interpolate(startAngH, endAngH, i, frames);
				dist = Q7_InterpolateSin(minDistH, maxDistH, i, frames);
				
				handleX = Link->X+8+VectorX(dist, baseAng+angle);
				handleY = Link->Y+8+VectorY(dist, baseAng+angle);
				
				// Screen->PutPixel(6, handleX, handleY, 0x81, 0, 0, 0, 128);
				
				sirknightUpdateTrails(tipX, tipY, 1, i==0, trailX, trailY, trailA);
				sirknightScytheDraw(tipX, tipY, handleX, handleY, true, dir, damage);
				
				if(i!=0&&Link->PressA){
					bufferedInput = 2;
				}
				
				Link->Action = LA_NONE;
				if(i<6){
					LinkMovement_Push(DirX(dir, 2), DirY(dir, 2));
					Link->Action = LA_ATTACKING;
				}
				
				WaitNoAction();
			}
			
			trailX[16*1] = 2;
		}
		if(bufferedInput>=2&&comboLevel>=3){
			startAngT = -160;
			endAngT = 120;
			startAngH = -160;
			endAngH = 120;
			
			minDistT = 32;
			maxDistT = 16;
			minDistH = 0;
			maxDistH = 0;
			
			frames = 12;
			Game->PlaySound(SFX_ZARATHSLASH);
			
			trailX[16*2] = 1;
			trailX[16*2+1] = 0;
			
			G[G_SWORDSHOOTERFLAG] = 2;
			for(i=0; i<frames; ++i){
				angle = Q7_Interpolate(startAngT, endAngT, i, frames);
				dist = Q7_InterpolateSin(minDistT, maxDistT, i, frames);
				
				tipX = Link->X+8+VectorX(dist, baseAng+angle);
				tipY = Link->Y+8+VectorY(dist, baseAng+angle);
				
				// Screen->PutPixel(6, tipX, tipY, 0x81, 0, 0, 0, 128);
				
				angle = Q7_Interpolate(startAngH, endAngH, i, frames);
				dist = Q7_InterpolateSin(minDistH, maxDistH, i, frames);
				
				handleX = Link->X+8+VectorX(dist, baseAng+angle);
				handleY = Link->Y+8+VectorY(dist, baseAng+angle);
				
				// Screen->PutPixel(6, handleX, handleY, 0x81, 0, 0, 0, 128);
				
				sirknightUpdateTrails(tipX, tipY, 2, i==0, trailX, trailY, trailA);
				sirknightScytheDraw(tipX, tipY, handleX, handleY, false, dir, damage);
				
				Link->Action = LA_NONE;
				if(i<6){
					LinkMovement_Push(DirX(dir, 1), DirY(dir, 1));
					Link->Action = LA_ATTACKING;
				}
				
				WaitNoAction();
			}
		
			trailX[16*2] = 2;
		}
		
		for(i=0; i<8; ++i){
			sirknightUpdateTrails(tipX, tipY, -1, false, trailX, trailY, trailA);
			Waitframe();
		}
	}
	void sirknightScytheDraw(int tipX, int tipY, int handleX, int handleY, bool flip, int dir, int damage){
		int x = tipX-24;
		int y = tipY-24;
		
		int angle = Angle(handleX, handleY, tipX, tipY);
		
		x += VectorX(-24, angle);
		y += VectorY(-24, angle);
		
		int tflip = 0;
		if(flip)
			tflip = 2;
		
		Screen->DrawTile(2, x, y, 7957, 3, 3, 10, -1, -1, x, y, angle, tflip, true, 128);
	
		if(flip){
			x = tipX-8;
			y = tipY-8;
			x += VectorX(-12, angle);
			y += VectorY(-12, angle);
			lweapon l = MakeHitbox(LW_BEAM, x+2, y+2, 12, 12, dir, damage);
			LWeaponPickup(l);
			x += VectorX(16, angle-90);
			y += VectorY(16, angle-90);
			l = MakeHitbox(LW_BEAM, x+2, y+2, 12, 12, dir, damage);
			LWeaponPickup(l);
		}
		else{
			x = tipX-8;
			y = tipY-8;
			x += VectorX(-12, angle);
			y += VectorY(-12, angle);
			lweapon l = MakeHitbox(LW_BEAM, x+2, y+2, 12, 12, dir, damage);
			LWeaponPickup(l);
			x += VectorX(16, angle+90);
			y += VectorY(16, angle+90);
			l = MakeHitbox(LW_BEAM, x+2, y+2, 12, 12, dir, damage);
			LWeaponPickup(l);
		}
	}
	void sirknightUpdateTrails(int x, int y, int which, bool firstFrame, int oX, int oY, int oA){
		int i; int j;
		
		int index = 16*which+4;
		int index2;
		if(which!=-1){
			if(firstFrame){
				for(i=0; i<=8; ++i){
					oX[index+i] = x;
					oY[index+i] = y;
				}
			}
			for(i=0; i<=8; ++i){
				if(i==8){
					if(Distance(oX[index+i], oY[index+i], x, y)<1)
						oA[index+i] = oA[index+i-1];
					else
						oA[index+i] = Angle(oX[index+i], oY[index+i], x, y);
					oX[index+i] = x;
					oY[index+i] = y;
				}
				else{
					oA[index+i] = oA[index+i+1];
					oX[index+i] = oX[index+i+1];
					oY[index+i] = oY[index+i+1];
				}
			}
		}
		
		for(j=0; j<3; ++j){
			index2 = 16*j;
			
			int tempTrailX[9];
			int tempTrailY[9];
			int tempTrailA[9];
			for(i=0; i<=8; ++i){
				tempTrailX[i] = oX[index2+4+i];
				tempTrailY[i] = oY[index2+4+i];
				tempTrailA[i] = oA[index2+4+i];
			}
			if(oX[index2]==1){ // Expanding
				oX[index2+1] = Min(oX[index2+1]+1, 8);
				
				DrawQuadTrail(2, tempTrailX, tempTrailY, tempTrailA, 0, oX[index2+1], 6+Rand(2), Choose(0x81, 0x0F));
			}
			else if(oX[index2]==2){ //Retracting
				oX[index2+1] = Max(oX[index2+1]-1, 0);
				
				DrawQuadTrail(2, tempTrailX, tempTrailY, tempTrailA, 0, oX[index2+1], 6+Rand(2), Choose(0x81, 0x0F));
				if(oX[index2+1]==0)
					oX[index2] = 0;
			}
		}
	}
	void runSpearBow(){
		int i; int j; int k;
		
		int dir = Link->Dir;
		
		int damage = SwordDamageLevel(2, 4, 8, 12)*G[G_HPSCALE];
		int level = SwordDamageLevel(1, 2, 3, 4);
		
		for(i=0; i<8; ++i){
			Link->Action = LA_NONE;
			Link->Action = LA_ATTACKING;
				
			if(level==1){
				SetInvisible();
				if(!CountFFCsRunning(FFCS_UTILITY))
					Screen->FastTile(2, Link->X+Link->DrawXOffset, Link->Y+Link->DrawYOffset, 16624+dir, 6, 128);
				
				if(dir==DIR_UP){
					Screen->DrawTile(4, Link->X-6, Link->Y-6, 16556, 1, 1, 8, -1, -1, 0, 0, 0, 0, true, 128);
				}
				else if(dir==DIR_DOWN){
					Screen->DrawTile(4, Link->X+6, Link->Y-6, 16556, 1, 1, 8, -1, -1, 0, 0, 0, 2, true, 128);
				}
				else if(dir==DIR_LEFT){
					Screen->DrawTile(4, Link->X, Link->Y-6, 16557, 1, 1, 8, -1, -1, 0, 0, 0, 1, true, 128);
				}
				else if(dir==DIR_RIGHT){
					Screen->DrawTile(4, Link->X, Link->Y-6, 16557, 1, 1, 8, -1, -1, 0, 0, 0, 0, true, 128);
				}
			}
			else{
				int bowCSet = 8;
				if(level==4)
					bowCSet = 11;
				if(dir==DIR_UP){
					Screen->DrawTile(2, Link->X, Link->Y-2, 16554, 1, 1, bowCSet, -1, -1, 0, 0, 0, 0, true, 128);
				}
				else if(dir==DIR_DOWN){
					Screen->DrawTile(4, Link->X, Link->Y+2, 16554, 1, 1, bowCSet, -1, -1, 0, 0, 0, 2, true, 128);
				}
				else if(dir==DIR_LEFT){
					Screen->DrawTile(4, Link->X-2, Link->Y+2, 16555, 1, 1, bowCSet, -1, -1, 0, 0, 0, 1, true, 128);
				}
				else if(dir==DIR_RIGHT){
					Screen->DrawTile(4, Link->X+2, Link->Y+2, 16555, 1, 1, bowCSet, -1, -1, 0, 0, 0, 0, true, 128);
				}
			}
			
			WaitNoAction();
		}
		G[G_SWORDSHOOTERFLAG] = 2;
		lweapon l;
		if(level==1){
			l = FireLWeapon(LW_BEAM, Link->X+DirX(dir, 8), Link->Y+DirY(dir, 8), DegtoRad(DirAngle(Link->Dir)), 250, damage, 0, 0);
			l->Tile = 16556;
			l->OriginalTile = l->Tile;
			l->CSet = 8;
			if(dir>1){
				++l->Tile;
				l->Y += 2;
			}
			if(dir==DIR_DOWN)
				l->Flip = 2;
			if(dir==DIR_LEFT)
				l->Flip = 1;
			l->Misc[LWM_DEATHTIMER] = 20;
			l->Misc[LWM_MISCFLAGS] = LWMF_FAKEARROW;
		}
		else if(level==2){
			for(i=0; i<2; ++i){
				l = FireLWeapon(LW_BEAM, Link->X+DirX(dir, 8), Link->Y+DirY(dir, 8), DegtoRad(DirAngle(Link->Dir)), 350, damage, 0, 0);
				l->Tile = 16576;
				l->OriginalTile = l->Tile;
				l->CSet = 8;
				if(dir>1){
					++l->Tile;
					l->Y += 2;
				}
				if(dir==DIR_DOWN)
					l->Flip = 2;
				if(dir==DIR_LEFT)
					l->Flip = 1;
				l->Misc[LWM_DEATHTIMER] = 25;
				l->Misc[LWM_MISCFLAGS] = LWMF_FAKEARROW;
			}
		}
		else if(level==3){
			for(i=0; i<3; ++i){
				l = FireLWeapon(LW_BEAM, Link->X+DirX(dir, 8), Link->Y+DirY(dir, 8), DegtoRad(DirAngle(Link->Dir)), 450, damage, 0, 0);
				l->Tile = 16576;
				l->OriginalTile = l->Tile;
				l->CSet = 10;
				if(dir>1){
					++l->Tile;
					l->Y += 2;
				}
				if(dir==DIR_DOWN)
					l->Flip = 2;
				if(dir==DIR_LEFT)
					l->Flip = 1;
				l->Misc[LWM_DEATHTIMER] = 30;
				l->Misc[LWM_MISCFLAGS] = LWMF_FAKEARROW;
			}
		}
		else if(level==4){
			int charge = 0;
			i = 0;
			while(Link->InputA){
				++i;
				i %= 360;
				
				if(charge<90)
					++charge;
				
				if(charge==60)
					Game->PlaySound(SFX_CHARGE1);
				
				dir = Link->Dir;
				
				int bowCSet = 11;
				if(dir==DIR_UP){
					Screen->DrawTile(2, Link->X, Link->Y-2, 16554, 1, 1, bowCSet, -1, -1, 0, 0, 0, 0, true, 128);
				}
				else if(dir==DIR_DOWN){
					Screen->DrawTile(4, Link->X, Link->Y+2, 16554, 1, 1, bowCSet, -1, -1, 0, 0, 0, 2, true, 128);
				}
				else if(dir==DIR_LEFT){
					Screen->DrawTile(4, Link->X-2, Link->Y+2, 16555, 1, 1, bowCSet, -1, -1, 0, 0, 0, 1, true, 128);
				}
				else if(dir==DIR_RIGHT){
					Screen->DrawTile(4, Link->X+2, Link->Y+2, 16555, 1, 1, bowCSet, -1, -1, 0, 0, 0, 0, true, 128);
				}
				
				if(i%2==0)
					NoWalk();
				
				Waitframe();
			}
			if(charge>=60){
				for(j=0; j<3; ++j){
					for(i=-2; i<=2; ++i){
						l = FireLWeapon(LW_BEAM, Link->X+DirX(dir, 8), Link->Y+DirY(dir, 8), DegtoRad(DirAngle(Link->Dir)+25*i), 450, damage, 0, 0);
						l->Tile = 16596;
						l->OriginalTile = l->Tile;
						l->CSet = 1;
						if(dir>1){
							++l->Tile;
							l->Y += 2;
						}
						if(dir==DIR_DOWN)
							l->Flip = 2;
						if(dir==DIR_LEFT)
							l->Flip = 1;
						l->Misc[LWM_DEATHTIMER] = 30;
						l->Misc[LWM_MISCFLAGS] = LWMF_FAKEARROW;
					}
				}
			}
			else{
				for(j=0; j<3; ++j){
					l = FireLWeapon(LW_BEAM, Link->X+DirX(dir, 8), Link->Y+DirY(dir, 8), DegtoRad(DirAngle(Link->Dir)), 450, damage, 0, 0);
					l->Tile = 16596;
					l->OriginalTile = l->Tile;
					l->CSet = 1;
					if(dir>1){
						++l->Tile;
						l->Y += 2;
					}
					if(dir==DIR_DOWN)
						l->Flip = 2;
					if(dir==DIR_LEFT)
						l->Flip = 1;
					l->Misc[LWM_DEATHTIMER] = 30;
					l->Misc[LWM_MISCFLAGS] = LWMF_FAKEARROW;
				}
			}
		}
		Game->PlaySound(SFX_ARROW);
		int oldX = Link->X;
		int oldY = Link->Y;
		int vX; int vY;
		if(level==1)
			LinkMovement_Push(DirX(dir, 4), DirY(dir, 4));
		for(i=0; i<8; ++i){
			if(i==1){
				vX = Link->X-oldX;
				vY = Link->Y-oldY;
			}
			Link->Action = LA_NONE;
			Link->Action = LA_ATTACKING;
			
			if(level>1){
				int bowCSet = 8;
				if(level==4)
					bowCSet = 11;
				if(dir==DIR_UP){
					Screen->DrawTile(2, Link->X, Link->Y-2, 16554, 1, 1, bowCSet, -1, -1, 0, 0, 0, 0, true, 128);
				}
				else if(dir==DIR_DOWN){
					Screen->DrawTile(4, Link->X, Link->Y+2, 16554, 1, 1, bowCSet, -1, -1, 0, 0, 0, 2, true, 128);
				}
				else if(dir==DIR_LEFT){
					Screen->DrawTile(4, Link->X-2, Link->Y+2, 16555, 1, 1, bowCSet, -1, -1, 0, 0, 0, 1, true, 128);
				}
				else if(dir==DIR_RIGHT){
					Screen->DrawTile(4, Link->X+2, Link->Y+2, 16555, 1, 1, bowCSet, -1, -1, 0, 0, 0, 0, true, 128);
				}
			}
			
			WaitNoAction();
		}
		if(level==1)
			LinkMovement_Push(-vX, -vY);
	}
	void runSummonStaff(ffc this){
		if(Link->Invisible)
			Quit();
		int damage = SwordDamageLevel(1, 1.5, 2, 3)*G[G_HPSCALE];
		int maxSummon = SwordDamageLevel(1, 2, 3, 4);
		int maxSummonLevel = SwordDamageLevel(0, 1, 2, 3);
		int dir = Link->Dir;
		int i;
		int x; int y;
		Game->PlaySound(SFX_SWORD);
		G[G_SWORDSHOOTERFLAG] = 2;
		for(i=0; i<12; ++i){
			x = Link->X+DirX(dir, 14);
			y = Link->Y+DirY(dir, 14);
			if(dir==DIR_UP)
				Screen->DrawTile(2, x, y, TIL_SUMMONSTAFF, 1, 1, 7, -1, -1, 0, 0, 0, 0, true, 128);
			else if(dir==DIR_DOWN)
				Screen->DrawTile(2, x, y, TIL_SUMMONSTAFF, 1, 1, 7, -1, -1, 0, 0, 0, 2, true, 128);
			else if(dir==DIR_LEFT)
				Screen->DrawTile(2, x, y, TIL_SUMMONSTAFF+1, 1, 1, 7, -1, -1, 0, 0, 0, 1, true, 128);
			else if(dir==DIR_RIGHT)
				Screen->DrawTile(2, x, y, TIL_SUMMONSTAFF+1, 1, 1, 7, -1, -1, 0, 0, 0, 0, true, 128);
			Link->Action = LA_NONE;
			Link->Action = LA_ATTACKING;
			MakeHitbox(LW_BEAM, x, y, 16, 16, dir, damage);
			WaitNoAction();
		}
		for(i=0; i<4; ++i){
			x = Link->X+DirX(dir, 14-(i/4)*14);
			y = Link->Y+DirY(dir, 14-(i/4)*14);
			if(dir==DIR_UP)
				Screen->DrawTile(2, x, y, TIL_SUMMONSTAFF, 1, 1, 7, -1, -1, 0, 0, 0, 0, true, 128);
			else if(dir==DIR_DOWN)
				Screen->DrawTile(2, x, y, TIL_SUMMONSTAFF, 1, 1, 7, -1, -1, 0, 0, 0, 2, true, 128);
			else if(dir==DIR_LEFT)
				Screen->DrawTile(2, x, y, TIL_SUMMONSTAFF+1, 1, 1, 7, -1, -1, 0, 0, 0, 1, true, 128);
			else if(dir==DIR_RIGHT)
				Screen->DrawTile(2, x, y, TIL_SUMMONSTAFF+1, 1, 1, 7, -1, -1, 0, 0, 0, 0, true, 128);
			Link->Action = LA_NONE;
			Link->Action = LA_ATTACKING;
			MakeHitbox(LW_BEAM, x, y, 16, 16, dir, damage);
			WaitNoAction();
		}
		Link->Action = LA_NONE;
		
		for(i=0; i<8&&Link->InputA; ++i){
			Waitframe();
		}
		if(Link->InputA){
			int summonCount = CountFFCsRunning(FFCS_NORASUMMON);
			int chargeTier = -2;
			int chargeTimer = 40;
			while(Link->InputA){
				--chargeTimer;
				if(chargeTimer<=0){
					if(summonCount<maxSummon){
						Game->PlaySound(SFX_PETALSHIELD_ABSORB);
						if(chargeTier==-2)
							chargeTier = 0;
						else{
							++chargeTier;
							if(chargeTier>maxSummonLevel)
								chargeTier = -1;
						}
					}
					else{
						if(chargeTier==-2){
							Game->PlaySound(SFX_PETALSHIELD_ABSORB);
							chargeTier = -1;
						}
					}
					chargeTimer = 40;
				}
				
				if(chargeTier!=-2)
					Screen->FastTile(6, Link->X, Link->Y-16, 5495, 11, 128);
				if(chargeTier==-1)
					Screen->FastTile(6, Link->X, Link->Y-16-2, 5574, 0, 128);
				else if(chargeTier>-1)
					Screen->FastTile(6, Link->X, Link->Y-16-2, 5494+chargeTier*20, 0, 128);
				
				Waitframe();
			}
			if(chargeTier==-1){
				for(i=1; i<=32; ++i){
					ffc f = Screen->LoadFFC(i);
					if(f->Script==FFCS_NORASUMMON)
						f->InitD[3] = 1;
				}
			}
			else if(chargeTier>-1){
				Game->PlaySound(SFX_PETALSHIELD_ACTIVATE);
				this->Flags[FFCF_IGNOREHOLDUP] = true;
				for(i=32; i<64; i+=2){
					Screen->DrawCombo(2, Link->X+8-i/2, Link->Y+8-i/2, 736, 2, 2, 7, i, i, 0, 0, 0, -1, 0, true, 128);
					
					Link->Action = LA_NONE;
					Link->Action = LA_HOLD1LAND;
					WaitNoAction();
				}
				this->Flags[FFCF_IGNOREHOLDUP] = false;
				Link->Action = LA_NONE;
				int x = Link->X;
				int y = Link->Y;
				for(i=0; i<32; ++i){
					Screen->DrawCombo(2, x+8-64/2, y+8-64/2, 737, 2, 2, 7, 64, 64, 0, 0, 0, -1, 0, true, 128);
					
					Waitframe();
				}
				int args[8] = {x, y, chargeTier, 0, 1};
				RunFFCScript(FFCS_NORASUMMON, args);
			}
		}
		else{
			G[G_NORAATTACKCOMMAND] = 32;
		}
	}
	void runBite(){
		int i;
		int damage = SwordDamageLevel(2, 4, 8, 12)*G[G_HPSCALE];
		Game->PlaySound(Choose(132, 133, 134));
		G[G_SWORDSHOOTERFLAG] = 2;
		for(i=0; i<12; ++i){
			LinkMovement_Push(DirX(Link->Dir, 4), DirY(Link->Dir, 4));
			
			MakeHitbox(LW_BEAM, Link->X+InFrontX(Link->Dir, 4), Link->Y+InFrontY(Link->Dir, 4), 16, 16, Link->Dir, damage);
			
			Link->Action = LA_NONE;
			Link->Action = LA_ATTACKING;
			
			SetNoColl();
			
			Screen->DrawCombo(4, Link->X+DirX(Link->Dir, i/2), Link->Y+DirY(Link->Dir, i/2), 687, 1, 1, 8, -1, -1, Link->X+DirX(Link->Dir, i/2), Link->Y+DirY(Link->Dir, i/2), DirAngle(Link->Dir), -1, 0, true, 128);
			
			WaitNoAction();
		}
		Link->Action = LA_NONE;
		Link->Action = LA_ATTACKING;
		Waitframes(4);
	}
	void runEggplant(){
		if(Link->Invisible)
			Quit();
		int damage = SwordDamageLevel(1.5, 3, 5, 6.9)*G[G_HPSCALE];
		int tearDamage = SwordDamageLevel(2, 4, 8, 10)*G[G_HPSCALE];
		int numTears = SwordDamageLevel(1, 3, 6, 12);
		int dir = Link->Dir;
		int i;
		int x; int y;
		Game->PlaySound(SFX_SWORD);
		G[G_SWORDSHOOTERFLAG] = 2;
		bool shoot;
		for(i=0; i<12; ++i){
			x = Link->X+DirX(dir, 14);
			y = Link->Y+DirY(dir, 14);
			if(dir==DIR_UP)
				Screen->DrawTile(2, x, y, TIL_EGGPLANT, 1, 1, 10, -1, -1, 0, 0, 0, 0, true, 128);
			else if(dir==DIR_DOWN)
				Screen->DrawTile(2, x, y, TIL_EGGPLANT, 1, 1, 10, -1, -1, 0, 0, 0, 2, true, 128);
			else if(dir==DIR_LEFT)
				Screen->DrawTile(2, x, y, TIL_EGGPLANT+1, 1, 1, 10, -1, -1, 0, 0, 0, 1, true, 128);
			else if(dir==DIR_RIGHT)
				Screen->DrawTile(2, x, y, TIL_EGGPLANT+1, 1, 1, 10, -1, -1, 0, 0, 0, 0, true, 128);
			Link->Action = LA_NONE;
			Link->Action = LA_ATTACKING;
			MakeHitbox(LW_BEAM, x, y, 16, 16, dir, damage);
			for(int j=Screen->NumNPCs(); j>0; --j){
				npc n = Screen->LoadNPC(j);
				if(n->CollDetection&&n->Defense[NPCD_BEAM]!=NPCDT_BLOCK&&n->Defense[NPCD_BEAM]!=NPCDT_IGNORE&&Q7_NPCRectCollision(n, x, y, 16, 16)){
					shoot = true;
				}
			}
			WaitNoAction();
		}
		if(shoot){
			Game->PlaySound(135);
			Game->PlaySound(SFX_BEAM);
			int angle = DirAngle(Link->Dir);
			for(int j=0; j<numTears; ++j){
				int k = 10+5*numTears;
				int m = 300+10*numTears;
				lweapon tear = FireLWeapon(LW_BEAM, x, y, DegtoRad(angle+Rand(-k, k)), Rand(250, m), tearDamage, 0, 0);
				tear->Tile = TIL_EGGPLANT+20;
				tear->OriginalTile = tear->Tile;
				tear->CSet = 7;
				tear->Misc[LWM_ROTATION] = 1;
				tear->Misc[LWM_DEATHTIMER] = 16;
			}
		}
		for(i=0; i<4; ++i){
			x = Link->X+DirX(dir, 14-(i/4)*14);
			y = Link->Y+DirY(dir, 14-(i/4)*14);
			if(dir==DIR_UP)
				Screen->DrawTile(2, x, y, TIL_EGGPLANT, 1, 1, 7, -1, -1, 0, 0, 0, 0, true, 128);
			else if(dir==DIR_DOWN)
				Screen->DrawTile(2, x, y, TIL_EGGPLANT, 1, 1, 7, -1, -1, 0, 0, 0, 2, true, 128);
			else if(dir==DIR_LEFT)
				Screen->DrawTile(2, x, y, TIL_EGGPLANT+1, 1, 1, 7, -1, -1, 0, 0, 0, 1, true, 128);
			else if(dir==DIR_RIGHT)
				Screen->DrawTile(2, x, y, TIL_EGGPLANT+1, 1, 1, 7, -1, -1, 0, 0, 0, 0, true, 128);
			Link->Action = LA_NONE;
			Link->Action = LA_ATTACKING;
			MakeHitbox(LW_BEAM, x, y, 16, 16, dir, damage);
			WaitNoAction();
		}
		Link->Action = LA_NONE;
	}
	void runLightOrb(){
		int i;
		int bowCharge;
		int bowMinDamage = SwordDamageLevel(0.5, 1, 1.5, 2)*G[G_HPSCALE];
		int bowMaxDamage = SwordDamageLevel(2, 4, 8, 12)*G[G_HPSCALE];
		int shotAngle = DirAngle(Link->Dir);
		int aimPrecision = 5;
		while(Link->InputA||(bowCharge>0&&bowCharge<16)&&(Link->Action==LA_WALKING||Link->Action==LA_ATTACKING)){
			if(i<16)
				++i;
			if(i>15){
				int shotTargetAngle = DirAngle(Link->Dir);
				if(LinkMovement_StickX()!=0||LinkMovement_StickY()!=0){
					shotTargetAngle = WrapDegrees(DirAngle(AngleDir8(Angle(0, 0, LinkMovement_StickX(), LinkMovement_StickY()))));
				}
				shotAngle = TurnToAngle(shotAngle, shotTargetAngle, aimPrecision);
				if(shotAngle==-135||shotAngle==135)
					Link->Dir = DIR_LEFT;
				else if(shotAngle==-45||shotAngle==45)
					Link->Dir = DIR_RIGHT;
				else
					Link->Dir = AngleDir4(WrapDegrees(shotAngle));
				Link->Action = LA_NONE;
				Link->Action = LA_ATTACKING;
				int x = Link->X+VectorX(8, shotAngle);
				int y = Link->Y+VectorY(8, shotAngle);
				if(aimPrecision<5){
					Screen->Line(2, x+8, y+8, x+8+VectorX(256, shotAngle), y+8+VectorY(256, shotAngle), 0x0E, 1, 0, 0, 0, 128);
				}
				Screen->DrawTile(2, x, y, 16503, 1, 1, 1, -1, -1, x, y, shotAngle, 0, true, 128);
				if(bowCharge<60)
					++bowCharge;
				else{
					aimPrecision = Max(aimPrecision-0.1, 1);
				}
			}
			Waitframe();
		}
		if(i<16){
			if(!LinkBusy()){
				RunFFCScript(FFCS_ZELDASWORD, 0);
			}
		}
		else{
			G[G_SWORDSHOOTERFLAG] = 2;
			Game->PlaySound(SFX_ARROW);
			int damage = Lerp(bowMinDamage, bowMaxDamage, bowCharge/60);
			damage = Round(damage);
			lweapon arrow = FireLWeapon(LW_ARROW, Link->X+VectorX(8, shotAngle), Link->Y+VectorY(8, shotAngle), DegtoRad(shotAngle), Lerp(200, 800, bowCharge/60), damage, 0, 0);
			arrow->OriginalTile = 16505;
			arrow->Tile = arrow->OriginalTile;
			arrow->CSet = 1;
			arrow->Misc[LWM_ROTATION] = 1;
			arrow->Misc[LWM_DEATHTIMER] = 24;
		}
	}
	void runEnergySpear(){
		int damage = SwordDamageLevel(2, 4, 8, 10)*G[G_HPSCALE];
		int lifespan = SwordDamageLevel(16, 32, 256, 256);
		int delay = SwordDamageLevel(8, 6, 4, 4);
		int dir = Link->Dir;
		if(GetSwordLevel()==4){
			if(LinkMovement_StickX()!=0||LinkMovement_StickY()!=0)
				dir = AngleDir8(Angle(0, 0, LinkMovement_StickX(), LinkMovement_StickY()));
		}
		int angle = DirAngle(dir);
		G[G_SWORDSHOOTERFLAG] = 2;
		lweapon l = FireLWeapon(LW_BEAM, Link->X+VectorX(8, angle), Link->Y+VectorY(8, angle), DegtoRad(angle), 0, damage, 0, 0);
		int otil = 16648;
		int til = 16648;
		int flip = 0;
		if(GetSwordLevel()>2)
			til += 40;
		if(GetSwordLevel()==2)
			til += 20;
		if(dir==DIR_DOWN)
			flip = 2;
		if(dir==DIR_LEFT||dir==DIR_RIGHT){
			++til;
			if(dir==DIR_LEFT)
				flip = 1;
		}
		else if(dir>DIR_RIGHT){
			til += 3;
			if(dir==DIR_LEFTUP)
				flip = 1;
			else if(dir==DIR_LEFTDOWN)
				flip = 3;
			else if(dir==DIR_RIGHTDOWN)
				flip = 2;
		}
		l->Tile = til+6;
		l->OriginalTile = otil+6;
		l->CSet = 7;
		l->Flip = flip;
		l->CollDetection = false;
		l->Misc[LWM_MISCFLAGS] |= LWMF_DRAWOVER;
		for(int i=0; i<delay; ++i){
			Link->Action = LA_NONE;
			Link->Action = LA_ATTACKING;
			Waitframe();
		}
		Game->PlaySound(139);
		l->CollDetection = true;
		l->Tile = til;
		l->OriginalTile = otil;
		l->Misc[LWM_DEATHTIMER] = lifespan;
		for(int i=0; i<8; ++i){
			l->Step = Lerp(0, 400, i/8);
			Waitframe();
		}
		l->Step = 400;
	}
	void runGooshGooshGun(){
		int i; int j; int k;
		int damage = SwordDamageLevel(2, 4, 6, 8)*G[G_HPSCALE];
		int attackLevel = SwordDamageLevel(0, 1, 2, 2);
		
		if(G[G_FROGGER_SHIELDLEVEL]>=3){
			damage += 1*G[G_HPSCALE];
			++attackLevel;
		}
		if(G[G_FROGGER_SHIELDLEVEL]>=5){
			damage += 2*G[G_HPSCALE];
			++attackLevel;
		}
		if(G[G_FROGGER_SHIELDLEVEL]>=7){
			damage += 2*G[G_HPSCALE];
			++attackLevel;
		}
		int drawYOff = Link->DrawYOffset;
		int hitYOff = Link->HitYOffset;
		int z = 0;
		int jump = 2.4;
		Game->PlaySound(SFX_JUMP);
		
		int hopSpeed;
		if(InputDir(Link->Dir)){
			if(attackLevel<=2)
				hopSpeed = 0.5;
			else if(attackLevel==3)
				hopSpeed = 1;
			else if(attackLevel==4)
				hopSpeed = 2;
			else if(attackLevel==5)
				hopSpeed = 4;
		}
		while(jump>0||z>0){
			if(hopSpeed){
				LinkMovement_Push(DirX(Link->Dir, hopSpeed), DirY(Link->Dir, hopSpeed));
			}
			z = Max(z+jump, 0);
			jump = Clamp(jump-0.32, -3.2, 3.2);
			Link->DrawYOffset = drawYOff-z;
			Link->HitYOffset = hitYOff-z;
			Link->Action = LA_NONE;
			Link->Action = LA_ATTACKING;
			Waitframe();
		}
		Link->DrawYOffset = 0;
		Link->HitYOffset = 0;
		int angle = DirAngle(Link->Dir);
		G[G_SWORDSHOOTERFLAG] = 2;
		if(attackLevel<3){
			for(i=0; i<=attackLevel; ++i){
				lweapon l = FireLWeapon(LW_BOMBBLAST, Link->X+VectorX(12+12*i, angle), Link->Y+VectorY(12+12*i, angle), 0, 0, damage, 0, 0);
				MakeHitbox(LW_BEAM, l->X, l->Y, 16, 16, Link->Dir, damage);
				l->Dir = -1;
				for(j=0; j<4; ++j){
					Link->Action = LA_NONE;
					Link->Action = LA_ATTACKING;
					Waitframe();
				}
			}
			Link->Action = LA_NONE;
		}
		else{
			lweapon bomb[32];
			int bX[32];
			int bY[32];
			int bAng[32];
			int bStep[32];
			int bT[32];
			int bAmp[32];
			int bTStep[32];
			int bombStream[] = {0, bX, bY, bAng, bStep, bT, bAmp, bTStep};
			int numBomb;
			lweapon l = FireLWeapon(LW_BOMBBLAST, Link->X+VectorX(12, angle), Link->Y+VectorY(12, angle), 0, 0, damage, 0, 0);
			l->Dir = -1;
			for(i=0; i<5; ++i){
				if(attackLevel==3){
					bomb[numBomb] = FireLWeapon(LW_BOMBBLAST, Link->X+VectorX(12, angle), Link->Y+VectorY(12, angle), 0, 0, damage, 0, 0);
					bomb[numBomb]->Dir = -1;
					bX[numBomb] = bomb[numBomb]->X;
					bY[numBomb] = bomb[numBomb]->Y;
					bAng[numBomb] = angle;
					bStep[numBomb] = 2.5;
					bAmp[numBomb] = 16;
					bTStep[numBomb] = 8;
					++numBomb;
				}
				else if(attackLevel==4){
					bomb[numBomb] = FireLWeapon(LW_BOMBBLAST, Link->X+VectorX(12, angle), Link->Y+VectorY(12, angle), 0, 0, damage, 0, 0);
					bomb[numBomb]->Dir = Link->Dir;
					bX[numBomb] = bomb[numBomb]->X;
					bY[numBomb] = bomb[numBomb]->Y;
					bAng[numBomb] = angle;
					bStep[numBomb] = 5;
					bAmp[numBomb] = 24;
					bTStep[numBomb] = 14;
					++numBomb;
				}
				else if(attackLevel==5){
					for(j=0; j<3; ++j){
						bomb[numBomb] = FireLWeapon(LW_BOMBBLAST, Link->X+VectorX(12, angle+120*j), Link->Y+VectorY(12, angle+120*j), 0, 0, damage, 0, 0);
						bomb[numBomb]->Dir = Link->Dir;
						if(j>0)
							bomb[numBomb]->Dir = AngleDir4(WrapDegrees(angle+120*j));
						bX[numBomb] = bomb[numBomb]->X;
						bY[numBomb] = bomb[numBomb]->Y;
						bAng[numBomb] = angle+120*j;
						bStep[numBomb] = 5;
						bAmp[numBomb] = 24;
						bTStep[numBomb] = 14;
						++numBomb;
					}
				}
				for(j=0; j<6; ++j){
					Link->Action = LA_NONE;
					Link->Action = LA_ATTACKING;
					updateBombStream(bomb, bombStream, numBomb, damage);
					Waitframe();
				}
			}
			Link->Action = LA_NONE;
			while(bombStream[0]>0){
				updateBombStream(bomb, bombStream, numBomb, damage);
				Waitframe();
			}
		}
	}
	void updateBombStream(lweapon bomb, int bombStream, int numBomb, int damage){
		int bX = bombStream[1];
		int bY = bombStream[2];
		int bAng = bombStream[3];
		int bStep = bombStream[4];
		int bT = bombStream[5];
		int bAmp = bombStream[6];
		int bTStep = bombStream[7];
		bombStream[0] = 0;
		for(int i=0; i<numBomb; ++i){
			if(bomb[i]->isValid()){
				++bombStream[0];
				bX[i] += VectorX(bStep[i], bAng[i]);
				bY[i] += VectorY(bStep[i], bAng[i]);
				bT[i] += bTStep[i];
				bomb[i]->X = bX[i]+VectorX(bAmp[i]*Sin(bT[i]), bAng[i]-90);
				bomb[i]->Y = bY[i]+VectorY(bAmp[i]*Sin(bT[i]), bAng[i]-90);
				MakeHitbox(LW_BEAM, bX[i], bY[i], 16, 16, -1, damage);
			}
		}
	}
	void runProcessOfElimination(){
		if(G[G_DIMITRANSFORM]){
			lweapon l;
			int damage = SwordDamageLevel(2, 4, 8, 12)*G[G_HPSCALE];
			G[G_SWORDSHOOTERFLAG] = 2;
			if(G[G_DIMITRANSFORM]==DT_OCTOROK){
				Link->Action = LA_ATTACKING;
				if(G[G_DIMITRANSFORMSUBTYPE]==1){ //Cracktorok
					l = FireLWeapon(LW_MAGIC, Link->X, Link->Y, DegtoRad(DirAngle(Link->Dir)), 250, damage, 21, SFX_WAND);
					Rotate4(l);
				}
				else{
					RunMiscSpellFFC(4, 0, 0, damage);
				}
				G[G_SIGCOOLDOWN] = 30;
				G[G_SIGCOOLDOWNMAX] = 30;
			}
			if(G[G_DIMITRANSFORM]==DT_MOBLIN){
				Link->Action = LA_ATTACKING;
				l = FireLWeapon(LW_ARROW, Link->X, Link->Y, DegtoRad(DirAngle(Link->Dir)), 250, damage, 19, SFX_ARROW);
				Rotate4(l);
				G[G_SIGCOOLDOWN] = 30;
				G[G_SIGCOOLDOWNMAX] = 30;
			}
			if(G[G_DIMITRANSFORM]==DT_LYNEL||G[G_DIMITRANSFORM]==DT_STALFOS){
				Link->Action = LA_ATTACKING;
				l = FireLWeapon(LW_BEAM, Link->X, Link->Y, DegtoRad(DirAngle(Link->Dir)), 350, damage, 20, SFX_BEAM);
				l->Misc[LWM_MISCFLAGS] |= LWMF_NODEADANIM;
				Rotate4(l);
				G[G_SIGCOOLDOWN] = 90;
				G[G_SIGCOOLDOWNMAX] = 90;
			}
			if(G[G_DIMITRANSFORM]==DT_LEEVER){
				RunMiscSpellFFC(5, 0, 0, damage, true);
				G[G_SIGCOOLDOWN] = 60;
				G[G_SIGCOOLDOWNMAX] = 60;
			}
			if(G[G_DIMITRANSFORM]==DT_TEKTITE){
				RunMiscSpellFFC(6, 0, 0, damage, true);
				G[G_SIGCOOLDOWN] = 30;
				G[G_SIGCOOLDOWNMAX] = 30;
			}
			if(G[G_DIMITRANSFORM]==DT_PEAHAT){
				RunMiscSpellFFC(7, 0, 0, damage, true);
				G[G_SIGCOOLDOWN] = 30;
				G[G_SIGCOOLDOWNMAX] = 30;
			}
			if(G[G_DIMITRANSFORM]==DT_ARMOS){
				RunMiscSpellFFC(8, 0, 0, damage, true);
				G[G_SIGCOOLDOWN] = 30;
				G[G_SIGCOOLDOWNMAX] = 30;
			}
			if(G[G_DIMITRANSFORM]==DT_GHINI){
				RunMiscSpellFFC(9, 0, 0, damage, true);
				G[G_SIGCOOLDOWN] = 30;
				G[G_SIGCOOLDOWNMAX] = 30;
			}
			if(G[G_DIMITRANSFORM]==DT_KEESE){
				RunMiscSpellFFC(10, -4, 10, damage, true);
				G[G_SIGCOOLDOWN] = 60;
				G[G_SIGCOOLDOWNMAX] = 60;
			}
			if(G[G_DIMITRANSFORM]==DT_ZOL||G[G_DIMITRANSFORM]==DT_GIBDO){
				RunMiscSpellFFC(10, 4, 4, Cond(G[G_DIMITRANSFORM]==DT_GIBDO, damage*1.5, damage), true);
				G[G_SIGCOOLDOWN] = 30;
				G[G_SIGCOOLDOWNMAX] = 30;
			}
			if(G[G_DIMITRANSFORM]==DT_GORIYA){
				Link->Action = LA_ATTACKING;
				l = FireLWeapon(LW_BRANG, Link->X, Link->Y, DegtoRad(DirAngle(Link->Dir)), 200, 2*G[G_HPSCALE], 4, SFX_BRANG);
				G[G_SIGCOOLDOWN] = 30;
				G[G_SIGCOOLDOWNMAX] = 30;
			}
			if(G[G_DIMITRANSFORM]==DT_WALLMASTER){
				RunMiscSpellFFC(11, 0, 0, damage);
				G[G_SIGCOOLDOWN] = 180;
				G[G_SIGCOOLDOWNMAX] = 180;
			}
			if(G[G_DIMITRANSFORM]==DT_LIKELIKE){
				RunMiscSpellFFC(12, 0, 0, damage, true);
				G[G_SIGCOOLDOWN] = 180;
				G[G_SIGCOOLDOWNMAX] = 180;
			}
			if(G[G_DIMITRANSFORM]==DT_DARKNUT){
				RunMiscSpellFFC(13, 0, 0, damage, true);
				G[G_SIGCOOLDOWN] = 30;
				G[G_SIGCOOLDOWNMAX] = 30;
			}
			if(G[G_DIMITRANSFORM]==DT_ROPE){
				RunMiscSpellFFC(14, 0, 0, damage, true);
				G[G_SIGCOOLDOWN] = 30;
				G[G_SIGCOOLDOWNMAX] = 30;
			}
			if(G[G_DIMITRANSFORM]==DT_POLSVOICE){
				RunMiscSpellFFC(6, 1, 0, damage, true);
				G[G_SIGCOOLDOWN] = 30;
				G[G_SIGCOOLDOWNMAX] = 30;
			}
			if(G[G_DIMITRANSFORM]==DT_WIZZROBE){
				if(G[G_DIMITRANSFORMSUBTYPE]==1){ //Windrobe
					RunMiscSpellFFC(11, 0, 0, damage);
					G[G_SIGCOOLDOWN] = 60;
					G[G_SIGCOOLDOWNMAX] = 60;
				}
				else{
					l = FireLWeapon(LW_MAGIC, Link->X, Link->Y, DegtoRad(DirAngle(Link->Dir)), 250, damage, 21, SFX_WAND);
					Rotate4(l);
					G[G_SIGCOOLDOWN] = 30;
					G[G_SIGCOOLDOWNMAX] = 30;
				}
			}
			if(G[G_DIMITRANSFORM]==DT_WIZZROBEBREATH){
				for(int i=0; i<32; ++i){
					l = FireLWeapon(LW_REFFIREBALL, Link->X+DirX(Link->Dir, 16), Link->Y+DirY(Link->Dir, 16), DegtoRad(DirAngle(Link->Dir)+Rand(-10, 10)), Rand(200, 400), damage, 17, SFX_FIREBALL);
					for(int j=0; j<4; ++j){
						Link->Action = LA_NONE;
						Link->Action = LA_ATTACKING;
						WaitNoAction();
					}
				}
				G[G_SIGCOOLDOWN] = 90;
				G[G_SIGCOOLDOWNMAX] = 90;
			}
			if(G[G_DIMITRANSFORM]==DT_WIZZROBEFIRE){
				RunMiscSpellFFC(15, Link->X, Link->Y, damage);
				G[G_SIGCOOLDOWN] = 180;
				G[G_SIGCOOLDOWNMAX] = 180;
			}
			if(G[G_DIMITRANSFORM]==DT_WIZZROBEBABA){
				RunMiscSpellFFC(16, 0, 0, damage);
				G[G_SIGCOOLDOWN] = 90;
				G[G_SIGCOOLDOWNMAX] = 90;
			}
			if(G[G_DIMITRANSFORM]==DT_WIZZROBEBAT){
				RunMiscSpellFFC(17, 0, 0, damage);
				G[G_SIGCOOLDOWN] = 180;
				G[G_SIGCOOLDOWNMAX] = 180;
			}
			if(G[G_DIMITRANSFORM]==DT_WIZZROBESHOCK){
				RunMiscSpellFFC(18, 0, 0, damage, true);
				G[G_SIGCOOLDOWN] = 40;
				G[G_SIGCOOLDOWNMAX] = 40;
			}
			if(G[G_DIMITRANSFORM]==DT_VIRE){
				RunMiscSpellFFC(6, 2, 0, damage, true);
				G[G_SIGCOOLDOWN] = 30;
				G[G_SIGCOOLDOWNMAX] = 30;
			}
			if(G[G_DIMITRANSFORM]==DT_NIGHTMARESLIME){
				RunMiscSpellFFC(10, 4, 4, Cond(G[G_DIMITRANSFORM]==DT_GIBDO, 1, damage), true);
				G[G_SIGCOOLDOWN] = 10;
				G[G_SIGCOOLDOWNMAX] = 10;
			}
			if(G[G_DIMITRANSFORM]==DT_KNIGHTKNIGHT){
				RunMiscSpellFFC(19, 0, 0, damage, true);
				G[G_SIGCOOLDOWN] = 30;
				G[G_SIGCOOLDOWNMAX] = 30;
			}
			if(G[G_DIMITRANSFORM]==DT_ZIRRO){
				RunMiscSpellFFC(20, 0, 0, damage, true);
				G[G_SIGCOOLDOWN] = 90;
				G[G_SIGCOOLDOWNMAX] = 90;
			}
		}
		else{
			G[G_SWORDSHOOTERFLAG] = 2;
			Link->Action = LA_ATTACKING;
			RunMiscSpellFFC(2, 0, 0, 0);
			G[G_SIGCOOLDOWN] = 40;
			G[G_SIGCOOLDOWNMAX] = 40;
		}
	}
}

void DrawQuadTrail(int layer, int trailX, int trailY, int trailAng, int start, int end, int w, int clr){
	DrawQuadTrail(layer, trailX, trailY, trailAng, start, end, w, clr, true);
}
void DrawQuadTrail(int layer, int trailX, int trailY, int trailAng, int start, int end, int w, int clr, bool taperEnd){
	int size = end-start;
	for(int i=start; i<end; ++i){
		int qX[4];
		int qY[4];
		int ang = trailAng[i];
		
		int tempW = ((i-start)/size)*w;
		
		qX[0] = trailX[i]+Floor(VectorX(-tempW/2, ang+90));
		qY[0] = trailY[i]+Floor(VectorY(-tempW/2, ang+90));
		
		qX[1] = trailX[i]+Floor(VectorX(tempW/2, ang+90));
		qY[1] = trailY[i]+Floor(VectorY(tempW/2, ang+90));
		
		tempW = (((i-start)+1)/size)*w;
		if(i==end-1&&taperEnd)
			tempW = 0;
		
		ang = trailAng[i+1];
		
		qX[2] = trailX[i+1]+Floor(VectorX(tempW/2, ang+90));
		qY[2] = trailY[i+1]+Floor(VectorY(tempW/2, ang+90));
		
		qX[3] = trailX[i+1]+Floor(VectorX(-tempW/2, ang+90));
		qY[3] = trailY[i+1]+Floor(VectorY(-tempW/2, ang+90));
		
		Screen->Quad(layer, qX[0], qY[0], qX[1], qY[1], qX[2], qY[2], qX[3], qY[3], 1, 1, clr, 0, -1, PT_FLAT);
	}
}

void DrawQuadTrail2(int layer, int pointX, int pointY, int pointAng, int pointW, int numPoints, int clr){
	for(int i=0; i<numPoints-1; ++i){
		int qX[4];
		int qY[4];
		int ang = pointAng[i];
		
		qX[0] = pointX[i]+Floor(VectorX(-pointW[i]/2, ang+90));
		qY[0] = pointY[i]+Floor(VectorY(-pointW[i]/2, ang+90));
		
		qX[1] = pointX[i]+Floor(VectorX(pointW[i]/2, ang+90));
		qY[1] = pointY[i]+Floor(VectorY(pointW[i]/2, ang+90));
		
		ang = pointAng[i+1];
		
		qX[2] = pointX[i+1]+Floor(VectorX(pointW[i+1]/2, ang+90));
		qY[2] = pointY[i+1]+Floor(VectorY(pointW[i+1]/2, ang+90));
		
		qX[3] = pointX[i+1]+Floor(VectorX(-pointW[i+1]/2, ang+90));
		qY[3] = pointY[i+1]+Floor(VectorY(-pointW[i+1]/2, ang+90));
		
		Screen->Quad(layer, qX[0], qY[0], qX[1], qY[1], qX[2], qY[2], qX[3], qY[3], 1, 1, clr, 0, -1, PT_FLAT);
	}
}

void LWLightningInit(int lightning, int offset, int x, int y, int count, int angle, int skew, int rnd){
	int tmpX; int tmpY;
	int dist; int dist2; int randOff;
	int angleSkew = Rand(-40, 40);
	for(int i=0; i<count; ++i){
		dist = 320*(i/(count-1));
		dist2 = skew*(i/(count-1));
		randOff = Rand(-rnd, rnd)*0.5;
		randOff += randOff*(i/(count-1));
		if(i==0)
			randOff = 0;
		tmpX = x+VectorX(dist, angle)+VectorX(dist2, angle+90)+VectorX(randOff, angle+90+angleSkew);
		tmpY = y+VectorY(dist, angle)+VectorY(dist2, angle+90)+VectorY(randOff, angle+90+angleSkew);
		lightning[offset+2*i+0] = tmpX;
		lightning[offset+2*i+1] = tmpY;
	}
}
void LWLightningUpdate(int lightning, int offset, int count, int startDist, int endDist, int maxDist, int c1, int c2, int damage){
	if(Link->HP<=0)
		return;
	int distPerSegment = maxDist/(count-1);
	int tmpAngle;
	int tmpDist;
	int segPercent;
	int x1; int y1; int x2; int y2;
	for(int i=0; i<count-1; ++i){
		if(endDist>distPerSegment*i&&endDist<distPerSegment*(i+1)){
			x1 = lightning[offset+i*2+0];
			y1 = lightning[offset+i*2+1];
			x2 = lightning[offset+(i+1)*2+0];
			y2 = lightning[offset+(i+1)*2+1];
			tmpAngle = Angle(x1, y1, x2, y2);
			tmpDist = Distance(x1, y1, x2, y2);
			segPercent = (endDist-distPerSegment*i)/distPerSegment;
			x2 = x1+VectorX(tmpDist*segPercent, tmpAngle);
			y2 = y1+VectorY(tmpDist*segPercent, tmpAngle);
			DrawThickLine(4, x1, y1, x2, y2, 1, c1, true, 128);
			Screen->Line(4, x1, y1, x2, y2, c2, 1, 0, 0, 0, 128);
			// if(EZBE_LineBoxCollision(x1, y1, x2, y2, Link->X+4, Link->Y+4, Link->X+11, Link->Y+11, 0)){
				// EZBE_DamageLink(damage);
			// }
		}
		else if(startDist>distPerSegment*i&&startDist<distPerSegment*(i+1)){
			x1 = lightning[offset+i*2+0];
			y1 = lightning[offset+i*2+1];
			x2 = lightning[offset+(i+1)*2+0];
			y2 = lightning[offset+(i+1)*2+1];
			tmpAngle = Angle(x1, y1, x2, y2);
			tmpDist = Distance(x1, y1, x2, y2);
			segPercent = (startDist-distPerSegment*i)/distPerSegment;
			x1 = x1+VectorX(tmpDist*segPercent, tmpAngle);
			y1 = y1+VectorY(tmpDist*segPercent, tmpAngle);
			DrawThickLine(4, x1, y1, x2, y2, 1, c1, true, 128);
			Screen->Line(4, x1, y1, x2, y2, c2, 1, 0, 0, 0, 128);
			// if(EZBE_LineBoxCollision(x1, y1, x2, y2, Link->X+4, Link->Y+4, Link->X+11, Link->Y+11, 0)){
				// EZBE_DamageLink(damage);
			// }
		}
		else if(startDist<=distPerSegment*i&&endDist>=distPerSegment*(i+1)){
			x1 = lightning[offset+i*2+0];
			y1 = lightning[offset+i*2+1];
			x2 = lightning[offset+(i+1)*2+0];
			y2 = lightning[offset+(i+1)*2+1];
			DrawThickLine(4, x1, y1, x2, y2, 1, c1, true, 128);
			Screen->Line(4, x1, y1, x2, y2, c2, 1, 0, 0, 0, 128);
			// if(EZBE_LineBoxCollision(x1, y1, x2, y2, Link->X+4, Link->Y+4, Link->X+11, Link->Y+11, 0)){
				// EZBE_DamageLink(damage);
			// }
		}
	}
}

void DrawThickLine(int layer,  int x1, int y1, int x2, int y2, int width, int color, bool fill, int op){
	Screen->Rectangle(layer, x1, y1-width, x1+Distance(x1, y1, x2, y2), y1+width, color, 1, x1, y1, Angle(x1, y1, x2, y2), fill, op);
}
	
//A shorthand way to get a combo on the current layer.
//Layer 0 is the screen itself.
int Q7_GetLayerComboS(int layer, int pos) 
{
	if (!layer) //layer 0
	{
		return Screen->ComboS[pos];
	}
	else
	{
		if ( Screen->LayerMap(layer) != -1 && Screen->LayerScreen(layer) != -1 )
		{
			return Game->GetComboSolid(Screen->LayerMap(layer), Screen->LayerScreen(layer), pos);
		}
	}
	return 0;
}

bool Q7_IsPit(int x, int y){
	int ct = Screen->ComboT[ComboAt(x, y)];
	return ct==CT_HOOKSHOTONLY||ct==CT_LADDERHOOKSHOT||ct==CT_LADDERONLY;
}

bool Q7_IsWater(int x, int y){
	int ct = Screen->ComboT[ComboAt(x, y)];
	return ct==CT_WATER;
}

bool Q7_InScreen(int x, int y){
	return x>=0&&x<=240&&y>=0&&y<=160;
}

const int CMB_ZARATH_LANTERN = 694;
const int TIL_CHAINSOFHATRED = 16620;
const int TIL_SHOTGUN = 16392;
const int TIL_SHOTGUN_PELLET = 16413;
const int TIL_SHOTGUN_TRAIL = 16388;

const int SFX_FLAKESHIELD_ACTIVATE = 129;
const int SFX_FLAKESHIELD_SPREAD = 128;

const int SFX_PETALSHIELD_ACTIVATE = 127;
const int SFX_PETALSHIELD_ABSORB = 128;

const int SFX_SKULLSHIELD_ACTIVATE = 127;

ffc script UtilityWeapons{
	void run(){
		if(G[G_ALTCHARACTER]==CHAR_ZELDA)
			runSpellblossom();
		if(G[G_ALTCHARACTER]==CHAR_ADJEAN)
			runWizardWormhole();
		if(G[G_ALTCHARACTER]==CHAR_BANNON)
			runLocustSwarm();
		if(G[G_ALTCHARACTER]==CHAR_ZARATH)
			runSoulSeverance();
		if(G[G_ALTCHARACTER]==CHAR_KELL)
			runFishOrb();
		if(G[G_ALTCHARACTER]==CHAR_RIGGS)
			runLadder();
		if(G[G_ALTCHARACTER]==CHAR_ALIYA)
			runChainsOfHatred();
		if(G[G_ALTCHARACTER]==CHAR_HOLM)
			runFlakeShield();
		if(G[G_ALTCHARACTER]==CHAR_GARDEA)
			runMoonblast();
		if(G[G_ALTCHARACTER]==CHAR_SILVIO)
			runCapeOfVaquia();
		if(G[G_ALTCHARACTER]==CHAR_NORA)
			runFrostHydra();
		if(G[G_ALTCHARACTER]==CHAR_ARIA)
			runPowerSlash();
		if(G[G_ALTCHARACTER]==CHAR_SPURDO)
			runShotgun();
		if(G[G_ALTCHARACTER]==CHAR_MANI)
			runStarfall();
		if(G[G_ALTCHARACTER]==CHAR_ARCANA)
			runChaoticMagic();
		if(G[G_ALTCHARACTER]==CHAR_FROGGER)
			runOneWholeRupee();
		if(G[G_ALTCHARACTER]==CHAR_DIMI)
			runFaceOff();
	}
	void runSpellblossom(){
		int dir = Link->Dir;
		int cset = Choose(1, 5, 7, 8, 10);
		int cx = Link->X+DirX(Link->Dir, 16);
		int cy = Link->Y+DirY(Link->Dir, 16);
		int damage = SwordDamageLevel(2, 4, 8, 10)*G[G_HPSCALE];
		int scale = SwordDamageLevel(16, 18, 20, 24);
		int step = SwordDamageLevel(2, 1.5, 1, 0.5);
		int t;
		Game->PlaySound(SFX_WAND);
		while(cx>0&&cx<240&&cy>0&&cy<160){
			G[G_UTILITYCOOLDOWN] = 180;
			G[G_UTILITYCOOLDOWNMAX] = 180;
			drawSpellblossom(cset, cx, cy, t, scale, dir, damage, 128);
			cx += DirX(dir, step);
			cy += DirY(dir, step);
			++t;
			Waitframe();
		}
		Game->PlaySound(SFX_FARORESWIND);
		for(int i=0; i<16; ++i){
			drawSpellblossom(cset, cx, cy, t, scale+3*i, dir, damage, Cond(i<12, 128, 64));
			cx -= DirX(dir, 1);
			cy -= DirY(dir, 1);
			++t;
			Waitframe();
		}
	}
	void drawSpellblossom(int cset, int cx, int cy, int t, int width, int dir, int damage, int op){
		int x; int y; int ang;
		for(int i=0; i<18; ++i){
			ang = WrapDegrees(20*i+t);
			// x = cx+VectorX(width*(Sin(6*ang)+0.2*Cos(12*ang)), ang+t*4);
			// y = cy+VectorY(width*(Sin(6*ang)+0.2*Cos(12*ang)), ang+t*4);
			int dist = width*(0.3+Sin(6*ang)+0.2*Cos(12*ang));
			dist += Sign(dist)*0.3;
			x = cx+VectorX(dist, ang+t*4);
			y = cy+VectorY(dist, ang+t*4);
			Screen->FastCombo(2, x, y, 690, cset, op);
			
			MakeHitbox(LW_BEAM, x, y, 16, 16, dir, damage);
		}
	}
	void runWizardWormhole(){
		int i;
		int portalX = Link->X;
		int portalY = Link->Y;
		for(i=0; i<16; ++i){
			Screen->DrawCombo(2, portalX-8, portalY-8, CMB_ADJEAN_PORTAL+2, 2, 2, 10, -1, -1, 0, 0, 0, -1, 0, true, 128);
			WaitNoAction();
		}
		for(i=0; i<16; ++i){
			Screen->DrawCombo(2, portalX-8, portalY-8, CMB_ADJEAN_PORTAL+1, 2, 2, 10, -1, -1, 0, 0, 0, -1, 0, true, 128);
			WaitNoAction();
		}
		G[G_UTILITYCOOLDOWNMAX] = 90;
		G[G_UTILITYCOOLDOWN] = 90;
		while(true){
			if(PressButtonItem(I_UTILITYSPELL)&&!G[G_UTILITYCOOLDOWN]&&!Link->ItemJinx)
				break;
			Screen->DrawCombo(2, portalX-8, portalY-8, CMB_ADJEAN_PORTAL, 2, 2, 10, -1, -1, 0, 0, 0, -1, 0, true, 128);
			Waitframe();
		}
		Link->Invisible = true;
		Link->CollDetection = false;
		int linkX = Link->X;
		int linkY = Link->Y;
		int x; int y;
		int angle = Angle(linkX, linkY, portalX, portalY);
		int dist = Distance(linkX, linkY, portalX, portalY);
		Game->PlaySound(SFX_ADJEAN_DASH);
		int damage = SwordDamageLevel(2, 4, 8, 10)*G[G_HPSCALE];
		for(int i=0; i<=16; ++i){
			int x = linkX+VectorX(dist*(i/16), angle);
			int y = linkY+VectorY(dist*(i/16), angle);
			if(i%4==0){
				npc n = Generic_FindTarget(NPCD_REFFIREBALL, x+8, y+8, -1000);
				if(n->isValid()){
					lweapon fireball = FireLWeapon(LW_REFFIREBALL, x, y, DegtoRad(Angle(x, y, CenterX(n)-8, CenterY(n)-8)), 300, damage, 17, SFX_FIREBALL);
					fireball->Misc[LWM_REFLINKCOLLISION] = 2;
					fireball->Misc[LWM_REFHASMULTIPLIED] = 1;
					fireball->Misc[LWM_ARTIFICIALPUSHTIME] = 16;
				}
			}
			Screen->DrawCombo(2, portalX-8, portalY-8, CMB_ADJEAN_PORTAL, 2, 2, 10, -1, -1, 0, 0, 0, -1, 0, true, 128);
			Screen->FastCombo(2, x, y, 691, 10, 128);
			WaitNoAction();
		}
		for(i=0; i<16; ++i){
			Screen->DrawCombo(2, portalX-8, portalY-8, CMB_ADJEAN_PORTAL+1, 2, 2, 10, -1, -1, 0, 0, 0, -1, 0, true, 128);
			Waitframe();
		}
		for(i=0; i<16; ++i){
			Screen->DrawCombo(2, portalX-8, portalY-8, CMB_ADJEAN_PORTAL+2, 2, 2, 10, -1, -1, 0, 0, 0, -1, 0, true, 128);
			Waitframe();
		}
		G[G_UTILITYCOOLDOWNMAX] = 90;
		G[G_UTILITYCOOLDOWN] = 90;
		Link->X = portalX;
		Link->Y = portalY;
		Link->Invisible = false;
		Link->CollDetection = true;
	}
	void runLocustSwarm(){
		int locustX[32];
		int locustY[32];
		int locustT[32];
		int locustAng[32];
		int locustStep[32];
		int locustAngStep[32];
		int locust[] = {0, locustX, locustY, locustT, locustAng, locustStep, locustAngStep};
		
		int freq = SwordDamageLevel(48, 32, 16, 8);
		
		G[G_UTILITYCOOLDOWN] = 120;
		G[G_UTILITYCOOLDOWNMAX] = 300;
		
		for(int i=0; i<32&&InputButtonItem(I_UTILITYSPELL); ++i){
			Game->PlaySound(SFX_BANNON_FLIES);
			addLocust(locust, Link->X+DirX(Link->Dir, 8), Link->Y+DirY(Link->Dir, 8), DirAngle(Link->Dir)+Rand(-20, 20), 3+Rand(10)*0.1);
			for(int j=0; j<4&&InputButtonItem(I_UTILITYSPELL); ++j){
				G[G_UTILITYCOOLDOWN] = Clamp(Floor(120 + 190*(i/32)), 0, 300);
				updateLocust(locust, 2*G[G_HPSCALE], freq);
				if(j%2==0)
					NoWalk();
				Waitframe();
			}
		}
		while(locust[0]){
			updateLocust(locust, 2*G[G_HPSCALE], freq);
			Waitframe();
		}
	}
	void addLocust(int locust, int x, int y, int ang, int step){
		int locustX = locust[1];
		int locustY = locust[2];
		int locustT = locust[3];
		int locustAng = locust[4];
		int locustStep = locust[5];
		int locustAngStep = locust[6];
		
		for(int i=0; i<32; ++i){
			if(!locustStep[i]){
				locustX[i] = x;
				locustY[i] = y;
				locustT[i] = 0;
				locustAng[i] = ang;
				locustStep[i] = step;
				locustAngStep[i] = Rand(12, 16);
				return;
			}
		}
	}
	void updateLocust(int locust, int damage, int freq){
		int x; int y;
		
		int locustX = locust[1];
		int locustY = locust[2];
		int locustT = locust[3];
		int locustAng = locust[4];
		int locustStep = locust[5];
		int locustAngStep = locust[6];
		
		locust[0] = 0;
		for(int i=0; i<32; ++i){
			if(locustStep[i]){
				++locust[0];
				locustT[i] += locustAngStep[i];
				locustT[i] %= 360;
				
				locustX[i] += VectorX(locustStep[i], locustAng[i]);
				locustY[i] += VectorY(locustStep[i], locustAng[i]);
				
				x = locustX[i]+VectorX(12*Sin(locustT[i]), locustAng[i]+90);
				y = locustY[i]+VectorY(12*Sin(locustT[i]), locustAng[i]+90);
				Screen->DrawCombo(2, x, y, 2914, 1, 1, 5, -1, -1, x, y, locustAng[i]+90*Sin(locustT[i]), -1, 0, true, 128);
			
				for(int j=Screen->NumNPCs(); j>0; --j){
					npc n = Screen->LoadNPC(j);
					if(n->CollDetection&&canHitLocust(n)){
						if(!n->Misc[NPCM_PIERCINGIFRAMES]){
							if(RectCollision(x+4, y+4, x+11, y+11, n->X+n->HitXOffset, n->Y+n->HitYOffset, n->X+n->HitXOffset+n->HitWidth-1, n->Y+n->HitYOffset+n->HitHeight-1)){
								if(n->Defense[NPCD_ARROW]==NPCDT_ONEHITKILL)
									damage = n->HP;
								Game->PlaySound(SFX_EHIT);
								n->Misc[NPCM_PIERCEDAMAGE] += damage;
								//n->HP -= damage;//SetEnemyProperty(n, ENPROP_HP, n->HP-damage);
								n->Misc[NPCM_PIERCINGIFRAMES] = freq;
							}
						}
					}
				}
				
				if(x<-16||x>256||y<-16||y>176)
					locustStep[i] = 0;
			}
		}
	}
	bool canHitLocust(npc n){
		if(n->Defense[NPCD_ARROW]!=NPCDT_BLOCK&&n->Defense[NPCD_ARROW]!=NPCDT_IGNORE)
			return true;
		if(n->Defense[NPCD_SWORD]!=NPCDT_BLOCK&&n->Defense[NPCD_SWORD]!=NPCDT_IGNORE)
			return true;
		return false;
	}
	void runSoulSeverance(){
		int i; int j;
		
		int damage = SwordDamageLevel(6, 12, 18, 24)*G[G_HPSCALE];
		
		int lanternX; int lanternY;
		int lanternTimer;
		
		int strandX[128];
		int strandY[128];
		int strandAngle[128];
		int strandT[128];
		int strandScale[128];
		int strandState[128];
		int numStand;
		int strand[] = {strandX, strandY, strandAngle, strandT, strandScale, strandState};
		for(j=0; j<16; ++j){
			i = j*2;
			strandX[i] = Link->X+Rand(16);
			strandY[i] = Link->Y+Rand(16);
			strandAngle[i] = Rand(360);
			strandT[i] = 0;
			strandScale[i] = Rand(8, 16);
			strandState[i] = 1;
			
			i = j*2+1;
			strandX[i] = Link->X+Rand(16);
			strandY[i] = Link->Y+Rand(16);
			strandAngle[i] = Rand(360);
			strandT[i] = 0;
			strandScale[i] = Rand(8, 16);
			strandState[i] = 1;
			
			strandUpdate(strand, Link->X+8, Link->Y+8);
			Waitframe();
		}
		lanternX = Link->X;
		lanternY = Link->Y;
		for(i=0; i<48; ++i){
			strandUpdate(strand, lanternX+8, lanternY+8);
			Screen->Circle(4, lanternX+8, lanternY+8, Min(i/32*8, 8)+Sin(i*8), Choose(0x11, 0x12, 0x13), 1, 0, 0, 0, true, 128);
			Waitframe();
		}
		bool gotHit;
		int strandDelay = 16;
		while(!gotHit&&RectCollision(Link->X, Link->Y, Link->X+15, Link->Y+15, lanternX, lanternY, lanternX+15, lanternY+15)){
			if(strandDelay){
				--strandDelay;
				strandUpdate(strand, Link->X+8, Link->Y+8);
			}
			++lanternTimer;
			lanternTimer %= 360;
			
			lanternDrawShadow(lanternX, lanternY, lanternTimer);
			Screen->FastCombo(2, lanternX, lanternY-2+2*Cos(lanternTimer*4), CMB_ZARATH_LANTERN, 1, 128);
			gotHit = lanternCollision(lanternX, lanternY);
			
			Waitframe();
		}
		int lanternMoveTimer;
		int angle;
		while(!gotHit&&!RectCollision(Link->X+4, Link->Y+4, Link->X+11, Link->Y+11, lanternX+4, lanternY+4, lanternX+11, lanternY+11)){
			++lanternTimer;
			lanternTimer %= 360;
			
			if(PressButtonItem(I_UTILITYSPELL)&&!G[G_UTILITYCOOLDOWN]&&!Link->ItemJinx)
				lanternMoveTimer = 16;
			if(lanternMoveTimer){
				angle = Angle(lanternX, lanternY, Link->X, Link->Y);
				lanternX += VectorX(1, angle);
				lanternY += VectorY(1, angle);
				
				angle = Angle(Link->X, Link->Y, lanternX, lanternY);
				LinkMovement_Push(VectorX(3, angle), VectorY(3, angle));
				
				--lanternMoveTimer;
				if(lanternMoveTimer==1&&Link->InputB)
					++lanternMoveTimer;
				if(lanternMoveTimer==0){
					for(i=0; i<8; ++i){
						lweapon l = FireLWeapon(LW_FIRE, lanternX, lanternY, DegtoRad(DirAngle(i)), 100, damage, 12, SFX_FIRE);
						l->CSet = 1;
						l->Misc[LWM_FIRETYPE] = 1;
					}
					G[G_UTILITYCOOLDOWN] = 120;
					G[G_UTILITYCOOLDOWNMAX] = 120;
				}
			}
			
			lanternDrawShadow(lanternX, lanternY, lanternTimer);
			Screen->FastCombo(2, lanternX, lanternY-2+2*Cos(lanternTimer*4), CMB_ZARATH_LANTERN, 1, 128);
			gotHit = lanternCollision(lanternX, lanternY);
			
			Waitframe();
		}
		if(gotHit){
			Game->PlaySound(83);
			for(i=0; i<40; ++i){
				lanternDrawShadow(lanternX, lanternY, lanternTimer);
				Screen->FastTile(2, lanternX, lanternY-2+2*Cos(lanternTimer*4), 9048, 1, 128);
			
				NoAction();
				Waitframe();
			}
			int gX[8];
			int gY[8];
			int gAng[8];
			for(i=0; i<8; ++i){
				gX[i] = lanternX;
				gY[i] = lanternY-2+2*Cos(lanternTimer*4);
				gAng[i] = 90+45*i+Rand(-10, 10);
			}
			Game->PlaySound(84);
			for(i=0; i<32; ++i){
				lanternDrawShadow(lanternX, lanternY, lanternTimer);
				Screen->Circle(4, lanternX+8, lanternY-2+2*Cos(lanternTimer*4), 2*i, Choose(0x11, 0x12, 0x13), 1, 0, 0, 0, true, 128);
				for(j=0; j<8; ++j){
					gX[j] += VectorX(1, gAng[j]);
					gY[j] += VectorY(1, gAng[j]);
					Screen->FastTile(4, gX[j], gY[j], 9068+j, 1, 128);
				}
				
				NoAction();
				Waitframe();
			}
			while(true){
				Link->HP = 0;
				
				NoAction();
				Waitframe();
			}
		}
		G[G_UTILITYCOOLDOWN] = 120;
		G[G_UTILITYCOOLDOWNMAX] = 120;
	}
	bool lanternCollision(int x, int y){
		G[G_TEMPDAMAGEMULTIPLIER] *= 2;
		
		bool hit;
		for(int i=Screen->NumEWeapons(); i>0; --i){
			eweapon e = Screen->LoadEWeapon(i);
			if(e->CollDetection&&e->DeadState==WDS_ALIVE&&e->Damage>0){
				if(RectCollision(x+4, y+4, x+11, y+11, e->X+e->HitXOffset, e->Y+e->HitYOffset, e->X+e->HitXOffset+e->HitWidth, e->Y+e->HitYOffset+e->HitHeight)){
					hit = true;
				}
			}
		}
		for(int i=Screen->NumNPCs(); i>0; --i){
			npc n = Screen->LoadNPC(i);
			if(n->CollDetection&&n->Damage>0){
				if(RectCollision(x+4, y+4, x+11, y+11, n->X+n->HitXOffset, n->Y+n->HitYOffset, n->X+n->HitXOffset+n->HitWidth, n->Y+n->HitYOffset+n->HitHeight)){
					hit = true;
				}
			}
		}
		return hit;
	}
	void lanternDrawShadow(int x, int y, int t){
		Screen->FastTile(0, x, y, 9032+Floor((t%90)/22.5)%4, 7, 128);
	}
	void strandUpdate(int strand, int tx, int ty){
		int strandX = strand[0];
		int strandY = strand[1];
		int strandAngle = strand[2];
		int strandT = strand[3];
		int strandScale = strand[4];
		int strandState = strand[5];
		
		int angle; int dist;
		
		int x[4];
		int y[4];
		int d;
		for(int i=0; i<128; ++i){
			if(strandState[i]){
				if(strandState[i]==1){
					for(int j=0; j<4; ++j){
						d = Clamp((16*strandT[i]-48)+j*16, 0, 256);
						x[j] = strandX[i]+VectorX(d, strandAngle[i])+VectorX(strandScale[i]*Sin(d*4), strandAngle[i]+90);
						y[j] = strandY[i]+VectorY(d, strandAngle[i])+VectorY(strandScale[i]*Sin(d*4), strandAngle[i]+90);
					}
					Screen->Spline(4, x[0], y[0], x[1], y[1], x[2], y[2], x[3], y[3], Choose(0x11, 0x12, 0x13), 128);
				
					++strandT[i];
					if(strandT[i]==16){
						strandX[i] = x[3];
						strandY[i] = y[3];
						strandState[i] = 2;
						strandT[i] = 0;
					}
				}
				else if(strandState[i]==2){
					angle = Angle(strandX[i], strandY[i], tx, ty);
					dist = Distance(strandX[i], strandY[i], tx, ty);
					for(int j=0; j<4; ++j){
						angle = Angle(strandX[i], strandY[i], tx, ty);
						d = Clamp((12*(strandT[i])-48)+j*16, 0, 256);
						int sc = Min((256-d)/48, 1);
						x[j] = strandX[i]+VectorX(d, angle)+VectorX(sc*strandScale[i]*Sin(d*4), angle+90);
						y[j] = strandY[i]+VectorY(d, angle)+VectorY(sc*strandScale[i]*Sin(d*4), angle+90);
					}
					Screen->Spline(4, x[0], y[0], x[1], y[1], x[2], y[2], x[3], y[3], Choose(0x11, 0x12, 0x13), 128);
				
					++strandT[i];
					if(strandT[i]==32){
						strandState[i] = 0;
						strandT[i] = 0;
					}
				}
			}
		}
	}
	void runFishOrb(){
		int i; int j; int k;
		int x; int y;
		int ang; int dist;
		
		int fishX[128];
		int fishY[128];
		int fishTX[128];
		int fishTY[128];
		int fishST[128];
		int fishType[128];
		
		int orbSize = SwordDamageLevel(24, 32, 48, 64);
		int orbTickFreq = SwordDamageLevel(32, 16, 8, 4);
		int orbDuration = SwordDamageLevel(300, 360, 420, 480);
		
		int fish[] = {0, 0, fishX, fishY, fishTX, fishTY, fishST, fishType};
	
		int orbX = Link->X;
		int orbY = Link->Y;
		
		int dir = Link->Dir;
		
		int cooldown = 600;
		
		k = 2;
		Game->PlaySound(SFX_PLACE);
		for(i=0; i<32; ++i){
			orbX += DirX(dir, k);
			orbY += DirY(dir, k);
			
			k = Max(k-0.1, 0.1);
			
			Screen->FastTile(4, orbX, orbY, 16540, 7, 128);
			
			Waitframe();
		}
		for(i=0; i<32; ++i){
			Screen->FastTile(4, orbX, orbY, 16540, 7, 128);
			
			Waitframe();
		}
	
		i = 0;
		for(j=0; j<128; ++j){
			G[G_UTILITYCOOLDOWN] = cooldown;
			G[G_UTILITYCOOLDOWNMAX] = cooldown;
			
			fishX[i] = Rand(-16, 256);
			fishY[i] = Rand(-16, 176);
			if(Rand(2))
				fishX[i] = Choose(-16, 256);
			else
				fishY[i] = Choose(-16, 176);
			ang = Rand(360);
			dist = Rand(orbSize);
			fishTX[i] = orbX+VectorX(dist, ang);
			fishTY[i] = orbY+VectorY(dist, ang);
			fishST[i] = 1;
			if(i%3==0)
				fishType[i] = 7;
			else
				fishType[i] = Rand(7);
			++i;
			
			Screen->FastTile(4, orbX, orbY, 16540, 7, 128);
			
			fishUpdate(fish, orbX, orbY, orbSize, orbTickFreq, false);
			
			Waitframe();
		}
		for(i=0; i<orbDuration; ++i){
			G[G_UTILITYCOOLDOWN] = cooldown;
			G[G_UTILITYCOOLDOWNMAX] = cooldown;
			
			Screen->FastTile(4, orbX, orbY, 16540, 7, 128);
			
			fishUpdate(fish, orbX, orbY, orbSize, orbTickFreq, true);
			
			Waitframe();
		}
		for(i=0; i<128; ++i){
			fishST[i] = 3;
		}
		Game->PlaySound(118);
		while(fish[0]){
			G[G_UTILITYCOOLDOWN] = cooldown;
			G[G_UTILITYCOOLDOWNMAX] = cooldown;
		
			Screen->FastTile(4, orbX, orbY, 16540, 8, 128);
			
			fishUpdate(fish, orbX, orbY, orbSize, orbTickFreq, false);
			
			Waitframe();
		}
		G[G_UTILITYCOOLDOWN] = cooldown;
		G[G_UTILITYCOOLDOWNMAX] = cooldown;
	}
	void fishUpdate(int fish, int orbX, int orbY, int orbSize, int orbTickFreq, bool damageEnemies){
		int fishX = fish[2];
		int fishY = fish[3];
		int fishTX = fish[4];
		int fishTY = fish[5];
		int fishST = fish[6];
		int fishType = fish[7];
		
		fish[0] = 0;
		bool hitLink;
		for(int i=0; i<128; ++i){
			if(fishST[i]){
				++fish[0];
				int vX; int vY;
				int angle = Angle(fishX[i], fishY[i], fishTX[i], fishTY[i]);
				int dist = Distance(fishX[i], fishY[i], fishTX[i], fishTY[i]);
				vX = VectorX(1, angle);
				vY = VectorY(1, angle);
				if(fishST[i]==1){
					if(dist<4){
						fishST[i] = 2;
						angle = Rand(360);
						dist = Rand(orbSize);
						fishTX[i] = orbX+VectorX(dist, angle);
						fishTY[i] = orbY+VectorY(dist, angle);
					}
					else{
						fishX[i] += vX*3;
						fishY[i] += vY*3;
					}
				}
				else if(fishST[i]==2){
					if(dist<8){
						fishX[i] = fishTX[i];
						fishY[i] = fishTY[i];
						angle = Rand(360);
						dist = Rand(orbSize);
						fishTX[i] = orbX+VectorX(dist, angle);
						fishTY[i] = orbY+VectorY(dist, angle);
					}
					else{
						fishX[i] += vX*5;
						fishY[i] += vY*5;
					}
				}
				else if(fishST[i]==3){
					if(dist<2){
						fishST[i] = 4;
						fishX[i] = fishTX[i];
						fishY[i] = fishTY[i];
						angle = Angle(orbX, orbY, fishX[i], fishY[i]);
						dist = Rand(orbSize);
						fishTX[i] = orbX+VectorX(300, angle);
						fishTY[i] = orbY+VectorY(300, angle);
					}
					else{
						fishX[i] += vX*1.5;
						fishY[i] += vY*1.5;
					}
				}
				else if(fishST[i]==4){
					if(dist<4){
						fishST[i] = 0;
					}
					else{
						fishX[i] += vX*3;
						fishY[i] += vY*3;
					}
				}
				
				if(vX<0)
					Screen->FastCombo(4, fishX[i], fishY[i], 720+fishType[i]*2, 0, 128);
				else
					Screen->FastCombo(4, fishX[i], fishY[i], 720+fishType[i]*2+1, 0, 128);
				
				// if(fishType[i]==7&&RectCollision(Link->X+4, Link->Y+4, Link->X+11, Link->Y+11, fishX[i]+4, fishY[i]+4, fishX[i]+11, fishY[i]+11)){
					// hitLink = true;
				// }
			}
		}
		
		if(fish[1])
			--fish[1];
		else if(hitLink){
			Game->PlaySound(SFX_OUCH);
			DealDirectDamage(4);
			fish[1] = orbTickFreq;
		}
		
		if(damageEnemies){
			for(int i=Screen->NumNPCs(); i>0; --i){
				npc n = Screen->LoadNPC(i);
				if(Distance(orbX, orbY, CenterX(n)-8, CenterY(n)-8)<orbSize){
					if(!n->Misc[NPCM_PIERCINGIFRAMES]){
						Game->PlaySound(SFX_EHIT);
						n->Misc[NPCM_PIERCEDAMAGE] = 2*G[G_HPSCALE];
						n->Misc[NPCM_PIERCINGIFRAMES] = orbTickFreq;
					}
				}
			}
		}
	}
	void runLadder(){
		int i; int j; int k;
		int x; int y;
		
		int ladderMap;
		int ladderScreen;
		int ladderPos;
		int ladderDir;
		int ladderLength;
		bool ladderOnThisScreen;
		for(i=0; i<8; ++i){
			ladderMap = G[G_RIGGSLADDERSTART+i*8+0];
			ladderScreen = G[G_RIGGSLADDERSTART+i*8+1];
			ladderPos = G[G_RIGGSLADDERSTART+i*8+2];
			ladderDir = G[G_RIGGSLADDERSTART+i*8+3];
			ladderLength = G[G_RIGGSLADDERSTART+i*8+4];
			if(ladderMap==Game->GetCurMap()&&ladderScreen==Game->GetCurScreen()){
				ladderOnThisScreen = true;
				break;
			}
		}
		
		int sx = Link->X+DirX(Link->Dir, 16);
		int sy = Link->Y+DirY(Link->Dir, 16);
		int dir = ladderDir;
		if(!ladderOnThisScreen)
			dir = Link->Dir;
		int len;
		int pos;
		int tempPos;
		int ladderCMB = 702;
		if(dir==DIR_LEFT||dir==DIR_RIGHT)
			++ladderCMB;
		
		int ladderableCombos[65280];
		ladderableCombos[39] = 1;
		ladderableCombos[48] = 1;
		ladderableCombos[49] = 1;
		ladderableCombos[50] = 1;
		ladderableCombos[176] = 1;
		ladderableCombos[177] = 1;
		ladderableCombos[256] = 1;
		ladderableCombos[257] = 1;
		ladderableCombos[356] = 1;
		ladderableCombos[7709] = 1;
		ladderableCombos[7732] = 1;
		ladderableCombos[7986] = 1;
		
		//Check for the lader extending
		if(!ladderOnThisScreen&&InputButtonItem(I_UTILITYSPELL)){
			if(!G[G_REMAININGLADDERS]){
				Quit();
			}
			
			int wallDist = 32;
			if(Game->GetCurLevel()==0){
				wallDist = 16;
			}
			
			pos = ComboAt(sx+8, sy+8);
			sx = ComboX(pos);
			sy = ComboY(pos);
			if(sx<wallDist||sx>240-wallDist||sy<wallDist||sy>160-wallDist){
				Quit();
			}
			if(!ladderCheckPit(pos, ladderableCombos)){
				Quit();
			}
			
			tempPos = pos;
			len = 1;
			for(i=0; i<16; ++i){
				tempPos = Q7_AdjacentCombo(tempPos, dir);
				sx = ComboX(tempPos);
				sy = ComboY(tempPos);
				if(sx<wallDist||sx>240-wallDist||sy<wallDist||sy>160-wallDist){
					break;
				}
				if(!ladderCheckPit(tempPos, ladderableCombos)){
					break;
				}
				++len;
			}
			
			for(i=0; i<len; ++i){
				x = ComboX(pos)+DirX(dir, 16*i);
				y = ComboY(pos)+DirY(dir, 16*i);
				Game->PlaySound(SFX_PLACE);
				SpriteAnim(x, y, 22, 1, 1);
				for(j=0; j<4; ++j){
					x = ComboX(pos);
					y = ComboY(pos);
					for(k=0; k<i; ++k){
						Screen->FastCombo(2, x, y, ladderCMB, 6, 128);
						x += DirX(dir, 16);
						y += DirY(dir, 16);
					}
					Waitframe();
				}
			}
			
			ladderMap = Game->GetCurMap();
			ladderScreen = Game->GetCurScreen();
			ladderPos = pos;
			ladderDir = dir;
			ladderLength = len;
			i = 0;
			for(j=0; j<8; ++j){
				if(G[G_RIGGSLADDERSTART+j*8+0]==0){
					i = j;
					break;
				}
			}
			G[G_RIGGSLADDERSTART+i*8+0] = ladderMap;
			G[G_RIGGSLADDERSTART+i*8+1] = ladderScreen;
			G[G_RIGGSLADDERSTART+i*8+2] = ladderPos;
			G[G_RIGGSLADDERSTART+i*8+3] = ladderDir;
			G[G_RIGGSLADDERSTART+i*8+4] = ladderLength;
			ladderOnThisScreen = true;
			--G[G_REMAININGLADDERS];
		}
		
		//Place the full ladder
		if(ladderOnThisScreen){
			tempPos = ladderPos;
			for(i=0; i<ladderLength; ++i){
				CopyTile(Game->ComboTile(Screen->ComboD[tempPos]), 16520+i);
				Screen->ComboD[tempPos] = 704+i;
				tempPos = Q7_AdjacentCombo(tempPos, ladderDir);
			}
			while(true){
				tempPos = ladderPos;
				for(i=0; i<ladderLength; ++i){
					Screen->FastCombo(2, ComboX(tempPos), ComboY(tempPos), ladderCMB, 6, 128);
					tempPos = Q7_AdjacentCombo(tempPos, ladderDir);
				}
				Waitframe();
			}
		}
	}
	bool ladderCheckPit(int pos, int ladderableCombos){
		int ct = Screen->ComboT[pos];
		int csL = Q7_GetLayerComboS(1, pos)|Q7_GetLayerComboS(2, pos);
		if(csL)
			return false;
		if(ct==CT_WATER||ct==CT_WASWATER||ct==CT_LADDERHOOKSHOT||ct==CT_HOOKSHOTONLY||ct==CT_LADDERONLY)
			return true;
		int cd = Screen->ComboD[pos];
		if(ladderableCombos[cd])
			return true;
		return false;
	}
	void runChainsOfHatred(){
		int damage = SwordDamageLevel(2, 4, 6, 8)*G[G_HPSCALE];
		int damageFire = SwordDamageLevel(0, 0, 8, 12)*G[G_HPSCALE];
		int doFire = SwordDamageLevel(0, 0, 1, 1);
		
		int i; int j; int k;
		int hookX = Link->X+DirX(Link->Dir, 8);
		int hookY = Link->Y+DirY(Link->Dir, 8)+4;
		int hookZ;
		int hookJump = 1;
		int hookAngle = DirAngle(Link->Dir);
		int chainArc;
		Game->PlaySound(SFX_FALL);
		for(i=0; i<40; ++i){
			chainArc = 8*Sin(i/20*180);
			hookJump = hookJump-0.05;
			hookZ = Max(hookZ+hookJump, 0);
			
			hookX += VectorX(6, hookAngle);
			hookY += VectorY(6, hookAngle);
			
			if(hookX+8<0||hookX+8>255||hookY+8<0||hookY+8>175)
				break;
			if(Screen->isSolid(hookX+8, hookY+8)){
				if(!Q7_IsPit(hookX+8, hookY+8)&&!Q7_IsWater(hookX+8, hookY+8)){
					Game->PlaySound(57);
					break;
				}
			}
			
			drawChainsOfHatred(Link->X, Link->Y, hookX, hookY, chainArc, hookZ, damage);
			
			Waitframe();
		}
		while(hookZ>0||chainArc>0){
			hookJump = hookJump-0.05;
			hookZ = Max(hookZ+hookJump, 0);
			chainArc = Max(chainArc+hookJump, 0);
			
			drawChainsOfHatred(Link->X, Link->Y, hookX, hookY, chainArc, hookZ, damage);
			
			Waitframe();
		}
		for(i=0; i<90; ++i){
			int dir = AngleDir4(Angle(hookX, hookY, Link->X, Link->Y));
			if(PressDir(0, dir)){
				break;
			}
			
			drawChainsOfHatred(Link->X, Link->Y, hookX, hookY, chainArc, hookZ, damage);
			
			Waitframe();
		}
		i = 0;
		while(Distance(hookX, hookY, Link->X, Link->Y)>6){
			hookAngle = Angle(hookX, hookY, Link->X, Link->Y);
			hookX += VectorX(6, hookAngle);
			hookY += VectorY(6, hookAngle);
			
			if(i%4==0&&doFire){
				lweapon fire = FireLWeapon(LW_FIRE, hookX, hookY, DegtoRad(hookAngle), 0, damageFire, 12, SFX_FIRE);
				fire->Misc[LWM_FIRETYPE] = 1;
			}
			++i;
			
			drawChainsOfHatred(Link->X, Link->Y, hookX, hookY, chainArc, hookZ, damage);
			
			Waitframe();
		}
		G[G_UTILITYCOOLDOWN] = 120;
		G[G_UTILITYCOOLDOWNMAX] = 120;
	}
	void drawChainsOfHatred(int startX, int startY, int endX, int endY, int arcHeight, int height, int damage){
		int dist = Distance(startX, startY, endX, endY);
		int angle = Angle(startX, startY, endX, endY);
		int x[16];
		int y[16];
		int z[16];
		for(int i=1; i<16; ++i){
			x[i] = startX+VectorX(dist*(i/16), angle);
			y[i] = startY+VectorY(dist*(i/16), angle);
			z[i] = Sin(arcHeight*180*(i/16))+height*(i/16);
			if(z>0)
				Screen->FastTile(2, x[i], y[i], TIL_CHAINSOFHATRED+2, 7, 128);
		}
		if(z>0)
			Screen->FastTile(2, endX, endY, TIL_CHAINSOFHATRED+3, 7, 128);
		for(int i=1; i<16; ++i){
			Screen->FastTile(2, x[i], y[i]-z[i], TIL_CHAINSOFHATRED, 8, 128);
		}
		Screen->DrawTile(2, endX, endY-height, TIL_CHAINSOFHATRED+1, 1, 1, 8, -1, -1, endX, endY-height, angle, 0, true, 128);
	
		if(damage)
			MakeHitbox(LW_ARROW, endX+4, endY-height+4, 8, 8, -1, damage);
	}
	void runFlakeShield(){
		int i; int j; int k;
		
		int x; int y;
		int xy[2];
		
		int cooldown;
		
		int chargeTier = 1;
		if(G[G_HOLMLASTSHIELD])
			chargeTier = G[G_HOLMLASTSHIELD];
		int chargeTimer;
		if(G[G_PRESERVEDCHARGEB]){
			chargeTier = G[G_PRESERVEDCHARGEB]>>12;
			chargeTimer = G[G_PRESERVEDCHARGEB]&0xFFF;
		}
		else{
			for(i=0; i<8&&InputButtonItem(I_UTILITYSPELL); ++i){
				Waitframe();
			}
			chargeTimer = 40;
			while(InputButtonItem(I_UTILITYSPELL)){
				--chargeTimer;
				if(chargeTimer<=0){
					Game->PlaySound(SFX_PETALSHIELD_ABSORB);
					++chargeTier;
					if(chargeTier>3)
						chargeTier = 1;
					chargeTimer = 40;
				}
				
				Screen->FastTile(6, Link->X, Link->Y-16, 5495, 11, 128);
				if(chargeTier==1)
					Screen->FastTile(6, Link->X, Link->Y-16, 5515, 0, 128);
				else if(chargeTier==2)
					Screen->FastTile(6, Link->X, Link->Y-16, 5535, 0, 128);
				else if(chargeTier==3)
					Screen->FastTile(6, Link->X, Link->Y-16, 5555, 0, 128);
				
				Waitframe();
			}
			G[G_HOLMLASTSHIELD] = chargeTier;
		}
		
		if(chargeTier==1){ //Flake
			int damageFlakeShield = SwordDamageLevel(2, 4, 6, 8)*G[G_HPSCALE];
			int damageFlakeShieldIce = SwordDamageLevel(4, 6, 8, 12)*G[G_HPSCALE];
			
			cooldown = 600;
			
			int numFlakes = SwordDamageLevel(3, 4, 5, 6);
			
			int flakeAngle = DirAngle(Link->Dir);
			int flakeSubAngle = 360/numFlakes;
			
			lweapon flake[6];
			int flakeX[6];
			int flakeY[6];
			bool flakeDestroyed[6];
			for(j=0; j<numFlakes; ++j){
				flake[j] = FireLWeapon(LW_SCRIPT10, Link->X, Link->Y, 0, 0, damageFlakeShield, SPR_INVISIBLE, 0);
			}
			
			Game->PlaySound(SFX_FLAKESHIELD_ACTIVATE);
			for(i=0; i<24; ++i){
				G[G_UTILITYCOOLDOWN] = cooldown;
				G[G_UTILITYCOOLDOWNMAX] = cooldown;
				
				flakeAngle = WrapDegrees(flakeAngle+4);
				
				for(j=0; j<numFlakes; ++j){
					flakeX[j] = Link->X+VectorX(i, flakeAngle+flakeSubAngle*j);
					flakeY[j] = Link->Y+VectorY(i, flakeAngle+flakeSubAngle*j);
					if(flake[j]->isValid()){
						flake[j]->X = 0;
						flake[j]->Y = 0;
						flake[j]->HitXOffset = flakeX[j];
						flake[j]->HitYOffset = flakeY[j];
						Screen->FastCombo(2, flakeX[j], flakeY[j], 685, 7, 128);
					}
					else{
						if(!flakeDestroyed[j]){
							npc target = flakeShieldHasKilled(flakeX[j], flakeY[j], xy);
							if(target->isValid()){
								target->ItemSet = 0;
								int args[8] = {xy[0], xy[1], damageFlakeShieldIce};
								RunFFCScript(FFCS_ICEBLOCK, args);
								SetEnemyProperty(target, ENPROP_HP, -1000);
								SetEnemyProperty(target, ENPROP_Y, -1000);
							}
							flakeDestroyed[j] = true;
						}
					}
				}
				
				Waitframe();
			}
			int flakesAlive = 8;
			while(!PressButtonItem(I_UTILITYSPELL)&&flakesAlive){
				G[G_UTILITYCOOLDOWN] = cooldown;
				G[G_UTILITYCOOLDOWNMAX] = cooldown;
				
				flakeAngle = WrapDegrees(flakeAngle+4);
				
				if(flakesAlive)
					--flakesAlive;
				for(j=0; j<numFlakes; ++j){
					flakeX[j] = Link->X+VectorX(24, flakeAngle+flakeSubAngle*j);
					flakeY[j] = Link->Y+VectorY(24, flakeAngle+flakeSubAngle*j);
					if(flake[j]->isValid()){
						flakesAlive = 8;
						flake[j]->X = 0;
						flake[j]->Y = 0;
						flake[j]->HitXOffset = flakeX[j];
						flake[j]->HitYOffset = flakeY[j];
						Screen->FastCombo(2, flakeX[j], flakeY[j], 685, 7, 128);
					}
					else{
						if(!flakeDestroyed[j]){
							npc target = flakeShieldHasKilled(flakeX[j], flakeY[j], xy);
							if(target->isValid()){
								target->ItemSet = 0;
								int args[8] = {xy[0], xy[1], damageFlakeShieldIce};
								RunFFCScript(FFCS_ICEBLOCK, args);
								SetEnemyProperty(target, ENPROP_HP, -1000);
								SetEnemyProperty(target, ENPROP_Y, -1000);
							}
							flakeDestroyed[j] = true;
						}
					}
				}
				
				Waitframe();
			}
			if(flakesAlive)
				Game->PlaySound(SFX_FLAKESHIELD_SPREAD);
			i = 24;
			while(flakesAlive){
				i += 8;
				
				G[G_UTILITYCOOLDOWN] = cooldown;
				G[G_UTILITYCOOLDOWNMAX] = cooldown;
				
				flakeAngle = WrapDegrees(flakeAngle+4);
				
				if(flakesAlive)
					--flakesAlive;
				for(j=0; j<numFlakes; ++j){
					flakeX[j] = Link->X+VectorX(i, flakeAngle+flakeSubAngle*j);
					flakeY[j] = Link->Y+VectorY(i, flakeAngle+flakeSubAngle*j);
					if(flake[j]->isValid()){
						flakesAlive = 8;
						if(flakeX[j]<-16||flakeX[j]>256||flakeY[j]<-16||flakeY[j]>256)
							flake[j]->DeadState = 0;
						flake[j]->X = 0;
						flake[j]->Y = 0;
						flake[j]->HitXOffset = flakeX[j];
						flake[j]->HitYOffset = flakeY[j];
						Screen->FastCombo(2, flakeX[j], flakeY[j], 685, 7, 128);
					}
					else{
						if(!flakeDestroyed[j]){
							npc target = flakeShieldHasKilled(flakeX[j], flakeY[j], xy);
							if(target->isValid()){
								target->ItemSet = 0;
								int args[8] = {xy[0], xy[1], damageFlakeShieldIce};
								RunFFCScript(FFCS_ICEBLOCK, args);
								SetEnemyProperty(target, ENPROP_HP, -1000);
								SetEnemyProperty(target, ENPROP_Y, -1000);
							}
							flakeDestroyed[j] = true;
						}
					}
				}
				
				Waitframe();
			}
		}
		else if(chargeTier==2){ //Petal
			int petalRadius = SwordDamageLevel(16, 24, 32, 48);
			int petalHealing = SwordDamageLevel(8, 8, 16, 16);
		
			cooldown = 900;
			
			if(!G[G_PRESERVEDCHARGEB])
				Game->PlaySound(SFX_PETALSHIELD_ACTIVATE);
			for(i=chargeTimer; i<300; ++i){
				G[G_PRESERVEDCHARGEB] = (chargeTier<<12)|i;
				
				G[G_UTILITYCOOLDOWN] = cooldown;
				G[G_UTILITYCOOLDOWNMAX] = cooldown;
				
				if(i<300-60||i%4<2){
					Screen->DrawTile(2, Link->X-24, Link->Y-24, 9200, 4, 4, 0, -1, -1, Link->X-24, Link->Y-24, WrapDegrees(G[G_ANIM]), 0, true, OP_TRANS);
					Screen->Circle(2, Link->X+8, Link->Y+8, petalRadius+2*Sin(G[G_ANIM]*8), 0x52, 1, 0, 0, 0, false, OP_OPAQUE);
					Screen->Circle(2, Link->X+8, Link->Y+8, petalRadius-2*Sin(G[G_ANIM]*8), 0xB8, 1, 0, 0, 0, false, OP_OPAQUE);
				}
				
				petalShieldHeal(petalRadius, petalHealing);
				
				Waitframe();
			}
			G[G_PRESERVEDCHARGEB] = 0;
		}
		else if(chargeTier==3){ //Skull
			cooldown = 420;
			
			int orbDamage = SwordDamageLevel(1, 2, 4, 8)*G[G_HPSCALE];
			int numOrbs = SwordDamageLevel(2, 2, 4, 4);
			
			int skullAngle = DirAngle(Link->Dir);
			int skullSubAngle = 360/numOrbs;
			int skullTimer;
			
			int skullX = Link->X;
			int skullY = Link->Y;
			
			if(!G[G_PRESERVEDCHARGEB])
				Game->PlaySound(SFX_SKULLSHIELD_ACTIVATE);
			for(i=chargeTimer; i<600&&!PressButtonItem(I_UTILITYSPELL); ++i){
				G[G_PRESERVEDCHARGEB] = (chargeTier<<12)|i;
				
				G[G_UTILITYCOOLDOWN] = cooldown;
				G[G_UTILITYCOOLDOWNMAX] = cooldown;
				
				skullX = Link->X;
				skullY = Link->Y;
				for(j=0; j<numOrbs; ++j){
					x = skullX+VectorX(12+16+16*Sin(2*skullTimer), skullAngle+skullSubAngle*j);
					y = skullY+VectorY(12+16+16*Sin(2*skullTimer), skullAngle+skullSubAngle*j);
				
					MakeHitbox(LW_BEAM, x+4, y+4, 8, 8, -1, orbDamage);
					Screen->FastCombo(2, x, y, 686, 11, 128);
				}
				
				++skullTimer;
				skullAngle = WrapDegrees(skullAngle+8);
				
				Waitframe();
			}
			G[G_PRESERVEDCHARGEB] = 0;
			if(PressButtonItem(I_UTILITYSPELL)){
				int dir = Link->Dir;
				while(skullX>-16-32&&skullX<256+32&&skullY>-16-32&&skullY<176+32){
					skullX += DirX(dir, 2);
					skullY += DirY(dir, 2);
					for(j=0; j<numOrbs; ++j){
						x = skullX+VectorX(12+16+16*Sin(2*skullTimer), skullAngle+skullSubAngle*j);
						y = skullY+VectorY(12+16+16*Sin(2*skullTimer), skullAngle+skullSubAngle*j);
					
						MakeHitbox(LW_BEAM, x+4, y+4, 8, 8, -1, orbDamage);
						Screen->FastCombo(2, x, y, 686, 11, 128);
					}
					
					++skullTimer;
					skullAngle = WrapDegrees(skullAngle+8);
					
					Waitframe();
				}
				
			}
		}
	}
	npc flakeShieldHasKilled(int flakeX, int flakeY, int retXY){
		for(int i=Screen->NumNPCs(); i>0; --i){
			npc n = Screen->LoadNPC(i);
			if(GetEnemyProperty(n, ENPROP_HP)<=0){
				int x = n->X+n->HitXOffset;
				int y = n->Y+n->HitYOffset;
				if(RectCollision(flakeX, flakeY, flakeX+15, flakeY+15, x, y, x+n->HitWidth-1, y+n->HitHeight-1)){
					retXY[0] = CenterX(n)-8;
					retXY[1] = CenterY(n)-8;
					return n;
				}
			}
		}
	}
	void petalShieldHeal(int rad, int healing){
		for(int i=Screen->NumEWeapons(); i>0; --i){
			eweapon e = Screen->LoadEWeapon(i);
			bool collDetection = e->CollDetection;
			if(collDetection&&e->TileWidth<=1&&e->TileHeight<=1&&e->Damage>0&&e->DeadState!=WDS_DEAD){
				if(Distance(e->X, e->Y, Link->X, Link->Y)<rad){
					Game->PlaySound(SFX_PETALSHIELD_ABSORB);
					Link->HP += healing;
					e->DeadState = 0;
				}
			}
		}
	}
	void runMoonblast(){
		int i; int j; int k;
		
		int damage = SwordDamageLevel(4, 6, 10, 16)*G[G_HPSCALE];
		int cooldown = 180;
		
		npc moonblastTarget[16];
		int mbTrailX[512];
		int mbTrailY[512];
		int mbStartX[16];
		int mbStartY[16];
		int mbBendX[16];
		int mbBendY[16];
		int mbTargetX[16];
		int mbTargetY[16];
		int mbState[16];
		int mbTimer[16];
		int mbTrailA[512];
		int mbSpecial[16];
		int moonblast[] = {mbTrailX, mbTrailY, mbStartX, mbStartY, mbBendX, mbBendY, mbTargetX, mbTargetY, mbState, mbTimer, mbTrailA, mbSpecial};
	
		if(Game->Counter[CR_RUPEES]>=5){
			for(i=0; i<5; ++i){
				Game->PlaySound(79);
				addMoonblast(moonblastTarget, moonblast, Link->X, Link->Y);
				if(Game->Counter[CR_RUPEES])
					--Game->Counter[CR_RUPEES];
				for(j=0; j<8; ++j){
					updateMoonblast(moonblastTarget, moonblast, damage);
					if(j%2==0)
						NoWalk();
					Waitframe();
				}
			}
			while(InputButtonItem(I_UTILITYSPELL)&&Game->Counter[CR_RUPEES]>=5){
				for(i=0; i<5; ++i){
					Game->PlaySound(79);
					addMoonblast(moonblastTarget, moonblast, Link->X, Link->Y);
					if(Game->Counter[CR_RUPEES])
						--Game->Counter[CR_RUPEES];
					for(j=0; j<8; ++j){
						updateMoonblast(moonblastTarget, moonblast, damage);
						if(j%2==0)
							NoWalk();
						Waitframe();
					}
				}
			}
			G[G_UTILITYCOOLDOWN] = cooldown;
			G[G_UTILITYCOOLDOWNMAX] = cooldown;
			for(i=0; i<48; ++i){
				updateMoonblast(moonblastTarget, moonblast, damage);
				Waitframe();
			}
		}
	}
	void addMoonblast(npc moonblastTarget, int moonblast, int x, int y){
		int mbTrailX = moonblast[0];
		int mbTrailY = moonblast[1];
		int mbStartX = moonblast[2];
		int mbStartY = moonblast[3];
		int mbBendX = moonblast[4];
		int mbBendY = moonblast[5];
		int mbTargetX = moonblast[6];
		int mbTargetY = moonblast[7];
		int mbState = moonblast[8];
		int mbTimer = moonblast[9];
		int mbTrailA = moonblast[10];
		int mbSpecial = moonblast[11];
		
		for(int i=0; i<16; ++i){
			if(!mbState[i]){
				moonblastTarget[i] = moonblastFindTarget(i, mbTargetX, mbTargetY);
				
				for(int j=0; j<16; ++j){
					mbTrailX[i*32+j] = x;
					mbTrailY[i*32+j] = y;
					mbTrailA[i*32+j] = 0;
				}
				mbStartX[i] = x;
				mbStartY[i] = y;
				int ang = Angle(mbTargetX[i], mbTargetY[i], mbStartX[i], mbStartY[i])+Rand(-60, 60);
				int dist = Rand(16, 64);
				mbBendX[i] = x+VectorX(dist, ang);
				mbBendY[i] = y+VectorY(dist, ang);
				
				mbState[i] = 1;
				mbTimer[i] = 32;
				
				mbSpecial[i] = 0;
				if(Rand(256)==0)
					mbSpecial[i] = 1;
				
				return;
			}
		}
	}
	void updateMoonblast(npc moonblastTarget, int moonblast, int damage){
		int i; int j; int k;
		
		int mbTrailX = moonblast[0];
		int mbTrailY = moonblast[1];
		int mbStartX = moonblast[2];
		int mbStartY = moonblast[3];
		int mbBendX = moonblast[4];
		int mbBendY = moonblast[5];
		int mbTargetX = moonblast[6];
		int mbTargetY = moonblast[7];
		int mbState = moonblast[8];
		int mbTimer = moonblast[9];
		int mbTrailA = moonblast[10];
		int mbSpecial = moonblast[11];
		
		int xy[2];
		
		for(i=0; i<16; ++i){
			if(mbState[i]){
				if(mbState[i]==1){
					if(moonblastTarget[i]->isValid()){
						mbTargetX[i] = CenterX(moonblastTarget[i])-8;
						mbTargetY[i] = CenterY(moonblastTarget[i])-8;
					}
					
					BezierQuadFrame(xy, 32-mbTimer[i], 32, mbStartX[i], mbStartY[i], mbBendX[i], mbBendY[i], mbTargetX[i], mbTargetY[i]);
					moonblastTrails(xy[0]+8, xy[1]+8, i, mbTrailX, mbTrailY, mbTrailA, 16-Min(32-mbTimer[i], 16), 16, 12, true);
					Screen->Circle(2, xy[0]+8, xy[1]+8, 6, 0x01, 1, 0, 0, 0, true, 128);
					if(mbSpecial[i])
						Screen->FastCombo(2, xy[0], xy[1], 682, 8, 128);
					else
						Screen->FastTile(2, xy[0], xy[1], 5678, 11, 128);
					
					MakeHitbox(LW_ARROW, xy[0]+4, xy[1]+4, 8, 8, -1, damage);
					
					--mbTimer[i];
					if(mbTimer[i]<=-1){
						mbState[i] = 2;
						mbTimer[i] = 16;
					}
				}
				else if(mbState[i]==2){
					xy[0] = mbTargetX[i];
					xy[1] = mbTargetY[i];
					moonblastTrails(xy[0]+8, xy[1]+8, i, mbTrailX, mbTrailY, mbTrailA, 16-mbTimer[i], 16, 12, false);
					Screen->Circle(2, xy[0]+8, xy[1]+8, 6, 0x01, 1, 0, 0, 0, true, 128);
					if(mbTimer[i]%4<2){
						if(mbSpecial[i])
							Screen->FastCombo(2, xy[0], xy[1], 682, 8, 128);
						else
							Screen->FastTile(2, xy[0], xy[1], 5678, 11, 128);
					}
					
					--mbTimer[i];
					if(mbTimer[i]<=0){
						mbState[i] = 0;
					}
				}
			}
		}
	}
	npc moonblastFindTarget(int index, int mbTargetX, int mbTargetY){
		int numTargets;
		
		int npcT[256];
		int npcID[256];
		LoadInvulnerableNPCs(npcT, npcID);
		
		npc targets[256];
		for(int i=Screen->NumNPCs(); i>0; --i){
			npc n = Screen->LoadNPC(i);
			if(n->CollDetection&&!npcT[n->Type]&&!npcID[n->ID]&&n->Defense[NPCD_ARROW]!=NPCDT_BLOCK&&n->Defense[NPCD_ARROW]!=NPCDT_IGNORE){
				targets[numTargets] = n;
				++numTargets;
			}
		}
		
		if(numTargets>0){
			npc target = targets[Rand(numTargets)];
			mbTargetX[index] = CenterX(target)-8;
			mbTargetY[index] = CenterY(target)-8;
			return target;
		}
		else{
			mbTargetX[index] = Link->X+DirX(Link->Dir, 48);
			mbTargetY[index] = Link->Y+DirY(Link->Dir, 48);
			npc nullnpc;
			return nullnpc;
		}
	}
	void moonblastTrails(int x, int y, int whichTrail, int mbTrailX, int mbTrailY, int mbTrailA, int start, int end, int w, bool updateTrails){
		int index = whichTrail*32;
		int tempX[17];
		int tempY[17];
		int tempA[17];
		for(int i=0; i<=16; ++i){
			if(updateTrails){
				if(i==16){
					if(Distance(mbTrailX[index+i], mbTrailY[index+i], x, y)<1)
						mbTrailA[index+i] = mbTrailA[index+i-1];
					else
						mbTrailA[index+i] = Angle(mbTrailX[index+i], mbTrailY[index+i], x, y);
					mbTrailX[index+i] = x;
					mbTrailY[index+i] = y;
				}
				else{
					mbTrailX[index+i] = mbTrailX[index+i+1];
					mbTrailY[index+i] = mbTrailY[index+i+1];
					mbTrailA[index+i] = mbTrailA[index+i+1];
				}
			}
			tempX[i] = mbTrailX[index+i];
			tempY[i] = mbTrailY[index+i];
			tempA[i] = mbTrailA[index+i];
		}
		DrawQuadTrail(2, tempX, tempY, tempA, start, end, w, 0x01, false);
	}
	void runCapeOfVaquia(){
		int cooldown = 900;
		int duration = SwordDamageLevel(120, 180, 240, 360);
		
		int timePassed;
		if(G[G_PRESERVEDCHARGEB])
			timePassed = G[G_PRESERVEDCHARGEB];
		else{
			Game->PlaySound(60);
			SpriteAnim(Link->X, Link->Y, 22, 1, 1);
		}
		for(int i=timePassed; i<duration; ++i){
			G[G_UTILITYCOOLDOWN] = cooldown;
			G[G_UTILITYCOOLDOWNMAX] = cooldown;
			G[G_PRESERVEDCHARGEB] = i;
			
			if(i<duration-60||i%4<2)
				SetInvisible();
			
			SetNoColl();
			
			Screen->FastCombo(2, Link->X, Link->Y, 683, 7, 128);
			
			Waitframe();
		}
		G[G_UTILITYCOOLDOWN] = cooldown;
		G[G_UTILITYCOOLDOWNMAX] = cooldown;
			
		Game->PlaySound(60);
		lweapon poof = SpriteAnim(Link->X, Link->Y, 22, 1, 1);
		G[G_PRESERVEDCHARGEB] = 0;
		while(poof->isValid()){
			Q7_DrawToLayer(poof, 6, 128);
			Waitframe();
		}
	}
	void runFrostHydra(){
		int i; int j; int k;
		int vX;
		
		int cooldown = 300;
		
		int hydraX = Link->X;
		int hydraY = Link->Y;
		
		int damage = SwordDamageLevel(2, 4, 6, 8)*G[G_HPSCALE];
		int attackFreq = SwordDamageLevel(300, 240, 210, 180);
		
		Game->PlaySound(60);
		SpriteAnim(Link->X, Link->Y, 22, 1, 1);
		
		int fireCounter = 60;
		int fireAng;
		npc target;
		
		while(!PressButtonItem(I_UTILITYSPELL)){
			G[G_UTILITYCOOLDOWN] = cooldown;
			G[G_UTILITYCOOLDOWNMAX] = cooldown;
			
			target = Generic_FindTarget(NPCD_SCRIPT, hydraX, hydraY, Angle(hydraX, hydraY, Link->X, Link->Y));
			if(target->isValid())
				fireAng = Angle(hydraX, hydraY, CenterX(target)-8, CenterY(target)-8);
			else
				fireAng = Angle(hydraX, hydraY, Link->X, Link->Y);
			
			if(fireCounter)
				--fireCounter;
			else{
				fireCounter = attackFreq;
				for(i=0; i<24; ++i){
					G[G_UTILITYCOOLDOWN] = cooldown;
					G[G_UTILITYCOOLDOWNMAX] = cooldown;
			
					target = Generic_FindTarget(NPCD_SCRIPT, hydraX, hydraY, Angle(hydraX, hydraY, Link->X, Link->Y), 3);
					if(target->isValid())
						fireAng = Angle(hydraX, hydraY, CenterX(target)-8, CenterY(target)-8);
					else
						fireAng = Angle(hydraX, hydraY, Link->X, Link->Y);
					
					if(i%8==0){
						lweapon l = FireLWeapon(LW_SCRIPT10, hydraX, hydraY, DegtoRad(fireAng), 350, damage, 0, SFX_ICE);
						l->OriginalTile = 16683;
						l->Tile = l->OriginalTile;
						l->Misc[LWM_ROTATION] = 1;
					}
					
					vX = VectorX(10, fireAng);
			
					if(vX<0)
						Screen->DrawTile(2, hydraX+Rand(-2, 2), hydraY+Rand(-2, 2), 16682, 1, 1, 7, -1, -1, 0, 0, 0, 1, true, 128);
					else
						Screen->DrawTile(2, hydraX+Rand(-2, 2), hydraY+Rand(-2, 2), 16682, 1, 1, 7, -1, -1, 0, 0, 0, 0, true, 128);
			
					
					Waitframe();
				}
			}
			
			vX = VectorX(10, fireAng);
			
			if(vX<0)
				Screen->DrawTile(2, hydraX, hydraY, 16682, 1, 1, 7, -1, -1, 0, 0, 0, 1, true, 128);
			else
				Screen->DrawTile(2, hydraX, hydraY, 16682, 1, 1, 7, -1, -1, 0, 0, 0, 0, true, 128);
			
			Waitframe();
		}
		
		Game->PlaySound(60);
		SpriteAnim(hydraX, hydraY, 22, 1, 1);
	}
	void runPowerSlash(){
		int i; int j; int k;
		
		int damage = SwordDamageLevel(2, 4, 8, 12)*G[G_HPSCALE];
		int critMultiplier = 1;
		if(Rand(10)==0)
			critMultiplier = 3;
		
		int cooldown = 240;
		
		int centerX = Link->X + 8 + DirX(Link->Dir, 64);
		int centerY = Link->Y + 8 + DirY(Link->Dir, 64);
		int angle = DirAngle(Link->Dir)+90;
		
		int pointX[16];
		int pointY[16];
		int pointA[16];
		int pointW[16];
		
		Game->PlaySound(SFX_ZARATHSLASH);
		for(i=0; i<16; ++i){
			G[G_UTILITYCOOLDOWN] = cooldown;
			G[G_UTILITYCOOLDOWNMAX] = cooldown;
			
			for(j=0; j<16; ++j){
				pointX[j] = centerX+VectorX(-96+192*(i/16)*(j/16), angle);
				pointY[j] = centerY+VectorY(-96+192*(i/16)*(j/16), angle);
				pointA[j] = angle+Rand(-60, 60);
				pointW[j] = 8*(i/16)*Sin((j/15)*180)*Rand(5, 20)*0.1+4;
				
				lweapon hitbox = MakeHitbox(LW_BEAM, pointX[j]-4, pointY[j]-4, 8, 8, -1, damage*critMultiplier);
			}
			
			DrawQuadTrail2(5, pointX, pointY, pointA, pointW, 16, 0x02);
			
			for(j=0; j<16; ++j){
				pointX[j] = centerX+VectorX(-96+192*(i/16)*(j/16), angle);
				pointY[j] = centerY+VectorY(-96+192*(i/16)*(j/16), angle);
				pointW[j] -= 4;
			}
			
			DrawQuadTrail2(5, pointX, pointY, pointA, pointW, 16, 0x01);
			
			Waitframe();
		}
		if(critMultiplier>1)
			Game->PlaySound(SFX_ZARATHPOKE);
		//angle += 180;
		for(i=16; i>0; --i){
			G[G_UTILITYCOOLDOWN] = cooldown;
			G[G_UTILITYCOOLDOWNMAX] = cooldown;
			
			for(j=0; j<16; ++j){
				pointX[j] = centerX+VectorX(96-192*(i/16)*(j/16), angle);
				pointY[j] = centerY+VectorY(96-192*(i/16)*(j/16), angle);
				pointA[j] = angle+Rand(-60, 60);
				pointW[j] = 8*(i/16)*Sin((j/15)*180)*Rand(5, 20)*0.1+4;
				
				lweapon hitbox = MakeHitbox(LW_BEAM, pointX[j]-4, pointY[j]-4, 8, 8, -1, damage*critMultiplier);
			}
			
			DrawQuadTrail2(5, pointX, pointY, pointA, pointW, 16, 0x02);
			
			for(j=0; j<16; ++j){
				pointX[j] = centerX+VectorX(96-192*(i/16)*(j/16), angle);
				pointY[j] = centerY+VectorY(96-192*(i/16)*(j/16), angle);
				pointW[j] -= 4;
			}
			
			DrawQuadTrail2(5, pointX, pointY, pointA, pointW, 16, 0x01);
			
			Waitframe();
		}
		
		//DrawQuadTrail2(int layer, int pointX, int pointY, int pointAng, int pointW, int numPoints, int clr){
	}
	void runShotgun(){
		int damage = SwordDamageLevel(4, 8, 16, 24)*G[G_HPSCALE];
		int cooldown = 80;
		int x; int y;
		for(int i=0; i<8; ++i){
			G[G_UTILITYCOOLDOWN] = cooldown;
			G[G_UTILITYCOOLDOWNMAX] = cooldown;
			x = Link->X + DirX(Link->Dir, (i/8)*8);
			y = Link->Y + DirY(Link->Dir, (i/8)*8);
			Screen->FastTile(Cond(Link->Dir==DIR_UP, 2, 4), x, y, TIL_SHOTGUN+Link->Dir, 8, 128);
			Link->Action = LA_NONE;
			Link->Action = LA_ATTACKING;
			NoAction();
			Waitframe();
		}
		for(int i=0; i<8; ++i){
			G[G_UTILITYCOOLDOWN] = cooldown;
			G[G_UTILITYCOOLDOWNMAX] = cooldown;
			x = Link->X + DirX(Link->Dir, 8);
			y = Link->Y + DirY(Link->Dir, 8);
			Screen->FastTile(Cond(Link->Dir==DIR_UP, 2, 4), x, y, TIL_SHOTGUN+Link->Dir, 8, 128);
			Link->Action = LA_NONE;
			Link->Action = LA_ATTACKING;
			NoAction();
			Waitframe();
		}
		Game->PlaySound(136);
		lweapon shotgunPellet[6];
		for(int i=0; i<6; ++i){
			shotgunPellet[i] = FireLWeapon(LW_BEAM, x+DirX(Link->Dir, 8), y+DirY(Link->Dir, 8), DegtoRad(DirAngle(Link->Dir)+Rand(-20, 20)), 300+Rand(50), damage, 0, 0);
			shotgunPellet[i]->HitXOffset = 6;
			shotgunPellet[i]->HitYOffset = 6;
			shotgunPellet[i]->HitWidth = 4;
			shotgunPellet[i]->HitHeight = 4;
			shotgunPellet[i]->Tile = TIL_SHOTGUN_PELLET;
			shotgunPellet[i]->OriginalTile = TIL_SHOTGUN_PELLET;
			shotgunPellet[i]->CSet = 11;
		}
		bool hitWall;
		for(int i=0; i<8; ++i){
			for(int j=0; j<6; ++j){
				if(shotgunPellet[j]->isValid()){
					if(shotgunPellet[j]->DeadState==WDS_ALIVE)
						SpriteAnim(shotgunPellet[j]->X, shotgunPellet[j]->Y, TIL_SHOTGUN_TRAIL, 11, 4, 1, 1, 1);
				}
			}
			G[G_UTILITYCOOLDOWN] = cooldown;
			G[G_UTILITYCOOLDOWNMAX] = cooldown;
			x = Link->X + DirX(Link->Dir, 8);
			y = Link->Y + DirY(Link->Dir, 8);
			Screen->FastTile(Cond(Link->Dir==DIR_UP, 2, 4), x, y, TIL_SHOTGUN+Link->Dir, 8, 128);
			LinkMovement_Push(DirX(Link->Dir, -3), DirY(Link->Dir, -3));
			Link->Action = LA_NONE;
			Link->Action = LA_ATTACKING;
			if(!CanWalkNoEdgeNoWater(Link->X, Link->Y, OppositeDir(Link->Dir), 1, false)){
				hitWall = true;
				break;
			}
			NoAction();
			Waitframe();
		}
		if(hitWall){
			Game->PlaySound(16);
			for(int i=0; i<=8; ++i){
				x = Link->X+DirX(OppositeDir(Link->Dir), Sin(360*(i/8)));
				y = Link->Y+DirY(OppositeDir(Link->Dir), Sin(360*(i/8)));
				Link->X = Clamp(x, 0, 240);
				Link->Y = Clamp(y, 0, 160);
				PlaySpurdoMessage(1);
				if(i==4){
					Game->PlaySound(SFX_OUCH);
					Link->Action = LA_GOTHURTLAND;
					Link->HitDir = -1;
					DealDirectDamage(16);
				}
				NoAction();
				Waitframe();
			}
		}
		for(int i=0; i<80; ++i){
			for(int j=0; j<6; ++j){
				if(shotgunPellet[j]->isValid()){
					if(shotgunPellet[j]->DeadState==WDS_ALIVE)
						SpriteAnim(shotgunPellet[j]->X, shotgunPellet[j]->Y, TIL_SHOTGUN_TRAIL, 11, 4, 1, 1, 1);
				}
			}
			Waitframe();
		}
		Game->PlaySound(137);
		PlaySpurdoMessage(0);
	}
	void runStarfall(){
		if(G[G_MANISTARFALLLEVEL]==0){
			Quit();
		}
		int maxSize = 16;
		int damage = 1;
		if(G[G_MANISTARFALLLEVEL]==2){
			maxSize = 32;
			damage = 2;
		}
		if(G[G_MANISTARFALLLEVEL]==3){
			maxSize = 48;
			damage = 4;
		}
		if(G[G_MANISTARFALLLEVEL]==4){
			maxSize = 56;
			damage = 8;
		}
		if(G[G_MANISTARFALLLEVEL]==5){
			maxSize = 64;
			damage = 32;
		}
		damage *= G[G_HPSCALE];
		G[G_MANISTARFALLLEVEL] = 0;
		G[G_MANISTARFALLCHARGE] = 0;
		CopyTile(12994, 12985);
		
		int sX[256];
		int sY[256];
		int sT[256];
		int sST[256];
		int sAng[256];
		npc sNPC[256];
		int starCount;
		int i;
		for(i=Screen->NumNPCs(); i>0; --i){
			npc n = Screen->LoadNPC(i);
			if(Q7_NPCIsBeatable(n)&&n->CollDetection){
				sNPC[starCount] = n;
				sAng[starCount] = Rand(360);
				sT[starCount] = starCount*10+Rand(20);
				++starCount;
			}
		}
		int starsFinished;
		while(starsFinished<starCount){
			for(i=0; i<starCount; ++i){
				if(sST[i]==0){ //Waiting to spawn
					--sT[i];
					if(sT[i]==0){
						if(sNPC[i]->isValid()){ //If the enemy is still alive, drop
							Game->PlaySound(SFX_FALL);
							sX[i] = CenterX(sNPC[i])-8;
							sY[i] = CenterY(sNPC[i])-8;
							sST[i] = 1;
							sT[i] = 176;
						}
						else{ //Otherwise flag as finished
							sST[i] = -1;
							++starsFinished;
						}
					}
				}
				else if(sST[i]==1){ //Falling
					sAng[i] += 5;
					sT[i] -= 8;
					if(G[G_ANIM]%4<2)
						Screen->FastTile(4, sX[i], sY[i], 7015, 7, 128);
					int x = sX[i]+sT[i]/4;
					int y = sY[i]-sT[i];
					Screen->DrawCombo(4, x+4, y-16, 699, 1, 1, 1, -1, -1, x+2, y-8, sAng[i]-10, -1, 0, true, 64);
					Screen->DrawCombo(4, x+2, y-8, 699, 1, 1, 1, -1, -1, x+1, y-4, sAng[i]-5, -1, 0, true, 64);
					Screen->DrawCombo(4, x, y, 699, 1, 1, 1, -1, -1, x, y, sAng[i], -1, 0, true, 128);
					if(sT[i]<=0){
						Game->PlaySound(138);
						sST[i] = 2;
						sT[i] = 0;
					}
				}
				else if(sST[i]==2){ //Impact
					++sT[i];
					if(sT[i]<32){
						sAng[i] += 7;
						Starfall_DrawShockwave(4, sX[i]+8, sY[i]+8, sAng[i], Lerp(8, maxSize, sT[i]/32), 0, Choose(0x11, 0x12, 0x13));
						int w = Lerp(16, maxSize, sT[i]/32)*0.75;
						lweapon hitbox = MakeHitbox(LW_BEAM, sX[i]+8-w/2, sY[i]+8-w/2, w, w, -1, damage);
					}
					else{
						sAng[i] += 10;
						Starfall_DrawShockwave(4, sX[i]+8, sY[i]+8, sAng[i], Lerp(maxSize, maxSize+64, (sT[i]-32)/32), Round(Lerp(4, 1, (sT[i]-32)/32)), Choose(0x11, 0x12, 0x13));
					}
					if(sT[i]==64){
						sST[i] = -1;
						++starsFinished;
					}
				}
			}
			Waitframe();
		}
	}
	void Starfall_DrawShockwave(int layer, int x, int y, int ang, int r, int lineW, int c){
		int pX[20];
		int pY[20];
		int i;
		int mult = 0.618; //0.382 for regular star
		for(i=0; i<10; ++i){
			pX[2*i] = x+VectorX(r, ang+i*72);
			pY[2*i] = y+VectorY(r, ang+i*72);
			pX[2*i+1] = x+VectorX(r*mult, ang+36+i*72);
			pY[2*i+1] = y+VectorY(r*mult, ang+36+i*72);
		}
		if(lineW==0){
			for(int i=0; i<5; ++i){
				Screen->Quad(layer, pX[1+4*i], pY[1+4*i], pX[2+4*i], pY[2+4*i], pX[3+4*i], pY[3+4*i], x, y, 1, 1, c, 0, -1, PT_FLAT);
			}
		}
		else if(lineW==1){
			for(int i=0; i<5; ++i){
				Screen->Line(layer, pX[2*i], pY[2*i], pX[2*i+1], pY[2*i+1], c, 1, 0, 0, 0, 128);
				Screen->Line(layer, pX[2*i+1], pY[2*i+1], pX[2*i+2], pY[2*i+2], c, 1, 0, 0, 0, 128);
			}
		}
		else{
			for(int i=0; i<5; ++i){
				DrawThickLine(4, pX[2*i], pY[2*i], pX[2*i+1], pY[2*i+1], lineW, c, true, 128);
				DrawThickLine(4, pX[2*i+1], pY[2*i+1], pX[2*i+2], pY[2*i+2], lineW, c, true, 128);
			}
		}
		//DrawThickLine(4, x1, y1, x2, y2, 1, c1, true, 128);
	}
	void runChaoticMagic(){
		int cooldown = 180;
		int sigDamage = SwordDamageLevel(2, 4, 8, 10)*G[G_HPSCALE];
		
		int pattern = Rand(7);
		int i; int j; int k; int m;
		if(pattern==0){ //Fires
			for(i=0; i<8; ++i){
				lweapon fire = FireLWeapon(LW_FIRE, Link->X, Link->Y, DegtoRad(45*i), 100, sigDamage+ChaoticCritDamage(), 12, SFX_FIRE);
				if(Link->Item[I_CANDLE3])
					fire->CSet = 10;
			}
		}
		else if(pattern==1){ //Wind
			j = Rand(4, 6);
			k = Link->Dir;
			for(i=0; i<j; ++i){
				lweapon wind = FireLWeapon(LW_ARROW, Link->X+DirX(Link->Dir, 8), Link->Y+DirY(Link->Dir, 8), DegtoRad(DirAngle(k)+Rand(-30, 30)), Rand(300, 350), sigDamage+ChaoticCritDamage(), 13, 59);
				for(m=0; m<8; ++m){
					G[G_UTILITYCOOLDOWN] = cooldown;
					G[G_UTILITYCOOLDOWNMAX] = cooldown;
					Waitframe();
				}
			}
		}
		else if(pattern==2){ //Lightning
			lweapon lwLightning[128];
			int lightningBuffer[8192];
			int lightningX[128];
			int lightningY[128];
			int lightningState[128];
			int lightningMaxDist[128];
			int lightningCurDist[128];
			int lightningSplit[128];
			int lightning[] = {0, lightningBuffer, lightningX, lightningY, lightningState, lightningMaxDist, lightningCurDist, lightningSplit};
			SignatureWeapons.addLightning(lwLightning, lightning, Link->X+8+DirX(Link->Dir, 8), Link->Y+8+DirY(Link->Dir, 8), DirAngle(Link->Dir), sigDamage*2, 2);
			for(i=0; i<128; ++i){
				if(lwLightning[i]->isValid())
					lwLightning[i]->Misc[LWM_MISCFLAGS] |= LWMF_PIERCING;
			}
			lightning[0] = 1;
			while(lightning[0]){
				G[G_UTILITYCOOLDOWN] = cooldown;
				G[G_UTILITYCOOLDOWNMAX] = cooldown;
				SignatureWeapons.updateLightning(lwLightning, lightning);
				Waitframe();
			}
		}
		else if(pattern==3){ //Ice
			RunMiscSpellFFC(0, 0, 0, sigDamage*1.5);
		}
		else if(pattern==4){ //Magic
			j = SwordDamageLevel(3, 3, 5, 7);
			k = SwordDamageLevel(30, 30, 40, 50);
			for(i=0; i<j; ++i){
				lweapon l = FireLWeapon(LW_MAGIC, Link->X+DirX(Link->Dir, 16), Link->Y+DirY(Link->Dir, 16), DegtoRad(DirAngle(Link->Dir)+Lerp(-k, k, i/(j-1))), 250, sigDamage+ChaoticCritDamage(), 21, SFX_WAND);
				if(l->Dir==DIR_DOWN)
					l->Flip = 2;
				if(l->Dir>DIR_DOWN){
					++l->Tile;
					if(l->Dir==DIR_LEFT)
						l->Flip = 1;
				}
			}
		}
		else if(pattern==5){ //Spear Storm
			k = Rand(5, 8);
			for(i=0; i<k; ++i){
				RunMiscSpellFFC(1, Link->X+DirX(Link->Dir, 8)+Cond(Link->Dir<=DIR_DOWN, Rand(-16, 16), 0), Link->Y+DirY(Link->Dir, 8)+Cond(Link->Dir>DIR_DOWN, Rand(-16, 16), 0), sigDamage*1.5+ChaoticCritDamage());
				for(j=0; j<8; ++j){
					G[G_UTILITYCOOLDOWN] = cooldown;
					G[G_UTILITYCOOLDOWNMAX] = cooldown;
					NoAction();
					Waitframe();
				}
			}
		}
		else if(pattern==6){ //Targetted Bomb
			int posX[3];
			int posY[3];
			int delay[3];
			j = Rand(360);
			for(i=0; i<3; ++i){
				posX[i] = Link->X+VectorX(40, j+120*i);
				posY[i] = Link->Y+VectorY(40, j+120*i);
				delay[i] = Rand(1, 31);
			}
			Game->PlaySound(SFX_PLACE);
			for(i=0; i<90; ++i){
				for(j=0; j<3; ++j){
					Screen->FastCombo(2, posX[j], posY[j], 738, 8, 128);
				}
				G[G_UTILITYCOOLDOWN] = cooldown;
				G[G_UTILITYCOOLDOWNMAX] = cooldown;
				Waitframe();
			}
			for(i=0; i<32; ++i){
				for(j=0; j<3; ++j){
					if(delay[j]){
						Screen->FastCombo(2, posX[j], posY[j], 738, 8, 128);
						--delay[j];
						if(delay[j]==0){
							lweapon l = FireLWeapon(LW_BOMBBLAST, posX[j], posY[j], 0, 0, sigDamage*2+ChaoticCritDamage(), 0, 0);
							l->Dir = -1;
						}
					}
				}
				G[G_UTILITYCOOLDOWN] = cooldown;
				G[G_UTILITYCOOLDOWNMAX] = cooldown;
				Waitframe();
			}
		}
		G[G_UTILITYCOOLDOWN] = cooldown;
		G[G_UTILITYCOOLDOWNMAX] = cooldown;
	}
	int ChaoticCritDamage(){
		if(Rand(16)){
			return SwordDamageLevel(1, 2, 3, 4)*G[G_HPSCALE];
		}
		return 0;
	}
	void runOneWholeRupee(){
		if(Game->Counter[CR_RUPEES]>20&&G[G_FROGGER_SHIELDLEVEL]<8){
			int holdTime = 64;
			int postHoldTime = 24;
			do{
				for(int i=0; i<holdTime; ++i){
					SetInvisible();
					Screen->DrawCombo(2, Link->X-8, Link->Y-13, 739, 2, 2, 10, -1, -1, 0, 0, 0, -1, 0, true, 128);
					Screen->FastTile(2, Link->X, Link->Y, 13016, 6, 128);
					Screen->FastTile(2, Link->X-5, Link->Y-12, 16495, 5, 128);
					G[G_FROGGER_HALOEXCEPTION] = 1;
					WaitNoAction();
				}
				Game->PlaySound(69);
				for(int i=0; i<20; ++i){
					lweapon l = SparkleSpriteAnim(Link->X, Link->Y, 127, 1, 1, Rand(360), Rand(100, 350));
					l->OriginalTile += Rand(4);
					l->Tile = l->OriginalTile;
					l->OriginalCSet = 8;
					l->FlashCSet = 7;
				}
				Game->Counter[CR_RUPEES] = Max(Game->Counter[CR_RUPEES]-20, 0);
				for(int i=0; i<postHoldTime; ++i){
					SetInvisible();
					Screen->DrawCombo(2, Link->X-8, Link->Y-13, 739, 2, 2, 10, -1, -1, 0, 0, 0, -1, 0, true, 128);
					Screen->FastTile(2, Link->X, Link->Y, 13016, 6, 128);
					G[G_FROGGER_HALOEXCEPTION] = 1;
					WaitNoAction();
				}
				LongDongRegalia.FroggerShield_AddElement(true);
				holdTime = Max(holdTime-8, 16);
				postHoldTime = Max(postHoldTime-4, 8);
			}while(Link->InputB&&Game->Counter[CR_RUPEES]>0&&G[G_FROGGER_SHIELDLEVEL]<8)
		}
		else{
			Game->PlaySound(SFX_ERROR);
		}
		//SparkleSpriteAnim(int x, int y, int til, int cset, int numframes, int aspeed, int w, int h, int angle, int step)
	}
	void runFaceOff(){
		int i;
		int x; int y;
		
		int damage = 1*G[G_HPSCALE];
		int npcForms[1024];
		DimiFormEnemies(npcForms);
		
		npc closest;
		ffc closestFFC;
		int closestDist = 1000;
		int closestForm;
		int closestType;
		int closestSubtype;
		for(int i=Screen->NumNPCs(); i>0; --i){
			npc n = Screen->LoadNPC(i);
			if(npcForms[n->ID]>0&&npcForms[n->ID]!=G[G_DIMITRANSFORM]){
				int dist = Distance(CenterX(n), CenterY(n), Link->X+8, Link->Y+8);
				if(dist<closestDist){
					closestDist = dist;
					closest = n;
					closestForm = npcForms[n->ID];
					closestSubtype = npcForms[512+n->ID];
					closestType = 1;
				}
			}
		}
		int soulX;
		int soulY;
		for(int i=1; i<=32; ++i){
			ffc f = Screen->LoadFFC(i);
			if(f->Script==FFCS_MISCSPELLS&&f->InitD[0]==3){
				int dist = Distance(f->InitD[1], f->InitD[2], Link->X, Link->Y)*0.5;
				if(dist<closestDist){
					closestFFC = f;
					soulX = f->InitD[1];
					soulY = f->InitD[2];
					npc invalid;
					closestDist = dist;
					closest = invalid;
					closestForm = f->InitD[3]&0x1FF;
					closestSubtype = f->InitD[3]>>9;
					closestType = 2;
				}
			}
		}
		if(closestType){
			if(closest->isValid()){
				soulX = CenterX(closest)-8;
				soulY = CenterY(closest)-8;
				closest->Misc[NPCM_PIERCEDAMAGE] += damage;
			}
			if(closestType==2){
				closestFFC->Script = 0;
				closestFFC->Data = 0;
			}
			int trailX[4];
			int trailY[4];
			for(i=0; i<4; ++i){
				trailX[i] = soulX;
				trailY[i] = soulY;
			}
			
			Game->PlaySound(139);
			while(Distance(soulX, soulY, Link->X, Link->Y)>4){
				i = Angle(soulX, soulY, Link->X, Link->Y);
				soulX += VectorX(4, i);
				soulY += VectorY(4, i);
				for(i=3; i>0; --i){
					trailX[i] = trailX[i-1];
					trailY[i] = trailY[i-1];
				}
				trailX[0] = soulX;
				trailY[0] = soulY;
				for(i=0; i<4; ++i){
					x = trailX[i]+Lerp(0, 6, i/3);
					y = trailY[i]+Lerp(0, 6, i/3);
					Screen->DrawCombo(4, x, y, 741, 1, 1, 11, Lerp(16, 4, i/3), Lerp(16, 4, i/3), 0, 0, 0, -1, 0, true, 128);
				}
				Waitframe();
			}
			soulX = -1000;
			soulY = -1000;
			int transformTile = DimiTransformations.GetTransformationGFX(closestForm)+18;
			int oldTransformTile = 49160;
			if(G[G_DIMITRANSFORM]!=DT_NONE)
				oldTransformTile = DimiTransformations.GetTransformationGFX(G[G_DIMITRANSFORM])+18;
			
			Game->PlaySound(142);
			for(i=0; i<64; ++i){
				SetInvisible();
				x = Link->X+Lerp(0, 6, i/64);
				y = Link->Y+Lerp(0, 6, i/64);
				Screen->DrawTile(2, x, y, oldTransformTile+Cond(i%4<2, 0, 1), 1, 1, 6, Lerp(16, 4, i/64), Lerp(16, 4, i/64), 0, 0, 0, 0, true, 128);
				x = Link->X+Lerp(6, 0, i/64);
				y = Link->Y+Lerp(6, 0, i/64);
				Screen->DrawTile(2, x, y, transformTile+Cond(i%4<2, 0, 1), 1, 1, 6, Lerp(4, 16, i/64), Lerp(4, 16, i/64), 0, 0, 0, 0, true, 128);
				NoAction();
				Waitframe();
			}
			Link->Dir = DIR_DOWN;
			G[G_DIMITRANSFORM] = closestForm;
			G[G_DIMITRANSFORMSUBTYPE] = closestSubtype;
			DimiTransformations.UpdateTransformationGFX();
			G[G_UTILITYCOOLDOWNMAX] = 60*SwordDamageLevel(20, 15, 10, 5);
			G[G_UTILITYCOOLDOWN] = G[G_UTILITYCOOLDOWNMAX];
		}
	}
}

// bool InputDir(int direction){
	// if(direction == DIR_UP){
		// return Link->InputUp;
	// }
	// if(direction == DIR_DOWN){
		// return Link->InputDown;
	// }
	// if(direction == DIR_LEFT){
		// return Link->InputLeft;
	// }
	// if(direction == DIR_RIGHT){
		// return Link->InputRight;
	// }
// }

bool PressDir(int P2, int direction){
	if(direction == DIR_UP){
		return Link->PressUp;
	}
	if(direction == DIR_DOWN){
		return Link->PressDown;
	}
	if(direction == DIR_LEFT){
		return Link->PressLeft;
	}
	if(direction == DIR_RIGHT){
		return Link->PressRight;
	}
}

const int FFCS_LIGHTOFDARKNESS = 132;

const int TIL_LOD_RUNE = 9002;
const int TIL_LOD_CHAIN = 9004;
const int TIL_LOD_SWORD = 9024;

const int SFX_LIGHTOFDARKNESS_IMPACT = 17; //SFX when chains hit an enemy
const int SFX_LIGHTOFDARKNESS_HITWALL = 6; //SFX when chains hit a wall
const int SFX_LIGHTOFDARKNESS_FIRE = 90; //SFX when chains are fired
const int SFX_ZARATHSLASH = 124; //SFX for the sword combo
const int SFX_ZARATHPOKE = 123; //SFX for the sword poke

const float DAMAGE_LIGHTOFDARKNESS_HEAD = 1; //Damage the head of the chain deals
const float DAMAGE_LIGHTOFDARKNESS_DOT = 150; //Damage over time the chain deals, this happens 6 times a second and is unaffected by scaling
const float DAMAGE_LIGHTOFDARKNESS_SLASH = 2; //Damage the sword counter deals

const int COOLDOWN_LIGHTOFDARKNESS_SLASH = 120;

ffc script LightOfDarkness{
	void run(){
		int damageHead = SwordDamageLevel(1, 2, 3, 4);
		int damageSlash = SwordDamageLevel(4, 6, 8, 12);
		//G[G_ZARATHOVERDRIVE] = 480;
		
		int i; int j; int k; int angle;
		int x; int y;
		int vX; int vY;
		
		int vars[32];
		int oldChainX[4];
		int oldChainY[4];
		for(i=0; i<4; i++){
			oldChainX[i] = -1000;
			oldChainY[i] = -1000;
		}
		int push[2];
		int bezierX[128];
		int bezierY[128];
		
		vars[0] = -1000; //Chain X
		vars[1] = -1000; //Chain Y
		vars[2] = oldChainX;
		vars[3] = oldChainY;
		vars[4] = -1; //State: 0 = Extending, 1 = Grabbed solid, 2 = Grabbed enemy, 3 = Pulling enemy, 4 = Pull to enemy, 5 = After pull, 6 = Slash
		vars[5] = -1000; //Chain angle
		vars[6] = 1; //Timer
		vars[7] = 0; //Chain timer
		vars[8] = 0; //Chain safety timer (prevents getting stuck and infinitely chaining to something)
		vars[9] = 0; //
		vars[10] = 0; //Stored HP total
		vars[11] = Link->HP; //Stored Link HP
		vars[12] = 10; //Spawning grace period
		vars[13] = 0; //Collided with chain?
		vars[14] = push;
		vars[15] = bezierX;
		vars[16] = bezierY;
		vars[17] = 0;
		vars[18] = 0; //Buffered grab
		vars[19] = 0; //Stored Chain X
		vars[20] = 0; //Stored Chain Y
		vars[24] = damageHead;
		vars[25] = damageSlash;
		//vars[26] - Angle
		
		int chainCooldown;
		
		lweapon hitbox[1];
		npc target[1];
		while(true){
			if(!chainCooldown&&LOD_IsPressing()&&vars[4]==-1 && !Link->SwordJinx){
				vX = 0;
				if(InputDir(DIR_LEFT)&&!InputDir(DIR_RIGHT))
					vX = -1;
				else if(InputDir(DIR_RIGHT)&&!InputDir(DIR_LEFT))
					vX = 1;
				vY = 0;
				if(InputDir(DIR_UP)&&!InputDir(DIR_DOWN))
					vY = -1;
				else if(InputDir(DIR_DOWN)&&!InputDir(DIR_UP))
					vY = 1;
				
				if(vX!=0||vY!=0){
					angle = Angle(0, 0, 10*vX, 10*vY);
				}
				else
					angle = LOD_TargetAngle();
				Game->PlaySound(SFX_LIGHTOFDARKNESS_FIRE);
				G[G_SWORDSHOOTERFLAG] = 2;
				vars[4] = 0;
				vars[5] = angle;
				vars[0] = Link->X+VectorX(12, angle);
				vars[1] = Link->Y+VectorY(12, angle);
				if(hitbox[0]->isValid())
					hitbox[0]->DeadState = 0;
				hitbox[0] = CreateLWeaponAt(LW_BEAM, vars[0], vars[1]);
				hitbox[0]->CollDetection = false;
				hitbox[0]->DrawYOffset = -1000;
				hitbox[0]->Dir = Link->Dir;
				hitbox[0]->Step = 0;
				
				chainCooldown = 8;
			}
			if(chainCooldown)
				--chainCooldown;
			
			if(vars[23])
				--vars[23];
			
			// if(G[G_ZARATHOVERDRIVE]>0){
				// G[G_ZARATHSCALING] = 0;
				// --G[G_ZARATHOVERDRIVE];
				// if(G[G_ZARATHOVERDRIVE]==0){
					// vars[23] = 60;
					// G[G_ZARATHSCALING] = 0;
				// }
			// }
			LOD_Waitframe(vars, hitbox, target);
		}
	}
	void LOD_Waitframe(int vars, lweapon hitbox, npc target){
		int i; int j; int k; int x; int y;
		npc NULLNPC;
		
		int oldChainX = vars[2];
		int oldChainY = vars[3];
		int push = vars[14];
		
		//HandlePushArray(push, 24, 2, P2);
		
		vars[6] = (vars[6]+1)%360;
		if(vars[12]>0) //Spawning grace period
			vars[12]--;
		
		
		LOD_UpdateRetractChain(vars);
		
		if(vars[4]>-1){
			int angle = Angle(Link->X, Link->Y, vars[0], vars[1]);
			int xStart = Link->X+VectorX(12, angle);
			int yStart = Link->Y+VectorY(12, angle);
			if(vars[0]<-16||vars[0]>256||vars[1]<-16||vars[1]>176){
				vars[4] = -1;
				LOD_AddRetractChain(vars, vars[19], vars[20]);
				target[0] = NULLNPC;
			}
			
			if(vars[4]==0){ //Extending
				vars[7] = 0;
				vars[0] += VectorX(12, vars[5]);
				vars[1] += VectorY(12, vars[5]);
				
				if(hitbox[0]->isValid()){
					hitbox[0]->X = vars[0];
					hitbox[0]->Y = vars[1];
					hitbox[0]->HitXOffset = -4;
					hitbox[0]->HitYOffset = -4;
					hitbox[0]->HitWidth = 24;
					hitbox[0]->HitHeight = 24;
				}
				else{
					hitbox[0] = CreateLWeaponAt(LW_BEAM, vars[0], vars[1]);
					hitbox[0]->HitXOffset = -4;
					hitbox[0]->HitYOffset = -4;
					hitbox[0]->HitWidth = 24;
					hitbox[0]->HitHeight = 24;
					hitbox[0]->CollDetection = false;
					hitbox[0]->DrawYOffset = -1000;
					hitbox[0]->Dir = Link->Dir;
					hitbox[0]->Step = 0;
				}
				
				LOD_DrawChain(xStart, yStart, vars[0], vars[1], vars[6]);
				if(LOD_IsSolid(vars[0]+8, vars[1]+8)){
					i = AngleDir8(Angle(Link->X, Link->Y, vars[0], vars[1]));
					if(i==DIR_UP||i==DIR_DOWN)
						vars[1] = GridY(vars[1]+8);
					else if(i==DIR_LEFT||i==DIR_RIGHT)
						vars[0] = GridX(vars[0]+8);
					else{
						vars[0] = GridX(vars[0]+8);
						vars[1] = GridY(vars[1]+8);
					}
					
					vars[4] = 1;
					Game->PlaySound(SFX_LIGHTOFDARKNESS_HITWALL);
					if(hitbox[0]->isValid())
						hitbox[0]->DeadState = 0;
				}
				if(vars[0]<-16||vars[0]>256||vars[1]<-16||vars[1]>176){
					vars[4] = -1;
					LOD_AddRetractChain(vars, vars[19], vars[20]);
					if(hitbox[0]->isValid())
						hitbox[0]->DeadState = 0;
				}
				
			}
			else if(vars[4]==1){ //Grabbed Solid
				LOD_DrawChain(xStart, yStart, vars[0], vars[1], vars[6]);
				if(vars[7]<8)
					vars[7]++;
				if(vars[7]>=8&&!LOD_IsUsing()){
					vars[4] = -1;
					LOD_AddRetractChain(vars, vars[0], vars[1]);
					if(hitbox[0]->isValid())
						hitbox[0]->DeadState = 0;
				}
				else if(!LOD_IsSolid(vars[0]+8, vars[1]+8)){
					vars[4] = -1;
					LOD_AddRetractChain(vars, vars[0], vars[1]);
					if(hitbox[0]->isValid())
						hitbox[0]->DeadState = 0;
				}
			}
			else if(vars[4]==2){ //Grabbed Enemy
				if(target[0]->isValid()){
					if(LOD_CanStun(target[0]))
						target[0]->Stun = 20;
					vars[0] = CenterX(target[0])-8;
					vars[1] = CenterY(target[0])-8;
					if(!(vars[0]<-16||vars[0]>256||vars[1]<-16||vars[1]>176))
						LOD_DrawChain(xStart, yStart, vars[0], vars[1], vars[6]);
					vars[7]++;
					
					int dir = AngleDir4(Angle(Link->X, Link->Y, CenterX(target[0])-8, CenterY(target[0])-8));
					bool pulledAway;
					bool pulledTowards;
					if(LOD_CanPull(target[0])){
						if(dir==DIR_UP&&InputDir(DIR_DOWN))
							pulledAway = true;
						else if(dir==DIR_DOWN&&InputDir(DIR_UP))
							pulledAway = true;
						else if(dir==DIR_LEFT&&InputDir(DIR_RIGHT))
							pulledAway = true;
						else if(dir==DIR_RIGHT&&InputDir(DIR_LEFT))
							pulledAway = true;
					}
					
					if(dir==DIR_UP&&InputDir(DIR_UP))
						pulledTowards = true;
					else if(dir==DIR_DOWN&&InputDir(DIR_DOWN))
						pulledTowards = true;
					else if(dir==DIR_LEFT&&InputDir(DIR_LEFT))
						pulledTowards = true;
					else if(dir==DIR_RIGHT&&InputDir(DIR_RIGHT))
						pulledTowards = true;
					
					if(vars[0]<-16||vars[0]>256||vars[1]<-16||vars[1]>176){
						vars[4] = -1;
						LOD_AddRetractChain(vars, vars[19], vars[20]);
						target[0] = NULLNPC;
					}
					else if(LOD_IsPressing()){
						if(pulledAway){
							vars[4] = 3;
							vars[8] = 32;
						}
						else if(pulledTowards){
							vars[4] = 4;
							vars[7] = 4;
							vars[8] = 32;
						}
					}
					else if(vars[7]>=32){
						if(pulledAway){
							vars[4] = 3;
							vars[8] = 32;
						}
						else{
							vars[4] = -1;
							LOD_AddRetractChain(vars, vars[0], vars[1]);
						}
					}
				}
				else{
					LOD_DrawChain(xStart, yStart, vars[0], vars[1], vars[6]);
					vars[4] = -1;
					LOD_AddRetractChain(vars, vars[0], vars[1]);
				}
				
				if(hitbox[0]->isValid())
					hitbox[0]->DeadState = 0;
			}
			else if(vars[4]==3){ //Pulling Enemy
				angle = Angle(Link->X, Link->Y, vars[0], vars[1]);
				x = Link->X+VectorX(12, angle);
				y = Link->Y+VectorY(12, angle);
				angle = Angle(vars[0], vars[1], x, y);
				if(vars[8]>0)
					vars[8]--;
				else{
					vars[4] = -1;
					LOD_AddRetractChain(vars, vars[0], vars[1]);
					target[0] = NULLNPC;
				}
				if(Distance(Link->X, Link->Y, vars[0], vars[1])<52){
					if(LOD_IsPressing())
						vars[18] = 1;
				}
				if(vars[0]<-16||vars[0]>256||vars[1]<-16||vars[1]>176){
						vars[4] = -1;
						LOD_AddRetractChain(vars, vars[19], vars[20]);
						target[0] = NULLNPC;
				}
				else if(Distance(Link->X, Link->Y, vars[0], vars[1])>24){
					vars[0] += VectorX(8, angle);
					vars[1] += VectorY(8, angle);
				}
				else{
					vars[4] = 5;
					vars[8] = 6;
					LOD_AddRetractChain(vars, vars[0], vars[1]);
				}
				if(target[0]->isValid()){
					SetEnemyProperty(target[0], ENPROP_X, vars[0]);
					SetEnemyProperty(target[0], ENPROP_Y, vars[1]);
					if(LOD_CanStun(target[0]))
						target[0]->Stun = 40;
					if(LOD_IsSolid(vars[0]+8, vars[1]+8)){
						SetEnemyProperty(target[0], ENPROP_X, GridX(vars[0]+8));
						SetEnemyProperty(target[0], ENPROP_Y, GridY(vars[1]+8));
						vars[4] = -1;
						LOD_AddRetractChain(vars, vars[0], vars[1]);
						target[0] = NULLNPC;
					}
				}
				if(!(vars[0]<-16||vars[0]>256||vars[1]<-16||vars[1]>176))
					LOD_DrawChain(x, y, vars[0], vars[1], vars[6]);
				
				if(hitbox[0]->isValid())
					hitbox[0]->DeadState = 0;
			}
			else if(vars[4]==4){ //Pull to Enemy
				if(target[0]->isValid()){
					if(LOD_CanStun(target[0]))
						target[0]->Stun = 40;
					vars[0] = CenterX(target[0])-8;
					vars[1] = CenterY(target[0])-8;
					push[0] = VectorX(4, Angle(Link->X, Link->Y, vars[0], vars[1]));
					push[1] = VectorY(4, Angle(Link->X, Link->Y, vars[0], vars[1]));
					LinkMovement_Push(push[0], push[1]);
					if(!CanWalk(Link->X, Link->Y, AngleDir4(Angle(Link->X, Link->Y, vars[0], vars[1])), 1, true)){
						vars[4] = -1;
						LOD_AddRetractChain(vars, vars[0], vars[1]);
						target[0] = NULLNPC;
					}
					
					if(vars[7]>0)
						vars[7]--;
					
					if(!G[G_SIGCOOLDOWN]&&LOD_IsUsing()&&Distance(Link->X, Link->Y, CenterX(target[0])-8, CenterY(target[0])-8)<56){
						if(true){
							vars[4] = 7;
							vars[8] = 8;
							vars[26] = Angle(Link->X, Link->Y, vars[0], vars[1]);
							Game->PlaySound(SFX_ZARATHPOKE);
							G[G_SIGCOOLDOWN] = COOLDOWN_LIGHTOFDARKNESS_SLASH;
							G[G_SIGCOOLDOWNMAX] = COOLDOWN_LIGHTOFDARKNESS_SLASH;
						}
					}
					if(vars[8]>0)
						vars[8]--;
					else{
						vars[4] = -1;
						LOD_AddRetractChain(vars, vars[0], vars[1]);
						target[0] = NULLNPC;
					}
					if(vars[0]<-16||vars[0]>256||vars[1]<-16||vars[1]>176){
						vars[4] = -1;
						LOD_AddRetractChain(vars, vars[19], vars[20]);
						target[0] = NULLNPC;
					}
					else if(Distance(Link->X, Link->Y, vars[0], vars[1])<16){
						vars[4] = 8;
						vars[8] = 6;
						vars[26] = Angle(Link->X, Link->Y, vars[0], vars[1]);
						LOD_AddRetractChain(vars, vars[0], vars[1]);
						//target[0] = NULLNPC;
					}
					else if(Distance(Link->X, Link->Y, vars[0], vars[1])<32&&vars[7]==0){
						vars[4] = 8;
						vars[8] = 6;
						vars[26] = Angle(Link->X, Link->Y, vars[0], vars[1]);
						LOD_AddRetractChain(vars, vars[0], vars[1]);
						//target[0] = NULLNPC;
					}
					x = Link->X+VectorX(12, angle);
					y = Link->Y+VectorY(12, angle);
					if(!(vars[0]<-16||vars[0]>256||vars[1]<-16||vars[1]>176))
						LOD_DrawChain(x, y, vars[0], vars[1], vars[6]);
				}
				else{
					vars[4] = -1;
					LOD_AddRetractChain(vars, vars[0], vars[1]);
					target[0] = NULLNPC;
				}
			
				if(hitbox[0]->isValid())
					hitbox[0]->DeadState = 0;
			}
			else if(vars[4]==5){ //After pull
				if(target[0]->isValid()){
					if(!G[G_SIGCOOLDOWN]&&Distance(Link->X, Link->Y, CenterX(target[0])-8, CenterY(target[0])-8)<32&&(LOD_IsPressing()||vars[18])){
						if(true){
							vars[4] = 6;
							vars[8] = 20;
							LOD_SetSlash(vars, target);
							Game->PlaySound(SFX_ZARATHSLASH);
							G[G_SIGCOOLDOWN] = COOLDOWN_LIGHTOFDARKNESS_SLASH;
							G[G_SIGCOOLDOWNMAX] = COOLDOWN_LIGHTOFDARKNESS_SLASH;
						}
						else{
							vars[4] = -1;
							target[0] = NULLNPC;
						}
					}
					else if(vars[8]>0)
						vars[8]--;
					else{
						vars[4] = -1;
						target[0] = NULLNPC;
					}
				}
				else{
					vars[4] = -1;
					target[0] = NULLNPC;
				}
			
				if(hitbox[0]->isValid())
					hitbox[0]->DeadState = 0;
			}
			else if(vars[4]==6){ //Slash
				if(target[0]->isValid()){
					if(LOD_CanStun(target[0]))
						target[0]->Stun = 40;
					vars[0] = CenterX(target[0]);
					vars[1] = CenterY(target[0]);
					
					if(vars[8]==10){
						int lodSlashDamage = DAMAGE_LIGHTOFDARKNESS_SLASH;
						LOD_DamageEnemy(target[0], vars[25]+CritRingDamage(), false);
					}
				}
				j = 20-vars[8];
				k = 128;
				if(j<4||j>16)
					k = 64;
				
				Link->Dir = AngleDir4(Angle(Link->X, Link->Y, vars[0], vars[1]));
				Link->Action = LA_NONE;
				Link->Action = LA_ATTACKING;
			
				angle = Angle(Link->X, Link->Y, vars[0], vars[1]);
				x = Link->X+VectorX(14, angle-80+9*j);
				y = Link->Y+VectorY(16, angle-80+9*j);
				Screen->DrawTile(4, x, y, TIL_LOD_SWORD, 1, 1, 11, -1, -1, x, y, angle-80+9*j, 0, true, k);
				LOD_DrawSlash(vars[0], vars[1], vars, j*5);
				
				if(vars[8]>=0)
					vars[8]--;
				else{
					vars[4] = -1;
					target[0] = NULLNPC;
				}
				
				if(hitbox[0]->isValid())
					hitbox[0]->DeadState = 0;
			}
			else if(vars[4]==7){ //Stab
				if(target[0]->isValid()){
					if(LOD_CanStun(target[0]))
						target[0]->Stun = 40;
					vars[0] = CenterX(target[0])-8;
					vars[1] = CenterY(target[0])-8;
				}
				// else if(vars[0]>-1000){
					// vars[0] = -1000;
					// LOD_AddRetractChain(vars, vars[0], vars[1]);
					// target[0] = NULLNPC;
				// }
			
				push[0] = VectorX(1, Angle(Link->X, Link->Y, vars[0], vars[1]));
				push[1] = VectorY(1, Angle(Link->X, Link->Y, vars[0], vars[1]));
				LinkMovement_Push(push[0], push[1]);
					
				Link->Action = LA_NONE;
				Link->Action = LA_ATTACKING;
				
				x = Link->X+VectorX(12, vars[26]);
				y = Link->Y+VectorY(12, vars[26]);
				Screen->DrawTile(4, x, y, TIL_LOD_SWORD, 1, 1, 11, -1, -1, x, y, vars[26], 0, true, 128);
				
				LOD_DrawSlash2(Link->X+8, Link->Y+8, vars, 8-vars[8]);
			
				if(hitbox[0]->isValid())
					hitbox[0]->DeadState = 0;
				
				if(vars[8]>=0)
					vars[8]--;
				else{
					vars[4] = -1;
					target[0] = NULLNPC;
				}
				
				if(hitbox[0]->isValid())
					hitbox[0]->DeadState = 0;
			}
			else if(vars[4]==8){ //After pull to enemy
				if(target[0]->isValid()){
					if(LOD_CanStun(target[0]))
						target[0]->Stun = 40;
					vars[0] = CenterX(target[0])-8;
					vars[1] = CenterY(target[0])-8;
				}
				push[0] = VectorX(8, vars[26]);
				push[1] = VectorY(8, vars[26]);
				LinkMovement_Push(push[0], push[1]);
				
				if(!G[G_SIGCOOLDOWN]&&LOD_IsPressing()&&Distance(Link->X, Link->Y, CenterX(target[0])-8, CenterY(target[0])-8)<56){
					if(true){
						vars[4] = 7;
						vars[8] = 8;
						//vars[26] = Angle(Link->X, Link->Y, vars[0], vars[1]);
						Game->PlaySound(SFX_ZARATHPOKE);
						G[G_SIGCOOLDOWN] = COOLDOWN_LIGHTOFDARKNESS_SLASH;
						G[G_SIGCOOLDOWNMAX] = COOLDOWN_LIGHTOFDARKNESS_SLASH;
					}
				}
					
				if(vars[8]>=0)
					vars[8]--;
				else{
					vars[4] = -1;
					target[0] = NULLNPC;
				}
				
				if(hitbox[0]->isValid())
					hitbox[0]->DeadState = 0;
			}
		}
		
		int HPTotal;
		npc n;
		int mostDamage;
		int remHP;
		for(i = Screen->NumNPCs(); i>=1; i--){
			npc n = Screen->LoadNPC(i);
			
			if(n->CollDetection&&n->HP>0&&n->Defense[NPCD_BEAM]!=NPCDT_IGNORE){
				if(vars[4]==0){//&&GetEnemyProperty(n, 18)<=0){
					if(RectCollision(n->X+n->HitXOffset, n->Y+n->HitYOffset, n->X+n->HitXOffset+n->HitWidth-1, n->Y+n->HitYOffset+n->HitHeight-1, vars[0]+4, vars[1]+4, vars[0]+11, vars[1]+11)){
						if(hitbox[0]->isValid())
							hitbox[0]->DeadState = 0;
						int lodDamage = DAMAGE_LIGHTOFDARKNESS_HEAD;
						if(LOD_CanGrab(n)){
							vars[0] = CenterX(n)-8;
							vars[1] = CenterY(n)-8;
							LOD_DamageEnemy(n, vars[24]+CritRingDamage(), false);
							//G[G_ZARATHSCALING] += 100;
							vars[4] = 2;
							target[0] = n;
							if(LOD_CanStun(n))
								n->Stun = 20;
						}
						else{
							vars[0] = CenterX(n)-8;
							vars[1] = CenterY(n)-8;
							LOD_DamageEnemy(n, vars[24]+CritRingDamage(), false);
							//G[G_ZARATHSCALING] += 100;
							vars[4] = 1;
							if(LOD_CanStun(n))
								n->Stun = 20;
						}
					}
				}
				vars[13] = 0;
				for(j=0; j<4; j++){
					if(oldChainX[j]>-1000){
						k = Angle(Link->X, Link->Y, oldChainX[j], oldChainY[j]);
						x = Link->X+VectorX(12, k);
						y = Link->Y+VectorY(12, k);
						LOD_ChainDOT(vars, x, y, oldChainX[j], oldChainY[j], n);
					}
				}
				if(vars[4]>-1){
					k = Angle(Link->X, Link->Y, vars[0], vars[1]);
					x = Link->X+VectorX(12, k);
					y = Link->Y+VectorY(12, k);
					LOD_ChainDOT(vars, x, y, vars[0], vars[1], n);
				}
				if(vars[13]){
					LOD_DamageEnemy(n, DAMAGE_LIGHTOFDARKNESS_DOT, true);
				}
			}
		}
		

		int damage;
		if(mostDamage>0){//HPTotal!=vars[10]){
			if(!vars[12]&&!vars[22]){//if(HPTotal<vars[10]&&vars[10]!=0&&vars[12]==0){
				vars[22] = 40;
			}
		}
		
		if(vars[22])
			--vars[22];
			
		vars[19] = vars[0];
		vars[20] = vars[1];
		Waitframe();
	}
	bool LOD_IsSolid(int x, int y){
		int pos = ComboAt(x, y);
		int ct = Screen->ComboT[pos];
		if((ct==CT_NOENEMY || ct==CT_NOGROUNDENEMY || ct==CT_WATER || ct==CT_LADDERHOOKSHOT || ct==CT_HOOKSHOTONLY || ct==CT_LADDERONLY)){
			return false;
		}
		return Screen->isSolid(x, y);
	}
	bool LOD_CanPlaceLink(int x, int y){
		for(int X=4; X<=11; X=Min(X+8, 11)){
			for(int Y=4; Y<=11; Y=Min(Y+8, 11)){
				if(Screen->isSolid(x+X, y+Y)){
					return false;
				}
				if(Y==11)
					break;
			}
			if(X==11)
				break;
		}
		return true;
	}
	bool LOD_IsUsing(){
		if(Link->Action == LA_SWIMMING || Link->Action == LA_DIVING || Link->Action == LA_GOTHURTWATER)
			return false;
		if(Link->InputA)
			return true;
		return false;
	}
	bool LOD_IsPressing(){
		if(Link->Action == LA_SWIMMING || Link->Action == LA_DIVING || Link->Action == LA_GOTHURTWATER)
			return false;
		if(Link->PressA)
			return true;
		return false;
	}
	int LOD_TargetAngle(){
		int baseAngle = WrapDegrees(DirAngle(Link->Dir));
		
		int dist; int angle;
		int bestScore = 1000;
		
		npc best;
		for(int i=Screen->NumNPCs(); i>=1; i--){
			npc n = Screen->LoadNPC(i);
			int cx = CenterX(n);
			int cy = CenterY(n);
			if((n->MiscFlags&1000b)||!n->CollDetection||Abs(n->HitXOffset)>=1000||Abs(n->HitYOffset)>=1000||LOD_IsSolid(cx, cy)){
				continue;
			}
			
			dist = Distance(Link->X+8, Link->Y+8, cx, cy);
			angle = Angle(Link->X+8, Link->Y+8, cx, cy);
			int score = Abs(AngDiff(angle, baseAngle))*(Min(dist, 80)/80);
			if(score<bestScore&&Abs(AngDiff(angle, baseAngle))<=45){
				bestScore = score;
				best = n;
			}
		}
		
		if(best->isValid()){
			return Angle(Link->X+8, Link->Y+8, CenterX(best), CenterY(best));
		}
		return baseAngle;
	}
	void LOD_AddRetractChain(int vars, int x, int y){
		int P2 = vars[21];
		int angle = Angle(Link->X, Link->Y, x, y);
		int xStart = Link->X+VectorX(12, angle);
		int yStart = Link->Y+VectorY(12, angle);
		
		int oldChainX = vars[2];
		int oldChainY = vars[3];
		for(int i=0; i<4; i++){
			if(oldChainX[i]==-1000){
				oldChainX[i] = x;
				oldChainY[i] = y;
				return;
			}
		}
	}
	void LOD_UpdateRetractChain(int vars){
		int angle; int xStart; int yStart;
		int oldChainX = vars[2];
		int oldChainY = vars[3];
		
		for(int i=0; i<4; i++){
			if(oldChainX[i]>-1000){
				angle = Angle(Link->X, Link->Y, oldChainX[i], oldChainY[i]);
				xStart = Link->X+VectorX(12, angle);
				yStart = Link->Y+VectorY(12, angle);
				if(oldChainX[i]>=-16-16&&oldChainX[i]<=256+16&&oldChainY[i]>=-16-16&&oldChainY[i]<=176+16){
					LOD_DrawChain(xStart, yStart, oldChainX[i], oldChainY[i], vars[6]);

					angle = Angle(oldChainX[i], oldChainY[i], xStart, yStart);
					if(Distance(oldChainX[i], oldChainY[i], xStart, yStart)>4){
						oldChainX[i] += VectorX(4, angle);
						oldChainY[i] += VectorY(4, angle);
					}
					else{
						oldChainX[i] = -1000;
						oldChainY[i] = -1000;
					}
				}
				else{
					oldChainX[i] = -1000;
					oldChainY[i] = -1000;
				}
			}
		}
	}
	void LOD_DrawChain(int x1, int y1, int x2, int y2, int anim){
		int i; int x; int y;
		if(anim%4<2){
			Screen->Circle(4, x1+8, y1+8, 12+4*Sin(anim*8), 0x0F, 1, 0, 0, 0, true, 128);
			Screen->DrawTile(4, x1-8, y1-8, TIL_LOD_RUNE, 2, 2, 1, -1, -1, x1-8, y1-8, 4*anim, 0, true, 128);
		}
		else{
			Screen->DrawTile(4, x1-8, y1-8, TIL_LOD_RUNE, 2, 2, 1, -1, -1, x1-8, y1-8, 4*anim, 0, true, 128);
			Screen->Circle(4, x1+8, y1+8, 12+4*Sin(anim*8), 0x0F, 1, 0, 0, 0, true, 128);
		}
		
		int ang = Angle(x1, y1, x2, y2);
		int dist = Distance(x1, y1, x2, y2);
		for(i=0; i<Ceiling(dist/8); i++){
			x = x1+VectorX(8*i, ang);
			y = y1+VectorY(8*i, ang);
			Screen->DrawTile(4, x, y, TIL_LOD_CHAIN, 1, 1, 1, -1, -1, x, y, ang, 0, true, 128);
		}
		Screen->DrawTile(4, x2, y2, TIL_LOD_CHAIN+1, 1, 1, 1, -1, -1, x2, y2, ang, 0, true, 128);
		
		if(G[G_ZARATH_MULTIPLIER]==4){
			int oldX = x1+8+Rand(-4, 4);
			int oldY = y1+8+Rand(-4, 4);
			for(i=0; i<Ceiling(dist/8); i++){
				x = x1+VectorX(8*i, ang)+Rand(-6, 6)+8;
				y = y1+VectorY(8*i, ang)+Rand(-6, 6)+8;
				Screen->Rectangle(4, oldX, oldY-1, oldX+Distance(oldX, oldY, x, y), oldY+1, 0x0F, 1, oldX, oldY, Angle(oldX, oldY, x, y), true, 128);
				Screen->Line(4, oldX, oldY, x, y, 0x12, 1, 0, 0, 0, 128);
				//Screen->Line(4, oldX, oldY, x, y, 0x0F, 1, 0, 0, 0, 128);
				oldX = x;
				oldY = y;
			}
		}
	}
	void LOD_ChainDOT(int vars, int x1, int y1, int x2, int y2, npc n){
		if(G[G_ZARATH_MULTIPLIER]==4&&vars[6]%10==0){
			int cx = (x1+x2)/2+8;
			int cy = (y1+y2)/2+8;
			if(Q7_RotRectCollision(cx, cy, 4, Distance(x1, y1, x2, y2)/2, Angle(x1, y1, x2, y2), CenterX(n), CenterY(n), n->HitHeight/2-4, n->HitWidth/2-4, 0, false)){
				vars[13] = 1;
				G[G_ZARATH_FILL] += 10;
			}
		}
	}
	//Set enemies that can't be grabbed at all right here
	//The hook will just pass right through them
	bool LOD_CanGrab(npc n){
		bool exceptions[512];
		
		exceptions[66] = true;
		exceptions[67] = true;
		exceptions[286] = true;
		
		return !exceptions[n->ID];
	}
	//Set enemies that can't be pulled here
	//These would be any with complex AI that might break or stuff like sandcrocs that wouldn't make sense
	bool LOD_CanPull(npc n){
		if(n->HitWidth>16||n->HitHeight>16)
			return false;
		
		if(n->Type==NPCT_AQUAMENTUS||n->Type==NPCT_DODONGO||n->Type==NPCT_DIGDOGGER||n->Type==NPCT_MANHANDLA||n->Type==NPCT_GLEEOK||n->Type==NPCT_GOHMA||n->Type==NPCT_PATRA||n->Type==NPCT_MOLDORM||n->Type==NPCT_LANMOLA)
			return false;
		
		bool exceptions[512];
		
		exceptions[NPC_ENEMYFIRE] = true;
		exceptions[NPC_NIGHTMARE_FROG] = true;
		exceptions[NPC_NIGHTMARE_BOY] = true;
		exceptions[NPC_NIGHTMARE_CLOWN] = true;
		
		return !exceptions[n->ID];
	}
	//Set enemies that can't be stunned here
	//These would be enemies that don't have the proper behaviors to support it mostly
	bool LOD_CanStun(npc n){
		bool exceptions[512];
		
		return !exceptions[n->ID];
	}
	void LOD_DamageEnemy(npc n, int damage, bool pierce){
		if(!pierce){
			damage = damage*G[G_HPSCALE];
		}
		if(G[G_ZARATH_MULTIPLIER]!=4){
			if(n->Defense[NPCD_BEAM]==NPCDT_HALFDAMAGE)
				damage = Round(damage/2);
			else if(n->Defense[NPCD_BEAM]==NPCDT_QUARTERDAMAGE)
				damage = Round(damage/4);
			else if(n->Defense[NPCD_BEAM]==NPCDT_BLOCK){
				Game->PlaySound(6);
				return;
			}
		}
		Game->PlaySound(SFX_LIGHTOFDARKNESS_IMPACT);
		SetEnemyProperty(n, ENPROP_HP, GetEnemyProperty(n, ENPROP_HP)-damage);
		//SetEnemyProperty(n, 18, 32);
	}
	void LOD_SetSlash(int vars, npc target){
		int i; int j;
		
		int bezierX = vars[15];
		int bezierY = vars[16];
		int P2 = vars[21];
		
		int angle = Angle(Link->X, Link->Y, CenterX(target[0])-8, CenterY(target[0])-8);
		int x[3];
		int y[3];
		
		i = Rand(-32, 32);
		j = Rand(-12, 12);
		x[0] = VectorX(96, angle-120)+VectorX(i, angle)+VectorX(j, angle+90);
		y[0] = VectorY(96, angle-120)+VectorY(i, angle)+VectorY(j, angle+90);
		
		x[1] = 0;
		y[1] = 0;
		
		x[2] = VectorX(96, angle+120)+VectorX(i, angle)+VectorX(j, angle+90);
		y[2] = VectorY(96, angle+120)+VectorY(i, angle)+VectorY(j, angle+90);
		
		BezierQuad(bezierX, bezierY, 128, x[0], y[0], x[1], y[1], x[2], y[2]);
		
		int offX = bezierX[64];
		int offY = bezierY[64];
		for(i=0; i<128; i++){
			bezierX[i] -= offX;
			bezierY[i] -= offY;
		}
	}
	void LOD_DrawSlash(int X, int Y, int vars, int frame){
		int i; int j;
		
		int bezierX = vars[15];
		int bezierY = vars[16];
		
		int scale;
		
		int slashX[7];
		int slashY[7];
		int slashWidth[7];
		
		for(i=0; i<7; i++){
			j = Clamp(i*4+frame, 0, 127);
			slashX[i] = bezierX[j];
			slashY[i] = bezierY[j];
		}
		slashWidth[0] = 0; 
		slashWidth[1] = (1+Sin(frame*1.8)*12)*0.5;
		slashWidth[2] = (1+Sin(frame*1.8)*12)*0.8;
		slashWidth[3] = (1+Sin(frame*1.8)*12)*1;
		slashWidth[4] = (1+Sin(frame*1.8)*12)*0.8;
		slashWidth[5] = (1+Sin(frame*1.8)*12)*0.5;
		slashWidth[6] = 0; 
		
		int x[4];
		int y[4];
		
		for(i=0; i<6; i++){
			x[0] = X+slashX[i]+VectorX(slashWidth[i]/2+1, vars[17]);
			y[0] = Y+slashY[i]+VectorY(slashWidth[i]/2+1, vars[17]);
			
			x[1] = X+slashX[i+1]+VectorX(slashWidth[i+1]/2+1, vars[17]);
			y[1] = Y+slashY[i+1]+VectorY(slashWidth[i+1]/2+1, vars[17]);
			
			x[2] = X+slashX[i+1]+VectorX(-slashWidth[i+1]/2-1, vars[17]);
			y[2] = Y+slashY[i+1]+VectorY(-slashWidth[i+1]/2-1, vars[17]);
			
			x[3] = X+slashX[i]+VectorX(-slashWidth[i]/2, vars[17]);
			y[3] = Y+slashY[i]+VectorY(-slashWidth[i]/2, vars[17]);
			
			Screen->Quad(4, x[0], y[0], x[1], y[1], x[2], y[2], x[3], y[3], 1, 1, 0x02, 0, -1, PT_FLAT);
		}
		for(i=0; i<6; i++){
			x[0] = X+slashX[i]+VectorX(slashWidth[i]/2, vars[17]);
			y[0] = Y+slashY[i]+VectorY(slashWidth[i]/2, vars[17]);
			
			x[1] = X+slashX[i+1]+VectorX(slashWidth[i+1]/2, vars[17]);
			y[1] = Y+slashY[i+1]+VectorY(slashWidth[i+1]/2, vars[17]);
			
			x[2] = X+slashX[i+1]+VectorX(-slashWidth[i+1]/2, vars[17]);
			y[2] = Y+slashY[i+1]+VectorY(-slashWidth[i+1]/2, vars[17]);
			
			x[3] = X+slashX[i]+VectorX(-slashWidth[i]/2, vars[17]);
			y[3] = Y+slashY[i]+VectorY(-slashWidth[i]/2, vars[17]);
			
			Screen->Quad(4, x[0], y[0], x[1], y[1], x[2], y[2], x[3], y[3], 1, 1, 0x01, 0, -1, PT_FLAT);
		}
	}
	void LOD_DrawSlash2(int X, int Y, int vars, int frame){
		int i; int j;
		
		int bezierX = vars[15];
		int bezierY = vars[16];
		
		int scale;
		
		int slashX[7];
		int slashY[7];
		int slashWidth[7];
		
		int len = 64*(frame/8);
		int w = 16-12*(frame/8);
		
		int angle = vars[26];
		
		int hx = X-8+VectorX(56*(frame/8), angle);
		int hy = Y-8+VectorY(56*(frame/8), angle);
		MakeHitbox(LW_BEAM, hx+4, hy+4, 8, 8, -1, vars[25]*G[G_HPSCALE]);
		hx = X-8+VectorX(12, angle);
		hy = Y-8+VectorY(12, angle);
		MakeHitbox(LW_BEAM, hx, hy, 16, 16, Link->Dir, vars[25]*G[G_HPSCALE]);
		
		// for(i=0; i<7; i++){
			// j = Clamp(i*4+frame, 0, 127);
			// slashX[i] = VectorX(-16+len*(i/6), vars[26]);
			// slashY[i] = VectorY(-16+len*(i/6), vars[26]);
		// }
		// slashWidth[0] = w; 
		// slashWidth[1] = w*0.8;
		// slashWidth[2] = w*0.7;
		// slashWidth[3] = w*0.6;
		// slashWidth[4] = w*0.3;
		// slashWidth[5] = w*0.15;
		// slashWidth[6] = 0; 
		
		int x[4];
		int y[4];
		
		x[0] = X+VectorX(w+1, angle-90);
		y[0] = Y+VectorY(w+1, angle-90);
		x[1] = X+VectorX(len+1, angle);
		y[1] = Y+VectorY(len+1, angle);
		x[2] = X+VectorX(-w-1, angle-90);
		y[2] = Y+VectorY(-w-1, angle-90);
		x[3] = X+VectorX(len*0.5-1, angle);
		y[3] = Y+VectorY(len*0.5-1, angle);
		
		Screen->Triangle(4, x[0], y[0], x[1], y[1], x[3], y[3], 1, 1, 0x02, 0, -1, PT_FLAT);
		Screen->Triangle(4, x[2], y[2], x[1], y[1], x[3], y[3], 1, 1, 0x02, 0, -1, PT_FLAT);
		//Screen->Quad(4, x[0], y[0], x[1], y[1], x[2], y[2], x[3], y[3], 1, 1, 0x02, 0, -1, PT_FLAT);
		
		x[0] = X+VectorX(w, angle-90);
		y[0] = Y+VectorY(w, angle-90);
		x[1] = X+VectorX(len, angle);
		y[1] = Y+VectorY(len, angle);
		x[2] = X+VectorX(-w, angle-90);
		y[2] = Y+VectorY(-w, angle-90);
		x[3] = X+VectorX(len*0.5, angle);
		y[3] = Y+VectorY(len*0.5, angle);
		
		Screen->Triangle(4, x[0], y[0], x[1], y[1], x[3], y[3], 1, 1, 0x01, 0, -1, PT_FLAT);
		Screen->Triangle(4, x[2], y[2], x[1], y[1], x[3], y[3], 1, 1, 0x01, 0, -1, PT_FLAT);
		//Screen->Quad(4, x[0], y[0], x[1], y[1], x[2], y[2], x[3], y[3], 1, 1, 0x01, 0, -1, PT_FLAT);
		
		// for(i=0; i<6; i++){
			// x[0] = X+slashX[i]+VectorX(slashWidth[i]/2+1, vars[26]+90);
			// y[0] = Y+slashY[i]+VectorY(slashWidth[i]/2+1, vars[26]+90);
			
			// x[1] = X+slashX[i+1]+VectorX(slashWidth[i+1]/2+1, vars[26]+90);
			// y[1] = Y+slashY[i+1]+VectorY(slashWidth[i+1]/2+1, vars[26]+90);
			
			// x[2] = X+slashX[i+1]+VectorX(-slashWidth[i+1]/2-1, vars[26]+90);
			// y[2] = Y+slashY[i+1]+VectorY(-slashWidth[i+1]/2-1, vars[26]+90);
			
			// x[3] = X+slashX[i]+VectorX(-slashWidth[i]/2, vars[26]+90);
			// y[3] = Y+slashY[i]+VectorY(-slashWidth[i]/2, vars[26]+90);
			
			// Screen->Quad(4, x[0], y[0], x[1], y[1], x[2], y[2], x[3], y[3], 1, 1, 0x02, 0, -1, PT_FLAT);
		// }
		// for(i=0; i<6; i++){
			// x[0] = X+slashX[i]+VectorX(slashWidth[i]/2, vars[26]+90);
			// y[0] = Y+slashY[i]+VectorY(slashWidth[i]/2, vars[26]+90);
			
			// x[1] = X+slashX[i+1]+VectorX(slashWidth[i+1]/2, vars[26]+90);
			// y[1] = Y+slashY[i+1]+VectorY(slashWidth[i+1]/2, vars[26]+90);
			
			// x[2] = X+slashX[i+1]+VectorX(-slashWidth[i+1]/2, vars[26]+90);
			// y[2] = Y+slashY[i+1]+VectorY(-slashWidth[i+1]/2, vars[26]+90);
			
			// x[3] = X+slashX[i]+VectorX(-slashWidth[i]/2, vars[26]+90);
			// y[3] = Y+slashY[i]+VectorY(-slashWidth[i]/2, vars[26]+90);
			
			// Screen->Quad(4, x[0], y[0], x[1], y[1], x[2], y[2], x[3], y[3], 1, 1, 0x01, 0, -1, PT_FLAT);
		// }
	}
}

void LWeaponPickup(lweapon l){
	for(int i=Screen->NumItems(); i>0; --i){
		item itm = Screen->LoadItem(i);
		if(Collision(l, itm)&&itm->Pickup&IP_TIMEOUT){
			itm->Misc[ITM_REMOTEPICKUP] = 1;
		}
	}
}

const int FFCS_ZELDASWORD = 133;

//Copied from Yuurand modified
//P2 elements left intact but commented out in case I add multiplayer functionality at a later date
ffc script ZeldaSword{
	void run(){
		int attacker = 0;
		int damage; int sprite; int sound; int slash; int upgrade;
		int Tile; int Flip; int TridentTile; int CSet; int InitTile;
		if(G[G_ALTCHARACTER]==CHAR_KELL){
			damage = SwordDamageLevel(2, 4, 8, 12);
			sprite = 123;
			Tile = 16380;
			CSet = 7;
			sound = 30;
			slash = 0;
			if(GetSwordLevel()>2){
				upgrade = 1;
				Tile = 16400;
			}
		}
		else if(G[G_ALTCHARACTER]==CHAR_RIGGS){
			damage = SwordDamageLevel(2, 4, 6, 8);
			sprite = 124;
			Tile = 16441;
			CSet = 11;
			sound = 30;
			slash = 1;
			if(GetSwordLevel()>2){
				upgrade = 1;
				CSet = 1;
			}
		}
		else if(G[G_ALTCHARACTER]==CHAR_MANI){
			damage = SwordDamageLevel(1.5, 3, 6, 9);
			sprite = 123;
			Tile = 16403;
			CSet = 1;
			sound = 30;
			slash = 0;
			upgrade = 1;
		}
		
		int SwordProperties[6];
		int TridentProperties[6];
		Game->PlaySound(sound);
		G[G_SWORDSHOOTERFLAG] = 2;
		int frames;
		if(!slash){
			while(frames <5){
				frames++;
				DrawLinkAttacking(this, false, attacker);
				NoMovementWaitframesAttackerBased(1, attacker);
			}
			DrawLinkAttacking(this, false, attacker);
			int swordx;
			int swordy;
			int tridentx;
			int tridenty;
			if(attacker == 0){
				if(Link->Dir == DIR_UP){
					SwordProperties[0] = -1;
					SwordProperties[1] = -10;
				}
				if(Link->Dir == DIR_DOWN){
					SwordProperties[0] = 1;
					SwordProperties[1] = 14;
				}
				if(Link->Dir == DIR_LEFT){
					SwordProperties[0] = -11;
					SwordProperties[1] = 3;
				}
				if(Link->Dir == DIR_RIGHT){
					SwordProperties[0] = 11;
					SwordProperties[1] = 3;
				}
			}
			
			lweapon trident;
			lweapon sword = CreateLWeaponAt(LW_BEAM, Clamp(swordx,5,234), Clamp(swordy,5,154));
			sword->Step = 0;
			sword->Dir = Link->Dir;
			sword->UseSprite(125);
			sword->Damage = damage*G[G_HPSCALE];
			// Tile = 19820;
			// if(sprite == 126)
				// Tile = 19840;
			//CSet = 7;
			Flip = 0;
			SwordProperties[2] = sword->Damage;
			SwordProperties[3] = Tile;
			if(attacker == 0){
				if(Link->Dir == DIR_LEFT || Link->Dir == DIR_RIGHT)
					SwordProperties[3]++;
				if(Link->Dir == DIR_DOWN)
					Flip = 3;
				if(Link->Dir == DIR_LEFT)
					Flip = 1;
			}
			Tile = SwordProperties[3];
			UpdateSword(sword, SwordProperties, attacker);
			if(upgrade == 1){
				if(attacker == 0){
					if(Link->Dir == DIR_UP){
						// tridenty = swordy-16;
						TridentProperties[1] = SwordProperties[1]-16;
						TridentProperties[0] = SwordProperties[0];
						
					}
					if(Link->Dir == DIR_DOWN){
						// tridenty = swordy+16;
						TridentProperties[1] = SwordProperties[1]+16;
						TridentProperties[0] = SwordProperties[0];
					}
					if(Link->Dir == DIR_LEFT){
						// tridentx = swordx-16;
						 TridentProperties[0]=SwordProperties[0]-16;
						 TridentProperties[1] = SwordProperties[1];
					}
					if(Link->Dir == DIR_RIGHT){
						// tridentx = swordx+16;
						 TridentProperties[0] = SwordProperties[0]+16;
						 TridentProperties[1] = SwordProperties[1];
					}
				}
				trident = CreateLWeaponAt(LW_BEAM, Clamp(tridentx,5,234), Clamp(tridenty,5,154));
				trident->Step = 0;
				trident->Dir = Link->Dir;
				// if(attacker == 1)
					// sword->Dir = G[G_PLAYER_TWO_DIR];
				trident->UseSprite(125);
				trident->Damage = damage*G[G_HPSCALE];
				TridentTile = Tile+20;
				TridentProperties[2] = trident->Damage;
				TridentProperties[3] = TridentTile;
				if(attacker == 0){
					//if(Link->Dir == DIR_LEFT || Link->Dir == DIR_RIGHT)
						//TridentProperties[3]++;
					if(Link->Dir == DIR_DOWN)
						trident->Flip = 3;
					if(Link->Dir == DIR_LEFT)
						trident->Flip = 1;
				}
				TridentTile = TridentProperties[3];
				UpdateSword(trident, TridentProperties, attacker);
			}
			while(frames <12){
				if(frames == 7 || frames == 11){
					if(Link->InputUp){
						if(Link->Dir == DIR_LEFT || Link->Dir == DIR_RIGHT){
							SwordProperties[3]--;
							Tile--;
						}
						Flip = 0;
						SwordProperties[0] = -1;
						SwordProperties[1] = -10;
						if(upgrade==1){
							if(Link->Dir == DIR_LEFT || Link->Dir == DIR_RIGHT){
								TridentProperties[3]--;
								TridentTile--;
							}
							TridentProperties[1] = SwordProperties[1]-16;
							TridentProperties[0] = SwordProperties[0];
							trident->Dir = DIR_UP;
						}
						Link->Dir = DIR_UP;
						sword->Dir = Link->Dir;
					}
					else if(Link->InputDown){
						if(Link->Dir == DIR_LEFT || Link->Dir == DIR_RIGHT){
							SwordProperties[3]--;
							Tile--;
						}
						Flip = 3;
						SwordProperties[0] = 1;
						SwordProperties[1] = 14;
						if(upgrade==1){
							if(Link->Dir == DIR_LEFT || Link->Dir == DIR_RIGHT){
								TridentProperties[3]--;
								TridentTile--;
							}
							TridentProperties[1] = SwordProperties[1]+16;
							TridentProperties[0] = SwordProperties[0];
							trident->Dir = DIR_DOWN;
						}
						Link->Dir = DIR_DOWN;
						sword->Dir = Link->Dir;
					}
					else if(Link->InputLeft){
						if(Link->Dir == DIR_UP || Link->Dir == DIR_DOWN){
							SwordProperties[3]++;
							Tile++;
						}
						Flip = 1;
						SwordProperties[0] = -11;
						SwordProperties[1] = 3;
						if(upgrade==1){
							if(Link->Dir == DIR_UP || Link->Dir == DIR_DOWN){
								TridentProperties[3]++;
								TridentTile++;
							}
							TridentProperties[1] = SwordProperties[1];
							TridentProperties[0] = SwordProperties[0]-16;
							trident->Dir = DIR_LEFT;
						}
						Link->Dir = DIR_LEFT;
						sword->Dir = Link->Dir;
					}
					else if(Link->InputRight){
						if(Link->Dir == DIR_UP || Link->Dir == DIR_DOWN){
							SwordProperties[3]++;
							Tile++;
						}
						sword->Dir = Link->Dir;
						Flip = 0;
						SwordProperties[0] = 11;
						SwordProperties[1] = 3;
						if(upgrade==1){
							if(Link->Dir == DIR_UP || Link->Dir == DIR_DOWN){
								TridentProperties[3]++;
								TridentTile++;
							}
							TridentProperties[1] = SwordProperties[1];
							TridentProperties[0] = SwordProperties[0]+16;
							trident->Dir = DIR_RIGHT;
						}
						Link->Dir = DIR_RIGHT;
						sword->Dir = Link->Dir;
					}
				}
				// Screen->DrawTile(2, swordx, swordy, Tile, 1, 1, CSet, -1, -1, 0, 0, 0, Flip, true, OP_OPAQUE);
				Screen->DrawTile(2, SwordProperties[0]+Link->X, SwordProperties[1]+Link->Y, Tile, 1, 1, CSet, -1, -1, 0, 0, 0, Flip, true, OP_OPAQUE);
				DrawLinkAttacking(this, false, attacker);
				UpdateSword(sword, SwordProperties, attacker);
				sword = CreateSword(sword, SwordProperties);
				if(upgrade == 1){
					// Screen->DrawTile(2, tridentx, tridenty, TridentTile, 1, 1, CSet, -1, -1, 0, 0, 0, Flip, true, OP_OPAQUE);
					Screen->DrawTile(2, TridentProperties[0]+Link->X, TridentProperties[1]+Link->Y, TridentTile, 1, 1, CSet, -1, -1, 0, 0, 0, Flip, true, OP_OPAQUE);
					UpdateSword(trident, TridentProperties, attacker);
					trident = CreateSword(trident, TridentProperties);
				}
				frames++;
				NoMovementWaitframesAttackerBased(1, attacker);
			}
			if(attacker == 0)
				Link->Invisible = false;
			// else
				// G[G_PLAYER_TWO_INVIS] = 0;
			// Screen->DrawTile(2, swordx, swordy, Tile, 1, 1, CSet, -1, -1, 0, 0, 0, Flip, true, OP_OPAQUE);
			Screen->DrawTile(2, SwordProperties[0]+Link->X, SwordProperties[1]+Link->Y, Tile, 1, 1, CSet, -1, -1, 0, 0, 0, Flip, true, OP_OPAQUE);
			UpdateSword(sword, SwordProperties, attacker);
			sword = CreateSword(sword, SwordProperties);
			if(upgrade == 1){
				// Screen->DrawTile(2, trident->X, trident->Y, TridentTile, 1, 1, CSet, -1, -1, 0, 0, 0, Flip, true, OP_OPAQUE);
				Screen->DrawTile(2, TridentProperties[0]+Link->X, TridentProperties[1]+Link->Y, TridentTile, 1, 1, CSet, -1, -1, 0, 0, 0, Flip, true, OP_OPAQUE);
				UpdateSword(trident, TridentProperties, attacker);
				trident = CreateSword(trident, TridentProperties);
			}
			this->Data = 0;
			NoMovementWaitframesAttackerBased(1, attacker);
			for(int i = 0; i <2; i++){
				if(attacker == 0){
					if(Link->Dir == DIR_UP){
						SwordProperties[1] +=4;
						swordy+=4;
					}
					if(Link->Dir == DIR_DOWN){
						SwordProperties[1] -=4;
						swordy-=4;
					}
					if(Link->Dir == DIR_LEFT){
						SwordProperties[0] +=4;
						swordx+=4;
					}
					if(Link->Dir == DIR_RIGHT){
						SwordProperties[0] -=4;
						swordx-=4;
					}
				}
				Screen->DrawTile(2, SwordProperties[0]+Link->X, SwordProperties[1]+Link->Y, Tile, 1, 1, CSet, -1, -1, 0, 0, 0, Flip, true, OP_OPAQUE);
				UpdateSword(sword, SwordProperties, attacker);
				sword = CreateSword(sword, SwordProperties);
				if(upgrade == 1){
					if(attacker == 0){
						if(Link->Dir == DIR_UP){
							TridentProperties[1] +=4;
							tridenty+=4;
						}
						if(Link->Dir == DIR_DOWN){
							TridentProperties[1] -=4;
							tridenty-=4;
						}
						if(Link->Dir == DIR_LEFT){
							TridentProperties[0] +=4;
							tridentx+=4;
						}
						if(Link->Dir == DIR_RIGHT){
							TridentProperties[0] -=4;
							tridentx-=4;
						}
					}
					Screen->DrawTile(2, TridentProperties[0]+Link->X, TridentProperties[1]+Link->Y, TridentTile, 1, 1, CSet, -1, -1, 0, 0, 0, Flip, true, OP_OPAQUE);
					UpdateSword(trident, TridentProperties, attacker);
					trident = CreateSword(trident, TridentProperties);
				}
				NoMovementWaitframesAttackerBased(1, attacker);
			}
			sword->DeadState = WDS_DEAD;
			trident->DeadState = WDS_DEAD;
		}
		else if(slash && upgrade == 0){
			DrawLinkAttacking(this, false, attacker);
			NoMovementWaitframesAttackerBased(1, attacker);
			int swordx;
			int swordy;
			if(attacker == 0){
				if(Link->Dir == DIR_UP){
					// swordx = Link->X+15;
					// swordy = Link->Y-1;
					SwordProperties[0] = 15;
					SwordProperties[1] = -1;
				}
				if(Link->Dir == DIR_DOWN){
					// swordx = Link->X-13;
					// swordy = Link->Y+1;
					SwordProperties[0] = -13;
					SwordProperties[1] = 1;
				}
				if(Link->Dir == DIR_LEFT){
					// swordx = Link->X;
					// swordy = Link->Y-13;
					SwordProperties[0] = 0;
					SwordProperties[1] = -13;
				}
				if(Link->Dir == DIR_RIGHT){
					// swordx = Link->X+3;
					// swordy = Link->Y-13;
					SwordProperties[0] = 3;
					SwordProperties[1] = -13;
				}
			}
			
			
			lweapon sword = CreateLWeaponAt(LW_BEAM, Clamp(swordx, 5, 234), Clamp(swordy, 5, 154));
			sword->Step = 0;
			sword->Dir = Link->Dir;
			// if(attacker == 1)
				// sword->Dir = G[G_PLAYER_TWO_DIR];
			sword->UseSprite(125);
			sword->Damage = damage*G[G_HPSCALE];
			//Tile = 19881;
			InitTile = Tile;
			CSet = 11;
			SwordProperties[2] = sword->Damage;
			SwordProperties[3] = Tile;
			
			if(attacker == 0){
				if(Link->Dir == DIR_DOWN){
					SwordProperties[3] +=1;
					Flip = 1;
				}
				if(Link->Dir == DIR_UP){
					SwordProperties[3] += 1;
				}
				if(Link->Dir ==DIR_LEFT)
					Flip = 1;
			}
			Tile = SwordProperties[3];
			// Screen->DrawTile(2, swordx, swordy, Tile, 1, 1, CSet, -1, -1, 0, 0, 0, Flip, true, OP_OPAQUE);
			Screen->DrawTile(2, SwordProperties[0]+Link->X, SwordProperties[1]+Link->Y, Tile, 1, 1, CSet, -1, -1, 0, 0, 0, Flip, true, OP_OPAQUE);
			UpdateSword(sword, SwordProperties, attacker);
			while(frames <5){
				// Screen->DrawTile(2, swordx, swordy, Tile, 1, 1, CSet, -1, -1, 0, 0, 0, Flip, true, OP_OPAQUE);
				Screen->DrawTile(2, SwordProperties[0]+Link->X, SwordProperties[1]+Link->Y, Tile, 1, 1, CSet, -1, -1, 0, 0, 0, Flip, true, OP_OPAQUE);
				DrawLinkAttacking(this, false, attacker);
				UpdateSword(sword, SwordProperties, attacker);
				sword = CreateSword(sword, SwordProperties);
				frames++;
				NoMovementWaitframesAttackerBased(1, attacker);
			}
			DrawLinkAttacking(this, false, attacker);
			if(attacker == 0){
				if(Link->Dir == DIR_UP){
					Tile += 1;
					SwordProperties[0] = 12;
					SwordProperties[1] = -10;
				}
				if(Link->Dir == DIR_DOWN){
					Tile += 1;
					Flip = 3;
					SwordProperties[0] = -11;
					SwordProperties[1] = 14;
				}
				if(Link->Dir == DIR_LEFT){
					Tile += 2;
					Flip = 1;
					SwordProperties[0] = -12;
					SwordProperties[1] = -10;
				}
				if(Link->Dir == DIR_RIGHT){
					Tile += 2;
					SwordProperties[0] = 11;
					SwordProperties[1] = -10;
				}
			}
			while(frames <9){
				if(frames == 7){
					if(Link->InputUp && Link->Dir != DIR_UP){
						Tile = InitTile+2;
						Flip = 0;
						SwordProperties[0] = 12;
						SwordProperties[1] = -10;
						Link->Dir = DIR_UP;
						sword->Dir = Link->Dir;
					}
					else if(Link->InputDown && Link->Dir != DIR_DOWN){
						Tile = InitTile+2;
						Flip = 3;
						SwordProperties[0] = -11;
						SwordProperties[1] = 14;
						Link->Dir = DIR_DOWN;
						sword->Dir = Link->Dir;
					}
					else if(Link->InputLeft && Link->Dir != DIR_LEFT){
						Tile = InitTile+2;
						Flip = 1;
						SwordProperties[0] = -12;
						SwordProperties[1] = -10;
						Link->Dir = DIR_LEFT;
						sword->Dir = Link->Dir;
					}
					else if(Link->InputRight && Link->Dir != DIR_RIGHT){
						Tile = InitTile+2;
						sword->Dir = Link->Dir;
						Flip = 0;
						SwordProperties[0] = 11;
						SwordProperties[1] = -10;
						Link->Dir = DIR_RIGHT;
						sword->Dir = Link->Dir;
					}
				}
				Screen->DrawTile(2, SwordProperties[0]+Link->X, SwordProperties[1]+Link->Y, Tile, 1, 1, CSet, -1, -1, 0, 0, 0, Flip, true, OP_OPAQUE);
				UpdateSword(sword, SwordProperties, attacker);
				DrawLinkAttacking(this, false, attacker);
				UpdateSword(sword, SwordProperties, attacker);
				sword = CreateSword(sword, SwordProperties);
				frames++;
				NoMovementWaitframesAttackerBased(1, attacker);
			}
			if(attacker == 0){
				if(Link->Dir == DIR_UP){
					Tile -=2;
					Flip = 0;
					SwordProperties[0] = 0;
					SwordProperties[1] = -18;
				}
				if(Link->Dir == DIR_DOWN){
					Tile -=2;
					Flip = 3;
					SwordProperties[0] = 1;
					SwordProperties[1] = 16;
				}
				if(Link->Dir == DIR_LEFT){
					Tile -= 1;
					Flip = 1;
					SwordProperties[0] = -16;
					SwordProperties[1] = 2;
				}
				if(Link->Dir == DIR_RIGHT){
					Tile -= 1;
					SwordProperties[0] = 16;
					SwordProperties[1] = 2;
				}
			}
			while(frames <12){
				if(frames == 11){
					if(Link->InputUp && Link->Dir != DIR_UP){
						Tile = InitTile;
						Flip = 0;
						SwordProperties[0] = 0;
						SwordProperties[1] = -18;
						Link->Dir = DIR_UP;
						sword->Dir = Link->Dir;
					}
					else if(Link->InputDown && Link->Dir != DIR_DOWN){
						Tile = InitTile;
						Flip = 2;
						SwordProperties[0] = 1;
						SwordProperties[1] = 16;
						Link->Dir = DIR_DOWN;
						sword->Dir = Link->Dir;
					}
					else if(Link->InputLeft && Link->Dir != DIR_LEFT){
						Tile = InitTile+1;
						Flip = 1;
						SwordProperties[0] = -16;
						SwordProperties[1] = 2;
						Link->Dir = DIR_LEFT;
						sword->Dir = Link->Dir;
					}
					else if(Link->InputRight && Link->Dir != DIR_RIGHT){
						Tile = InitTile+1;
						sword->Dir = Link->Dir;
						Flip = 0;
						SwordProperties[0] = 16;
						SwordProperties[1] = 2;
						Link->Dir = DIR_RIGHT;
						sword->Dir = Link->Dir;
					}
				}
				Screen->DrawTile(2, SwordProperties[0]+Link->X, SwordProperties[1]+Link->Y, Tile, 1, 1, CSet, -1, -1, 0, 0, 0, Flip, true, OP_OPAQUE);
				UpdateSword(sword, SwordProperties, attacker);
				DrawLinkAttacking(this, true, attacker);
				UpdateSword(sword, SwordProperties, attacker);
				sword = CreateSword(sword, SwordProperties);
				frames++;
				NoMovementWaitframesAttackerBased(1, attacker);
			}
			//Beams or extra effects like that would go here.
			DrawLinkAttacking(this, true, attacker);
			if(attacker == 0){
				if(Link->Dir == DIR_UP)
					SwordProperties[1] +=5;
				if(Link->Dir == DIR_DOWN)
					SwordProperties[1] -=5;
				if(Link->Dir == DIR_LEFT)
					SwordProperties[0] +=5;
				if(Link->Dir == DIR_RIGHT)
					SwordProperties[0] -=5;
				NoMovementWaitframesAttackerBased(1, attacker);
				this->Data = 0;
				Link->Invisible = false;
			}
			sword->DeadState = WDS_DEAD;

		}
		
		else if(slash && upgrade == 1){
			DrawLinkAttacking(this, false, attacker);
			NoMovementWaitframesAttackerBased(1, attacker);
			int swordx;
			int swordy;
			if(attacker == 0){
				if(Link->Dir == DIR_UP){
					// swordx = Link->X+15;
					// swordy = Link->Y-1;
					SwordProperties[0] = 15;
					SwordProperties[1] = -1;
				}
				if(Link->Dir == DIR_DOWN){
					// swordx = Link->X-13;
					// swordy = Link->Y+1;
					SwordProperties[0] = -13;
					SwordProperties[1] = 1;
				}
				if(Link->Dir == DIR_LEFT){
					// swordx = Link->X;
					// swordy = Link->Y-13;
					SwordProperties[0] = 0;
					SwordProperties[1] = -13;
				}
				if(Link->Dir == DIR_RIGHT){
					// swordx = Link->X+3;
					// swordy = Link->Y-13;
					SwordProperties[0] = 3;
					SwordProperties[1] = -13;
				}
			}
			
			
			lweapon sword = CreateLWeaponAt(LW_BEAM, Clamp(swordx, 5, 234), Clamp(swordy, 5, 154));
			sword->Step = 0;
			sword->Dir = Link->Dir;
			sword->UseSprite(125);
			sword->Damage = damage*G[G_HPSCALE];
			//Tile = 19901;
			InitTile = Tile;
			CSet = 1;
			SwordProperties[2] = sword->Damage;
			SwordProperties[3] = Tile;
			
			if(attacker == 0){
				if(Link->Dir == DIR_DOWN){
					SwordProperties[3] +=1;
					Flip = 1;
				}
				if(Link->Dir == DIR_UP){
					SwordProperties[3] += 1;
				}
				if(Link->Dir ==DIR_LEFT)
					Flip = 1;
			}
			Tile = SwordProperties[3];
			UpdateSword(sword, SwordProperties, attacker);
			while(frames <2){
				UpdateSword(sword, SwordProperties, attacker);
				Screen->DrawTile(2, SwordProperties[0]+Link->X, SwordProperties[1]+Link->Y, Tile, 1, 1, CSet, -1, -1, 0, 0, 0, Flip, true, OP_OPAQUE);
				DrawLinkAttacking(this, false, attacker);
				UpdateSword(sword, SwordProperties, attacker);
				sword = CreateSword(sword, SwordProperties);
				frames++;
				NoMovementWaitframesAttackerBased(1, attacker);
			}
			DrawLinkAttacking(this, false, attacker);
			if(attacker == 0){
				if(Link->Dir == DIR_UP){
					Tile += 1;
					SwordProperties[0] = 12;
					SwordProperties[1] = -10;
				}
				if(Link->Dir == DIR_DOWN){
					Tile += 1;
					Flip = 3;
					SwordProperties[0] = -11;
					SwordProperties[1] = 14;
				}
				if(Link->Dir == DIR_LEFT){
					Tile += 2;
					Flip = 1;
					SwordProperties[0] = -12;
					SwordProperties[1] = -10;
				}
				if(Link->Dir == DIR_RIGHT){
					Tile += 2;
					SwordProperties[0] = 11;
					SwordProperties[1] = -10;
				}
			}
			while(frames <5){
				Screen->DrawTile(2, SwordProperties[0]+Link->X, SwordProperties[1]+Link->Y, Tile, 1, 1, CSet, -1, -1, 0, 0, 0, Flip, true, OP_OPAQUE);
				UpdateSword(sword, SwordProperties, attacker);
				DrawLinkAttacking(this, false, attacker);
				UpdateSword(sword, SwordProperties, attacker);
				sword = CreateSword(sword, SwordProperties);
				frames++;
				NoMovementWaitframesAttackerBased(1, attacker);
			}
			if(attacker == 0){
				if(Link->Dir == DIR_UP){
					Tile -=2;
					Flip = 0;
					SwordProperties[0] = 0;
					SwordProperties[1] = -18;
				}
				if(Link->Dir == DIR_DOWN){
					Tile -=2;
					Flip = 3;
					SwordProperties[0] = 1;
					SwordProperties[1] = 16;
				}
				if(Link->Dir == DIR_LEFT){
					Tile -= 1;
					Flip = 1;
					SwordProperties[0] = -16;
					SwordProperties[1] = 2;
				}
				if(Link->Dir == DIR_RIGHT){
					Tile -= 1;
					SwordProperties[0] = 16;
					SwordProperties[1] = 2;
				}
			}
			while(frames <7){
				Screen->DrawTile(2, SwordProperties[0]+Link->X, SwordProperties[1]+Link->Y, Tile, 1, 1, CSet, -1, -1, 0, 0, 0, Flip, true, OP_OPAQUE);
				UpdateSword(sword, SwordProperties, attacker);
				DrawLinkAttacking(this, true, attacker);
				UpdateSword(sword, SwordProperties, attacker);
				sword = CreateSword(sword, SwordProperties);
				frames++;
				NoMovementWaitframesAttackerBased(1, attacker);
			}
			if(attacker == 0){
				if(Link->Dir == DIR_UP){
					Tile += 2;
					Flip = 1;
					SwordProperties[0] = -12;
					SwordProperties[1] = -10;
				}
				if(Link->Dir == DIR_DOWN){
					Tile += 2;
					Flip = 2;
					SwordProperties[0] = 11;
					SwordProperties[1] = 14;
				}
				if(Link->Dir == DIR_LEFT){
					Tile += 1;
					Flip = 3;
					SwordProperties[0] = -12;
					SwordProperties[1] = 10;
				}
				if(Link->Dir == DIR_RIGHT){
					Tile += 1;
					Flip = 2;
					SwordProperties[0] = 11;
					SwordProperties[1] = 10;
				}
			}
			while(frames <10){
				if(frames == 7){
					if(Link->InputUp){
						Tile = InitTile+2;
						Flip = 1;
						SwordProperties[0] = -12;
						SwordProperties[1] = -10;
						Link->Dir = DIR_UP;
						sword->Dir = Link->Dir;
					}
					else if(Link->InputDown){
						Tile = InitTile+2;
						Flip = 2;
						SwordProperties[0] = 11;
						SwordProperties[1] = 14;
						Link->Dir = DIR_DOWN;
						sword->Dir = Link->Dir;
					}
					else if(Link->InputLeft){
						Tile = InitTile+2;
						Flip = 3;
						SwordProperties[0] = -12;
						SwordProperties[1] = 10;
						Link->Dir = DIR_LEFT;
						sword->Dir = Link->Dir;
					}
					else if(Link->InputRight){
						Tile = InitTile+2;
						sword->Dir = Link->Dir;
						Flip = 2;
						SwordProperties[0] = 11;
						SwordProperties[1] = 10;
						Link->Dir = DIR_RIGHT;
						sword->Dir = Link->Dir;
					}
				}
				Screen->DrawTile(2, SwordProperties[0]+Link->X, SwordProperties[1]+Link->Y, Tile, 1, 1, CSet, -1, -1, 0, 0, 0, Flip, true, OP_OPAQUE);
				UpdateSword(sword, SwordProperties, attacker);
				DrawLinkAttacking(this, false, attacker);
				UpdateSword(sword, SwordProperties, attacker);
				sword = CreateSword(sword, SwordProperties);
				frames++;
				NoMovementWaitframesAttackerBased(1, attacker);
			}
			if(attacker == 0){
				if(Link->Dir == DIR_UP){
					Tile -= 1;
					Flip = 1;
					// swordx = Link->X-15;
					// swordy = Link->Y-1;
					SwordProperties[0] = -15;
					SwordProperties[1] = -1;
				}
				if(Link->Dir == DIR_DOWN){
					Tile -= 1;
					Flip = 0;
					// swordx = Link->X+13;
					// swordy = Link->Y+1;
					SwordProperties[0] = 13;
					SwordProperties[1] = 1;
				}
				if(Link->Dir == DIR_LEFT){
					Tile -= 2;
					Flip = 2;
					// swordx = Link->X;
					// swordy = Link->Y+13;
					SwordProperties[0] = 0;
					SwordProperties[1] = 13;
				}
				if(Link->Dir == DIR_RIGHT){
					Tile -= 2;
					Flip = 2;
					// swordx = Link->X+3;
					// swordy = Link->Y+13;
					SwordProperties[0] = 3;
					SwordProperties[1] = 13;
				}
				// SwordProperties[0] = swordx-Link->X;
				// SwordProperties[1] = swordy-Link->Y;
			}
			while(frames <12){
				if(frames == 11){
					if(Link->InputUp){
						Tile = InitTile+1;
						Flip = 1;
						SwordProperties[0] = -5;
						SwordProperties[1] = -1;
						Link->Dir = DIR_UP;
						sword->Dir = Link->Dir;
					}
					else if(Link->InputDown){
						Tile = InitTile+1;
						Flip = 0;
						SwordProperties[0] = 13;
						SwordProperties[1] = 1;
						Link->Dir = DIR_DOWN;
						sword->Dir = Link->Dir;
					}
					else if(Link->InputLeft){
						Tile = InitTile;
						Flip = 3;
						SwordProperties[0] = 0;
						SwordProperties[1] = 13;
						Link->Dir = DIR_LEFT;
						sword->Dir = Link->Dir;
					}
					else if(Link->InputRight){
						Tile = InitTile;
						Flip = 3;
						sword->Dir = Link->Dir;
						SwordProperties[0] = 3;
						SwordProperties[1] = 13;
						Link->Dir = DIR_RIGHT;
						sword->Dir = Link->Dir;
					}
				}
				UpdateSword(sword, SwordProperties, attacker);
				// Screen->DrawTile(2, swordx, swordy, Tile, 1, 1, CSet, -1, -1, 0, 0, 0, Flip, true, OP_OPAQUE);
				Screen->DrawTile(2, SwordProperties[0]+Link->X, SwordProperties[1]+Link->Y, Tile, 1, 1, CSet, -1, -1, 0, 0, 0, Flip, true, OP_OPAQUE);
				DrawLinkAttacking(this, false, attacker);
				UpdateSword(sword, SwordProperties, attacker);
				sword = CreateSword(sword, SwordProperties);
				frames++;
				NoMovementWaitframesAttackerBased(1, attacker);
			}
			//Beams or extra effects like that would go here.
			DrawLinkAttacking(this, false, attacker);
			if(attacker == 0){
				if(Link->Dir == DIR_UP)
					SwordProperties[1] +=5;
				if(Link->Dir == DIR_DOWN)
					SwordProperties[1] -=5;
				if(Link->Dir == DIR_LEFT)
					SwordProperties[0] +=5;
				if(Link->Dir == DIR_RIGHT)
					SwordProperties[0] -=5;
				NoMovementWaitframesAttackerBased(1, attacker);
				this->Data = 0;
				Link->Invisible = false;
			}
			sword->DeadState = WDS_DEAD;

		}
	}
	void UpdateSword(lweapon sword, int SwordProperties, int attacker){
		sword->DeadState = WDS_ALIVE;
		if(sword->isValid() && sword->DeadState == WDS_ALIVE){
			SwordProperties[2] = sword->Damage;
			SwordProperties[3] = sword->Tile;
			SwordProperties[4] = sword->Flip;
			SwordProperties[5] = sword->CSet;
			int weaponx = Link->X+SwordProperties[0];
			int weapony = Link->Y+SwordProperties[1];
			sword->X = Clamp(weaponx, 5, 234);
			sword->Y = Clamp(weapony,5,154);
			sword->DrawXOffset = weaponx-sword->X;
			sword->DrawYOffset = weapony-sword->Y;
			sword->HitXOffset = sword->DrawXOffset;
			sword->HitYOffset = sword->DrawYOffset;
			//sword->Misc[9] = 1;
			if(G[G_ALTCHARACTER]==CHAR_RIGGS){
				if(GetSwordLevel()>2){
					if(G[G_ANIM]%5==0){
						lweapon l = CreateLWeaponAt(LW_SCRIPT10, sword->X+Rand(-8, 8), sword->Y+Rand(-8, 8));
						l->UseSprite(32);
						l->DeadState = l->NumFrames*l->ASpeed;
					}
				}
			}
		}
		
	}
	lweapon CreateSword(lweapon sword, int SwordProperties){
		if(!sword->isValid() || sword->DeadState == WDS_DEAD){
			int weaponx = Link->X+SwordProperties[0];
			int weapony = Link->Y+SwordProperties[1];
			sword = CreateLWeaponAt(LW_BEAM, Clamp(weaponx, 5, 234), Clamp(weapony, 5, 154));
			sword->DrawXOffset = weaponx-sword->X;
			sword->DrawYOffset = weapony-sword->Y;
			sword->HitXOffset = sword->DrawXOffset;
			sword->HitYOffset = sword->DrawYOffset;
			sword->Damage = SwordProperties[2];
			sword->UseSprite(129);
			//sword->Misc[9] = 1;
			sword->Step = 0;
			sword->Dir = Link->Dir;
		}
		if(G[G_ALTCHARACTER]==CHAR_RIGGS&&GetSwordLevel()>2){
			LWeaponTryInflictStatus(sword, NSTAT_BURN, 40);
		}
		LWeaponPickup(sword);
		return sword;
	}
	void DrawLinkAttacking(ffc this, bool slashing, int attacker){
		if(attacker == 0){
			int xposition = Link->X;
			int yposition = Link->Y;
			if(slashing){
				if(Link->Dir == DIR_UP)
					yposition -=4;
				if(Link->Dir == DIR_DOWN)
					yposition += 4;
				if(Link->Dir == DIR_LEFT)
					xposition -= 4;
				if(Link->Dir == DIR_RIGHT)
					xposition += 4;
			}
			SetInvisible();
			int attackcombo;
			if(G[G_ALTCHARACTER]==CHAR_KELL)
				attackcombo = 768+Link->Dir; 
			else if(G[G_ALTCHARACTER]==CHAR_RIGGS)
				attackcombo = 772+Link->Dir; 
			else if(G[G_ALTCHARACTER]==CHAR_MANI)
				attackcombo = 812+Link->Dir; 
			else
				attackcombo = 768+Link->Dir; 
			int layer = 2;
			int topleft = Screen->ComboF[ComboAt(Link->X, Link->Y)];
			int topright = Screen->ComboF[ComboAt(Link->X+15, Link->Y)];
			if(topleft == 1 || topleft == 2 || (topleft >= 47 && topleft <= 65) || topright == 1 || topright == 2 || (topright >= 47 && topright <= 65)) //Why can't we just draw to the freaking sprite layer?
				layer = 3;
			
			Screen->FastCombo(layer, xposition, yposition, attackcombo, 6, OP_OPAQUE);
		}
	}
}

void LWeaponTryInflictStatus(lweapon l, int status, int frames){
	for(int i=Screen->NumNPCs(); i>0; --i){
		npc n = Screen->LoadNPC(i);
		if(n->Misc[NPCM_HITFRAME]){
			if(Collision(n, l)&&n->Misc[NPCM_STATUSTYPE]==0){
				n->Misc[NPCM_STATUSTYPE] = status;
				n->Misc[NPCM_STATUSCOUNTER] = frames;
			}
		}
	}
}

void NoMovementWaitframesAttackerBased(int frames, int attacker){
	for(int i = frames; i >0; i--){
		if(attacker == 0){
			Link->InputUp = false;
			Link->PressUp = false;
			Link->InputDown = false;
			Link->PressDown = false;
			Link->InputLeft = false;
			Link->PressLeft = false;
			Link->InputRight = false;
			Link->PressRight = false;
			Waitframe();
			if(frames == 1){
				if(Link->InputUp)
					Link->PressUp = true;
				if(Link->InputDown)
					Link->PressDown = true;
				if(Link->InputLeft)
					Link->PressLeft = true;
				if(Link->InputRight)
					Link->PressRight = true;
			}
		}
	}
}

const int FFCS_MISCSPELLS = 138;

void RunMiscSpellFFC(int type, int x, int y, int damage){
	int args[8] = {type, x, y, damage};
	RunFFCScript(FFCS_MISCSPELLS, args);
}

void RunMiscSpellFFC(int type, int x, int y, int damage, bool wait){
	int args[8] = {type, x, y, damage};
	int i = RunFFCScript(FFCS_MISCSPELLS, args);
	if(wait){
		ffc f = Screen->LoadFFC(i);
		while(f->Script==FFCS_MISCSPELLS){
			Waitframe();
		}
	}
}

lweapon FakeSwordStab_16(int dir, int til, int cs, int damage, int frame){
	int flip;
	if(dir>DIR_DOWN){
		++til;
		if(dir==DIR_LEFT)
			flip = 1;
	}
	else if(dir==DIR_DOWN)
		flip = 2;
	if(frame<12){
		int x = Link->X+DirX(dir, 14);
		int y = Link->Y+DirY(dir, 14);
		Screen->DrawTile(2, x, y, til, 1, 1, cs, -1, -1, 0, 0, 0, flip, true, 128);
		Link->Action = LA_NONE;
		Link->Action = LA_ATTACKING;
		return MakeHitbox(LW_BEAM, x, y, 16, 16, dir, damage);
	}
	else if(frame<16){
		int x = Link->X+DirX(dir, Lerp(14, 0, (frame-12)/4));
		int y = Link->Y+DirY(dir,  Lerp(14, 0, (frame-12)/4));
		Screen->DrawTile(2, x, y, til, 1, 1, cs, -1, -1, 0, 0, 0, flip, true, 128);
		Link->Action = LA_NONE;
		Link->Action = LA_ATTACKING;
		return MakeHitbox(LW_BEAM, x, y, 16, 16, dir, damage);
	}
}

lweapon FakeSword_Slash5(int dir, int til, int cs, int damage, int frame, int frameCounts){
	int whichFrame = Clamp(Floor(frame/frameCounts), 0, 4);
	int slashDir;
	int orders[] = {	DIR_LEFT, DIR_LEFTUP, DIR_UP, DIR_RIGHTUP, DIR_RIGHT,
					DIR_RIGHT, DIR_RIGHTDOWN, DIR_DOWN, DIR_LEFTDOWN, DIR_LEFT,
					DIR_UP, DIR_LEFTUP, DIR_LEFT, DIR_LEFTDOWN, DIR_DOWN,
					DIR_UP, DIR_RIGHTUP, DIR_RIGHT, DIR_RIGHTDOWN, DIR_DOWN };
	slashDir = orders[dir*5+whichFrame];
	
	int x = DirX(slashDir, 14); 
	int y = DirY(slashDir, 14);
	if(slashDir>DIR_RIGHT){
		x = DirX(slashDir, 12); 
		y = DirY(slashDir, 12);
	}
	x += Link->X;
	y += Link->Y;
	
	Screen->FastTile(2, x, y, til+slashDir, cs, 128);
	Link->Action = LA_NONE;
	Link->Action = LA_ATTACKING;
	return MakeHitbox(LW_BEAM, x, y, 16, 16, dir, damage);
}

ffc script MiscSpells{
	void run(int type, int x, int y, int damage){
		if(type==0)
			runIceWave(damage);
		if(type==1)
			runEnergySpear2(x, y, damage);
		if(type==2)
			runCursedProjectile();
		if(type==3)
			runDimiTransformBackup(this, x, y, damage);
		if(type==4)
			runNormalRock(damage);
		if(type==5)
			runLeeverDig(damage);
		if(type==6)
			runTektiteJump(x, damage);
		if(type==7)
			runPeahatSpin(damage);
		if(type==8)
			runArmosBoost(damage);
		if(type==9)
			runGhiniVanish();
		if(type==10)
			runDash(x, y, damage);
		if(type==11)
			runWallmasterStorage(damage);
		if(type==12)
			runLikeLikeMunch(damage);
		if(type==13)
			runDarknutSword(damage);
		if(type==14)
			runRopeDash(damage);
		if(type==15)
			runFireWheel(x, y, damage);
		if(type==16)
			runBabaBlast(damage);
		if(type==17)
			runBats(damage);
		if(type==18)
			runShockOrbit(damage);
		if(type==19)
			runKnightCharge(damage);
		if(type==20)
			runCarpetBomb(damage);
	}
	void runIceWave(int damage){
		int maxWaves = SwordDamageLevel(3, 4, 5, 5);
		lweapon flakes[32];
		int flakeX[32];
		int flakeY[32];
		int flakeDeadFrames[32];
		int numFlakes;
		bool flakesValid = true;
		int waveNum;
		int cooldown;
		int startX = Link->X;
		int startY = Link->Y;
		int startDir = Link->Dir;
		int i; int j; int k;
		int x; int y;
		int angle;
		while(flakesValid){
			flakesValid = false;
			if(cooldown==0&&waveNum<maxWaves){
				if(waveNum<5)
					Game->PlaySound(44);
				if(waveNum==0){
					j = CircleRadAngle(12, 12);
					angle = DirAngle(startDir)+Rand(-j/2, j/2);
					x = startX+VectorX(12, angle);
					y = startY+VectorY(12, angle);
					flakes[numFlakes] = FireLWeapon(LW_SCRIPT10, x, y, 0, 0, damage, 0, 0);
					flakes[numFlakes]->OriginalTile = 16489;
					flakes[numFlakes]->Tile = 16489;
					flakes[numFlakes]->CSet = 7;
					flakes[numFlakes]->Misc[LWM_DEATHTIMER] = 60;
					flakes[numFlakes]->Misc[LWM_MISCFLAGS] |= LWMF_PIERCING;
					flakeX[numFlakes] = flakes[numFlakes]->X;
					flakeY[numFlakes] = flakes[numFlakes]->Y;
					++numFlakes;
				}
				else if(waveNum==1){
					j = CircleRadAngle(12, 24);
					angle = DirAngle(startDir)+Rand(-j/2, j/2);
					for(i=0; i<2; ++i){
						x = startX+VectorX(24, angle-j/2+j*i);
						y = startY+VectorY(24, angle-j/2+j*i);
						flakes[numFlakes] = FireLWeapon(LW_SCRIPT10, x, y, 0, 0, damage, 0, 0);
						flakes[numFlakes]->OriginalTile = 16489;
						flakes[numFlakes]->Tile = 16489;
						flakes[numFlakes]->CSet = 7;
						flakes[numFlakes]->Misc[LWM_DEATHTIMER] = 60;
						flakes[numFlakes]->Misc[LWM_MISCFLAGS] |= LWMF_PIERCING;
						flakeX[numFlakes] = flakes[numFlakes]->X;
						flakeY[numFlakes] = flakes[numFlakes]->Y;
						++numFlakes;
					}
				}
				else if(waveNum==2){
					j = CircleRadAngle(12, 36);
					angle = DirAngle(startDir)+Rand(-j/2, j/2);
					for(i=0; i<3; ++i){
						x = startX+VectorX(36, angle-j+j*i);
						y = startY+VectorY(36, angle-j+j*i);
						flakes[numFlakes] = FireLWeapon(LW_SCRIPT10, x, y, 0, 0, damage, 0, 0);
						flakes[numFlakes]->OriginalTile = 16489;
						flakes[numFlakes]->Tile = 16489;
						flakes[numFlakes]->CSet = 7;
						flakes[numFlakes]->Misc[LWM_DEATHTIMER] = 60;
						flakes[numFlakes]->Misc[LWM_MISCFLAGS] |= LWMF_PIERCING;
						flakeX[numFlakes] = flakes[numFlakes]->X;
						flakeY[numFlakes] = flakes[numFlakes]->Y;
						++numFlakes;
					}
				}
				else if(waveNum==3){
					j = CircleRadAngle(12, 48);
					angle = DirAngle(startDir)+Rand(-j/2, j/2);
					for(i=0; i<4; ++i){
						x = startX+VectorX(48, angle-j+j*i);
						y = startY+VectorY(48, angle-j+j*i);
						flakes[numFlakes] = FireLWeapon(LW_SCRIPT10, x, y, 0, 0, damage, 0, 0);
						flakes[numFlakes]->OriginalTile = 16489;
						flakes[numFlakes]->Tile = 16489;
						flakes[numFlakes]->CSet = 7;
						flakes[numFlakes]->Misc[LWM_DEATHTIMER] = 60;
						flakes[numFlakes]->Misc[LWM_MISCFLAGS] |= LWMF_PIERCING;
						flakeX[numFlakes] = flakes[numFlakes]->X;
						flakeY[numFlakes] = flakes[numFlakes]->Y;
						++numFlakes;
					}
				}
				else if(waveNum==4){
					j = CircleRadAngle(12, 60);
					angle = DirAngle(startDir)+Rand(-j/2, j/2);
					for(i=0; i<5; ++i){
						x = startX+VectorX(60, angle-j*1.5+j*i);
						y = startY+VectorY(60, angle-j*1.5+j*i);
						flakes[numFlakes] = FireLWeapon(LW_SCRIPT10, x, y, 0, 0, damage, 0, 0);
						flakes[numFlakes]->OriginalTile = 16489;
						flakes[numFlakes]->Tile = 16489;
						flakes[numFlakes]->CSet = 7;
						flakes[numFlakes]->Misc[LWM_DEATHTIMER] = 60;
						flakes[numFlakes]->Misc[LWM_MISCFLAGS] |= LWMF_PIERCING;
						flakeX[numFlakes] = flakes[numFlakes]->X;
						flakeY[numFlakes] = flakes[numFlakes]->Y;
						++numFlakes;
					}
				}
				cooldown = 8;
				++waveNum;
			}
			else if(cooldown)
				--cooldown;
			flakesValid = false;
			for(j=0; j<numFlakes; ++j){
				if(flakes[j]->isValid()){
					flakesValid = true;
					int xy[2];
					npc target = flakeWaveHasKillled(xy, flakeX[j], flakeY[j]);
					if(target->isValid()){
						target->ItemSet = 0;
						int args[8] = {xy[0], xy[1], damage};
						RunFFCScript(FFCS_ICEBLOCK, args);
						SetEnemyProperty(target, ENPROP_HP, -1000);
						SetEnemyProperty(target, ENPROP_Y, -1000);
					}
				}
			}
			Waitframe();
		}
	}
	npc flakeWaveHasKillled(int retXY, int flakeX, int flakeY){
		for(int i=Screen->NumNPCs(); i>0; --i){
			npc n = Screen->LoadNPC(i);
			if(GetEnemyProperty(n, ENPROP_HP)<=0){
				int x = n->X+n->HitXOffset;
				int y = n->Y+n->HitYOffset;
				if(RectCollision(flakeX, flakeY, flakeX+15, flakeY+15, x, y, x+n->HitWidth-1, y+n->HitHeight-1)){
					retXY[0] = CenterX(n)-8;
					retXY[1] = CenterY(n)-8;
					return n;
				}
			}
		}
	}
	void runEnergySpear2(int x, int y, int damage){
		int delay = 4;
		int dir = Link->Dir;
		int angle = DirAngle(dir);
		lweapon l = FireLWeapon(LW_BEAM, x, y, DegtoRad(angle), 0, damage, 0, 0);
		int otil = 16648;
		int til = 16648;
		int flip = 0;
		til += 20;
		if(dir==DIR_DOWN)
			flip = 2;
		if(dir==DIR_LEFT||dir==DIR_RIGHT){
			++til;
			if(dir==DIR_LEFT)
				flip = 1;
		}
		l->Tile = til+6;
		l->OriginalTile = otil+6;
		l->CSet = 7;
		l->Flip = flip;
		l->CollDetection = false;
		l->Misc[LWM_MISCFLAGS] |= LWMF_DRAWOVER;
		for(int i=0; i<delay; ++i){
			Link->Action = LA_NONE;
			Link->Action = LA_ATTACKING;
			Waitframe();
		}
		Game->PlaySound(139);
		l->CollDetection = true;
		l->Tile = til;
		l->OriginalTile = otil;
		for(int i=0; i<8; ++i){
			l->Step = Lerp(0, 400, i/8);
			Waitframe();
		}
		l->Step = 400;
	}
	void runCursedProjectile(){
		int x; int y;
		int damage = SwordDamageLevel(Rand(10, 15)/10, Rand(25, 35)/10, Rand(60, 70)/10, Rand(75, 80)/10)*G[G_HPSCALE];
		
		int pattern = Rand(4);
		if(pattern==0){ //Boomerang
			int angle = DirAngle(Link->Dir)+Rand(-10, 10);
			int step = 2.5;
			x = Link->X+VectorX(16, angle);
			y = Link->Y+VectorY(16, angle);
			lweapon l = FireLWeapon(LW_BEAM, x, y, DegtoRad(angle), 0, damage, 101, SFX_WAND);
			l->Misc[LWM_MISCFLAGS] |= LWMF_PIERCING|LWMF_NODEADANIM;
			while(step>0){
				x += VectorX(step, angle);
				y += VectorY(step, angle);
				l->X = x;
				l->Y = y;
				step -= 0.1;
				Waitframe();
			}
			step = 0;
			while(Distance(Link->X, Link->Y, x, y)>step){
				angle = Angle(x, y, Link->X, Link->Y);
				x += VectorX(step, angle);
				y += VectorY(step, angle);
				l->X = x;
				l->Y = y;
				step += 0.1;
				Waitframe();
			}
			if(l->isValid()){
				l->DeadState = 0;
				l->Misc[LWM_MISCFLAGS] &= ~LWMF_PIERCING;
			}
		}
		else if(pattern==1){ //Circle
			int dir = Link->Dir;
			int tX = Link->X+DirX(Link->Dir, 16);
			int tY = Link->Y+DirY(Link->Dir, 16);
			x = tX;
			y = tY;
			lweapon l = FireLWeapon(LW_BEAM, x, y, DegtoRad(DirAngle(dir)), 0, damage, 101, SFX_WAND);
			l->Misc[LWM_MISCFLAGS] |= LWMF_PIERCING|LWMF_NODEADANIM;
			for(int i=0; i<36; ++i){
				tX = Link->X+DirX(dir, Lerp(16, 0, i/36)+48)+VectorX(48, DirAngle(dir)+180+10*i);
				tY = Link->Y+DirY(dir, Lerp(16, 0, i/36)+48)+VectorY(48, DirAngle(dir)+180+10*i);
				int ang = Angle(x, y, tX, tY);
				int dist = Distance(x, y, tX, tY);
				x += VectorX(dist/4, ang);
				y += VectorY(dist/4, ang);
				l->X = x;
				l->Y = y;
				Waitframe();
			}
			while(Distance(tX, tY, x, y)>4){
				tX = Link->X;
				tY = Link->Y;
				int ang = Angle(x, y, tX, tY);
				int dist = Distance(x, y, tX, tY);
				x += VectorX(dist/2, ang);
				y += VectorY(dist/2, ang);
				l->X = x;
				l->Y = y;
				Waitframe();
			}
			if(l->isValid()){
				l->DeadState = 0;
				l->Misc[LWM_MISCFLAGS] &= ~LWMF_PIERCING;
			}
		}
		else if(pattern==2){ //Firework
			x = Link->X+DirX(Link->Dir, 16);
			y = Link->Y+DirY(Link->Dir, 16);
			lweapon fuse = FireLWeapon(LW_BEAM, x, y, DegtoRad(DirAngle(Link->Dir)), 100, damage, 101, SFX_WAND);
			fuse->Misc[LWM_MISCFLAGS] |= LWMF_NODEADANIM;
			fuse->CollDetection = false;
			fuse->DrawStyle = DS_PHANTOM;
			for(int i=0; i<80; ++i){
				if(fuse->isValid()){
					fuse->DrawYOffset = Cond(i%4<2, 0, -1000);
				}
				Waitframe();
			}
			if(fuse->isValid()){
				for(int i=0; i<8; ++i){
					lweapon l = FireLWeapon(LW_BEAM, fuse->X, fuse->Y, DegtoRad(45*i+Rand(45)), 400, damage, 101, SFX_WAND);
					l->Misc[LWM_MISCFLAGS] |= LWMF_PIERCING|LWMF_NODEADANIM;
					l->Misc[LWM_DEATHTIMER] = 12;
				}
				fuse->DeadState = 0;
			}
		}
		else if(pattern==3){ //Breath
			int dir = Link->Dir;
			lweapon orbit[2];
			x = Link->X+DirX(dir, 16);
			y = Link->Y+DirY(dir, 16);
			int orbitAngle = Rand(360);
			for(int j=0; j<2; ++j){
				orbit[j] = FireLWeapon(LW_BEAM, x+VectorX(8, orbitAngle+180*j), y+VectorY(8, orbitAngle+180*j), DegtoRad(DirAngle(dir)), 0, damage, 101, SFX_WAND);
				orbit[j]->Misc[LWM_MISCFLAGS] |= LWMF_PIERCING|LWMF_NODEADANIM;
			}
			
			for(int i=0; i<64; ++i){
				if(i%8==0){
					lweapon l = FireLWeapon(LW_BEAM, x, y, DegtoRad(DirAngle(dir)+Rand(-30, 30)), 250, damage, 101, SFX_WAND);
					l->Misc[LWM_DEATHTIMER] = 24;
					l->Misc[LWM_MISCFLAGS] |= LWMF_PIERCING|LWMF_NODEADANIM;
				}
				for(int j=0; j<2; ++j){
					if(orbit[j]->isValid()){
						orbit[j]->X = x+VectorX(8, orbitAngle+180*j);
						orbit[j]->Y = y+VectorY(8, orbitAngle+180*j);
					}
				}
				orbitAngle += 5;
				Waitframe();
			}
			for(int j=0; j<2; ++j){
				if(orbit[j]->isValid()){
					orbit[j]->Misc[LWM_MISCFLAGS] &= ~LWMF_PIERCING|LWMF_NODEADANIM;
					orbit[j]->DeadState = 0;
				}
			}
		}
	}
	void runDimiTransformBackup(ffc this, int x, int y, int form){
		for(int i=1; i<=32; ++i){
			ffc f = Screen->LoadFFC(i);
			if(f->Script==this->Script&&f->InitD[0]==3&&f!=this){
				f->Script = 0;
				f->Data = 0;
			}
		}
		int angle = Rand(360);
		for(int i=0; i<600; ++i){
			if(i<480&&i%2==0)
				Screen->FastCombo(2, x+VectorX(2, angle), y+VectorY(2, angle), 741, 11, Cond(i<480, 128, 64));
			angle = WrapDegrees(angle + 5);
			Waitframe();
		}
		this->Data = 0;
		Quit();
	}
	void runNormalRock(int damage){
		lweapon l = FireLWeapon(EW_SCRIPT10, Link->X, Link->Y, DegtoRad(DirAngle(Link->Dir)), 250, damage, 18, SFX_ROCK);
		while(l->isValid()){
			if(Screen->isSolid(l->X+8, l->Y+8))
				l->DeadState = 0;
			Waitframe();
		}
	}
	void runLeeverDig(int damage){
		for(int i=0; i<16; ++i){
			SetInvisible();
			Screen->FastTile(2, Link->X, Link->Y, 98, 6, 128);
			NoButton();
			WaitNoAction();
		}
		for(int i=0; i<128; ++i){
			SetInvisible();
			SetNoColl();
			Screen->FastTile(2, Link->X, Link->Y, 96+Cond(G[G_ANIM]%16<8, 0, 1), 6, 128);
			NoButton();
			Waitframe();
		}
		for(int i=0; i<16; ++i){
			SetInvisible();
			SetNoColl();
			Screen->FastTile(2, Link->X, Link->Y, 98, 6, 128);
			MakeHitbox(LW_BEAM, Link->X-4, Link->Y-4, 24, 24, Link->Dir, damage);
			WaitNoAction();
		}
	}
	void runTektiteJump(int alt, int damage){
		int dir = Link->Dir;
		Game->PlaySound(SFX_JUMP);
		int step = 2;
		int height = 16;
		int frames = 16;
		int til = 103;
		if(alt==1){
			til = 49162;
			height = 32;
			frames = 32;
			step = 3.5;
			damage *= 2;
		}
		else if(alt==2){
			til = 49182;
			height = 32;
			frames = 16;
			step = 1;
		}
		for(int i=0; i<frames; ++i){
			SetInvisible();
			SetNoColl();
			Screen->FastTile(2, Link->X, Link->Y-height*Sin(i/frames*180), til+1, 6, 128);
			if(i<frames/2)
				MakeHitbox(LW_BEAM, Link->X, Link->Y-height*Sin(i/frames*180), 16, 16, dir, damage/2);
			LinkMovement_Push(DirX(dir, 2), DirY(dir, 2));
			WaitNoAction();
		}
		for(int i=0; i<8; ++i){
			SetInvisible();
			SetNoColl();
			Screen->FastTile(2, Link->X, Link->Y, til, 6, 128);
			MakeHitbox(LW_BEAM, Link->X, Link->Y, 16, 16, dir, damage);
			if(!alt)
				WaitNoAction();
		}
	}
	void runPeahatSpin(int damage){
		int aTimer;
		int aFrame;
		int maxFrame = 16;
		for(int i=0; i<48&&G[G_DIMITRANSFORM]==DT_PEAHAT; ++i){
			maxFrame = Lerp(16, 2, i/48);
			++aTimer;
			if(aTimer>=maxFrame){
				aTimer = 0;
				aFrame = Cond(aFrame, 0, 1);
				Game->PlaySound(SFX_SWORD);
			}
			SetInvisible();
			Screen->FastTile(2, Link->X, Link->Y, 101+aFrame, 6, 128);
			NoButton();
			Waitframe();
		}
		for(int i=0; i<192&&G[G_DIMITRANSFORM]==DT_PEAHAT; ++i){
			if(i>=128)
				maxFrame = Lerp(2, 32, (i-128)/64);
			++aTimer;
			if(aTimer>=maxFrame){
				aTimer = 0;
				aFrame = Cond(aFrame, 0, 1);
				Game->PlaySound(SFX_SWORD);
			}
			SetInvisible();
			SetNoColl();
			Screen->FastTile(2, Link->X, Link->Y, 101+aFrame, 6, 128);
			if(maxFrame<16)
				MakeHitbox(LW_BEAM, Link->X-4, Link->Y-4, 24, 24, Link->Dir, Round(Lerp(damage, damage*0.5, maxFrame/16)));
			NoButton();
			Waitframe();
		}
		for(int i=0; i<64&&Link->Action!=LA_GOTHURTLAND&&G[G_DIMITRANSFORM]==DT_PEAHAT; ++i){
			SetInvisible();
			Screen->FastTile(2, Link->X, Link->Y, 101+aFrame, 6, 128);
			NoAction();
			Waitframe();
		}
	}
	void runArmosBoost(int damage){
		for(int i=0; i<64&&G[G_DIMITRANSFORM]==DT_ARMOS; ++i){
			G[G_LINKSPEEDBOOST] += 1;
			Waitframe();
		}
		Game->PlaySound(SFX_SWORD);
		for(int i=0; i<16; ++i){
			FakeSwordStab_16(Link->Dir, 49180, 11, damage*1.5, i);
			WaitNoAction();
		}
	}
	void runGhiniVanish(){
		for(int i=0; i<32; ++i){
			if(i%4<2){
				SetInvisible();
				Screen->FastTile(2, Link->X, Link->Y, 49200, 6, 128);
			}
			WaitNoAction();
		}
		for(int i=0; i<300&&!Link->PressA&&G[G_DIMITRANSFORM]==DT_GHINI; ++i){
			SetInvisible();
			SetNoColl();
			Screen->FastTile(2, Link->X, Link->Y, 49200, 6, 128);
			Waitframe();
		}
		for(int i=0; i<32; ++i){
			if(i%4<2){
				SetInvisible();
				Screen->FastTile(2, Link->X, Link->Y, 49200, 6, 128);
			}
			WaitNoAction();
		}
	}
	void runDash(int step, int frames, int damage){
		int vX = DirX(Link->Dir, 1);
		int vY = DirY(Link->Dir, 1);
		if(step<0){
			if(LinkMovement_StickX()!=0||LinkMovement_StickY()!=0){
				vX = LinkMovement_StickX();
				vY = LinkMovement_StickY();
			}
			step = Abs(step);
		}
		Game->PlaySound(143);
		for(int i=0; i<frames; ++i){
			LinkMovement_Push(vX*step, vY*step);
			MakeHitbox(LW_BEAM, Link->X+vX*(8+step), Link->Y+vY*(8+step), 16, 16, Link->Dir, damage);
			Link->Action = LA_NONE;
			Link->Action = LA_ATTACKING;
			WaitNoAction();
		}
	}
	void runWallmasterStorage(int damage){
		if(CountFFCsRunning(143)>0){
			Quit();
		}
		int npcForms[1024];
		DimiFormEnemies(npcForms);
		lweapon wind = FireLWeapon(LW_BEAM, Link->X, Link->Y, DegtoRad(DirAngle(Link->Dir)), 300, damage, 0, SFX_WHIRLWIND);
		wind->OriginalTile = GH_BLANK_TILE;
		wind->DrawYOffset = -1000;
		wind->Misc[LWM_MISCFLAGS] |= LWMF_NODEADANIM;
		while(wind->isValid()){
			Screen->FastCombo(2, wind->X, wind->Y, 744, 7, 128);
			if(wind->DeadState!=WDS_ALIVE){
				for(int i=Screen->NumNPCs(); i>0; --i){
					npc n = Screen->LoadNPC(i);
					if(Collision(n, wind)){
						if(n->HP<=0){
							if(npcForms[n->ID]){
								bool stored;
								for(int j=0; j<10; ++j){
									if(G[G_WALLMASTERSTORAGE1+j]==0){
										G[G_WALLMASTERSTORAGE1+j] = n->ID;
										stored = true;
										break;
									}
								}
								if(!stored){
									for(int j=9; j>0; --j){
										G[G_WALLMASTERSTORAGE1+j] = G[G_WALLMASTERSTORAGE1+j-1];
									}
									G[G_WALLMASTERSTORAGE1] = n->ID;
								}
								wind->DeadState = WDS_ALIVE;
								wind->CollDetection = false;
								wind->Step = 0;
								wind->X = CenterX(n)-8;
								wind->Y = CenterY(n)-8;
								SetEnemyProperty(n, ENPROP_HP, -1000);
								n->ItemSet = 0;
								n->DrawYOffset = -1000;
								n->DrawXOffset = -1000;
								int step = 0;
								int y = wind->Y;
								Game->PlaySound(SFX_WHIRLWIND);
								while(wind->Y>0){
									y -= step;
									step += 0.1;
									wind->Y = y;
									Screen->FastCombo(2, wind->X, wind->Y, 744, 7, 128);
									Waitframe();
								}
								wind->DeadState = 0;
								Quit();
							}
						}
					}
				}
			}
			Waitframe();
		}
	}
	void runLikeLikeMunch(int damage){
		int npcForms[1024];
		DimiFormEnemies(npcForms);
		npc target;
		int dir = Link->Dir;
		int movedFrames;
		for(int i=0; i<8; ++i){
			++movedFrames;
			SetNoColl();
			LinkMovement_Push(DirX(dir, 2), DirY(dir, 2));
			for(int j=Screen->NumNPCs(); j>0; --j){
				npc n = Screen->LoadNPC(j);
				if(LinkCollision(n)&&n->TileWidth==1&&n->TileHeight==1){
					if(npcForms[n->ID]&&n->ID!=NPC_WALLMASTER){
						target = n;
						break;
					}
				}
			}
			Waitframe();
		}
		if(target->isValid()){
			for(int i=0; i<80&&target->isValid(); ++i){
				target->Stun = 60;
				SetEnemyProperty(target, ENPROP_X, Link->X);
				SetEnemyProperty(target, ENPROP_Y, Link->Y);
				if(i%4==0){
					Game->PlaySound(SFX_EHIT);
					target->Misc[NPCM_PIERCEDAMAGE] += Ceiling(damage/10);
				}
				Waitframe();
			}
			Link->HP = Min(Link->HP+16, Link->MaxHP);
		}
		else{
			for(int i=0; i<movedFrames; ++i){
				LinkMovement_Push(DirX(dir, -2), DirY(dir, -2));
				Waitframe();
			}
		}
	}
	void runDarknutSword(int damage){
		Game->PlaySound(SFX_SWORD);
		int dir = Link->Dir;
		for(int i=0; i<15; ++i){
			LinkMovement_Push(DirX(dir, 1.0666), DirY(dir, 1.0666));
			FakeSword_Slash5(dir, 3932, 7, damage, i, 3);
			WaitNoAction();
		}
	}
	void runRopeDash(int damage){
		int vX = DirX(Link->Dir, 1);
		int vY = DirY(Link->Dir, 1);
		int failsafe = 300;
		while(CanWalk(Link->X, Link->Y, Link->Dir, 1, Link->Dir==DIR_UP)&&failsafe){
			--failsafe;
			LinkMovement_Push(vX*2.5, vY*2.5);
			MakeHitbox(LW_BEAM, Link->X+vX*(8), Link->Y+vY*(8), 16, 16, Link->Dir, damage);
			Link->Action = LA_NONE;
			Link->Action = LA_ATTACKING;
			WaitNoAction();
		}
	}
	void runFireWheel(int centerX, int centerY, int damage){
		int i;
		int x; int y;
		int x2; int y2;
		
		int rotDir = Choose(-1, 1);
		int angle = Rand(360);
		lweapon fires[6];
		int xOff[6];
		int yOff[6];
		bool wentOffscreen[6];
		bool permaDead[6];
		int deathTimer[6];
		int lastX[6];
		int lastY[6];
		Game->PlaySound(SFX_FIRE);
		for(i=0; i<6; i++){
			fires[i] = FireLWeapon(LW_SCRIPT10, centerX, centerY, DegtoRad(angle+60*i), 0, damage, 35, 0);
			xOff[i] = Rand(-10, 10)/10;
			yOff[i] = Rand(-10, 10)/10;
			deathTimer[i] = 96+Rand(48);
		}
		int dist = 0;
		int rot = 0;
		int count = 1;
		
		int expandSpeed = LazyDiffMod(0.4, 0.5, 0.55);
		int rotAccelSpeed = LazyDiffMod(0.03, 0.04, 0.05);
		while(count){
			count = 0;
			dist += expandSpeed;
			rot += rotAccelSpeed;
			angle += rot*rotDir;
			for(i=0; i<6; i++){
				x = centerX+VectorX(dist, angle+60*i);
				y = centerY+VectorY(dist, angle+60*i);
				x += dist*xOff[i]*0.5;
				y += dist*yOff[i]*0.5;
				x2 = centerX+VectorX(dist, angle+((rot+0.05)*rotDir)+60*i);
				y2 = centerY+VectorY(dist, angle+((rot+0.05)*rotDir)+60*i);
				x2 += dist*xOff[i]*0.5;
				y2 += dist*yOff[i]*0.5;
				int dir = AngleDir4(Angle(x, y, x2, y2));
				deathTimer[i]--;
				if(fires[i]->isValid()){
					if(x<=16||x>=224||y<=16||y>=144){
						wentOffscreen[i] = true;
					}
					fires[i]->X = x;
					fires[i]->Y = y;
					fires[i]->Dir = dir;
					if(deathTimer[i]<=0){
						wentOffscreen[i] = false;
						fires[i]->DeadState = 0;
					}
					count++;
				}
				else{
					if(wentOffscreen[i]&&!permaDead[i]){
						if(x>16&&x<224&&y>16&&y<144){
							fires[i] = FireLWeapon(LW_SCRIPT10, x, y, DegtoRad(angle+60*i), 0, damage, 35, 0);
							fires[i]->Dir = dir;
							wentOffscreen[i] = false;
						}
					}
				}
				lastX[i] = x;
				lastY[i] = y;
			}
			
			Waitframe();
		}
		for(i=0; i<6; i++){
			if(fires[i]->isValid())
				fires[i]->DeadState = 0;
		}
	}
	void runBabaBlast(int damage){
		int i; int j; int k;
		
		int dir = Link->Dir;
		
		lweapon bah[12];
		if(AllowSomeJokes())
			Game->PlaySound(SFX_BABABABA);
		for(i=0; i<4; i++){
			if(!AllowSomeJokes())
				Game->PlaySound(SFX_WAND);
			for(k=0; k<3; k++){
				bah[i*3+k] = SparkleSpriteAnim(Link->X+Rand(-3, 3), Link->Y+Rand(-3, 3), SPR_BABABABA, 1, 1, DirAngle(dir), Rand(800, 1000));
				if(dir>=2){
					bah[i*3+k]->OriginalTile += 4;
					bah[i*3+k]->Tile = bah[i*3+k]->OriginalTile;
				}
				if(bah[i*3+k]->Dir==DIR_DOWN)
					bah[i*3+k]->Flip = 2;
				else if(bah[i*3+k]->Dir==DIR_LEFT)
					bah[i*3+k]->Flip = 1;
			}
			
			for(j=0; j<6; j++){
				updateBabaWeapons(bah, Ceiling(damage/4));
				Link->Action = LA_NONE;
				Link->Action = LA_ATTACKING;
				NoAction();
				Waitframe();
			}
		}
		for(j=0; j<24; ++j){
			updateBabaWeapons(bah, Ceiling(damage/4));
			Waitframe();
		}
	}
	void updateBabaWeapons(lweapon bah, int damage){
		for(int k=0; k<12; k++){
			if(bah[k]->isValid()){
				for(int j=Screen->NumNPCs(); j>0; --j){
					npc n = Screen->LoadNPC(j);
					if(n->Defense[NPCD_BOMB]!=NPCDT_BLOCK&&n->Defense[NPCD_BOMB]!=NPCDT_IGNORE){
						if(Collision(n, bah[k])&&n->CollDetection){
							eweapon boom = CreateEWeaponAt(EW_BOMBBLAST, bah[k]->X, bah[k]->Y);
							boom->CollDetection = false;
							
							n->Misc[NPCM_PIERCEDAMAGE] += damage;
							Game->PlaySound(SFX_EHIT);
							
							lweapon nullLWeapon;
							bah[k] = nullLWeapon;
						}
					}
				}
			}
		}
	}
	void runBats(int damage){
		lweapon bat[4];
		int batX[4];
		int batY[4];
		int batTime[4];
		int batDir[4];
		int batRedirects[4];
		Game->PlaySound(SFX_SUMMON);
		for(int i=0; i<4; ++i){
			batX[i] = Link->X;
			batY[i] = Link->Y;
			bat[i]->X = batX[i];
			bat[i]->Y = batY[i];
			batDir[i] = Rand(8);
			batTime[i] = Rand(24, 48);
			bat[i] = FireLWeapon(LW_SCRIPT10, Link->X, Link->Y, DegtoRad(DirAngle(batDir[i])), 0, damage, 0, 0);
			bat[i]->OriginalTile = 123;
			bat[i]->Tile = bat[i]->OriginalTile;
			bat[i]->CSet = 9;
			bat[i]->NumFrames = 2;
			bat[i]->ASpeed = 4;
			bat[i]->Misc[LWM_MISCFLAGS] |= LWMF_PIERCING;
		}
		for(int j=0; j<600; ++j){
			for(int i=0; i<4; ++i){
				if(bat[i]->isValid()){
					batX[i] += DirX(batDir[i], 1);
					batY[i] += DirY(batDir[i], 1);
					batX[i] = Clamp(batX[i], 32, 208);
					batY[i] = Clamp(batY[i], 32, 128);
					bat[i]->X = batX[i];
					bat[i]->Y = batY[i];
					int x = batX[i];
					int y = batY[i];
					if(batTime[i]<=0||x<=32||y<=32||x>=208||y>=128){
						batDir[i] = Rand(8);
						if(x<=32||y<=32||x>=208||y>=128)
							batDir[i] = AngleDir8(Angle(x, y, Link->X, Link->Y));
						batTime[i] = Rand(24, 48);
						++batRedirects[i];
					}
					else{
						--batTime[i];
					}
				}
			}
			Waitframe();
		}
		int numBats = 4;
		while(numBats){
			numBats = 0;
			for(int i=0; i<4; ++i){
				if(bat[i]->isValid()){
					++numBats;
					batX[i] += DirX(batDir[i], 1);
					batY[i] += DirY(batDir[i], 1);
					batX[i] = Clamp(batX[i], 32, 208);
					batY[i] = Clamp(batY[i], 32, 128);
					bat[i]->X = batX[i];
					bat[i]->Y = batY[i];
					int x = batX[i];
					int y = batY[i];
					if(batTime[i]<=0||x<=32||y<=32||x>=208||y>=128){
						batDir[i] = Rand(8);
						if(x<=32||y<=32||x>=208||y>=128)
							batDir[i] = AngleDir8(Angle(x, y, Link->X, Link->Y));
						batTime[i] = Rand(24, 48);
						if(batRedirects[i]>=25){
							Game->PlaySound(SFX_EDEAD);
							SpriteAnim(x, y, 23, 1, 1);
							bat[i]->Misc[LWM_MISCFLAGS] &= ~LWMF_PIERCING;
							bat[i]->DeadState = 0;
						}
						++batRedirects[i];
					}
					else{
						--batTime[i];
					}
				}
			}
			Waitframe();
		}
	}
	void runShockOrbit(int damage){
		int x; int y;
		int shockballAngle = Rand(360);
		int shockballDist = 40;
		for(int j=0; j<96; ++j){
			Screen->FastCombo(3, Link->X+Rand(-3, 3), Link->Y+Rand(-3, 3), 2752, 1, 128);
		
			shockballAngle += 2;
			shockballAngle %= 360;
			for(int i=0; i<3; i++){
				x = Link->X+VectorX(12, shockballAngle+120*i);
				y = Link->Y+VectorY(12, shockballAngle+120*i);
				Screen->FastCombo(3, x, y, 2753, 1, 128);
				MakeHitbox(LW_BEAM, x, y, 16, 16, Link->Dir, damage);
			}
			Waitframe();
		}
		int vX = DirX(Link->Dir, 1);
		int vY = DirY(Link->Dir, 1);
		if(LinkMovement_StickX()!=0||LinkMovement_StickY()!=0){
			vX = LinkMovement_StickX();
			vY = LinkMovement_StickY();
		}
		Game->PlaySound(SFX_SHOCKROBE_DASH);
		for(int j=0; j<32; ++j){
			Screen->FastCombo(3, Link->X+Rand(-3, 3), Link->Y+Rand(-3, 3), 2752, 1, 128);
		
			shockballAngle += 2;
			shockballAngle %= 360;
			LinkMovement_Push(vX*1.5, vY*1.5);
			for(int i=0; i<3; i++){
				x = Link->X+VectorX(12+shockballDist*Sin(j/32*180), shockballAngle+120*i);
				y = Link->Y+VectorY(12+shockballDist*Sin(j/32*180), shockballAngle+120*i);
				Screen->FastCombo(3, x, y, 2753, 1, 128);
				MakeHitbox(LW_BEAM, x, y, 16, 16, Link->Dir, damage);
			}
			NoAction();
			Waitframe();
		}
		for(int j=0; j<64; ++j){
			Screen->FastCombo(3, Link->X+Rand(-3, 3), Link->Y+Rand(-3, 3), 2752, 1, 128);
		
			shockballAngle += 2;
			shockballAngle %= 360;
			for(int i=0; i<3; i++){
				x = Link->X+VectorX(Lerp(12, 4, j/64), shockballAngle+120*i);
				y = Link->Y+VectorY(Lerp(12, 4, j/64), shockballAngle+120*i);
				Screen->FastCombo(3, x, y, 2753, 1, 128);
				MakeHitbox(LW_BEAM, x, y, 16, 16, Link->Dir, damage);
			}
			Waitframe();
		}
	}
	void runKnightCharge(int damage){
		int dir = Link->Dir;
		bool canMove = true;
		bool turnValid[2];
		int turnDir[2];
		int startX = GridX(Link->X+8);
		int startY = GridY(Link->Y+8);
		int x = startX;
		int y = startY;
		x += DirX(dir, 16);
		y += DirY(dir, 16);
		if(!CanPlace(x, y, 16, 16)){
			canMove = false;
		}
		x += DirX(dir, 16);
		y += DirY(dir, 16);
		if(!CanPlace(x, y, 16, 16)){
			canMove = false;
		}
		if(CanPlace(x+DirX(RotDirCCW4(dir), 16), y+DirY(RotDirCCW4(dir), 16), 16, 16)){
			turnValid[0] = true;
			turnDir[0] = RotDirCCW4(dir);
		}
		if(CanPlace(x+DirX(RotDirCW4(dir), 16), y+DirY(RotDirCW4(dir), 16), 16, 16)){
			turnValid[1] = true;
			turnDir[1] = RotDirCW4(dir);
		}
		if(!canMove||!(turnValid[0]||turnValid[1])){
			Game->PlaySound(SFX_ERROR);
			Quit();
		}
		Link->X = startX;
		Link->Y = startY;
		int tempDir = dir;
		int vX = DirX(tempDir);
		int vY = DirY(tempDir);
		for(int i=0; i<16; ++i){
			SetInvisible();
			SetNoColl();
			Screen->FastCombo(2, Link->X, Link->Y-12*Sin(i/16*180), Cond(vX<0||vY<0, 2770, 2771), 6, 128);
			MakeHitbox(LW_BEAM, Link->X, Link->Y-12*Sin(i/16*180), 16, 16, tempDir, damage);
			LinkMovement_Push(DirX(tempDir, 1), DirY(tempDir, 1));
			Link->HitDir = -1;
			WaitNoAction();
		}
		for(int i=0; i<16; ++i){
			SetInvisible();
			SetNoColl();
			Screen->FastCombo(2, Link->X, Link->Y-12*Sin(i/16*180), Cond(vX<0||vY<0, 2770, 2771), 6, 128);
			MakeHitbox(LW_BEAM, Link->X, Link->Y-12*Sin(i/16*180), 16, 16, tempDir, damage);
			LinkMovement_Push(DirX(tempDir, 1), DirY(tempDir, 1));
			Link->HitDir = -1;
			WaitNoAction();
		}
		if(turnValid[0]&&turnValid[1]){
			if(InputDir(turnDir[0]))
				tempDir = turnDir[0];
			else if(InputDir(turnDir[1]))
				tempDir = turnDir[1];
			else
				tempDir = Choose(turnDir[0], turnDir[1]);
		}
		else if(turnValid[0])
			tempDir = turnDir[0];
		else if(turnValid[1])
			tempDir = turnDir[1];
		
		vX = DirX(tempDir);
		vY = DirY(tempDir);
		for(int i=0; i<16; ++i){
			SetInvisible();
			SetNoColl();
			Screen->FastCombo(2, Link->X, Link->Y-12*Sin(i/16*180), Cond(vX<0||vY<0, 2770, 2771), 6, 128);
			MakeHitbox(LW_BEAM, Link->X, Link->Y-12*Sin(i/16*180), 16, 16, tempDir, damage);
			LinkMovement_Push(DirX(tempDir, 1), DirY(tempDir, 1));
			Link->HitDir = -1;
			WaitNoAction();
		}
	}
	void runCarpetBomb(int damage){
		int bX[8];
		int bY[8];
		int bJump[8];
		int bZ[8];
		int bTX[8];
		int bTY[8];
		int bStep[8];
		int tX = Link->X+DirX(Link->Dir, 48);
		int tY = Link->Y+DirY(Link->Dir, 48);
		int vX;
		int vY;
		for(int i=0; i<8; ++i){
			bX[i] = Link->X;
			bY[i] = Link->Y;
			bJump[i] = 3.6;
			bTX[i] = tX;
			bTY[i] = tY;
			int dist = Distance(bX[i], bY[i], bTX[i], bTY[i]);
			int jumpTime = FindJumpLength(3.6, false);
			bStep[i] = dist/jumpTime;
			Trace(dist);
			Trace(jumpTime);
			Trace(bStep[i]);
		
			for(int j=0; j<12; ++j){
				vX = Clamp(vX+0.1*LinkMovement_StickX(), -1.5, 1.5);
				vY = Clamp(vY+0.1*LinkMovement_StickY(), -1.5, 1.5);
				tX += vX;
				tY += vY;
				G[G_LINKSPEEDBOOST] -= 0.5;
				
				for(int k=0; k<8; ++k){
					if(bZ[k]>0||bJump[k]>0){
						int ang = Angle(bX[k], bY[k], bTX[k], bTY[k]);
						bX[k] += VectorX(bStep[k], ang);
						bY[k] += VectorY(bStep[k], ang);
						bJump[k] = Clamp(bJump[k]-0.16, -3.2, 3.2);
						bZ[k] = Max(bZ[k]+bJump[k], 0);
						Screen->FastTile(4, bX[k], bY[k]-bZ[k], 211, 7, 128);
						if(bZ[k]==0&&bJump[k]<=0){
							lweapon blast = FireLWeapon(LW_BOMBBLAST, bX[k], bY[k], 0, 0, damage, 0, 0);
							blast->Dir = -1;
						}
					}
				}
				Waitframe();
			}
		}
		int count = 8;
		while(count){
			vX = Clamp(vX+0.1*LinkMovement_StickX(), -1.5, 1.5);
			vY = Clamp(vY+0.1*LinkMovement_StickY(), -1.5, 1.5);
			tX += vX;
			tY += vY;
			G[G_LINKSPEEDBOOST] -= 0.5;
				
			count = 0;
			for(int k=0; k<8; ++k){
				if(bZ[k]>0||bJump[k]>0){
					++count;
					int ang = Angle(bX[k], bY[k], bTX[k], bTY[k]);
					bX[k] += VectorX(bStep[k], ang);
					bY[k] += VectorY(bStep[k], ang);
					bJump[k] = Clamp(bJump[k]-0.16, -3.2, 3.2);
					bZ[k] = Max(bZ[k]+bJump[k], 0);
					Screen->FastTile(4, bX[k], bY[k]-bZ[k], 211, 7, 128);
					if(bZ[k]==0&&bJump[k]<=0){
						lweapon blast = FireLWeapon(LW_BOMBBLAST, bX[k], bY[k], 0, 0, damage, 0, 0);
						blast->Dir = -1;
					}
				}
			}
			Waitframe();
		}
	}
}

int CircleRadAngle(int pixels, int rad){
	int diameter = 2*PI*rad;
	return (pixels/diameter)*360;
}

const int FFCS_ICEBLOCK = 134;

ffc script IceBlock{
	void run(int x, int y, int damage){
		//int damage = 12*G[G_HPSCALE];
		int pushDir = -1;
		Game->PlaySound(SFX_ICE);
		for(int i=0; i<300; ++i){
			
			if(RectCollision(Link->X+4, Link->Y+4, Link->X+11, Link->Y+11, x, y, x+15, y+15)){
				pushDir = AngleDir4(Angle(Link->X, Link->Y, x, y));
				break;
			}
			
			Screen->FastTile(2, x, y, 5658, 7, 128);
			Waitframe();
		}
		if(pushDir>-1){
			Game->PlaySound(6);
			while(x>-16&&x<256&&y>-16&&y<176){
				x += DirX(pushDir, 4);
				y += DirY(pushDir, 4);
				
				MakeHitbox(LW_SCRIPT10, x, y, 16, 16, pushDir, damage);
				Screen->FastTile(2, x, y, 5658, 7, 128);
				Waitframe();
			}
		}
		else{
			Game->PlaySound(84);
			for(int i=0; i<16; ++i){
				SparkleSpriteAnim(x+Rand(-8, 8), y+Rand(-8, 8), 126, 1, 1);
					
				Screen->FastTile(2, x, y, 5658, 7, 128);
				Waitframe();
			}
		}
	}
}

const int FFCS_NORASUMMON = 135;

ffc script NoraSummons{
	void run(int x, int y, int id, int despawn, int justSummoned){
		int i; int j; int k;
		int angle;
		
		if(justSummoned){
			setSummonFlag(id, false);
		}
		this->Flags[FFCF_IGNOREHOLDUP] = true;
		this->Flags[FFCF_ETHEREAL] = true;
		int data[16];
		npc target[1];
		//0 - X
		//1 - Y
		//2 - TX
		//3 - TY
		//4 - State
		//5 - Dir
		//6 - Timer
		//7 - Last Dir
		
		data[0] = x;
		data[1] = y;
		
		int combo;
		int step;
		int turnRate; int homingChance; int homingDist;
		
		int damageRanged;
		int damageCloseContact;
		
		int commandAttackCooldown;
		int passiveAttackCooldown;
		
		if(id==0){
			combo = 776;
			damageRanged = SwordDamageLevel(2, 3, 4, 4)*G[G_HPSCALE]; 
			damageCloseContact = SwordDamageLevel(2, 4, 6, 6)*G[G_HPSCALE];
			step = 0.5;
			turnRate = 4;
			homingChance = 4;
			homingDist = 64;
		}
		else if(id==1){
			combo = 784;
			damageRanged = SwordDamageLevel(2, 3, 4, 4)*G[G_HPSCALE]; 
			damageCloseContact = SwordDamageLevel(2, 4, 8, 8)*G[G_HPSCALE];
			step = 0.75;
			turnRate = 3;
			homingChance = 8;
			homingDist = 128;
		}
		else if(id==2){
			combo = 792;
			step = 0.5;
			damageRanged = SwordDamageLevel(2, 4, 12, 12)*G[G_HPSCALE]; 
			damageCloseContact = SwordDamageLevel(2, 4, 8, 8)*G[G_HPSCALE];
			turnRate = 8;
			homingChance = 4;
			homingDist = 128;
		}
		else if(id==3){
			combo = 784;
			step = 1.5;
			damageRanged = SwordDamageLevel(2, 4, 8, 8)*G[G_HPSCALE]; 
			damageCloseContact = SwordDamageLevel(4, 8, 16, 16)*G[G_HPSCALE];
			turnRate = 3;
			homingChance = 2;
			homingDist = 256;
			combo = 800;
		}
		
		while(true){
			if(commandAttackCooldown)
				--commandAttackCooldown;
			if(passiveAttackCooldown)
				--passiveAttackCooldown;
			
			noraWalker(data, target, step, turnRate, homingChance, homingDist);
			
			if(data[4]==2){ //Polling Attack
				data[4] = 1;
				
				if(this->InitD[3]){
					Game->PlaySound(SFX_EDEAD);
					SpriteAnim(data[0], data[1], 23, 1, 1);
					this->Flags[FFCF_IGNOREHOLDUP] = false;
					setSummonFlag(id, true);
					this->Data = 0;
					Quit();
				}
				
				int attack;
				int attackDir;
				if(id==0){
					if(G[G_NORAATTACKCOMMAND]&&!commandAttackCooldown){
						attack = 1;
						attackDir = AngleDir4(Angle(data[0], data[1], Link->X, Link->Y));
					
						commandAttackCooldown = 120;
						passiveAttackCooldown = 180;
					}
					else{
						attackDir = getSightDir(NPCD_REFROCK, data[0], data[1], data[5]);
						if(attackDir>-1&&!passiveAttackCooldown){
							attack = 1;
							
							passiveAttackCooldown = 180;
						}
					}
					
					if(attack==1){
						data[5] = attackDir;
						for(i=0; i<8; ++i){
							Screen->FastCombo(2, data[0], data[1]-2, combo+4+data[5], 5, 128);
							Waitframe();
						}
						lweapon l = FireLWeapon(LW_REFROCK, data[0], data[1], DegtoRad(DirAngle(attackDir)), 250, damageRanged, 18, SFX_ROCK);
						l->Misc[LWM_REFLINKCOLLISION] = 2;
						for(i=0; i<16; ++i){
							Screen->FastCombo(2, data[0], data[1]-2, combo+4+data[5], 5, 128);
							Waitframe();
						}
						data[4] = 0;
					}
				}
				else if(id==1){
					if(G[G_NORAATTACKCOMMAND]&&!commandAttackCooldown){
						attack = 1;
						attackDir = AngleDir4(Angle(data[0], data[1], Link->X, Link->Y));
					
						commandAttackCooldown = 120;
						passiveAttackCooldown = 300;
					}
					else{
						if(!passiveAttackCooldown&&((Abs(CenterX(target[0])-data[0]+8)<24&&Abs(CenterY(target[0])-data[1]+8)<24)||Rand(32)==0)){
							attackDir = data[5];
							attack = 2;
								
							passiveAttackCooldown = 300;
						}
						else{
							attackDir = getSightDir(NPCD_ARROW, data[0], data[1], data[5]);
							if(attackDir>-1&&!passiveAttackCooldown){
								attack = 1;
								
								passiveAttackCooldown = 120;
							}
						}
					}
					
					if(attack==1){
						data[5] = attackDir;
						for(i=0; i<8; ++i){
							Screen->FastCombo(2, data[0], data[1]-2, combo+4+data[5], 5, 128);
							Waitframe();
						}
						lweapon l = FireLWeapon(LW_ARROW, data[0], data[1], DegtoRad(DirAngle(attackDir)), 250, damageRanged, 19, SFX_ARROW);
						if(l->Dir>1)
							++l->Tile;
						if(l->Dir==DIR_DOWN)
							l->Flip = 2;
						else if(l->Dir==DIR_LEFT)
							l->Flip = 1;
						for(i=0; i<16; ++i){
							Screen->FastCombo(2, data[0], data[1]-2, combo+4+data[5], 5, 128);
							Waitframe();
						}
						data[4] = 0;
					}
					else if(attack==2){
						data[5] = attackDir;
						for(i=0; i<8; ++i){
							Screen->FastCombo(2, data[0], data[1]-2, combo+4+data[5], 5, 128);
							Waitframe();
						}
						lweapon l = FireLWeapon(LW_BOMB, data[0]+DirX(data[5], 12), data[1]+DirY(data[5], 12), DegtoRad(DirAngle(attackDir)), 0, damageCloseContact, 7, SFX_PLACE);
						for(i=0; i<16; ++i){
							Screen->FastCombo(2, data[0], data[1]-2, combo+4+data[5], 5, 128);
							Waitframe();
						}
						data[4] = 0;
					}
				}
				else if(id==2){
					if(G[G_NORAATTACKCOMMAND]&&!commandAttackCooldown){
						attack = 1;
						attackDir = Link->Dir;
					
						commandAttackCooldown = 180;
						passiveAttackCooldown = 240;
					}
					else{
						attackDir = getSightDir(NPCD_BEAM, data[0], data[1], data[5], 64);
						if(attackDir>-1&&!passiveAttackCooldown){
							attack = 2;
									
							passiveAttackCooldown = 300;
						}
						else{
							attackDir = getSightDir(NPCD_BEAM, data[0], data[1], data[5]);
							if(attackDir>-1&&!passiveAttackCooldown){
								attack = 1;
								
								passiveAttackCooldown = 180;
							}
						}
					}
					
					if(attack==1){
						data[5] = attackDir;
						for(i=0; i<8; ++i){
							Screen->FastCombo(2, data[0], data[1]-2, combo+4+data[5], 5, 128);
							Waitframe();
						}
						lweapon l = FireLWeapon(LW_BEAM, data[0], data[1], DegtoRad(DirAngle(attackDir)), 450, damageRanged, 20, SFX_BEAM);
						if(l->Dir>1)
							++l->Tile;
						if(l->Dir==DIR_DOWN)
							l->Flip = 2;
						else if(l->Dir==DIR_LEFT)
							l->Flip = 1;
						for(i=0; i<16; ++i){
							Screen->FastCombo(2, data[0], data[1]-2, combo+4+data[5], 5, 128);
							Waitframe();
						}
						data[4] = 0;
					}
					else if(attack==2){
						data[5] = attackDir;
						for(i=0; i<8; ++i){
							Screen->FastCombo(2, data[0], data[1]-2, combo+4+data[5], 5, 128);
							Waitframe();
						}
						for(i=0; i<32; ++i){
							if(i%4==0){
								lweapon l = FireLWeapon(LW_BEAM, data[0]+DirX(RotDirCW4(attackDir), Rand(-8, 8)), data[1]+DirY(RotDirCW4(attackDir), Rand(-8, 8)), DegtoRad(DirAngle(attackDir)), 350, damageCloseContact, 20, SFX_BEAM);
								if(l->Dir>1)
									++l->Tile;
								if(l->Dir==DIR_DOWN)
									l->Flip = 2;
								else if(l->Dir==DIR_LEFT)
									l->Flip = 1;
								l->Misc[LWM_DEATHTIMER] = 16;
							}
							k = ComboAt(data[0]+8, data[1]+8);
							j = Q7_AdjacentCombo(k, attackDir);
							if(j>-1){
								if(isWalkable(j)){
									angle = Angle(data[0], data[1], ComboX(j), ComboY(j));
									data[0] += VectorX(1.5, angle);
									data[1] += VectorY(1.5, angle);
								}
							}
							Screen->FastCombo(2, data[0], data[1]-2, combo+4+data[5], 5, 128);
							Waitframe();
						}
						data[4] = 0;
					}
				}
				else if(id==3){
					if(G[G_NORAATTACKCOMMAND]&&!commandAttackCooldown){
						attack = 2;
						attackDir = Link->Dir;
					
						commandAttackCooldown = 60;
						passiveAttackCooldown = 120;
					}
					else{
						attackDir = getSightDir(NPCD_BEAM, data[0], data[1], data[5], 32);
						if(attackDir>-1&&!passiveAttackCooldown){
							attack = 2;
									
							passiveAttackCooldown = 30;
						}
						else{
							attackDir = getSightDir(NPCD_BEAM, data[0], data[1], data[5]);
							if(attackDir>-1&&!passiveAttackCooldown&&Rand(4)==0){
								attack = 1;
								
								passiveAttackCooldown = 300;
							}
						}
					}
					
					if(attack==1){
						data[5] = attackDir;
						for(i=0; i<8; ++i){
							Screen->FastCombo(2, data[0], data[1]-2, combo+4+data[5], 5, 128);
							Waitframe();
						}
						int dashTimer = 14;
						Game->PlaySound(SFX_SWORD);
						while(dashTimer>0){
							for(i=0; i<4; ++i){
								k = ComboAt(data[0]+8, data[1]+8);
								j = Q7_AdjacentCombo(k, attackDir);
								if(j>-1){
									if(isWalkable(j)){
										angle = Angle(data[0], data[1], ComboX(j), ComboY(j));
										data[0] += VectorX(1, angle);
										data[1] += VectorY(1, angle);
									}
									else
										--dashTimer;
								}
								else
									--dashTimer;
							}
							Screen->FastCombo(2, data[0], data[1]-2, combo+4+data[5], 5, 128);
							
							x = data[0]+DirX(attackDir, dashTimer);
							y = data[1]+DirY(attackDir, dashTimer);
							
							Screen->DrawCombo(2, x, y, 808, 1, 1, 5, -1, -1, x, y, DirAngle(attackDir), 0, 0, true, 128);
							
							MakeHitbox(LW_BEAM, x, y, 16, 16, attackDir, damageRanged);
							
							Waitframe();
						}
						data[4] = 0;
					}
					else if(attack==2){
						data[5] = attackDir;
						for(i=0; i<8; ++i){
							Screen->FastCombo(2, data[0], data[1]-2, combo+4+data[5], 5, 128);
							Waitframe();
						}
						Game->PlaySound(SFX_SWORD);
						for(i=0; i<16; ++i){
							k = ComboAt(data[0]+8, data[1]+8);
							j = Q7_AdjacentCombo(k, attackDir);
							if(j>-1){
								if(isWalkable(j)){
									angle = Angle(data[0], data[1], ComboX(j), ComboY(j));
									data[0] += VectorX(1.2, angle);
									data[1] += VectorY(1.2, angle);
								}
							}
							Screen->FastCombo(2, data[0], data[1]-2, combo+4+data[5], 5, 128);
							
							x = data[0]+VectorX(14, DirAngle(attackDir)-60+120*(i/16));
							y = data[1]+VectorY(14, DirAngle(attackDir)-60+120*(i/16));
							
							Screen->DrawCombo(2, x, y, 808, 1, 1, 5, -1, -1, x, y, DirAngle(attackDir)-60+120*(i/16), 0, 0, true, 128);
							
							MakeHitbox(LW_BEAM, x, y, 16, 16, attackDir, damageCloseContact);
							
							Waitframe();
						}
						data[4] = 0;
					}
				}
			}
			
			Screen->FastCombo(2, data[0], data[1]-2, combo+data[5], 5, 128);
			
			Waitframe();
		}
	}
	void noraWalker(int data, npc target, int step, int turnRate, int homingChance, int homingDist){
		int i; int j; int k;
		
		int x = data[0];
		int y = data[1];
		int tx = data[2];
		int ty = data[3];
		int state = data[4];
		int dir = data[5];
		int timer = data[6];
		
		int pos = ComboAt(x+8, y+8);
		
		int tempDir;
		int angle;
		
		target[0] = Generic_FindTarget(LW_BEAM, x+8, y+8, -1000);
		
		if(state==0){ //Finding direction
			if(timer>0)
				--timer;
			else{
				tempDir = getNextDir(data, target, turnRate, homingChance, homingDist);
				if(tempDir>-1){
					i = Q7_AdjacentCombo(pos, tempDir);
					tx = ComboX(i);
					ty = ComboY(i);
					dir = tempDir;
					state = 1;
				}
				else{
					if(isWalkable(ComboAt(Link->X+8, Link->Y+8))){
						x = GridX(Link->X+8);
						y = GridY(Link->Y+8);
					}
					dir = Rand(4);
					timer = 16;
				}
			}
		}
		else if(state==1){ //Walking
			if(Distance(x, y, tx, ty)>step){
				angle = Angle(x, y, tx, ty);
				x += VectorX(step, angle);
				y += VectorY(step, angle);
			}
			else{
				x = tx;
				y = ty;
				
				tempDir = getNextDir(data, target, turnRate, homingChance, homingDist);
				if(tempDir>-1){
					state = 2;
					i = Q7_AdjacentCombo(pos, tempDir);
					tx = ComboX(i);
					ty = ComboY(i);
					dir = tempDir;
				}
				else{
					state = 2;
					if(isWalkable(ComboAt(Link->X+8, Link->Y+8))){
						x = GridX(Link->X+8);
						y = GridY(Link->Y+8);
					}
					dir = Rand(4);
					timer = 16;
				}
			}
		}
		else if(state==2){ //Polling Attack
			
		}
		data[0] = x;
		data[1] = y;
		data[2] = tx;
		data[3] = ty;
		data[4] = state;
		data[5] = dir;
		data[6] = timer;
	}
	int getNextDir(int data, npc target, int turnRate, int homingChance, int homingDist){
		int i; int j; int k;
		int dir;
		
		int pos = ComboAt(data[0]+8, data[1]+8);
		
		int lastDir = data[5];
		
		int availableDir[4] = {-1, -1, -1, -1};
		if(pos>15){
			i = Q7_AdjacentCombo(pos, DIR_UP);
			if(isWalkable(i))
				availableDir[DIR_UP] = i;
		}
		if(pos<160){
			i = Q7_AdjacentCombo(pos, DIR_DOWN);
			if(isWalkable(i))
				availableDir[DIR_DOWN] = i;
		}
		if(pos%16>0){
			i = Q7_AdjacentCombo(pos, DIR_LEFT);
			if(isWalkable(i))
				availableDir[DIR_LEFT] = i;
		}	
		if(pos%16<15){
			i = Q7_AdjacentCombo(pos, DIR_RIGHT);
			if(isWalkable(i))
				availableDir[DIR_RIGHT] = i;
		}
		
		if(target[0]->isValid()){
			int xDiff = CenterX(target[0])-data[0]+8;
			int yDiff = CenterY(target[0])-data[1]+8;
			if(Abs(xDiff)<homingDist&&Abs(yDiff)<homingDist&&Rand(homingChance)==0){
				if(Abs(yDiff)>16){
					if(yDiff<0)
						dir = DIR_UP;
					else
						dir = DIR_DOWN;
					
					i = availableDir[dir];
					if(i>-1){
						return dir;
					}
				}
				
				if(xDiff<0)
					dir = DIR_LEFT;
				else
					dir = DIR_RIGHT;
				
				i = availableDir[dir];
				if(i>-1){
					return dir;
				}
			}
		}
		
		int tryDir = lastDir;
		if(lastDir<0)
			tryDir = Rand(4);
		if(Rand(turnRate)==0){
			tryDir = Rand(4);
		}
		
		for(i=0; i<16; ++i){
			j = availableDir[tryDir];
			if(j>-1){
				return tryDir;
			}
			if(i>=11)
				tryDir = (i-11)%4;
			else
				tryDir = Rand(4);
		}
		
		return -1;
	}
	int getSightDir(int def, int x, int y, int dir){
		getSightDir(def, x, y, dir, 1000);
		// npc targets[256];
		// int numTargets;
		
		// for(int i=Screen->NumNPCs(); i>0; --i){
			// npc n = Screen->LoadNPC(i);
			// if(n->Defense[def]!=NPCDT_BLOCK&&n->Defense[def]!=NPCDT_IGNORE&&n->CollDetection){
				// int cx = CenterX(n);
				// int cy = CenterY(n);
				// if((Abs(x+8-cx)<12||Abs(y+8-cy)<12)&&AngleDir4(Angle(x+8, y+8, cx, cx))!=OppositeDir(dir)){
					// targets[numTargets] = n;
					// ++numTargets;
				// }
			// }
		// }
		
		// if(numTargets){
			// npc target = targets[Rand(numTargets)];
			// return AngleDir4(Angle(x, y, CenterX(target)-8, CenterY(target)-8));
		// }
		// return -1;
	}
	int getSightDir(int def, int x, int y, int dir, int dist){
		npc targets[256];
		int numTargets;
		
		for(int i=Screen->NumNPCs(); i>0; --i){
			npc n = Screen->LoadNPC(i);
			if(n->Defense[def]!=NPCDT_BLOCK&&n->Defense[def]!=NPCDT_IGNORE&&n->CollDetection){
				int cx = CenterX(n);
				int cy = CenterY(n);
				if(((Abs(x+8-cx)<12&&Abs(y+8-cy)<dist)||(Abs(y+8-cy)<12)&&(Abs(x+8-cx)<dist))&&AngleDir4(Angle(x+8, y+8, cx, cx))!=OppositeDir(dir)){
					targets[numTargets] = n;
					++numTargets;
				}
			}
		}
		
		if(numTargets){
			npc target = targets[Rand(numTargets)];
			return AngleDir4(Angle(x, y, CenterX(target)-8, CenterY(target)-8));
		}
		return -1;
	}
	bool isWalkable(int pos){
		int s1;
		int s2;
		if(Screen->LayerMap(1)>-1)
			s1 = Q7_GetLayerComboS(1, pos);
		if(Screen->LayerMap(2)>-1)
			s2 = Q7_GetLayerComboS(2, pos);
		int s = Screen->ComboS[pos]|s1|s2;
		int ct = Screen->ComboT[pos];
		if(Game->GetCurLevel()>=1&&Game->GetCurLevel()<=8){
			if(pos<32||pos>143||pos%16<2||pos%16>13)
				return false;
		}
		return !s; //&&(ct==CT_NONE||ct==CT_SLOWWALK||ct==CT_SHALLOWWATER||ct==CT_WASWATER||ct==CT_NOENEMY||ct==CT_NOGROUNDENEMY||ct==CT_NOJUMPZONE);
	}
	void setSummonFlag(int id, bool rem){
		int i;
		int summons[4];
		for(i=0; i<4; ++i){
			summons[i] = (G[G_PRESERVEDCHARGEA]>>(4*i))&1111b;
		}
		if(rem){
			for(i=0; i<4; ++i){
				if(summons[i]==id+1){
					summons[i] = 0;
					break;
				}
			}
		}
		else{
			for(i=0; i<4; ++i){
				if(summons[i]==0){
					summons[i] = id+1;
					break;
				}
			}
		}
		G[G_PRESERVEDCHARGEA] = 0;
		for(i=0; i<4; ++i){
			G[G_PRESERVEDCHARGEA] |= summons[i]<<(4*i);
		}
	}
	int getSummonFlag(int i){
		return (G[G_PRESERVEDCHARGEA]>>(4*i))&1111b;
	}
}

void PlaySpurdoMessage(int category){
	int name[] = "SpurdoMessage";
	int slot = Game->GetFFCScript(name);
	if(CountFFCsRunning(slot)==0){
		int args[8] = {category};
		RunFFCScript(slot, args);
	}
}

ffc script SpurdoMessage{
	void run(int category){
		int buf[512];
		if(category==0){
			Message_Shotgun(buf);
		}
		else if(category==1){
			Message_Hurt(buf);
		}
		else if(category==2){
			Message_BossKill(buf);
		}
		int w = DialogueBox_GetStringLength_LttPSmall(buf);
		for(int i=0; i<180; ++i){
			int x = Link->X+8-w/2;
			if(x>252-w)
				x = 252-w;
			if(x<4)
				x = 4;
			int y = Clamp(Link->Y - 16, 4, 172-6);
			DrawStringSpurdo(6, x, y, FONT_Z3SMALL, 0x01, 0x0F, TF_NORMAL, buf, 128);
			Waitframe();
		}
	}
	void CopyToBuffer(int buf, int str){
		int size = SizeOfArray(str);
		int j;
		for(int i=0; i<size; ++i){
			buf[j] = str[i];
			if(buf[j]=='B'||buf[j]=='b'){
				++j;
				buf[j] = '1';
			}
			++j;
		}
	}
	void DrawStringSpurdo(int layer, int x, int y, int font, int c1, int c2, int format, int buf, int op){
		int fontDef[] = {
			// Character widths, including any trailing space
			// ASCII characters 32 to 126
			
			// sp !  "  #  $  %  &  '  (  )  *  +  ,  -  .  /
			   4, 2, 4, 6, 6, 4, 5, 2, 3, 3, 4, 4, 3, 4, 2, 4,
			
			// 0  1  2  3  4  5  6  7  8  9
			   4, 3, 4, 4, 4, 4, 4, 4, 4, 4,
			
			// :  ;  <  =  >  ?  @
			   2, 2, 4, 4, 4, 4, 6,
			
			// A  B  C  D  E  F  G  H  I  J  K  L  M  N  O  P  Q  R  S  T  U  V  W  X  Y  Z
			   5, 5, 4, 5, 4, 4, 5, 4, 2, 4, 5, 4, 6, 5, 5, 5, 6, 5, 4, 4, 5, 6, 6, 4, 4, 4,
			
			// [  \  ]  ^  _  `
			   4, 4, 4, 4, 4, 4,
			
			// Note: This font's capital and lowercase letters are identical, but
			// ZC spaces some of them differently. This appears to be unintentional,
			// so it is not duplicated here.
			// a  b  c  d  e  f  g  h  i  j  k  l  m  n  o  p  q  r  s  t  u  v  w  x  y  z
			   5, 5, 4, 5, 4, 4, 5, 4, 2, 4, 5, 4, 6, 5, 5, 5, 6, 5, 4, 4, 5, 6, 6, 4, 4, 4,
			
			// {  |  }  ~
			   4, 2, 4, 5,
			
			// Additional characters
			   6, 10, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6,
			   6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6,
			   6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6,
			   6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6,
			   6, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,
			   4, 4, 4, 4, 4, 4, 4, 4, 4
		};
		
		Q7_DrawStringOutline(layer, x, y, font, c1, c2, format, buf, op);
		int xb = x;
		int size = SizeOfArray(buf);
		for(int i=0; i<size; ++i){
			if(buf[i]=='B'||buf[i]=='b'){
				Screen->FastTile(layer, xb-1, y-2, 16412, 8, 128);
			}
			xb += DialogueBox_GetCharLength_LttPSmall(fontDef, buf[i]);
			
		}
	}
	void Message_Shotgun(int buf){
		int i = Rand(15);
		if(Rand(111)==0)
			i = 111;
		if(i==0){
			int str[] = "FUG :D";
			CopyToBuffer(buf, str);
		}
		else if(i==1){
			int str[] = "EBIN :D :D :D";
			CopyToBuffer(buf, str);
		}
		else if(i==2){
			int str[] = "LOGGED EN LODED";
			CopyToBuffer(buf, str);
		}
		else if(i==3){
			int str[] = "TASDE BOOLET";
			CopyToBuffer(buf, str);
		}
		else if(i==4){
			int str[] = "EAT SHIDD :-DDD";
			CopyToBuffer(buf, str);
		}
		else if(i==5){
			int str[] = "EBER SEEN A LEADYBUG? :D";
			CopyToBuffer(buf, str);
		}
		else if(i==6){
			int str[] = "EBIL DEAD BOOMSTICK :DD";
			CopyToBuffer(buf, str);
		}
		else if(i==7){
			int str[] = "PROOT! :-DDD";
			CopyToBuffer(buf, str);
		}
		else if(i==8){
			int str[] = "CASCADE GOT THIRD EXIT";
			CopyToBuffer(buf, str);
		}
		else if(i==9){
			int str[] = "POBERTY NOT MY BROBLEM";
			CopyToBuffer(buf, str);
		}
		else if(i==10){
			int str[] = "I SHIDD MYSELF A LITTLE :D";
			CopyToBuffer(buf, str);
		}
		else if(i==11){
			int str[] = "TRIBBLE DN";
			CopyToBuffer(buf, str);
		}
		else if(i==12){
			int str[] = "YOU EBER REALIZE RUPEES ARE MEANINGLESS JUST LIKE TIME YOU SPEND FARMING THEM?";
			CopyToBuffer(buf, str);
		}
		else if(i==13){
			int str[] = "ARROW COUNTER CAN SUGG MY BENIS :-DD";
			CopyToBuffer(buf, str);
		}
		else if(i==14){
			int str[] = "WAND? BENIS IS MUCH HEABIER AND ALSO MAGICAL";
			CopyToBuffer(buf, str);
		}
		if(i==111){
			int str[] = "UNLOG FEBORA WITCH :-DDDDD";
			CopyToBuffer(buf, str);
		}
	}
	void Message_Hurt(int buf){
		int i = Rand(8);
		if(i==0){
			int str[] = "OOV";
			CopyToBuffer(buf, str);
		}
		else if(i==1){
			int str[] = "NOT EBIN";
			CopyToBuffer(buf, str);
		}
		else if(i==2){
			int str[] = "WHAD AR U DOIN?";
			CopyToBuffer(buf, str);
		}
		else if(i==3){
			int str[] = "GIB ME GONTROLLER :-DDD";
			CopyToBuffer(buf, str);
		}
		else if(i==3){
			int str[] = "L2PLAY";
			CopyToBuffer(buf, str);
		}
		else if(i==4){
			int str[] = "STUBBED MY BENIS :(";
			CopyToBuffer(buf, str);
		}
		else if(i==5){
			int str[] = "BEWARE BACKBLAST :-DD";
			CopyToBuffer(buf, str);
		}
		else if(i==6){
			int str[] = "TAKE DMG 2 SAVE TIME";
			CopyToBuffer(buf, str);
		}
		else if(i==7){
			int str[] = "O FUG TAKE COVER BEHIND THIS TEXT SHIELD ITS VERY STURDY :-DDDD";
			CopyToBuffer(buf, str);
		}
	}
	void Message_BossKill(int buf){
		int i = Rand(6);
		if(i==0){
			int str[] = "BOINT DOWN! :-DD";
			CopyToBuffer(buf, str);
		}
		else if(i==1){
			int str[] = "GITGUD SCRUB :D";
			CopyToBuffer(buf, str);
		}
		else if(i==2){
			int str[] = "TYBE BENIS REBORTIN IN";
			CopyToBuffer(buf, str);
		}
		else if(i==3){
			int str[] = "BARRY THIS, CASUL";
			CopyToBuffer(buf, str);
		}
		else if(i==4){
			int str[] = "BIRST TRY :-DDDD";
			CopyToBuffer(buf, str);
		}
		else if(i==5){
			int str[] = "GAN I SAY GAMER WORD?";
			CopyToBuffer(buf, str);
		}
	}
}

bool Q7_NPCIsBeatable(npc n){
	if ( n->Type != NPCT_PROJECTILE )
	{
		if ( !(n->MiscFlags&NPCMF_NOT_BEATABLE) )
		{
			if ( n->Type != NPCT_FAIRY )
			{
				if ( n->Type != NPCT_GUY )
				{
					return true;
				}
			}
		}
	}
	return false;
}

int Q7_NumBeatableEnemies()
{
	int count;
	for ( int q = Screen->NumNPCs(); q > 0; --q )
	{
		npc n = Screen->LoadNPC(q); 
		if ( n->Type != NPCT_PROJECTILE )
		{
			if ( !(n->MiscFlags&NPCMF_NOT_BEATABLE) )
			{
				if ( n->Type != NPCT_FAIRY )
				{
					if ( n->Type != NPCT_GUY )
					{
						if(n->HP>0)
							++count;
					}
				}
			}
		}
	}
	return count;
}

ffc script BossRoom{
	void run(){
		if(G[G_ALTCHARACTER]==CHAR_SPURDO){
			Waitframes(4);
			if(Q7_NumBeatableEnemies()>0){
				while(Q7_NumBeatableEnemies()>0){
					Waitframe();
				}
				PlaySpurdoMessage(2);
			}
		}
	}
}

void ManiStarfallCopyTile(){
	if(G[G_ALTCHARACTER]==CHAR_MANI)
		CopyTile(12994+Clamp(G[G_MANISTARFALLLEVEL], 0, 5), 12985);
}

void ManiStarfallIncrement(){
	int charged;
	++G[G_MANISTARFALLCHARGE];
	if(G[G_MANISTARFALLLEVEL]==0){
		G[G_MANISTARFALLCHARGE] = 0;
		G[G_MANISTARFALLLEVEL] = 1;
		CopyTile(12995, 12985);
		charged = 1;
	}
	else if(G[G_MANISTARFALLLEVEL]==1){
		if(G[G_MANISTARFALLCHARGE]>=4){
			G[G_MANISTARFALLCHARGE] = 0;
			G[G_MANISTARFALLLEVEL] = 2;
			CopyTile(12996, 12985);
			charged = 1;
		}
	}
	else if(G[G_MANISTARFALLLEVEL]==2){
		if(G[G_MANISTARFALLCHARGE]>=8){
			G[G_MANISTARFALLCHARGE] = 0;
			G[G_MANISTARFALLLEVEL] = 3;
			CopyTile(12997, 12985);
			charged = 1;
		}
	}
	else if(G[G_MANISTARFALLLEVEL]==3){
		if(G[G_MANISTARFALLCHARGE]>=16){
			G[G_MANISTARFALLCHARGE] = 0;
			G[G_MANISTARFALLLEVEL] = 4;
			CopyTile(12998, 12985);
			charged = 1;
		}
	}
	else if(G[G_MANISTARFALLLEVEL]==4){
		if(G[G_MANISTARFALLCHARGE]>=64){
			G[G_MANISTARFALLCHARGE] = 0;
			G[G_MANISTARFALLLEVEL] = 5;
			CopyTile(12999, 12985);
			charged = 2;
		}
	}
	else if(G[G_MANISTARFALLLEVEL]==5){
		G[G_MANISTARFALLCHARGE] = 0;
		charged = -1;
	}
	if(charged==2)
		Game->PlaySound(118);
	else if(charged==1)
		Game->PlaySound(115);
}

ffc script ExtraDungeonEntrance{
	void run(int dir, int shutter){
		if(shutter==3){
			UpdateContinueScreens();
			Quit();
		}
		if(G[G_MODE_DUNGEONCEPTION]){
			if(Game->GetCurMap()==4&&Game->GetCurScreen()==0x49){
				Screen->ComboD[82] = 51;
				Screen->ComboC[82] = 2;
			}
			if(shutter==2){
				Screen->TriggerSecrets();
			}
			else if(shutter==1){
				int dt = D_SHUTTER;
				int linkX = Link->X;
				int linkY = Link->Y;
				if(G[G_LASTDMAP]==Game->GetCurDMap()){
					if(linkX==0)
						linkX = 240;
					else if(linkX==240)
						linkX = 0;
					if(linkY==0)
						linkY = 160;
					else if(linkY==160)
						linkY = 0;
				}
				if(linkY<32&&dir==DIR_UP)
					dt = D_OPEN;
				if(linkY>128&&dir==DIR_DOWN)
					dt = D_OPEN;
				if(linkX<32&&dir==DIR_LEFT)
					dt = D_OPEN;
				if(linkX>208&&dir==DIR_RIGHT)
					dt = D_OPEN;
				Screen->Door[dir] = dt;
			}
			else{
				Screen->Door[dir] = D_OPEN;
			}
		}
		Waitframe();
		G[G_SCRIPTPASSAGE_OLDDMAP] = Game->GetCurDMap();
		G[G_SCRIPTPASSAGE_OLDSCREEN] = Game->GetCurDMapScreen();
		if(!Screen->State[ST_SPECIALITEM]){
			G[G_SCRIPTPASSAGE_OLDITEM] = Screen->RoomData;
			if(Randomizer_GetItemReplacement(Game->GetCurMap(), Game->GetCurScreen()))
				G[G_SCRIPTPASSAGE_OLDITEM] = Randomizer_GetItemReplacement(Game->GetCurMap(), Game->GetCurScreen());
		}
		else{
			G[G_SCRIPTPASSAGE_OLDITEM] = 0;
		}
		UpdateContinueScreens();
	}
	void UpdateContinueScreens(){
		Game->ContinueScreen = Game->DMapContinue[Game->GetCurDMap()]+Game->DMapOffset[Game->GetCurDMap()];
		Game->LastEntranceScreen = Game->DMapContinue[Game->GetCurDMap()]+Game->DMapOffset[Game->GetCurDMap()];
		if(Game->GetCurLevel()==4){
			if(Game->GetCurScreen()==0x0B){
				Game->ContinueScreen = 0x57+Game->DMapOffset[Game->GetCurDMap()];
				Game->LastEntranceScreen = 0x57+Game->DMapOffset[Game->GetCurDMap()];
			}
			else{
				Game->ContinueScreen = 0x22+Game->DMapOffset[Game->GetCurDMap()];
				Game->LastEntranceScreen = 0x22+Game->DMapOffset[Game->GetCurDMap()];
			}
		}
		if(Game->GetCurLevel()==9){
			if(Game->GetCurDMap()==70){
				Game->ContinueDMap = 69;
				Game->LastEntranceDMap = 69;
			}
			else{
				Game->ContinueDMap = 9;
				Game->LastEntranceDMap = 9;
			}
			Game->ContinueScreen = 0x73+Game->DMapOffset[9];
			Game->LastEntranceScreen = 0x73+Game->DMapOffset[9];
		}
	}
}

const int FFCS_LONGDONGREGALIA = 140;

const int FSHIELD_PHYSICAL 		= 00000001b;
const int FSHIELD_EARTH 		= 00000010b;
const int FSHIELD_ICE 			= 00000100b;
const int FSHIELD_FIRE	 		= 00001000b;
const int FSHIELD_LIGHTNING 	= 00010000b;
const int FSHIELD_NATURE 		= 00100000b;
const int FSHIELD_WIND	 		= 01000000b;
const int FSHIELD_DARK	 		= 10000000b;

bool HoldingItem(){
	return Link->Action==LA_HOLD1LAND||Link->Action==LA_HOLD2LAND||Link->Action==LA_HOLD1WATER||Link->Action==LA_HOLD2WATER;
}

//BIGGER, STRONGER, FASTER TOO!
//FROGGER X IS AFTER YOU!
ffc script LongDongRegalia{
	void run(){
		this->Flags[FFCF_IGNOREHOLDUP] = true;
		int i;
		int x; int y;
		int clr[] = {	0xB2, 0xB3,
						0x85, 0x86,
						0x72, 0x73,
						0x81, 0x82,
						0x12, 0x13,
						0x51, 0x52,
						0x52, 0x52, 
						0xA1, 0x0F
					};
				
		int orbitAngle;
		while(true){
			int layer;
			int xOff;
			int yOff;
			
			orbitAngle = WrapDegrees(orbitAngle+5);
			if(Link->Action!=LA_DIVING&&(!Link->Invisible||G[G_FROGGER_HALOEXCEPTION])){
				int shieldDist = 16;
				if(G[G_FROGGER_BLACKHOLETIMER]>0)
					shieldDist = Lerp(0, 16, G[G_FROGGER_BLACKHOLETIMER]/120);
				for(int i=0; i<8; ++i){
					x = Link->X+Link->DrawXOffset + VectorX(shieldDist, orbitAngle+45*i);
					y = Link->Y+Link->DrawYOffset + VectorY(shieldDist/2, orbitAngle+45*i);
					layer = 2;
					if(WrapDegrees(orbitAngle+45*i)>0){
						layer = 3;
						if(ScreenFlag(1, 5)) //Layer -3
							layer = 4;
					}
					if(G[G_FROGGER_SHIELDFLAGS]&(1<<i)){
						Screen->Circle(layer, x+8+Rand(-1, 1), y+8+Rand(-1, 1), Rand(4, 6), clr[i*2+Rand(2)], 1, 0, 0, 0, true, 128);
						Screen->FastTile(layer, x+4, y+4, 2740+i, 0, 128);
					}
				}
				
				layer = 2;
				if(Link->Dir==DIR_UP&&!HoldingItem()){
					layer = 3;
					if(ScreenFlag(1, 5)) //Layer -3
						layer = 4;
					yOff -= 2;
				}
				else if(Link->Dir==DIR_LEFT)
					xOff += 2;
				else if(Link->Dir==DIR_RIGHT)
					xOff -= 2;
				if(G[G_FROGGER_SHIELDCOOLDOWN]==0||G[G_ANIM]%4<2){
					if(G[G_FROGGER_BLACKHOLETIMER])
						Screen->DrawCombo(layer, Link->X+Link->DrawXOffset-8+xOff, Link->Y+Link->DrawYOffset-13+yOff, 740, 2, 2, 10, -1, -1, 0, 0, 0, -1, 0, true, 128);
					else
						Screen->DrawCombo(layer, Link->X+Link->DrawXOffset-8+xOff, Link->Y+Link->DrawYOffset-13+yOff, 739, 2, 2, 10, -1, -1, 0, 0, 0, -1, 0, true, 128);
				}
			}
			if(G[G_FROGGER_SHIELDCOOLDOWN]>0)
				--G[G_FROGGER_SHIELDCOOLDOWN];
			if(Link->Action==LA_GOTHURTLAND||Link->Action==LA_GOTHURTWATER){
				if(G[G_FROGGER_SHIELDCOOLDOWN]==0&&G[G_FROGGER_BLACKHOLETIMER]==0){
					FroggerShield_AddElement(false);
					G[G_FROGGER_SHIELDCOOLDOWN] = 600;
				}
			}
			FroggerShield_GetLevels();
			if(G[G_FROGGER_SHIELDLEVEL]>=2)
				G[G_LINKSPEEDBOOST] += 0.25;
			if(G[G_FROGGER_SHIELDLEVEL]>=6)
				G[G_LINKSPEEDBOOST] += 0.25;
			if(G[G_FROGGER_SHIELDLEVEL]>=8&&G[G_FROGGER_BLACKHOLETIMER]==0){
				G[G_FROGGER_BLACKHOLETIMER] = 120;
			}
			if(G[G_FROGGER_BLACKHOLETIMER]>0){
				--G[G_FROGGER_BLACKHOLETIMER];
				if(G[G_FROGGER_BLACKHOLETIMER]==0){
					RunFFCScript(FFCS_BLACKHOLE, 0);
				}
			}
			if(G[G_FROGGER_SHIELDDECAYTIME]){
				--G[G_FROGGER_SHIELDDECAYTIME];
				if(G[G_FROGGER_SHIELDDECAYTIME]<=0){
					if(G[G_FROGGER_SHIELDTEMPLEVEL]){
						FroggerShield_RemoveTempElement();
					}
				}
				if(G[G_FROGGER_SHIELDTEMPLEVEL]==0)
					G[G_FROGGER_SHIELDDECAYTIME] = 0;
			}
			if(G[G_FROGGER_SHIELDDECAYTIME]){
				G[G_UTILITYCOOLDOWN] = 3600-G[G_FROGGER_SHIELDDECAYTIME];
				G[G_UTILITYCOOLDOWNMAX] = 3600;
			}
			G[G_FROGGER_HALOEXCEPTION] = 0;
			
			Waitframe();
		}
	}
	void FroggerShield_GetLevels(){
		G[G_FROGGER_SHIELDLEVEL] = 0;
		G[G_FROGGER_SHIELDTEMPLEVEL] = 0;
		for(int i=0; i<8; ++i){
			if(G[G_FROGGER_SHIELDFLAGS]&(1<<i)){
				++G[G_FROGGER_SHIELDLEVEL];
				if(G[G_FROGGER_SHIELDFLAGS]&(1<<(i+8)))
					++G[G_FROGGER_SHIELDTEMPLEVEL];
			}
		}
	}
	void FroggerShield_AddElement(bool temp){
		int which = Rand(8);
		while(G[G_FROGGER_SHIELDFLAGS]&(1<<which)){
			if((G[G_FROGGER_SHIELDFLAGS]&0xFF)==11111111b)
				break;
			++which;
			which = Rand(8);
		}
		Game->PlaySound(140);
		G[G_FROGGER_SHIELDFLAGS] |= (1<<which);
		if(temp){
			G[G_FROGGER_SHIELDFLAGS] |= (1<<(which+8));
			G[G_FROGGER_SHIELDDECAYTIME] = 3600;
		}
		if(G[G_FROGGER_SHIELDTEMPLEVEL])
			G[G_FROGGER_SHIELDDECAYTIME] = 3600;
	}
	void FroggerShield_RemoveTempElement(){
		for(int i=0; i<8; ++i){
			if(G[G_FROGGER_SHIELDFLAGS]&(1<<(i+8))){
				Game->PlaySound(141);
				G[G_FROGGER_SHIELDFLAGS] &= ~((1<<(i))|(1<<(i+8)));
				G[G_FROGGER_SHIELDDECAYTIME] = 3600;
				return;
			}
		}
	}
}

void DrawLinePath(int layer, int x, int y, int size, int colors){
	int numC = SizeOfArray(colors);
	--size;
	for(int i=0; i<size; ++i){
		int clr;
		if(size<=numC){
			clr = colors[i];
		}
		else{
			int clri = Clamp(Round(Lerp(0, numC-1, i/(size-1))), 0, numC-1);
			clr = colors[clri];
		}
		Screen->Line(layer, x[i], y[i], x[i+1], y[i+1], clr, 1, 0, 0, 0, 128);
	}
}

const int FFCS_BLACKHOLE = 141;

void LoopingSFX(int timer, int looptime, int sfx){
	if(timer[0]==0)
		Game->PlaySound(sfx);
	++timer[0];
	if(timer[0]>=looptime)
		timer[0] = 0;
}

ffc script FroggerBlackHole{
	void run(){
		int lineA[16];
		int lineMin[16];
		int lineMax[16];
		int lines[] = {lineA, lineMin, lineMax};
		int ringDist[16];
		int ringStep[16];
		int ringC[16];
		int rings[] = {ringDist, ringStep, ringC};
		for(int i=0; i<16; ++i){
			lineA[i] = Rand(360);
			if(Rand(2)){
				lineMin[i] = 0;
				lineMax[i] = Rand(1, 15);
			}
			else{
				lineMin[i] = Rand(0, 14);
				lineMax[i] = 15;
			}
		}
		int maxSize = SwordDamageLevel(16, 32, 48, 64);
		int maxRingSize = maxSize+SwordDamageLevel(16, 21, 25, 32);
		int damage[2];
		damage[0] = (SwordDamageLevel(1, 2, 4, 5)+1)*G[G_HPSCALE];
		int sfxTimer[1];
		int damageTimer[2] = {0, 1};
		G[G_FROGGER_SHIELDFLAGS] = 0;
		G[G_FROGGER_SHIELDDECAYTIME] = 0;
		Game->PlaySound(141);
		for(int i=0; i<64; ++i){
			SetNoColl();
			DrawBlackHole(Link->X+8, Link->Y+8, maxSize, 256, maxRingSize, i/64, sfxTimer, damageTimer, lines, rings, damage);
			NoAction();
			Waitframe();
		}
		damage[1] = SwordDamageLevel(0.4, 0.6, 0.8, 1)*G[G_HPSCALE];
		for(int i=0; i<128; ++i){
			SetNoColl();
			DrawBlackHole(Link->X+8, Link->Y+8, maxSize, 256, maxRingSize, 1, sfxTimer, damageTimer, lines, rings, damage);
			if(i%4<2||(i>=16)){
				Screen->DrawCombo(6, Link->X-8, Link->Y-13, 739, 2, 2, 10, -1, -1, 0, 0, 0, -1, 0, true, 128);
				Screen->DrawTile(6, Link->X-8, Link->Y, 2700, 2, 1, 11, -1, -1, 0, 0, 0, 0, true, 128);
			}
			NoAction();
			Waitframe();
		}
		damage[0] = 0;
		damage[1] = 0;
		damageTimer[1] = 0;
		for(int i=0; i<16; ++i){
			SetNoColl();
			DrawBlackHole(Link->X+8, Link->Y+8, maxSize, 256, maxRingSize, 1-i/16, sfxTimer, damageTimer, lines, rings, damage);
			Screen->DrawCombo(6, Link->X-8, Link->Y-13, 739, 2, 2, 10, -1, -1, 0, 0, 0, -1, 0, true, 128);
			Screen->DrawTile(6, Link->X-8, Link->Y, 2700, 2, 1, 11, -1, -1, 0, 0, 0, 0, true, 128);
			SetInvisible();
			NoAction();
			Waitframe();
		}
		int oldHP = Link->HP;
		for(int i=0; i<90; ++i){
			if(Link->Action==LA_GOTHURTLAND&&Link->HP<oldHP){
				DealDirectDamage(oldHP-Link->HP);
			}
			oldHP = Link->HP;
			Screen->DrawCombo(2, Link->X-8, Link->Y-13, 739, 2, 2, 10, -1, -1, 0, 0, 0, -1, 0, true, 128);
			Screen->DrawTile(2, Link->X-8, Link->Y, 2702, 2, 1, 11, -1, -1, 0, 0, 0, 0, true, 128);
			SetInvisible();
			NoAction();
			Waitframe();
		}
		G[G_FROGGER_SHIELDCOOLDOWN] = 120;
	}
	void DrawBlackHole(int cx, int cy, int r, int r2, int r3, int scale, int sfxTimer, int damageTimer, int lines, int rings, int damage){
		r = Lerp(0, r, scale);
		r2 = Lerp(0, r2, scale);
		r3 = Lerp(0, r3, scale);
		
		LoopingSFX(sfxTimer, 24, 37);
		if(damageTimer[1]){
			++damageTimer[0];
			if(damageTimer[0]>=16){
				damageTimer[0] = 0;
				for(int i=Screen->NumNPCs(); i>0; --i){
					npc n = Screen->LoadNPC(i);
					if(Q7_NPCIsBeatable(n)){
						if(Abs(n->HitXOffset)<1000&&Abs(n->HitYOffset)<1000&&n->CollDetection){
							if(n->Defense[NPCD_SWORD]!=NPCDT_BLOCK&&n->Defense[NPCD_SWORD]!=NPCDT_IGNORE){
								int dist = Distance(CenterX(n), CenterY(n), cx, cy);
								if(dist<r+8+(n->HitWidth+n->HitHeight)/2){
									if(damage[0]>0){
										NPC_DirectDamage(n, damage[0]);
										Game->PlaySound(SFX_EHIT);
									}
								}
								else if(dist<r2){
									if(damage[1]>0){
										NPC_DirectDamage(n, damage[1]);
										Game->PlaySound(SFX_EHIT);
									}
								}
							}
						}
					}
				}
			}
		}
		
		Screen->Circle(6, cx, cy, r+(r3-r)*2+Cond(G[G_ANIM]%4<2, 0, 2), 0x0F, 1, 0, 0, 0, true, 64);
		Screen->Circle(6, cx, cy, r2+Cond(G[G_ANIM]%4<2, 0, 2), 0x0F, 1, 0, 0, 0, true, 64);
		int lineA = lines[0];
		int lineMin = lines[1];
		int lineMax = lines[2];
		int ringDist = rings[0];
		int ringStep = rings[1];
		int ringC = rings[2];
		if(G[G_ANIM]%2==0){
			for(int i=0; i<16; ++i){
				if(ringDist[i]==0){
					ringDist[i] = 1;
					ringStep[i] = Rand(10, 12)/100;
					ringC[i] = Choose(0x17, 0x18, 0x19);
					break;
				}
			}
		}
		for(int i=0; i<8; ++i){
			DrawBlackHoleLine(cx, cy, lineA[i], r, r3, 16, lineMin[i], lineMax[i], 18);
			if(lineMin[i]==0){
				--lineMax[i];
				if(lineMax[i]==0){
					lineMin[i] = 15;
					lineMax[i] = 15;
					lineA[i] = Rand(360);
				}
			}
			else{
				--lineMin[i];
			}
		}
		int ringMax = Min((r+r3)/2, r+8);
		for(int i=0; i<16; ++i){
			if(ringDist[i]>0){
				Screen->Circle(6, cx+Rand(-1, 1), cy+Rand(-1, 1), Lerp(r, ringMax, ringDist[i]), ringC[i], 1, 0, 0, 0, false, Cond(ringDist[i]>0.75, 64, 128));
				ringDist[i] -= ringStep[i];
				if(ringDist[i]<=0)
					ringDist[i] = 0;
			}
		}
		Screen->Circle(6, cx, cy, r+Cond(G[G_ANIM]%4<2, 0, 2), 0x0F, 1, 0, 0, 0, true, 128);
	}
	void DrawBlackHoleLine(int cx, int cy, int ang, int r, int r3, int numSegments, int activeMin, int activeMax, int turn){
		int lx[16];
		int ly[16];
		int c[] = {0x19, 0x18, 0x17, 0x0F};
		int i; int j;
		for(i=0; i<numSegments; ++i){
			int x = cx+VectorX(Lerp(r, r3, i/(numSegments-1)), ang+turn*i);
			int y = cy+VectorY(Lerp(r, r3, i/(numSegments-1)), ang+turn*i);
			if(i>=activeMin&&i<=activeMax){
				lx[j] = x;
				ly[j] = y;
				++j;
			}
		}
		DrawLinePath(6, lx, ly, j, c);
	}
}

void ApplyTransformation(int til){
	CopyTileBlock(til, til+17, 13000);
		
}

const int DT_NONE = 0;
const int DT_OCTOROK = 1;
const int DT_MOBLIN = 2;
const int DT_LYNEL = 3;
const int DT_LEEVER = 4;
const int DT_TEKTITE = 5;
const int DT_PEAHAT = 6;
const int DT_ARMOS = 7;
const int DT_GHINI = 8;
const int DT_KEESE = 9;
const int DT_ZOL = 11;
const int DT_STALFOS = 12;
const int DT_GORIYA = 13;
const int DT_GIBDO = 14;
const int DT_WALLMASTER = 15;
const int DT_LIKELIKE = 16;
const int DT_DARKNUT = 17;
const int DT_ROPE = 18;
const int DT_POLSVOICE = 19;
const int DT_WIZZROBE = 20;
const int DT_WIZZROBEBREATH = 21;
const int DT_WIZZROBEFIRE = 22;
const int DT_WIZZROBEBAT = 23;
const int DT_WIZZROBEBABA = 24;
const int DT_WIZZROBESHOCK = 25;
const int DT_VIRE = 26;
const int DT_NIGHTMARESLIME = 27;
const int DT_KNIGHTKNIGHT = 28;
const int DT_ZIRRO = 29;

void DimiFormEnemies(int npcForms){
	//Octoroks
	npcForms[22] = DT_OCTOROK;
	npcForms[20] = DT_OCTOROK;
	npcForms[23] = DT_OCTOROK;
	npcForms[21] = DT_OCTOROK;
	npcForms[86] = DT_OCTOROK;
	npcForms[512+86] = 1; //Cracktorok
	//Moblins
	npcForms[28] = DT_MOBLIN;
	npcForms[29] = DT_MOBLIN;
	//Lynels
	npcForms[30] = DT_LYNEL;
	npcForms[31] = DT_LYNEL;
	npcForms[295] = DT_LYNEL;
	//Leevers
	npcForms[26] = DT_LEEVER;
	npcForms[27] = DT_LEEVER;
	npcForms[137] = DT_LEEVER;
	npcForms[256] = DT_LEEVER;
	npcForms[257] = DT_LEEVER;
	npcForms[312] = DT_LEEVER;
	//Tektites
	npcForms[24] = DT_TEKTITE;
	npcForms[25] = DT_TEKTITE;
	npcForms[259] = DT_TEKTITE;
	npcForms[311] = DT_TEKTITE;
	//Peahats
	npcForms[32] = DT_PEAHAT;
	//Armos
	npcForms[37] = DT_ARMOS;
	//Ghinis
	npcForms[35] = DT_GHINI;
	npcForms[260] = DT_GHINI;
	//Keese
	npcForms[38] = DT_KEESE;
	npcForms[39] = DT_KEESE;
	npcForms[40] = DT_KEESE;
	npcForms[90] = DT_KEESE;
	npcForms[106] = DT_KEESE;
	//Zol
	npcForms[42] = DT_ZOL;
	npcForms[88] = DT_ZOL;
	npcForms[300] = DT_ZOL;
	npcForms[43] = DT_ZOL;
	npcForms[89] = DT_ZOL;
	//Stalfos
	npcForms[41] = DT_STALFOS;
	npcForms[79] = DT_STALFOS;
	npcForms[120] = DT_STALFOS;
	npcForms[262] = DT_STALFOS;
	//Goriya
	npcForms[45] = DT_GORIYA;
	npcForms[46] = DT_GORIYA;
	npcForms[136] = DT_GORIYA;
	//Gibdo
	npcForms[54] = DT_GIBDO;
	npcForms[305] = DT_GIBDO;
	//Wallmaster
	npcForms[48] = DT_WALLMASTER;
	npcForms[258] = DT_WALLMASTER;
	npcForms[267] = DT_WALLMASTER;
	//LikeLike
	npcForms[53] = DT_LIKELIKE;
	npcForms[261] = DT_LIKELIKE;
	//Darknut
	npcForms[49] = DT_DARKNUT;
	npcForms[50] = DT_DARKNUT;
	npcForms[92] = DT_DARKNUT;
	npcForms[304] = DT_DARKNUT;
	//Rope
	npcForms[44] = DT_ROPE;
	npcForms[80] = DT_ROPE;
	//PolsVoice
	npcForms[55] = DT_POLSVOICE;
	//Wizzrobe
	npcForms[301] = DT_WIZZROBE;
	npcForms[57] = DT_WIZZROBE;
	npcForms[113] = DT_WIZZROBE;
	npcForms[278] = DT_WIZZROBE;
	npcForms[56] = DT_WIZZROBE;
	npcForms[100] = DT_WIZZROBE;
	npcForms[512+100] = 1; //Windrobe
	//Wizzrobe Stream
	npcForms[268] = DT_WIZZROBEBREATH;
	//Wizzrobe Baba
	npcForms[302] = DT_WIZZROBEBABA;
	//Wizzrobe Bat
	npcForms[107] = DT_WIZZROBEBAT;
	//Wizzrobe Fire
	npcForms[99] = DT_WIZZROBEFIRE;
	npcForms[272] = DT_WIZZROBEFIRE;
	//Wizzrobe Shock
	npcForms[303] = DT_WIZZROBESHOCK;
	//Vire
	npcForms[52] = DT_VIRE;
	//Nightmare Slime
	npcForms[271] = DT_NIGHTMARESLIME;
	//Knight Knight
	npcForms[306] = DT_KNIGHTKNIGHT;
	npcForms[307] = DT_KNIGHTKNIGHT;
	npcForms[313] = DT_KNIGHTKNIGHT;
	//Zirro
	npcForms[297] = DT_ZIRRO;
	npcForms[298] = DT_ZIRRO;
}

const int FFCS_DIMITRANSFORMATION = 142;

void Rotate4(lweapon l){
	if(l->Dir>DIR_DOWN){
		++l->Tile;
		if(l->Dir==DIR_LEFT)
			l->Flip = 1;
	}
	if(l->Dir==DIR_DOWN)
		l->Flip = 2;
}

ffc script DimiTransformations{
	void run(){
		UpdateTransformationGFX();
		while(true){
			if((Link->Action==LA_GOTHURTLAND||Link->Action==LA_SWIMMING)&&G[G_DIMITRANSFORM]){
				int args[8] = {3, Link->X, Link->Y, G[G_DIMITRANSFORM]|(G[G_DIMITRANSFORMSUBTYPE]<<9)};
				RunFFCScript(FFCS_MISCSPELLS, args);
				G[G_DIMITRANSFORM] = 0;
				UpdateTransformationGFX();
			}
			Waitframe();
		}
	}
	void UpdateTransformationGFX(){
		ApplyTransformation(GetTransformationGFX(G[G_DIMITRANSFORM]));
	}
	int GetTransformationGFX(int form){
		if(form==DT_NONE){
			return 13940;
		}
		if(form==DT_OCTOROK){
			return 49400;
		}
		if(form==DT_MOBLIN){
			return 49420;
		}
		if(form==DT_LYNEL){
			return 49440;
		}
		if(form==DT_LEEVER){
			return 49460;
		}
		if(form==DT_TEKTITE){
			return 49480;
		}
		if(form==DT_PEAHAT){
			return 49500;
		}
		if(form==DT_ARMOS){
			return 49520;
		}
		if(form==DT_GHINI){
			return 49540;
		}
		if(form==DT_KEESE){
			return 49560;
		}
		if(form==DT_ZOL){
			return 49580;
		}
		if(form==DT_STALFOS){
			return 49600;
		}
		if(form==DT_GORIYA){
			return 49620;
		}
		if(form==DT_GIBDO){
			return 49640;
		}
		if(form==DT_WALLMASTER){
			return 49660;
		}
		if(form==DT_LIKELIKE){
			return 49680;
		}
		if(form==DT_DARKNUT){
			return 49700;
		}
		if(form==DT_ROPE){
			return 49720;
		}
		if(form==DT_POLSVOICE){
			return 49740;
		}
		if(form==DT_WIZZROBE||form==DT_WIZZROBEBREATH||form==DT_WIZZROBESHOCK){
			return 49760;
		}
		if(form==DT_WIZZROBEBABA){
			return 49900;
		}
		if(form==DT_WIZZROBEBAT){
			return 49780;
		}
		if(form==DT_WIZZROBEFIRE){
			return 49800;
		}
		if(form==DT_VIRE){
			return 49820;
		}
		if(form==DT_NIGHTMARESLIME){
			return 49840;
		}
		if(form==DT_KNIGHTKNIGHT){
			return 49860;
		}
		if(form==DT_ZIRRO){
			return 49880;
		}
	}
}

item script FunnyLaugh{
	void run(){
		if(G[G_MODE_RUPOORGARBAGE]){
			Game->PlaySound(144);
		}
	}
}